<!DOCTYPE html>
<html><head><title>joekychen/linux » net › ipv4 › tcp_output.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tcp_output.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  INET is implemented using the  BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *		Implementation of the Transmission Control Protocol(TCP).</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Ross Biro</span>
<span class="cm"> *		Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *		Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;</span>
<span class="cm"> *		Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;</span>
<span class="cm"> *		Florian La Roche, &lt;flla@stud.uni-sb.de&gt;</span>
<span class="cm"> *		Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;</span>
<span class="cm"> *		Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;</span>
<span class="cm"> *		Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;</span>
<span class="cm"> *		Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;</span>
<span class="cm"> *		Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;</span>
<span class="cm"> *		Jorge Cwik, &lt;jorge@laser.satlink.net&gt;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Changes:	Pedro Roque	:	Retransmit queue handled by TCP.</span>
<span class="cm"> *				:	Fragmentation on mtu decrease</span>
<span class="cm"> *				:	Segment collapse on retransmit</span>
<span class="cm"> *				:	AF independence</span>
<span class="cm"> *</span>
<span class="cm"> *		Linus Torvalds	:	send_delayed_ack</span>
<span class="cm"> *		David S. Miller	:	Charge memory using the right skb</span>
<span class="cm"> *					during syn/ack processing.</span>
<span class="cm"> *		David S. Miller :	Output engine completely rewritten.</span>
<span class="cm"> *		Andrea Arcangeli:	SYNACK carry ts_recent in tsecr.</span>
<span class="cm"> *		Cacophonix Gaul :	draft-minshall-nagle-01</span>
<span class="cm"> *		J Hadi Salim	:	ECN support</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) &quot;TCP: &quot; fmt</span>

<span class="cp">#include &lt;net/tcp.h&gt;</span>

<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cm">/* People can turn this off for buggy TCP&#39;s found in printers etc. */</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_retrans_collapse</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/* People can turn this on to work with those rare, broken TCPs that</span>
<span class="cm"> * interpret the window field as a signed quantity.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_workaround_signed_windows</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* This limits the percentage of the congestion window which we</span>
<span class="cm"> * will allow a single TSO frame to consume.  Building TSO frames</span>
<span class="cm"> * which are too large can cause TCP streams to be bursty.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_tso_win_divisor</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">sysctl_tcp_mtu_probing</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_base_mss</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">TCP_BASE_MSS</span><span class="p">;</span>

<span class="cm">/* By default, RFC2861 behavior.  */</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_slow_start_after_idle</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">sysctl_tcp_cookie_size</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* TCP_COOKIE_MAX */</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sysctl_tcp_cookie_size</span><span class="p">);</span>


<span class="cm">/* Account for new data that has been sent to the network. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_event_new_data_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prior_packets</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">;</span>

	<span class="n">tcp_advance_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t override Nagle indefinitely with F-RTO */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prior_packets</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">early_retrans_delayed</span><span class="p">)</span>
		<span class="n">tcp_rearm_rto</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* SND.NXT, if window was not shrunk.</span>
<span class="cm"> * If window has been shrunk, what should we make? It is not clear at all.</span>
<span class="cm"> * Using SND.UNA we will fail to open window, SND.NXT is out of window. :-(</span>
<span class="cm"> * Anything in between SND.UNA...SND.UNA+SND.WND also can be already</span>
<span class="cm"> * invalid. OK, let&#39;s make this for now:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">tcp_acceptable_seq</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">),</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Calculate mss to advertise in SYN segment.</span>
<span class="cm"> * RFC1122, RFC1063, draft-ietf-tcpimpl-pmtud-01 state that:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. It is independent of path mtu.</span>
<span class="cm"> * 2. Ideally, it is maximal possible segment size i.e. 65535-40.</span>
<span class="cm"> * 3. For IPv4 it is reasonable to calculate it from maximal MTU of</span>
<span class="cm"> *    attached devices, because some buggy hosts are confused by</span>
<span class="cm"> *    large MSS.</span>
<span class="cm"> * 4. We do not make 3, we advertise MSS, calculated from first</span>
<span class="cm"> *    hop device mtu, but allow to raise it to ip_rt_min_advmss.</span>
<span class="cm"> *    This may be overridden via information stored in routing table.</span>
<span class="cm"> * 5. Value 65535 for MSS is valid in IPv6 and means &quot;as large as possible,</span>
<span class="cm"> *    probably even Jumbo&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__u16</span> <span class="nf">tcp_advertise_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mss</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">metric</span> <span class="o">=</span> <span class="n">dst_metric_advmss</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">&lt;</span> <span class="n">mss</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mss</span> <span class="o">=</span> <span class="n">metric</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span> <span class="o">=</span> <span class="n">mss</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">__u16</span><span class="p">)</span><span class="n">mss</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* RFC2861. Reset CWND after idle period longer RTO to &quot;restart window&quot;.</span>
<span class="cm"> * This is the first part of cwnd validation mechanism. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_cwnd_restart</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">s32</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lsndtime</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">restart_cwnd</span> <span class="o">=</span> <span class="n">tcp_init_cwnd</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">cwnd</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">;</span>

	<span class="n">tcp_ca_event</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">CA_EVENT_CWND_RESTART</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">tcp_current_ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">restart_cwnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">restart_cwnd</span><span class="p">,</span> <span class="n">cwnd</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">delta</span> <span class="o">-=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cwnd</span> <span class="o">&gt;</span> <span class="n">restart_cwnd</span><span class="p">)</span>
		<span class="n">cwnd</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cwnd</span><span class="p">,</span> <span class="n">restart_cwnd</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Congestion state accounting after a packet has been sent. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_event_data_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">now</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_slow_start_after_idle</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s32</span><span class="p">)(</span><span class="n">now</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lsndtime</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">))</span>
		<span class="n">tcp_cwnd_restart</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lsndtime</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

	<span class="cm">/* If it is a reply for ato after last received</span>
<span class="cm">	 * packet, enter pingpong mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">now</span> <span class="o">-</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">lrcvtime</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span><span class="p">)</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Account for an ACK we sent. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_event_ack_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pkts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_dec_quickack_mode</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">pkts</span><span class="p">);</span>
	<span class="n">inet_csk_clear_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_DACK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Determine a window scaling and initial window to offer.</span>
<span class="cm"> * Based on the assumption that the given amount of space</span>
<span class="cm"> * will be offered. Store the results in the tp structure.</span>
<span class="cm"> * NOTE: for smooth operation initial space offering should</span>
<span class="cm"> * be a multiple of mss if possible. We assume here that mss &gt;= 1.</span>
<span class="cm"> * This MUST be enforced by all callers.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_select_initial_window</span><span class="p">(</span><span class="kt">int</span> <span class="n">__space</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">mss</span><span class="p">,</span>
			       <span class="n">__u32</span> <span class="o">*</span><span class="n">rcv_wnd</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">window_clamp</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">wscale_ok</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">rcv_wscale</span><span class="p">,</span>
			       <span class="n">__u32</span> <span class="n">init_rcv_wnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">space</span> <span class="o">=</span> <span class="p">(</span><span class="n">__space</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">__space</span><span class="p">);</span>

	<span class="cm">/* If no clamp set the clamp to the max possible scaled window */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">window_clamp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">window_clamp</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">65535</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">);</span>
	<span class="n">space</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">window_clamp</span><span class="p">,</span> <span class="n">space</span><span class="p">);</span>

	<span class="cm">/* Quantize space offering to a multiple of mss if possible. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&gt;</span> <span class="n">mss</span><span class="p">)</span>
		<span class="n">space</span> <span class="o">=</span> <span class="p">(</span><span class="n">space</span> <span class="o">/</span> <span class="n">mss</span><span class="p">)</span> <span class="o">*</span> <span class="n">mss</span><span class="p">;</span>

	<span class="cm">/* NOTE: offering an initial window larger than 32767</span>
<span class="cm">	 * will break some buggy TCP stacks. If the admin tells us</span>
<span class="cm">	 * it is likely we could be speaking with such a buggy stack</span>
<span class="cm">	 * we will truncate our initial window offering to 32K-1</span>
<span class="cm">	 * unless the remote has sent us a window scaling option,</span>
<span class="cm">	 * which we interpret as a sign the remote TCP is not</span>
<span class="cm">	 * misinterpreting the window field as a signed quantity.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_workaround_signed_windows</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">rcv_wnd</span><span class="p">)</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">MAX_TCP_WINDOW</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="p">(</span><span class="o">*</span><span class="n">rcv_wnd</span><span class="p">)</span> <span class="o">=</span> <span class="n">space</span><span class="p">;</span>

	<span class="p">(</span><span class="o">*</span><span class="n">rcv_wscale</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wscale_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set window scaling on max possible window</span>
<span class="cm">		 * See RFC1323 for an explanation of the limit to 14</span>
<span class="cm">		 */</span>
		<span class="n">space</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sysctl_rmem_max</span><span class="p">);</span>
		<span class="n">space</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="o">*</span><span class="n">window_clamp</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">space</span> <span class="o">&gt;</span> <span class="mi">65535</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">rcv_wscale</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">14</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">space</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">(</span><span class="o">*</span><span class="n">rcv_wscale</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Set initial window to a value enough for senders starting with</span>
<span class="cm">	 * initial congestion window of TCP_DEFAULT_INIT_RCVWND. Place</span>
<span class="cm">	 * a limit on the initial window when mss is larger than 1460.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mss</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">rcv_wscale</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">init_cwnd</span> <span class="o">=</span> <span class="n">TCP_DEFAULT_INIT_RCVWND</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mss</span> <span class="o">&gt;</span> <span class="mi">1460</span><span class="p">)</span>
			<span class="n">init_cwnd</span> <span class="o">=</span>
			<span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="p">(</span><span class="mi">1460</span> <span class="o">*</span> <span class="n">TCP_DEFAULT_INIT_RCVWND</span><span class="p">)</span> <span class="o">/</span> <span class="n">mss</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="cm">/* when initializing use the value from init_rcv_wnd</span>
<span class="cm">		 * rather than the default from above</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">init_rcv_wnd</span><span class="p">)</span>
			<span class="o">*</span><span class="n">rcv_wnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">rcv_wnd</span><span class="p">,</span> <span class="n">init_rcv_wnd</span> <span class="o">*</span> <span class="n">mss</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="o">*</span><span class="n">rcv_wnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">rcv_wnd</span><span class="p">,</span> <span class="n">init_cwnd</span> <span class="o">*</span> <span class="n">mss</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set the clamp no higher than max representable value */</span>
	<span class="p">(</span><span class="o">*</span><span class="n">window_clamp</span><span class="p">)</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">65535U</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">rcv_wscale</span><span class="p">),</span> <span class="o">*</span><span class="n">window_clamp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_select_initial_window</span><span class="p">);</span>

<span class="cm">/* Chose a new window to advertise, update state in tcp_sock for the</span>
<span class="cm"> * socket, and return result with RFC1323 scaling applied.  The return</span>
<span class="cm"> * value can be stuffed directly into th-&gt;window for an outgoing</span>
<span class="cm"> * frame.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="nf">tcp_select_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">cur_win</span> <span class="o">=</span> <span class="n">tcp_receive_window</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">new_win</span> <span class="o">=</span> <span class="n">__tcp_select_window</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Never shrink the offered window */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_win</span> <span class="o">&lt;</span> <span class="n">cur_win</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Danger Will Robinson!</span>
<span class="cm">		 * Don&#39;t update rcv_wup/rcv_wnd here or else</span>
<span class="cm">		 * we will not be able to advertise a zero</span>
<span class="cm">		 * window in time.  --DaveM</span>
<span class="cm">		 *</span>
<span class="cm">		 * Relax Will Robinson.</span>
<span class="cm">		 */</span>
		<span class="n">new_win</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">cur_win</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span> <span class="o">=</span> <span class="n">new_win</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">;</span>

	<span class="cm">/* Make sure we do not exceed the maximum possible</span>
<span class="cm">	 * scaled window.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span> <span class="o">&amp;&amp;</span> <span class="n">sysctl_tcp_workaround_signed_windows</span><span class="p">)</span>
		<span class="n">new_win</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">new_win</span><span class="p">,</span> <span class="n">MAX_TCP_WINDOW</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">new_win</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">new_win</span><span class="p">,</span> <span class="p">(</span><span class="mi">65535U</span> <span class="o">&lt;&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span><span class="p">));</span>

	<span class="cm">/* RFC1323 scaling applied */</span>
	<span class="n">new_win</span> <span class="o">&gt;&gt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span><span class="p">;</span>

	<span class="cm">/* If we advertise zero window, disable fast path. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_win</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">pred_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">new_win</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Packet ECN state for a SYN-ACK */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">TCP_ECN_send_synack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPHDR_CWR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_OK</span><span class="p">))</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPHDR_ECE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Packet ECN state for a SYN.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">TCP_ECN_send_syn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_ecn</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCPHDR_ECE</span> <span class="o">|</span> <span class="n">TCPHDR_CWR</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">=</span> <span class="n">TCP_ECN_OK</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span>
<span class="nf">TCP_ECN_make_synack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ecn_ok</span><span class="p">)</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">ece</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set up ECN state for a packet on a ESTABLISHED socket that is about to</span>
<span class="cm"> * be sent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">TCP_ECN_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">tcp_header_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not-retransmitted data segment: set ECT and inject CWR. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">tcp_header_len</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">INET_ECN_xmit</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_QUEUE_CWR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_ECN_QUEUE_CWR</span><span class="p">;</span>
				<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cwr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">|=</span> <span class="n">SKB_GSO_TCP_ECN</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* ACK or retransmitted segment: clear ECT|CE */</span>
			<span class="n">INET_ECN_dontxmit</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_DEMAND_CWR</span><span class="p">)</span>
			<span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ece</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Constructs common control bits of non-data skb. If SYN/FIN is present,</span>
<span class="cm"> * auto increment end seqno.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_init_nondata_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPHDR_SYN</span> <span class="o">|</span> <span class="n">TCPHDR_FIN</span><span class="p">))</span>
		<span class="n">seq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_urg_mode</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_up</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define OPTION_SACK_ADVERTISE	(1 &lt;&lt; 0)</span>
<span class="cp">#define OPTION_TS		(1 &lt;&lt; 1)</span>
<span class="cp">#define OPTION_MD5		(1 &lt;&lt; 2)</span>
<span class="cp">#define OPTION_WSCALE		(1 &lt;&lt; 3)</span>
<span class="cp">#define OPTION_COOKIE_EXTENSION	(1 &lt;&lt; 4)</span>

<span class="k">struct</span> <span class="n">tcp_out_options</span> <span class="p">{</span>
	<span class="n">u8</span> <span class="n">options</span><span class="p">;</span>		<span class="cm">/* bit field of OPTION_* */</span>
	<span class="n">u8</span> <span class="n">ws</span><span class="p">;</span>			<span class="cm">/* window scale, 0 to disable */</span>
	<span class="n">u8</span> <span class="n">num_sack_blocks</span><span class="p">;</span>	<span class="cm">/* number of SACK blocks to include */</span>
	<span class="n">u8</span> <span class="n">hash_size</span><span class="p">;</span>		<span class="cm">/* bytes in hash_location */</span>
	<span class="n">u16</span> <span class="n">mss</span><span class="p">;</span>		<span class="cm">/* 0 to disable */</span>
	<span class="n">__u32</span> <span class="n">tsval</span><span class="p">,</span> <span class="n">tsecr</span><span class="p">;</span>	<span class="cm">/* need to include OPTION_TS */</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">hash_location</span><span class="p">;</span>	<span class="cm">/* temporary pointer, overloaded */</span>
<span class="p">};</span>

<span class="cm">/* The sysctl int routines are generic, so check consistency here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">tcp_cookie_size_check</span><span class="p">(</span><span class="n">u8</span> <span class="n">desired</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cookie_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desired</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* previously specified */</span>
		<span class="k">return</span> <span class="n">desired</span><span class="p">;</span>

	<span class="n">cookie_size</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">sysctl_tcp_cookie_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cookie_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* no default specified */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cookie_size</span> <span class="o">&lt;=</span> <span class="n">TCP_COOKIE_MIN</span><span class="p">)</span>
		<span class="cm">/* value too small, specify minimum */</span>
		<span class="k">return</span> <span class="n">TCP_COOKIE_MIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cookie_size</span> <span class="o">&gt;=</span> <span class="n">TCP_COOKIE_MAX</span><span class="p">)</span>
		<span class="cm">/* value too large, specify maximum */</span>
		<span class="k">return</span> <span class="n">TCP_COOKIE_MAX</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cookie_size</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* 8-bit multiple, illegal, fix it */</span>
		<span class="n">cookie_size</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">cookie_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Write previously computed TCP options to the packet.</span>
<span class="cm"> *</span>
<span class="cm"> * Beware: Something in the Internet is very sensitive to the ordering of</span>
<span class="cm"> * TCP options, we learned this through the hard way, so be careful here.</span>
<span class="cm"> * Luckily we can at least blame others for their non-compliance but from</span>
<span class="cm"> * inter-operatibility perspective it seems that we&#39;re somewhat stuck with</span>
<span class="cm"> * the ordering which we have been using if we want to keep working with</span>
<span class="cm"> * those broken things (not that it currently hurts anybody as there isn&#39;t</span>
<span class="cm"> * particular reason why the ordering would need to be changed).</span>
<span class="cm"> *</span>
<span class="cm"> * At least SACK_PERM as the first option is known to lead to a disaster</span>
<span class="cm"> * (but it may well be that other scenarios fail similarly).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_options_write</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">tcp_out_options</span> <span class="o">*</span><span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">options</span> <span class="o">=</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">;</span>	<span class="cm">/* mungable copy */</span>

	<span class="cm">/* Having both authentication and cookies for security is redundant,</span>
<span class="cm">	 * and there&#39;s certainly not enough room.  Instead, the cookie-less</span>
<span class="cm">	 * extension variant is proposed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Consider the pessimal case with authentication.  The options</span>
<span class="cm">	 * could look like:</span>
<span class="cm">	 *   COOKIE|MD5(20) + MSS(4) + SACK|TS(12) + WSCALE(4) == 40</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">OPTION_MD5</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">OPTION_COOKIE_EXTENSION</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">((</span><span class="n">TCPOPT_COOKIE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
				       <span class="p">(</span><span class="n">TCPOLEN_COOKIE_BASE</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
				       <span class="p">(</span><span class="n">TCPOPT_MD5SIG</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
				       <span class="n">TCPOLEN_MD5SIG</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">((</span><span class="n">TCPOPT_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
				       <span class="p">(</span><span class="n">TCPOPT_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
				       <span class="p">(</span><span class="n">TCPOPT_MD5SIG</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
				       <span class="n">TCPOLEN_MD5SIG</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">OPTION_COOKIE_EXTENSION</span><span class="p">;</span>
		<span class="cm">/* overload cookie hash location */</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">hash_location</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">mss</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">((</span><span class="n">TCPOPT_MSS</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">TCPOLEN_MSS</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			       <span class="n">opts</span><span class="o">-&gt;</span><span class="n">mss</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">OPTION_TS</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">OPTION_SACK_ADVERTISE</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">((</span><span class="n">TCPOPT_SACK_PERM</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
				       <span class="p">(</span><span class="n">TCPOLEN_SACK_PERM</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
				       <span class="p">(</span><span class="n">TCPOPT_TIMESTAMP</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
				       <span class="n">TCPOLEN_TIMESTAMP</span><span class="p">);</span>
			<span class="n">options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">OPTION_SACK_ADVERTISE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">((</span><span class="n">TCPOPT_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
				       <span class="p">(</span><span class="n">TCPOPT_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
				       <span class="p">(</span><span class="n">TCPOPT_TIMESTAMP</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
				       <span class="n">TCPOLEN_TIMESTAMP</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">tsval</span><span class="p">);</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">tsecr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Specification requires after timestamp, so do it now.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Consider the pessimal case without authentication.  The options</span>
<span class="cm">	 * could look like:</span>
<span class="cm">	 *   MSS(4) + SACK|TS(12) + COOKIE(20) + WSCALE(4) == 40</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">OPTION_COOKIE_EXTENSION</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__u8</span> <span class="o">*</span><span class="n">cookie_copy</span> <span class="o">=</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">hash_location</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">cookie_size</span> <span class="o">=</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">hash_size</span><span class="p">;</span>

		<span class="cm">/* 8-bit multiple handled in tcp_cookie_size_check() above,</span>
<span class="cm">		 * and elsewhere.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="mh">0x2</span> <span class="o">&amp;</span> <span class="n">cookie_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__u8</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

			<span class="cm">/* 16-bit multiple */</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">TCPOPT_COOKIE</span><span class="p">;</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">TCPOLEN_COOKIE_BASE</span> <span class="o">+</span> <span class="n">cookie_size</span><span class="p">;</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">cookie_copy</span><span class="o">++</span><span class="p">;</span>
			<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">cookie_copy</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cookie_size</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* 32-bit multiple */</span>
			<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(((</span><span class="n">TCPOPT_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">TCPOPT_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">TCPOPT_COOKIE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">TCPOLEN_COOKIE_BASE</span><span class="p">)</span> <span class="o">+</span>
				       <span class="n">cookie_size</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cookie_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">cookie_copy</span><span class="p">,</span> <span class="n">cookie_size</span><span class="p">);</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">cookie_size</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">OPTION_SACK_ADVERTISE</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">((</span><span class="n">TCPOPT_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">TCPOPT_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">TCPOPT_SACK_PERM</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			       <span class="n">TCPOLEN_SACK_PERM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">OPTION_WSCALE</span> <span class="o">&amp;</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">((</span><span class="n">TCPOPT_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">TCPOPT_WINDOW</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">TCPOLEN_WINDOW</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			       <span class="n">opts</span><span class="o">-&gt;</span><span class="n">ws</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_sack_blocks</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">dsack</span> <span class="o">?</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">duplicate_sack</span> <span class="o">:</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">selective_acks</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">this_sack</span><span class="p">;</span>

		<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">((</span><span class="n">TCPOPT_NOP</span>  <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">TCPOPT_NOP</span>  <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">TCPOPT_SACK</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
			       <span class="p">(</span><span class="n">TCPOLEN_SACK_BASE</span> <span class="o">+</span> <span class="p">(</span><span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_sack_blocks</span> <span class="o">*</span>
						     <span class="n">TCPOLEN_SACK_PERBLOCK</span><span class="p">)));</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">this_sack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">this_sack</span> <span class="o">&lt;</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_sack_blocks</span><span class="p">;</span>
		     <span class="o">++</span><span class="n">this_sack</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">this_sack</span><span class="p">].</span><span class="n">start_seq</span><span class="p">);</span>
			<span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">this_sack</span><span class="p">].</span><span class="n">end_seq</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">dsack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Compute TCP options for SYN packets. This is not the final</span>
<span class="cm"> * network wire format yet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_syn_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tcp_out_options</span> <span class="o">*</span><span class="n">opts</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">**</span><span class="n">md5</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_cookie_values</span> <span class="o">*</span><span class="n">cvp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">MAX_TCP_OPTION_SPACE</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cookie_size</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">cookie_out_never</span> <span class="o">&amp;&amp;</span> <span class="n">cvp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span>
			 <span class="n">tcp_cookie_size_check</span><span class="p">(</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_desired</span><span class="p">)</span> <span class="o">:</span>
			 <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="o">*</span><span class="n">md5</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">md5_lookup</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">md5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_MD5</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">TCPOLEN_MD5SIG_ALIGNED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="o">*</span><span class="n">md5</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* We always get an MSS option.  The option bytes which will be seen in</span>
<span class="cm">	 * normal data packets should timestamps be used, must be in the MSS</span>
<span class="cm">	 * advertised.  But we subtract them from tp-&gt;mss_cache so that</span>
<span class="cm">	 * calculations in tcp_sendmsg are simpler etc.  So account for this</span>
<span class="cm">	 * fact here if necessary.  If we don&#39;t do this correctly, as a</span>
<span class="cm">	 * receiver we won&#39;t recognize data packets as being full sized when we</span>
<span class="cm">	 * should, and thus we won&#39;t abide by the delayed ACK rules correctly.</span>
<span class="cm">	 * SACKs don&#39;t matter, we never delay an ACK when we have any of those</span>
<span class="cm">	 * going out.  */</span>
	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mss</span> <span class="o">=</span> <span class="n">tcp_advertise_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">remaining</span> <span class="o">-=</span> <span class="n">TCPOLEN_MSS_ALIGNED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sysctl_tcp_timestamps</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">md5</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_TS</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">tsval</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">tsecr</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sysctl_tcp_window_scaling</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">ws</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_WSCALE</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">TCPOLEN_WSCALE_ALIGNED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sysctl_tcp_sack</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_SACK_ADVERTISE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">OPTION_TS</span> <span class="o">&amp;</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">)))</span>
			<span class="n">remaining</span> <span class="o">-=</span> <span class="n">TCPOLEN_SACKPERM_ALIGNED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Note that timestamps are required by the specification.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Odd numbers of bytes are prohibited by the specification, ensuring</span>
<span class="cm">	 * that the cookie is 16-bit aligned, and the resulting cookie pair is</span>
<span class="cm">	 * 32-bit aligned.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">md5</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">OPTION_TS</span> <span class="o">&amp;</span> <span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cookie_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">need</span> <span class="o">=</span> <span class="n">TCPOLEN_COOKIE_BASE</span> <span class="o">+</span> <span class="n">cookie_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="mh">0x2</span> <span class="o">&amp;</span> <span class="n">need</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* 32-bit multiple */</span>
			<span class="n">need</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* NOPs */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">need</span> <span class="o">&gt;</span> <span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* try shrinking cookie to fit */</span>
				<span class="n">cookie_size</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="n">need</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">need</span> <span class="o">&gt;</span> <span class="n">remaining</span> <span class="o">&amp;&amp;</span> <span class="n">TCP_COOKIE_MIN</span> <span class="o">&lt;=</span> <span class="n">cookie_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cookie_size</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
			<span class="n">need</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TCP_COOKIE_MIN</span> <span class="o">&lt;=</span> <span class="n">cookie_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_COOKIE_EXTENSION</span><span class="p">;</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">hash_location</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">hash_size</span> <span class="o">=</span> <span class="n">cookie_size</span><span class="p">;</span>

			<span class="cm">/* Remember for future incarnations. */</span>
			<span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_desired</span> <span class="o">=</span> <span class="n">cookie_size</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_desired</span> <span class="o">!=</span> <span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_pair_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Currently use random bytes as a nonce,</span>
<span class="cm">				 * assuming these are completely unpredictable</span>
<span class="cm">				 * by hostile users of the same system.</span>
<span class="cm">				 */</span>
				<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						 <span class="n">cookie_size</span><span class="p">);</span>
				<span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_pair_size</span> <span class="o">=</span> <span class="n">cookie_size</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">remaining</span> <span class="o">-=</span> <span class="n">need</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">MAX_TCP_OPTION_SPACE</span> <span class="o">-</span> <span class="n">remaining</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set up TCP options for SYN-ACKs. */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_synack_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">tcp_out_options</span> <span class="o">*</span><span class="n">opts</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">**</span><span class="n">md5</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">tcp_extend_values</span> <span class="o">*</span><span class="n">xvp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_request_sock</span> <span class="o">*</span><span class="n">ireq</span> <span class="o">=</span> <span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">MAX_TCP_OPTION_SPACE</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">cookie_plus</span> <span class="o">=</span> <span class="p">(</span><span class="n">xvp</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xvp</span><span class="o">-&gt;</span><span class="n">cookie_out_never</span><span class="p">)</span> <span class="o">?</span>
			 <span class="n">xvp</span><span class="o">-&gt;</span><span class="n">cookie_plus</span> <span class="o">:</span>
			 <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="o">*</span><span class="n">md5</span> <span class="o">=</span> <span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">md5_lookup</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">md5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_MD5</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">TCPOLEN_MD5SIG_ALIGNED</span><span class="p">;</span>

		<span class="cm">/* We can&#39;t fit any SACK blocks in a packet with MD5 + TS</span>
<span class="cm">		 * options. There was discussion about disabling SACK</span>
<span class="cm">		 * rather than TS in order to fit in better with old,</span>
<span class="cm">		 * buggy kernels, but that was deemed to be unnecessary.</span>
<span class="cm">		 */</span>
		<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">tstamp_ok</span> <span class="o">&amp;=</span> <span class="o">!</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">sack_ok</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="o">*</span><span class="n">md5</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* We always send an MSS option. */</span>
	<span class="n">opts</span><span class="o">-&gt;</span><span class="n">mss</span> <span class="o">=</span> <span class="n">mss</span><span class="p">;</span>
	<span class="n">remaining</span> <span class="o">-=</span> <span class="n">TCPOLEN_MSS_ALIGNED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">wscale_ok</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">ws</span> <span class="o">=</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">rcv_wscale</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_WSCALE</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">TCPOLEN_WSCALE_ALIGNED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">tstamp_ok</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_TS</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">tsval</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">tsecr</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">ts_recent</span><span class="p">;</span>
		<span class="n">remaining</span> <span class="o">-=</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">sack_ok</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_SACK_ADVERTISE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">tstamp_ok</span><span class="p">))</span>
			<span class="n">remaining</span> <span class="o">-=</span> <span class="n">TCPOLEN_SACKPERM_ALIGNED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Similar rationale to tcp_syn_options() applies here, too.</span>
<span class="cm">	 * If the &lt;SYN&gt; options fit, the same options should fit now!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">md5</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">tstamp_ok</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cookie_plus</span> <span class="o">&gt;</span> <span class="n">TCPOLEN_COOKIE_BASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">need</span> <span class="o">=</span> <span class="n">cookie_plus</span><span class="p">;</span> <span class="cm">/* has TCPOLEN_COOKIE_BASE */</span>

		<span class="k">if</span> <span class="p">(</span><span class="mh">0x2</span> <span class="o">&amp;</span> <span class="n">need</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* 32-bit multiple */</span>
			<span class="n">need</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* NOPs */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need</span> <span class="o">&lt;=</span> <span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_COOKIE_EXTENSION</span><span class="p">;</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">hash_size</span> <span class="o">=</span> <span class="n">cookie_plus</span> <span class="o">-</span> <span class="n">TCPOLEN_COOKIE_BASE</span><span class="p">;</span>
			<span class="n">remaining</span> <span class="o">-=</span> <span class="n">need</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* There&#39;s no error return, so flag it. */</span>
			<span class="n">xvp</span><span class="o">-&gt;</span><span class="n">cookie_out_never</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* true */</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">hash_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">MAX_TCP_OPTION_SPACE</span> <span class="o">-</span> <span class="n">remaining</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Compute TCP options for ESTABLISHED sockets. This is not the</span>
<span class="cm"> * final wire format yet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_established_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">tcp_out_options</span> <span class="o">*</span><span class="n">opts</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">**</span><span class="n">md5</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_skb_cb</span> <span class="o">*</span><span class="n">tcb</span> <span class="o">=</span> <span class="n">skb</span> <span class="o">?</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eff_sacks</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="o">*</span><span class="n">md5</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">md5_lookup</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">md5</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_MD5</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">TCPOLEN_MD5SIG_ALIGNED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="o">*</span><span class="n">md5</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">tstamp_ok</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">options</span> <span class="o">|=</span> <span class="n">OPTION_TS</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">tsval</span> <span class="o">=</span> <span class="n">tcb</span> <span class="o">?</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">tsecr</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">eff_sacks</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span> <span class="o">+</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">dsack</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">eff_sacks</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">MAX_TCP_OPTION_SPACE</span> <span class="o">-</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_sack_blocks</span> <span class="o">=</span>
			<span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">eff_sacks</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">remaining</span> <span class="o">-</span> <span class="n">TCPOLEN_SACK_BASE_ALIGNED</span><span class="p">)</span> <span class="o">/</span>
			      <span class="n">TCPOLEN_SACK_PERBLOCK</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">TCPOLEN_SACK_BASE_ALIGNED</span> <span class="o">+</span>
			<span class="n">opts</span><span class="o">-&gt;</span><span class="n">num_sack_blocks</span> <span class="o">*</span> <span class="n">TCPOLEN_SACK_PERBLOCK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This routine actually transmits TCP packets queued in by</span>
<span class="cm"> * tcp_do_sendmsg().  This is used by both the initial</span>
<span class="cm"> * transmission and possible later retransmissions.</span>
<span class="cm"> * All SKB&#39;s seen here are completely headerless.  It is our</span>
<span class="cm"> * job to build the TCP header, and pass the packet down to</span>
<span class="cm"> * IP so it can do the same plus pass the packet off to the</span>
<span class="cm"> * device.</span>
<span class="cm"> *</span>
<span class="cm"> * We are working here with either a clone of the original</span>
<span class="cm"> * SKB, or a fresh unique copy made by the retransmit engine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_transmit_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">clone_it</span><span class="p">,</span>
			    <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_skb_cb</span> <span class="o">*</span><span class="n">tcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_out_options</span> <span class="n">opts</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tcp_options_size</span><span class="p">,</span> <span class="n">tcp_header_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="n">md5</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span> <span class="o">||</span> <span class="o">!</span><span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="cm">/* If congestion control is doing timestamping, we must</span>
<span class="cm">	 * take such a timestamp before we potentially clone/copy.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCP_CONG_RTT_STAMP</span><span class="p">)</span>
		<span class="n">__net_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">clone_it</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">pskb_copy</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tcb</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opts</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_SYN</span><span class="p">))</span>
		<span class="n">tcp_options_size</span> <span class="o">=</span> <span class="n">tcp_syn_options</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">md5</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tcp_options_size</span> <span class="o">=</span> <span class="n">tcp_established_options</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">md5</span><span class="p">);</span>
	<span class="n">tcp_header_size</span> <span class="o">=</span> <span class="n">tcp_options_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_ca_event</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">CA_EVENT_TX_START</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ooo_okay</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ooo_okay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tcp_header_size</span><span class="p">);</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_set_owner_w</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Build TCP header and checksum it. */</span>
	<span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">source</span>		<span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_sport</span><span class="p">;</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">dest</span>		<span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_dport</span><span class="p">;</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">seq</span>			<span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">ack_seq</span>		<span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(((</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span><span class="n">th</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span>	<span class="o">=</span> <span class="n">htons</span><span class="p">(((</span><span class="n">tcp_header_size</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">tcp_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_SYN</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* RFC1323: The window in SYN &amp; SYN/ACK segments</span>
<span class="cm">		 * is never scaled.</span>
<span class="cm">		 */</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">window</span>	<span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">,</span> <span class="mi">65535U</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">window</span>	<span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">tcp_select_window</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">check</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">urg_ptr</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The urg_mode check is necessary during a below snd_una win probe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tcp_urg_mode</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">before</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_up</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_up</span><span class="p">,</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="mh">0x10000</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">th</span><span class="o">-&gt;</span><span class="n">urg_ptr</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_up</span> <span class="o">-</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
			<span class="n">th</span><span class="o">-&gt;</span><span class="n">urg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="mh">0xFFFF</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">th</span><span class="o">-&gt;</span><span class="n">urg_ptr</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mh">0xFFFF</span><span class="p">);</span>
			<span class="n">th</span><span class="o">-&gt;</span><span class="n">urg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tcp_options_write</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)(</span><span class="n">th</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_SYN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">TCP_ECN_send</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tcp_header_size</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="cm">/* Calculate the MD5 hash, as we have all we need now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">md5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk_nocaps_add</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">NETIF_F_GSO_MASK</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">calc_md5_hash</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">hash_location</span><span class="p">,</span>
					       <span class="n">md5</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">send_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_ACK</span><span class="p">))</span>
		<span class="n">tcp_event_ack_sent</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">tcp_header_size</span><span class="p">)</span>
		<span class="n">tcp_event_data_sent</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">tcb</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">)</span> <span class="o">||</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">==</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">)</span>
		<span class="n">TCP_ADD_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_OUTSEGS</span><span class="p">,</span>
			      <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">cork</span><span class="p">.</span><span class="n">fl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">tcp_enter_cwr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">net_xmit_eval</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This routine just queues the buffer for sending.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: probe0 timer is not checked, do not forget tcp_push_pending_frames,</span>
<span class="cm"> * otherwise socket can stall.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_queue_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Advance write_seq and place onto the write_queue. */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
	<span class="n">skb_header_release</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">tcp_add_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialize TSO segments for a packet. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_set_skb_tso_segs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss_now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">mss_now</span> <span class="o">||</span> <span class="o">!</span><span class="n">sk_can_gso</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Avoid the costly divide in the normal</span>
<span class="cm">		 * non-TSO case.</span>
<span class="cm">		 */</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="n">mss_now</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_gso_type</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* When a modification to fackets out becomes necessary, we need to check</span>
<span class="cm"> * skb is counted to fackets_out or not.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_adjust_fackets_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">decr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">||</span> <span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">tcp_highest_sack_seq</span><span class="p">(</span><span class="n">tp</span><span class="p">),</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">-=</span> <span class="n">decr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pcount in the middle of the write queue got changed, we need to do various</span>
<span class="cm"> * tweaks to fix counters</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_adjust_pcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">decr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">-=</span> <span class="n">decr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">-=</span> <span class="n">decr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_RETRANS</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">-=</span> <span class="n">decr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_LOST</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">-=</span> <span class="n">decr</span><span class="p">;</span>

	<span class="cm">/* Reno case is special. Sigh... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">decr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">-=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">,</span> <span class="n">decr</span><span class="p">);</span>

	<span class="n">tcp_adjust_fackets_out</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">decr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span> <span class="o">&amp;&amp;</span>
	    <span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">)))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_cnt_hint</span> <span class="o">-=</span> <span class="n">decr</span><span class="p">;</span>

	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Function to create two new TCP segments.  Shrinks the given segment</span>
<span class="cm"> * to the specified size and appends a new segment with the rest of the</span>
<span class="cm"> * packet to the list.  This won&#39;t be called frequently, I hope.</span>
<span class="cm"> * Remember, these are still headerless SKBs at this point.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tcp_fragment</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss_now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nsize</span><span class="p">,</span> <span class="n">old_factor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nlen</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">nsize</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Get a new skb... force flag on. */</span>
	<span class="n">buff</span> <span class="o">=</span> <span class="n">sk_stream_alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nsize</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span> <span class="cm">/* We&#39;ll just try again later. */</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+=</span> <span class="n">buff</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buff</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
	<span class="n">nlen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">len</span> <span class="o">-</span> <span class="n">nsize</span><span class="p">;</span>
	<span class="n">buff</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">nlen</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">-=</span> <span class="n">nlen</span><span class="p">;</span>

	<span class="cm">/* Correct the sequence numbers. */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>

	<span class="cm">/* PSH and FIN should only be set in the second packet. */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">TCPHDR_FIN</span> <span class="o">|</span> <span class="n">TCPHDR_PSH</span><span class="p">);</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Copy and checksum data tail into the new buffer. */</span>
		<span class="n">buff</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">csum_partial_copy_nocheck</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
						       <span class="n">skb_put</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">nsize</span><span class="p">),</span>
						       <span class="n">nsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">csum_block_sub</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">buff</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>
		<span class="n">skb_split</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">buff</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span><span class="p">;</span>

	<span class="cm">/* Looks stupid, but our code really uses when of</span>
<span class="cm">	 * skbs, which it never sent before. --ANK</span>
<span class="cm">	 */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span><span class="p">;</span>
	<span class="n">buff</span><span class="o">-&gt;</span><span class="n">tstamp</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">;</span>

	<span class="n">old_factor</span> <span class="o">=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Fix up tso_factor for both original and new SKB.  */</span>
	<span class="n">tcp_set_skb_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>
	<span class="n">tcp_set_skb_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>

	<span class="cm">/* If this packet has been sent out already, we must</span>
<span class="cm">	 * adjust the various packet counters.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">old_factor</span> <span class="o">-</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">diff</span><span class="p">)</span>
			<span class="n">tcp_adjust_pcount</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">diff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Link BUFF into the send queue. */</span>
	<span class="n">skb_header_release</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
	<span class="n">tcp_insert_write_queue_after</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is similar to __pskb_pull_head() (it will go to core/skbuff.c</span>
<span class="cm"> * eventually). The difference is that pulled data not copied, but</span>
<span class="cm"> * immediately discarded.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__pskb_trim_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">eat</span><span class="p">;</span>

	<span class="n">eat</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">eat</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">avail_size</span> <span class="o">-=</span> <span class="n">eat</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">eat</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">eat</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">eat</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_frag_unref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">eat</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eat</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">eat</span><span class="p">;</span>
				<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">eat</span><span class="p">);</span>
				<span class="n">eat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">k</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>

	<span class="n">skb_reset_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove acked data from a packet in the transmit queue. */</span>
<span class="kt">int</span> <span class="nf">tcp_trim_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">__pskb_trim_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span>	     <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span>   <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">sk_mem_uncharge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_QUEUE_SHRUNK</span><span class="p">);</span>

	<span class="cm">/* Any change of skb-&gt;len requires recalculation of tso factor. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">tcp_set_skb_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tcp_skb_mss</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Calculate MSS. Not accounting for SACKs here.  */</span>
<span class="kt">int</span> <span class="nf">tcp_mtu_to_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pmtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mss_now</span><span class="p">;</span>

	<span class="cm">/* Calculate base mss without TCP options:</span>
<span class="cm">	   It is MMS_S - sizeof(tcphdr) of rfc1122</span>
<span class="cm">	 */</span>
	<span class="n">mss_now</span> <span class="o">=</span> <span class="n">pmtu</span> <span class="o">-</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">net_header_len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">);</span>

	<span class="cm">/* IPv6 adds a frag_hdr in case RTAX_FEATURE_ALLFRAG is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">net_frag_header_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">&amp;&amp;</span> <span class="n">dst_allfrag</span><span class="p">(</span><span class="n">dst</span><span class="p">))</span>
			<span class="n">mss_now</span> <span class="o">-=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">net_frag_header_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clamp it (mss_clamp does not include tcp options) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mss_now</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span><span class="p">)</span>
		<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span><span class="p">;</span>

	<span class="cm">/* Now subtract optional transport overhead */</span>
	<span class="n">mss_now</span> <span class="o">-=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ext_hdr_len</span><span class="p">;</span>

	<span class="cm">/* Then reserve room for full set of TCP options and 8 bytes of data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mss_now</span> <span class="o">&lt;</span> <span class="mi">48</span><span class="p">)</span>
		<span class="n">mss_now</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>

	<span class="cm">/* Now subtract TCP options size, not including SACKs */</span>
	<span class="n">mss_now</span> <span class="o">-=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mss_now</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Inverse of above */</span>
<span class="kt">int</span> <span class="nf">tcp_mss_to_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mtu</span><span class="p">;</span>

	<span class="n">mtu</span> <span class="o">=</span> <span class="n">mss</span> <span class="o">+</span>
	      <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">+</span>
	      <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ext_hdr_len</span> <span class="o">+</span>
	      <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">net_header_len</span><span class="p">;</span>

	<span class="cm">/* IPv6 adds a frag_hdr in case RTAX_FEATURE_ALLFRAG is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">net_frag_header_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">&amp;&amp;</span> <span class="n">dst_allfrag</span><span class="p">(</span><span class="n">dst</span><span class="p">))</span>
			<span class="n">mtu</span> <span class="o">+=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">net_frag_header_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">mtu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* MTU probing init per socket */</span>
<span class="kt">void</span> <span class="nf">tcp_mtup_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="n">sysctl_tcp_mtu_probing</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">search_high</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">+</span>
			       <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">net_header_len</span><span class="p">;</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">search_low</span> <span class="o">=</span> <span class="n">tcp_mss_to_mtu</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sysctl_tcp_base_mss</span><span class="p">);</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_mtup_init</span><span class="p">);</span>

<span class="cm">/* This function synchronize snd mss to current pmtu/exthdr set.</span>

<span class="cm">   tp-&gt;rx_opt.user_mss is mss set by user by TCP_MAXSEG. It does NOT counts</span>
<span class="cm">   for TCP options, but includes only bare TCP header.</span>

<span class="cm">   tp-&gt;rx_opt.mss_clamp is mss negotiated at connection setup.</span>
<span class="cm">   It is minimum of user_mss and mss received with SYN.</span>
<span class="cm">   It also does not include TCP options.</span>

<span class="cm">   inet_csk(sk)-&gt;icsk_pmtu_cookie is last pmtu, seen by this function.</span>

<span class="cm">   tp-&gt;mss_cache is current effective sending mss, including</span>
<span class="cm">   all tcp options except for SACKs. It is evaluated,</span>
<span class="cm">   taking into account current pmtu, but never exceeds</span>
<span class="cm">   tp-&gt;rx_opt.mss_clamp.</span>

<span class="cm">   NOTE1. rfc1122 clearly states that advertised MSS</span>
<span class="cm">   DOES NOT include either tcp or ip options.</span>

<span class="cm">   NOTE2. inet_csk(sk)-&gt;icsk_pmtu_cookie and tp-&gt;mss_cache</span>
<span class="cm">   are READ ONLY outside this function.		--ANK (980731)</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_sync_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pmtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mss_now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">search_high</span> <span class="o">&gt;</span> <span class="n">pmtu</span><span class="p">)</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">search_high</span> <span class="o">=</span> <span class="n">pmtu</span><span class="p">;</span>

	<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tcp_mtu_to_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">pmtu</span><span class="p">);</span>
	<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tcp_bound_to_half_wnd</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>

	<span class="cm">/* And store cached results */</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_pmtu_cookie</span> <span class="o">=</span> <span class="n">pmtu</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">enabled</span><span class="p">)</span>
		<span class="n">mss_now</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">mss_now</span><span class="p">,</span> <span class="n">tcp_mtu_to_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">search_low</span><span class="p">));</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span> <span class="o">=</span> <span class="n">mss_now</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mss_now</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_sync_mss</span><span class="p">);</span>

<span class="cm">/* Compute the current effective MSS, taking SACKs and IP options,</span>
<span class="cm"> * and even PMTU discovery events into account.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_current_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">mss_now</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_out_options</span> <span class="n">opts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="n">md5</span><span class="p">;</span>

	<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">mtu</span> <span class="o">=</span> <span class="n">dst_mtu</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mtu</span> <span class="o">!=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_pmtu_cookie</span><span class="p">)</span>
			<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tcp_sync_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">mtu</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">header_len</span> <span class="o">=</span> <span class="n">tcp_established_options</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">md5</span><span class="p">)</span> <span class="o">+</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">);</span>
	<span class="cm">/* The mss_cache is sized based on tp-&gt;tcp_header_len, which assumes</span>
<span class="cm">	 * some common options. If this is an odd packet (because we have SACK</span>
<span class="cm">	 * blocks etc) then our calculated header_len will be different, and</span>
<span class="cm">	 * we have to adjust mss_now correspondingly */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">header_len</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">header_len</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span><span class="p">;</span>
		<span class="n">mss_now</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">mss_now</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Congestion window validation. (RFC2861) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_cwnd_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&gt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Network is feed fully. */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Network starves. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_used</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_used</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_slow_start_after_idle</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">s32</span><span class="p">)(</span><span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">)</span>
			<span class="n">tcp_cwnd_application_limited</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Returns the portion of skb which can be sent right away without</span>
<span class="cm"> * introducing MSS oddities to segment boundaries. In rare cases where</span>
<span class="cm"> * mss_now != mss_cache, we will request caller to create a small skb</span>
<span class="cm"> * per input skb which could be mostly avoided here (if desired).</span>
<span class="cm"> *</span>
<span class="cm"> * We explicitly want to create a request for splitting write queue tail</span>
<span class="cm"> * to a small skb for Nagle purposes while avoiding unnecessary modulos,</span>
<span class="cm"> * thus all the complexity (cwnd_len is always MSS multiple which we</span>
<span class="cm"> * return whenever allowed by the other factors). Basically we need the</span>
<span class="cm"> * modulo only when the receiver window alone is the limiting factor or</span>
<span class="cm"> * when we would be allowed to send the split-due-to-Nagle skb fully.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_mss_split_point</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss_now</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cwnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">needed</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">cwnd_len</span><span class="p">;</span>

	<span class="n">window</span> <span class="o">=</span> <span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">cwnd_len</span> <span class="o">=</span> <span class="n">mss_now</span> <span class="o">*</span> <span class="n">cwnd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">cwnd_len</span> <span class="o">&lt;=</span> <span class="n">window</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span> <span class="o">!=</span> <span class="n">tcp_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">cwnd_len</span><span class="p">;</span>

	<span class="n">needed</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">window</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cwnd_len</span> <span class="o">&lt;=</span> <span class="n">needed</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cwnd_len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">needed</span> <span class="o">-</span> <span class="n">needed</span> <span class="o">%</span> <span class="n">mss_now</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Can at least one segment of SKB be sent right now, according to the</span>
<span class="cm"> * congestion window rules?  If so, return how many segments are allowed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_cwnd_test</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">in_flight</span><span class="p">,</span> <span class="n">cwnd</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t be strict about the congestion window for the final FIN.  */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_FIN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">in_flight</span> <span class="o">=</span> <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">cwnd</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_flight</span> <span class="o">&lt;</span> <span class="n">cwnd</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">cwnd</span> <span class="o">-</span> <span class="n">in_flight</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize TSO state of a skb.</span>
<span class="cm"> * This must be invoked the first time we consider transmitting</span>
<span class="cm"> * SKB onto the wire.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_init_tso_segs</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss_now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tso_segs</span> <span class="o">=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tso_segs</span> <span class="o">||</span> <span class="p">(</span><span class="n">tso_segs</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_skb_mss</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mss_now</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tcp_set_skb_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>
		<span class="n">tso_segs</span> <span class="o">=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">tso_segs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Minshall&#39;s variant of the Nagle send check. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_minshall_check</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">after</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_sml</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_sml</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Return false, if packet can be sent now without violation Nagle&#39;s rules:</span>
<span class="cm"> * 1. It is full sized.</span>
<span class="cm"> * 2. Or it contains FIN. (already checked by caller)</span>
<span class="cm"> * 3. Or TCP_CORK is not set, and TCP_NODELAY is set.</span>
<span class="cm"> * 4. Or TCP_CORK is not set, and all sent packets are ACKed.</span>
<span class="cm"> *    With Minshall&#39;s modification: all sent small packets are ACKed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_nagle_check</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss_now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonagle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">mss_now</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="n">nonagle</span> <span class="o">&amp;</span> <span class="n">TCP_NAGLE_CORK</span><span class="p">)</span> <span class="o">||</span>
		 <span class="p">(</span><span class="o">!</span><span class="n">nonagle</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_minshall_check</span><span class="p">(</span><span class="n">tp</span><span class="p">)));</span>
<span class="p">}</span>

<span class="cm">/* Return true if the Nagle test allows this packet to be</span>
<span class="cm"> * sent now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_nagle_test</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_mss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonagle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Nagle rule does not apply to frames, which sit in the middle of the</span>
<span class="cm">	 * write_queue (they have no chances to get new data).</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is implemented in the callers, where they modify the &#39;nonagle&#39;</span>
<span class="cm">	 * argument based upon the location of SKB in the send queue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nonagle</span> <span class="o">&amp;</span> <span class="n">TCP_NAGLE_PUSH</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t use the nagle rule for urgent data (or for the final FIN).</span>
<span class="cm">	 * Nagle can be ignored during F-RTO too (see RFC4138).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_urg_mode</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_FIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_nagle_check</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cur_mss</span><span class="p">,</span> <span class="n">nonagle</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Does at least the first segment of SKB fit into the send window? */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_snd_wnd_test</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_mss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">cur_mss</span><span class="p">)</span>
		<span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="n">cur_mss</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* This checks if the data bearing packet SKB (usually tcp_send_head(sk))</span>
<span class="cm"> * should be put on the wire right now.  If so, it returns the number of</span>
<span class="cm"> * packets allowed by the congestion window.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_snd_test</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_mss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonagle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cwnd_quota</span><span class="p">;</span>

	<span class="n">tcp_init_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cur_mss</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_nagle_test</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cur_mss</span><span class="p">,</span> <span class="n">nonagle</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cwnd_quota</span> <span class="o">=</span> <span class="n">tcp_cwnd_test</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cwnd_quota</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tcp_snd_wnd_test</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cur_mss</span><span class="p">))</span>
		<span class="n">cwnd_quota</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cwnd_quota</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Test if sending is allowed right now. */</span>
<span class="n">bool</span> <span class="nf">tcp_may_send_now</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">skb</span> <span class="o">&amp;&amp;</span>
		<span class="n">tcp_snd_test</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tcp_current_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
			     <span class="p">(</span><span class="n">tcp_skb_is_last</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="o">?</span>
			      <span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span> <span class="o">:</span> <span class="n">TCP_NAGLE_PUSH</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Trim TSO SKB to LEN bytes, put the remaining data into a new packet</span>
<span class="cm"> * which is put after SKB on the list.  It is very much like</span>
<span class="cm"> * tcp_fragment() except that it may make several kinds of assumptions</span>
<span class="cm"> * in order to speed up the splitting operation.  In particular, we</span>
<span class="cm"> * know that all the data is in scatter-gather pages, and that the</span>
<span class="cm"> * packet has never been sent out before (and thus is not cloned).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tso_fragment</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nlen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* All of a TSO frame must be composed of paged data.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">tcp_fragment</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>

	<span class="n">buff</span> <span class="o">=</span> <span class="n">sk_stream_alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+=</span> <span class="n">buff</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buff</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
	<span class="n">buff</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">nlen</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">-=</span> <span class="n">nlen</span><span class="p">;</span>

	<span class="cm">/* Correct the sequence numbers. */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>

	<span class="cm">/* PSH and FIN should only be set in the second packet. */</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">TCPHDR_FIN</span> <span class="o">|</span> <span class="n">TCPHDR_PSH</span><span class="p">);</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* This packet was never sent out yet, so no SACK bits. */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">buff</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>
	<span class="n">skb_split</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Fix up tso_factor for both original and new SKB.  */</span>
	<span class="n">tcp_set_skb_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>
	<span class="n">tcp_set_skb_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>

	<span class="cm">/* Link BUFF into the send queue. */</span>
	<span class="n">skb_header_release</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
	<span class="n">tcp_insert_write_queue_after</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Try to defer sending, if possible, in order to minimize the amount</span>
<span class="cm"> * of TSO splitting we do.  View it as a kind of TSO Nagle test.</span>
<span class="cm"> *</span>
<span class="cm"> * This algorithm is from John Heffner.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_tso_should_defer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">send_win</span><span class="p">,</span> <span class="n">cong_win</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">in_flight</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">win_divisor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_FIN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">send_now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">TCP_CA_Open</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">send_now</span><span class="p">;</span>

	<span class="cm">/* Defer for less than two clock ticks. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tso_deferred</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(((</span><span class="n">u32</span><span class="p">)</span><span class="n">jiffies</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tso_deferred</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">send_now</span><span class="p">;</span>

	<span class="n">in_flight</span> <span class="o">=</span> <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&lt;=</span> <span class="n">in_flight</span><span class="p">));</span>

	<span class="n">send_win</span> <span class="o">=</span> <span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>

	<span class="cm">/* From in_flight test above, we know that cwnd &gt; in_flight.  */</span>
	<span class="n">cong_win</span> <span class="o">=</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">-</span> <span class="n">in_flight</span><span class="p">)</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">;</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">send_win</span><span class="p">,</span> <span class="n">cong_win</span><span class="p">);</span>

	<span class="cm">/* If a full-sized TSO skb can be sent, do it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&gt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_gso_max_size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">send_now</span><span class="p">;</span>

	<span class="cm">/* Middle in queue won&#39;t get any more data, full sendable already? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">skb</span> <span class="o">!=</span> <span class="n">tcp_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&gt;=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">send_now</span><span class="p">;</span>

	<span class="n">win_divisor</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">sysctl_tcp_tso_win_divisor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">win_divisor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">chunk</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">);</span>

		<span class="cm">/* If at least some fraction of a window is available,</span>
<span class="cm">		 * just use it.</span>
<span class="cm">		 */</span>
		<span class="n">chunk</span> <span class="o">/=</span> <span class="n">win_divisor</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&gt;=</span> <span class="n">chunk</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">send_now</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Different approach, try not to defer past a single</span>
<span class="cm">		 * ACK.  Receiver should ACK every other full sized</span>
<span class="cm">		 * frame, so if we have space for more than 3 frames</span>
<span class="cm">		 * then send now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="n">tcp_max_tso_deferred_mss</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">send_now</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Ok, it looks like it is advisable to defer.  */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tso_deferred</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">|</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">send_now:</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tso_deferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create a new MTU probe if we are ready.</span>
<span class="cm"> * MTU probe is regularly attempting to increase the path MTU by</span>
<span class="cm"> * deliberately sending larger packets.  This discovers routing</span>
<span class="cm"> * changes resulting in larger path MTUs.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if we should wait to probe (no cwnd available),</span>
<span class="cm"> *         1 if a probe was sent,</span>
<span class="cm"> *         -1 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_mtu_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">nskb</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">probe_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size_needed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mss_now</span><span class="p">;</span>

	<span class="cm">/* Not currently probing/verifying,</span>
<span class="cm">	 * not in recovery,</span>
<span class="cm">	 * have enough cwnd, and</span>
<span class="cm">	 * not SACKing (the variable headers throw things off) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">enabled</span> <span class="o">||</span>
	    <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span> <span class="o">||</span>
	    <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">TCP_CA_Open</span> <span class="o">||</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&lt;</span> <span class="mi">11</span> <span class="o">||</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">dsack</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Very simple search strategy: just double the MSS. */</span>
	<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tcp_current_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">probe_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">;</span>
	<span class="n">size_needed</span> <span class="o">=</span> <span class="n">probe_size</span> <span class="o">+</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">probe_size</span> <span class="o">&gt;</span> <span class="n">tcp_mtu_to_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">search_high</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* TODO: set timer for probe_converge_event */</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Have enough data in the send queue to probe? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span> <span class="o">&lt;</span> <span class="n">size_needed</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span> <span class="o">&lt;</span> <span class="n">size_needed</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span> <span class="o">+</span> <span class="n">size_needed</span><span class="p">,</span> <span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Do we need to wait to drain cwnd? With none in flight, don&#39;t stall */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We&#39;re allowed to probe.  Build it now. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">nskb</span> <span class="o">=</span> <span class="n">sk_stream_alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">probe_size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+=</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="n">probe_size</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">=</span> <span class="n">TCPHDR_ACK</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span><span class="p">;</span>

	<span class="n">tcp_insert_write_queue_before</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tcp_for_write_queue_from_safe</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">copy</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">probe_size</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nskb</span><span class="o">-&gt;</span><span class="n">ip_summed</span><span class="p">)</span>
			<span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">copy</span><span class="p">),</span> <span class="n">copy</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">skb_copy_and_csum_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							    <span class="n">skb_put</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">copy</span><span class="p">),</span>
							    <span class="n">copy</span><span class="p">,</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">copy</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* We&#39;ve eaten all the data from this skb.</span>
<span class="cm">			 * Throw it away. */</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span><span class="p">;</span>
			<span class="n">tcp_unlink_write_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
			<span class="n">sk_wmem_free_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span>
						   <span class="o">~</span><span class="p">(</span><span class="n">TCPHDR_FIN</span><span class="o">|</span><span class="n">TCPHDR_PSH</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
					<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">csum_partial</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
								 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">__pskb_trim_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
				<span class="n">tcp_set_skb_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">probe_size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tcp_init_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nskb</span><span class="p">,</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* We&#39;re ready to send.  If this fails, the probe will</span>
<span class="cm">	 * be resegmented into mss-sized pieces by tcp_write_xmit(). */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nskb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Decrement cwnd here because we are sending</span>
<span class="cm">		 * effectively two packets. */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="o">--</span><span class="p">;</span>
		<span class="n">tcp_event_new_data_sent</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nskb</span><span class="p">);</span>

		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span> <span class="o">=</span> <span class="n">tcp_mss_to_mtu</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mtu_probe</span><span class="p">.</span><span class="n">probe_seq_start</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mtu_probe</span><span class="p">.</span><span class="n">probe_seq_end</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This routine writes packets to the network.  It advances the</span>
<span class="cm"> * send_head.  This happens as incoming acks open up the remote</span>
<span class="cm"> * window for us.</span>
<span class="cm"> *</span>
<span class="cm"> * LARGESEND note: !tcp_urg_mode is overkill, only frames between</span>
<span class="cm"> * snd_up-64k-mss .. snd_up cannot be large. However, taking into</span>
<span class="cm"> * account rare use of URG, this is not a big flaw.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true, if no segments are in flight and we have queued segments,</span>
<span class="cm"> * but cannot send anything now because of SWS or another problem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_write_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss_now</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonagle</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">push_one</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tso_segs</span><span class="p">,</span> <span class="n">sent_pkts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cwnd_quota</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">sent_pkts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">push_one</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Do MTU probing. */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">tcp_mtu_probe</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sent_pkts</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>

		<span class="n">tso_segs</span> <span class="o">=</span> <span class="n">tcp_init_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tso_segs</span><span class="p">);</span>

		<span class="n">cwnd_quota</span> <span class="o">=</span> <span class="n">tcp_cwnd_test</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cwnd_quota</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">tcp_snd_wnd_test</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tso_segs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">tcp_nagle_test</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span>
						     <span class="p">(</span><span class="n">tcp_skb_is_last</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="o">?</span>
						      <span class="n">nonagle</span> <span class="o">:</span> <span class="n">TCP_NAGLE_PUSH</span><span class="p">))))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">push_one</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_tso_should_defer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">limit</span> <span class="o">=</span> <span class="n">mss_now</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tso_segs</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tcp_urg_mode</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">tcp_mss_split_point</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span>
						    <span class="n">cwnd_quota</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">limit</span> <span class="o">&amp;&amp;</span>
		    <span class="n">unlikely</span><span class="p">(</span><span class="n">tso_fragment</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">gfp</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gfp</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Advance the send_head.  This one is sent out.</span>
<span class="cm">		 * This call will increment packets_out.</span>
<span class="cm">		 */</span>
		<span class="n">tcp_event_new_data_sent</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">tcp_minshall_update</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">sent_pkts</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">push_one</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_Recovery</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prr_out</span> <span class="o">+=</span> <span class="n">sent_pkts</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sent_pkts</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tcp_cwnd_validate</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Push out any pending frames which were held back due to</span>
<span class="cm"> * TCP_CORK or attempt at coalescing tiny packets.</span>
<span class="cm"> * The socket must be locked by the caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__tcp_push_pending_frames</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_mss</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">nonagle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If we are closed, the bytes will have to remain here.</span>
<span class="cm">	 * In time closedown will finish, we empty the write queue and</span>
<span class="cm">	 * all will be happy.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_write_xmit</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">cur_mss</span><span class="p">,</span> <span class="n">nonagle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span>
		<span class="n">tcp_check_probe_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send _single_ skb sitting at the send head. This function requires</span>
<span class="cm"> * true push pending frames to setup probe timer etc.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_push_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss_now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">mss_now</span><span class="p">);</span>

	<span class="n">tcp_write_xmit</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">TCP_NAGLE_PUSH</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This function returns the amount that we can raise the</span>
<span class="cm"> * usable window based on the following constraints</span>
<span class="cm"> *</span>
<span class="cm"> * 1. The window can never be shrunk once it is offered (RFC 793)</span>
<span class="cm"> * 2. We limit memory per socket</span>
<span class="cm"> *</span>
<span class="cm"> * RFC 1122:</span>
<span class="cm"> * &quot;the suggested [SWS] avoidance algorithm for the receiver is to keep</span>
<span class="cm"> *  RECV.NEXT + RCV.WIN fixed until:</span>
<span class="cm"> *  RCV.BUFF - RCV.USER - RCV.WINDOW &gt;= min(1/2 RCV.BUFF, MSS)&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * i.e. don&#39;t raise the right edge of the window until you can raise</span>
<span class="cm"> * it at least MSS bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * Unfortunately, the recommended algorithm breaks header prediction,</span>
<span class="cm"> * since header prediction assumes th-&gt;window stays fixed.</span>
<span class="cm"> *</span>
<span class="cm"> * Strictly speaking, keeping th-&gt;window fixed violates the receiver</span>
<span class="cm"> * side SWS prevention criteria. The problem is that under this rule</span>
<span class="cm"> * a stream of single byte packets will cause the right side of the</span>
<span class="cm"> * window to always advance by a single byte.</span>
<span class="cm"> *</span>
<span class="cm"> * Of course, if the sender implements sender side SWS prevention</span>
<span class="cm"> * then this will not be a problem.</span>
<span class="cm"> *</span>
<span class="cm"> * BSD seems to make the following compromise:</span>
<span class="cm"> *</span>
<span class="cm"> *	If the free space is less than the 1/4 of the maximum</span>
<span class="cm"> *	space available and the free space is less than 1/2 mss,</span>
<span class="cm"> *	then set the window to 0.</span>
<span class="cm"> *	[ Actually, bsd uses MSS and 1/4 of maximal _window_ ]</span>
<span class="cm"> *	Otherwise, just prevent the window from shrinking</span>
<span class="cm"> *	and from being larger than the largest representable value.</span>
<span class="cm"> *</span>
<span class="cm"> * This prevents incremental opening of the window in the regime</span>
<span class="cm"> * where TCP is limited by the speed of the reader side taking</span>
<span class="cm"> * data out of the TCP receive queue. It does nothing about</span>
<span class="cm"> * those cases where the window is constrained on the sender side</span>
<span class="cm"> * because the pipeline is full.</span>
<span class="cm"> *</span>
<span class="cm"> * BSD also seems to &quot;accidentally&quot; limit itself to windows that are a</span>
<span class="cm"> * multiple of MSS, at least until the free space gets quite small.</span>
<span class="cm"> * This would appear to be a side effect of the mbuf implementation.</span>
<span class="cm"> * Combining these two algorithms results in the observed behavior</span>
<span class="cm"> * of having a fixed window size at almost all times.</span>
<span class="cm"> *</span>
<span class="cm"> * Below we obtain similar behavior by forcing the offered window to</span>
<span class="cm"> * a multiple of the mss when it is feasible to do so.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, we don&#39;t &quot;adjust&quot; for TIMESTAMP or SACK option bytes.</span>
<span class="cm"> * Regular options like TIMESTAMP are taken into account.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">__tcp_select_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* MSS for the peer&#39;s data.  Previous versions used mss_clamp</span>
<span class="cm">	 * here.  I don&#39;t know if the value based on our guesses</span>
<span class="cm">	 * of peer&#39;s MSS is better for the performance.  It&#39;s more correct</span>
<span class="cm">	 * but may be worse for the performance because of rcv_mss</span>
<span class="cm">	 * fluctuations.  --SAW  1998/11/1</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">mss</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">rcv_mss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free_space</span> <span class="o">=</span> <span class="n">tcp_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">full_space</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">,</span> <span class="n">tcp_full_space</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">window</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mss</span> <span class="o">&gt;</span> <span class="n">full_space</span><span class="p">)</span>
		<span class="n">mss</span> <span class="o">=</span> <span class="n">full_space</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free_space</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">full_space</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">quick</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk_under_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span><span class="p">,</span>
					       <span class="mi">4U</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">free_space</span> <span class="o">&lt;</span> <span class="n">mss</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">free_space</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span><span class="p">)</span>
		<span class="n">free_space</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t do rounding if we are using window scaling, since the</span>
<span class="cm">	 * scaled window will not line up with the MSS boundary anyway.</span>
<span class="cm">	 */</span>
	<span class="n">window</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">window</span> <span class="o">=</span> <span class="n">free_space</span><span class="p">;</span>

		<span class="cm">/* Advertise enough space so that it won&#39;t get scaled away.</span>
<span class="cm">		 * Import case: prevent zero window announcement if</span>
<span class="cm">		 * 1&lt;&lt;rcv_wscale &gt; mss.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">window</span> <span class="o">&gt;&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span><span class="p">)</span> <span class="o">!=</span> <span class="n">window</span><span class="p">)</span>
			<span class="n">window</span> <span class="o">=</span> <span class="p">(((</span><span class="n">window</span> <span class="o">&gt;&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
				  <span class="o">&lt;&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Get the largest window that is a nice multiple of mss.</span>
<span class="cm">		 * Window clamp already applied above.</span>
<span class="cm">		 * If our current window offering is within 1 mss of the</span>
<span class="cm">		 * free space we just keep it. This prevents the divide</span>
<span class="cm">		 * and multiply from happening most of the time.</span>
<span class="cm">		 * We also don&#39;t do any window rounding when the free space</span>
<span class="cm">		 * is too small.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">window</span> <span class="o">&lt;=</span> <span class="n">free_space</span> <span class="o">-</span> <span class="n">mss</span> <span class="o">||</span> <span class="n">window</span> <span class="o">&gt;</span> <span class="n">free_space</span><span class="p">)</span>
			<span class="n">window</span> <span class="o">=</span> <span class="p">(</span><span class="n">free_space</span> <span class="o">/</span> <span class="n">mss</span><span class="p">)</span> <span class="o">*</span> <span class="n">mss</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mss</span> <span class="o">==</span> <span class="n">full_space</span> <span class="o">&amp;&amp;</span>
			 <span class="n">free_space</span> <span class="o">&gt;</span> <span class="n">window</span> <span class="o">+</span> <span class="p">(</span><span class="n">full_space</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">window</span> <span class="o">=</span> <span class="n">free_space</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">window</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Collapses two adjacent SKB&#39;s during retransmission. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_collapse_retrans</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next_skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_next</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">skb_size</span><span class="p">,</span> <span class="n">next_skb_size</span><span class="p">;</span>

	<span class="n">skb_size</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">next_skb_size</span> <span class="o">=</span> <span class="n">next_skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">next_skb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">tcp_highest_sack_combine</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">next_skb</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">tcp_unlink_write_queue</span><span class="p">(</span><span class="n">next_skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">next_skb</span><span class="p">,</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">next_skb_size</span><span class="p">),</span>
				  <span class="n">next_skb_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next_skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">csum_block_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">next_skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">skb_size</span><span class="p">);</span>

	<span class="cm">/* Update sequence range on original skb. */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">next_skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>

	<span class="cm">/* Merge over control information. This moves PSH/FIN etc. over */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">next_skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span><span class="p">;</span>

	<span class="cm">/* All done, get rid of second SKB and account for it so</span>
<span class="cm">	 * packet counting does not break.</span>
<span class="cm">	 */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">|=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">next_skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_EVER_RETRANS</span><span class="p">;</span>

	<span class="cm">/* changed transmit queue under us so clear hints */</span>
	<span class="n">tcp_clear_retrans_hints_partial</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_skb</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="n">tcp_adjust_pcount</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">next_skb</span><span class="p">,</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">next_skb</span><span class="p">));</span>

	<span class="n">sk_wmem_free_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">next_skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check if coalescing SKBs is legal. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_can_collapse</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="cm">/* TODO: SACK collapsing could be used to remove this condition */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="cm">/* Some heurestics for collapsing over SACK&#39;d could be invented */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Collapse packets in the retransmit queue to make to create</span>
<span class="cm"> * less packets on the wire. This is only done on retransmission.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_retrans_try_collapse</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">to</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysctl_tcp_retrans_collapse</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_SYN</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tcp_for_write_queue_from_safe</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_can_collapse</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">space</span> <span class="o">-=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Punt if not enough space exists in the first SKB for</span>
<span class="cm">		 * the data in the second</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">skb_availroom</span><span class="p">(</span><span class="n">to</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">tcp_collapse_retrans</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This retransmits one SKB.  Policy decisions and retransmit queue</span>
<span class="cm"> * state updates are done by the caller.  Returns non-zero if an</span>
<span class="cm"> * error occurred which prevented the send.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tcp_retransmit_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_mss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Inconslusive MTU probe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do not sent more than we queued. 1/4 is reserved for possible</span>
<span class="cm">	 * copying overhead: fragmentation, tunneling, mangling etc.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">min</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">),</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_trim_head</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">rebuild_header</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span> <span class="cm">/* Routing failure or similar. */</span>

	<span class="n">cur_mss</span> <span class="o">=</span> <span class="n">tcp_current_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* If receiver has shrunk his window, and skb is out of</span>
<span class="cm">	 * new window, do not retransmit it. The exception is the</span>
<span class="cm">	 * case, when window is shrunk to zero. In this case</span>
<span class="cm">	 * our retransmit serves as a zero window probe.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">cur_mss</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_fragment</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cur_mss</span><span class="p">,</span> <span class="n">cur_mss</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span> <span class="cm">/* We&#39;ll try again later. */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">oldpcount</span> <span class="o">=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">oldpcount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcp_init_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cur_mss</span><span class="p">);</span>
			<span class="n">tcp_adjust_pcount</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">oldpcount</span> <span class="o">-</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tcp_retrans_try_collapse</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cur_mss</span><span class="p">);</span>

	<span class="cm">/* Some Solaris stacks overoptimize and ignore the FIN on a</span>
<span class="cm">	 * retransmit when old data is attached.  So strip it off</span>
<span class="cm">	 * since it is cheap to do so and saves bytes on the network.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_FIN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">==</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Reuse, even though it does some unnecessary work */</span>
			<span class="n">tcp_init_nondata_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					     <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Make a copy, if the first transmission SKB clone we made</span>
<span class="cm">	 * is still in somebody&#39;s hands, else make a clone.</span>
<span class="cm">	 */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>

	<span class="cm">/* make sure skb-&gt;data is aligned on arches that require it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">NET_IP_ALIGN</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span> <span class="o">=</span> <span class="n">__pskb_copy</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">MAX_TCP_HEADER</span><span class="p">,</span>
						   <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nskb</span> <span class="o">?</span> <span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nskb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)</span> <span class="o">:</span>
			     <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Update global TCP statistics. */</span>
		<span class="n">TCP_INC_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_RETRANSSEGS</span><span class="p">);</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">total_retrans</span><span class="o">++</span><span class="p">;</span>

<span class="cp">#if FASTRETRANS_DEBUG &gt; 0</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_RETRANS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">net_dbg_ratelimited</span><span class="p">(</span><span class="s">&quot;retrans_out leaked</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_retrans_low</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">|=</span> <span class="n">TCPCB_RETRANS</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* Save stamp of the first retransmit. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_stamp</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_stamp</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span><span class="p">;</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_retrans</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* snd_nxt is stored to detect loss of retransmitted segment,</span>
<span class="cm">		 * see tcp_input.c tcp_sacktag_write_queue().</span>
<span class="cm">		 */</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check if we forward retransmits are possible in the current</span>
<span class="cm"> * window/congestion state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_can_forward_retransmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Forward retransmissions are possible only during Recovery. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">TCP_CA_Recovery</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* No forward retransmissions in Reno are possible. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Yeah, we have to make difficult choice between forward transmission</span>
<span class="cm">	 * and retransmission... Both ways have their merits...</span>
<span class="cm">	 *</span>
<span class="cm">	 * For now we do not retransmit anything, while we have some new</span>
<span class="cm">	 * segments to send. In the other cases, follow rule 3 for</span>
<span class="cm">	 * NextSeg() specified in RFC3517.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_may_send_now</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This gets called after a retransmit timeout, and the initially</span>
<span class="cm"> * retransmitted data is acknowledged.  It tries to continue</span>
<span class="cm"> * resending the rest of the retransmit queue, until either</span>
<span class="cm"> * we&#39;ve sent it all or the congestion window limit is reached.</span>
<span class="cm"> * If doing SACK, the first ACK which comes back for a timeout</span>
<span class="cm"> * based retransmit packet might feed us FACK information again.</span>
<span class="cm"> * If so, we use it to avoid unnecessarily retransmissions.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_xmit_retransmit_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">hole</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">last_lost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mib_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fwd_rexmitting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_high</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span><span class="p">;</span>
		<span class="n">last_lost</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">last_lost</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_high</span><span class="p">))</span>
			<span class="n">last_lost</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_high</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">last_lost</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tcp_for_write_queue_from</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__u8</span> <span class="n">sacked</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* we could do better than to assign each time */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hole</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

		<span class="cm">/* Assume this retransmit will generate</span>
<span class="cm">		 * only one packet for congestion window</span>
<span class="cm">		 * calculation purposes.  This works because</span>
<span class="cm">		 * tcp_retransmit_skb() will chop up the</span>
<span class="cm">		 * packet to be MSS sized and all the</span>
<span class="cm">		 * packet counting works out.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fwd_rexmitting</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">begin_fwd:</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tcp_highest_sack_seq</span><span class="p">(</span><span class="n">tp</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPFORWARDRETRANS</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_high</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_high</span> <span class="o">=</span> <span class="n">last_lost</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_can_forward_retransmit</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* Backtrack if necessary to non-L&#39;ed skb */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hole</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">hole</span><span class="p">;</span>
				<span class="n">hole</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">fwd_rexmitting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">begin_fwd</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_LOST</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hole</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPCB_SACKED_RETRANS</span><span class="o">|</span><span class="n">TCPCB_SACKED_ACKED</span><span class="p">)))</span>
				<span class="n">hole</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">last_lost</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">TCP_CA_Loss</span><span class="p">)</span>
				<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPFASTRETRANS</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPSLOWSTARTRETRANS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPCB_SACKED_ACKED</span><span class="o">|</span><span class="n">TCPCB_SACKED_RETRANS</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_retransmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPRETRANSFAIL</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">mib_idx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_Recovery</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prr_out</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_RETRANS</span><span class="p">,</span>
						  <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">,</span>
						  <span class="n">TCP_RTO_MAX</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Send a fin.  The caller locks the socket for us.  This cannot be</span>
<span class="cm"> * allowed to fail queueing a FIN frame under any circumstances.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_send_fin</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mss_now</span><span class="p">;</span>

	<span class="cm">/* Optimization, tack on the FIN if we have a queue of</span>
<span class="cm">	 * unsent frames.  But be careful about outgoing SACKS</span>
<span class="cm">	 * and IP options.</span>
<span class="cm">	 */</span>
	<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tcp_current_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCPHDR_FIN</span><span class="p">;</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Socket is locked, keep trying until memory is available. */</span>
		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb_fclone</span><span class="p">(</span><span class="n">MAX_TCP_HEADER</span><span class="p">,</span>
					       <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">yield</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="cm">/* Reserve space for headers and prepare control bits. */</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">MAX_TCP_HEADER</span><span class="p">);</span>
		<span class="cm">/* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */</span>
		<span class="n">tcp_init_nondata_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">,</span>
				     <span class="n">TCPHDR_ACK</span> <span class="o">|</span> <span class="n">TCPHDR_FIN</span><span class="p">);</span>
		<span class="n">tcp_queue_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__tcp_push_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">TCP_NAGLE_OFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* We get here when a process closes a file descriptor (either due to</span>
<span class="cm"> * an explicit close() or as a byproduct of exit()&#39;ing) and there</span>
<span class="cm"> * was unread data in the receive queue.  This behavior is recommended</span>
<span class="cm"> * by RFC 2525, section 2.17.  -DaveM</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_send_active_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* NOTE: No TCP options attached and we never retransmit this. */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">MAX_TCP_HEADER</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NET_INC_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPABORTFAILED</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reserve space for headers and prepare control bits. */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">MAX_TCP_HEADER</span><span class="p">);</span>
	<span class="n">tcp_init_nondata_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tcp_acceptable_seq</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
			     <span class="n">TCPHDR_ACK</span> <span class="o">|</span> <span class="n">TCPHDR_RST</span><span class="p">);</span>
	<span class="cm">/* Send it off. */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">priority</span><span class="p">))</span>
		<span class="n">NET_INC_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPABORTFAILED</span><span class="p">);</span>

	<span class="n">TCP_INC_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_OUTRSTS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send a crossed SYN-ACK during socket establishment.</span>
<span class="cm"> * WARNING: This routine must only be called when we have already sent</span>
<span class="cm"> * a SYN packet that crossed the incoming SYN that caused this routine</span>
<span class="cm"> * to get called. If this assumption fails then the initial rcv_wnd</span>
<span class="cm"> * and rcv_wscale values will not be correct.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tcp_send_synack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_SYN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: wrong queue state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_ACK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span> <span class="o">=</span> <span class="n">skb_copy</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nskb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">tcp_unlink_write_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
			<span class="n">skb_header_release</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
			<span class="n">__tcp_add_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nskb</span><span class="p">);</span>
			<span class="n">sk_wmem_free_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+=</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
			<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCPHDR_ACK</span><span class="p">;</span>
		<span class="n">TCP_ECN_send_synack</span><span class="p">(</span><span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Prepare a SYN-ACK. */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_make_synack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">request_values</span> <span class="o">*</span><span class="n">rvp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_out_options</span> <span class="n">opts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_extend_values</span> <span class="o">*</span><span class="n">xvp</span> <span class="o">=</span> <span class="n">tcp_xv</span><span class="p">(</span><span class="n">rvp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_request_sock</span> <span class="o">*</span><span class="n">ireq</span> <span class="o">=</span> <span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_cookie_values</span> <span class="o">*</span><span class="n">cvp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="n">md5</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tcp_header_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">s_data_desired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cvp</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_constant</span> <span class="o">&amp;&amp;</span> <span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_desired</span><span class="p">)</span>
		<span class="n">s_data_desired</span> <span class="o">=</span> <span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_desired</span><span class="p">;</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_wmalloc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">MAX_TCP_HEADER</span> <span class="o">+</span> <span class="mi">15</span> <span class="o">+</span> <span class="n">s_data_desired</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Reserve space for headers. */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">MAX_TCP_HEADER</span><span class="p">);</span>

	<span class="n">skb_dst_set</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dst_clone</span><span class="p">(</span><span class="n">dst</span><span class="p">));</span>

	<span class="n">mss</span> <span class="o">=</span> <span class="n">dst_metric_advmss</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">user_mss</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">user_mss</span> <span class="o">&lt;</span> <span class="n">mss</span><span class="p">)</span>
		<span class="n">mss</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">user_mss</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ignored for retransmitted syns */</span>
		<span class="n">__u8</span> <span class="n">rcv_wscale</span><span class="p">;</span>
		<span class="cm">/* Set this up on the first call only */</span>
		<span class="n">req</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">?</span> <span class="o">:</span> <span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_WINDOW</span><span class="p">);</span>

		<span class="cm">/* limit the window selection if the user enforce a smaller rx buffer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_RCVBUF_LOCK</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">&gt;</span> <span class="n">tcp_full_space</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">||</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">req</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">tcp_full_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="cm">/* tcp_full_space because it is guaranteed to be the first packet */</span>
		<span class="n">tcp_select_initial_window</span><span class="p">(</span><span class="n">tcp_full_space</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
			<span class="n">mss</span> <span class="o">-</span> <span class="p">(</span><span class="n">ireq</span><span class="o">-&gt;</span><span class="n">tstamp_ok</span> <span class="o">?</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">,</span>
			<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">wscale_ok</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">rcv_wscale</span><span class="p">,</span>
			<span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_INITRWND</span><span class="p">));</span>
		<span class="n">ireq</span><span class="o">-&gt;</span><span class="n">rcv_wscale</span> <span class="o">=</span> <span class="n">rcv_wscale</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opts</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_SYN_COOKIES</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">cookie_ts</span><span class="p">))</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">cookie_init_timestamp</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="n">tcp_header_size</span> <span class="o">=</span> <span class="n">tcp_synack_options</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">mss</span><span class="p">,</span>
					     <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">md5</span><span class="p">,</span> <span class="n">xvp</span><span class="p">)</span>
			<span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">);</span>

	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tcp_header_size</span><span class="p">);</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">));</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">TCP_ECN_make_synack</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">th</span><span class="p">);</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">=</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">loc_port</span><span class="p">;</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">=</span> <span class="n">ireq</span><span class="o">-&gt;</span><span class="n">rmt_port</span><span class="p">;</span>
	<span class="cm">/* Setting of flags are superfluous here for callers (and ECE is</span>
<span class="cm">	 * not even correctly set)</span>
<span class="cm">	 */</span>
	<span class="n">tcp_init_nondata_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snt_isn</span><span class="p">,</span>
			     <span class="n">TCPHDR_SYN</span> <span class="o">|</span> <span class="n">TCPHDR_ACK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">OPTION_COOKIE_EXTENSION</span> <span class="o">&amp;</span> <span class="n">opts</span><span class="p">.</span><span class="n">options</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s_data_desired</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">s_data_desired</span><span class="p">);</span>

			<span class="cm">/* copy data directly from the listening socket. */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_payload</span><span class="p">,</span> <span class="n">s_data_desired</span><span class="p">);</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">+=</span> <span class="n">s_data_desired</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">hash_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__u32</span> <span class="n">workspace</span><span class="p">[</span><span class="n">SHA_WORKSPACE_WORDS</span><span class="p">];</span>
			<span class="n">u32</span> <span class="o">*</span><span class="n">mess</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xvp</span><span class="o">-&gt;</span><span class="n">cookie_bakery</span><span class="p">[</span><span class="n">COOKIE_DIGEST_WORDS</span><span class="p">];</span>
			<span class="n">u32</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mess</span><span class="p">[</span><span class="n">COOKIE_MESSAGE_WORDS</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>

			<span class="cm">/* Secret recipe depends on the Timestamp, (future)</span>
<span class="cm">			 * Sequence and Acknowledgment Numbers, Initiator</span>
<span class="cm">			 * Cookie, and others handled by IP variant caller.</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">tail</span><span class="o">--</span> <span class="o">^=</span> <span class="n">opts</span><span class="p">.</span><span class="n">tsval</span><span class="p">;</span>
			<span class="o">*</span><span class="n">tail</span><span class="o">--</span> <span class="o">^=</span> <span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_isn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="o">*</span><span class="n">tail</span><span class="o">--</span> <span class="o">^=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* recommended */</span>
			<span class="o">*</span><span class="n">tail</span><span class="o">--</span> <span class="o">^=</span> <span class="p">(((</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">);</span>
			<span class="o">*</span><span class="n">tail</span><span class="o">--</span> <span class="o">^=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cvp</span><span class="p">;</span> <span class="cm">/* per sockopt */</span>

			<span class="n">sha_transform</span><span class="p">((</span><span class="n">__u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">xvp</span><span class="o">-&gt;</span><span class="n">cookie_bakery</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				      <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mess</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">workspace</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">opts</span><span class="p">.</span><span class="n">hash_location</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">xvp</span><span class="o">-&gt;</span><span class="n">cookie_bakery</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">th</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">ack_seq</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_isn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* RFC1323: The window in SYN &amp; SYN/ACK segments is never scaled. */</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">,</span> <span class="mi">65535U</span><span class="p">));</span>
	<span class="n">tcp_options_write</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)(</span><span class="n">th</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">=</span> <span class="p">(</span><span class="n">tcp_header_size</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">TCP_ADD_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_OUTSEGS</span><span class="p">,</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="cm">/* Okay, we have all we need - do the md5 hash if needed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">md5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">calc_md5_hash</span><span class="p">(</span><span class="n">opts</span><span class="p">.</span><span class="n">hash_location</span><span class="p">,</span>
					       <span class="n">md5</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_make_synack</span><span class="p">);</span>

<span class="cm">/* Do all connect socket setups that can be done AF independent. */</span>
<span class="kt">void</span> <span class="nf">tcp_connect_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">__u8</span> <span class="n">rcv_wscale</span><span class="p">;</span>

	<span class="cm">/* We&#39;ll fix this up when we get a response from the other end.</span>
<span class="cm">	 * See tcp_input.c:tcp_rcv_state_process case TCP_SYN_SENT.</span>
<span class="cm">	 */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">sysctl_tcp_timestamps</span> <span class="o">?</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">md5_lookup</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">+=</span> <span class="n">TCPOLEN_MD5SIG_ALIGNED</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* If user gave his TCP_MAXSEG, record it to clamp */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">user_mss</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">user_mss</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_window</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tcp_mtup_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tcp_sync_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dst_mtu</span><span class="p">(</span><span class="n">dst</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_WINDOW</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span> <span class="o">=</span> <span class="n">dst_metric_advmss</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">user_mss</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">user_mss</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">user_mss</span><span class="p">;</span>

	<span class="n">tcp_initialize_rcv_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* limit the window selection if the user enforce a smaller rx buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_RCVBUF_LOCK</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">&gt;</span> <span class="n">tcp_full_space</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">tcp_full_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_select_initial_window</span><span class="p">(</span><span class="n">tcp_full_space</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
				  <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span> <span class="o">-</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span> <span class="o">?</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
				  <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">,</span>
				  <span class="n">sysctl_tcp_window_scaling</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">rcv_wscale</span><span class="p">,</span>
				  <span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_INITRWND</span><span class="p">));</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span> <span class="o">=</span> <span class="n">rcv_wscale</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DONE</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tcp_init_wl</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_sml</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_up</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">;</span>

	<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">=</span> <span class="n">TCP_TIMEOUT_INIT</span><span class="p">;</span>
	<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tcp_clear_retrans</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Build a SYN and send it off. */</span>
<span class="kt">int</span> <span class="nf">tcp_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">tcp_connect_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">buff</span> <span class="o">=</span> <span class="n">alloc_skb_fclone</span><span class="p">(</span><span class="n">MAX_TCP_HEADER</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="cm">/* Reserve space for headers. */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">MAX_TCP_HEADER</span><span class="p">);</span>

	<span class="n">tcp_init_nondata_skb</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="o">++</span><span class="p">,</span> <span class="n">TCPHDR_SYN</span><span class="p">);</span>
	<span class="n">TCP_ECN_send_syn</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>

	<span class="cm">/* Send it off. */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_stamp</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span><span class="p">;</span>
	<span class="n">skb_header_release</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
	<span class="n">__tcp_add_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+=</span> <span class="n">buff</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buff</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* We change tp-&gt;snd_nxt after the tcp_transmit_skb() call</span>
<span class="cm">	 * in order to make this packet get counted in tcpOutSegs.</span>
<span class="cm">	 */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">pushed_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">;</span>
	<span class="n">TCP_INC_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_ACTIVEOPENS</span><span class="p">);</span>

	<span class="cm">/* Timer for repeating the SYN until an answer. */</span>
	<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_RETRANS</span><span class="p">,</span>
				  <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">,</span> <span class="n">TCP_RTO_MAX</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_connect</span><span class="p">);</span>

<span class="cm">/* Send out a delayed ack, the caller does the policy checking</span>
<span class="cm"> * to see if we should even be here.  See tcp_input.c:tcp_ack_snd_check()</span>
<span class="cm"> * for details.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_send_delayed_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ato</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ato</span> <span class="o">&gt;</span> <span class="n">TCP_DELACK_MIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">max_ato</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="n">ICSK_ACK_PUSHED</span><span class="p">))</span>
			<span class="n">max_ato</span> <span class="o">=</span> <span class="n">TCP_DELACK_MAX</span><span class="p">;</span>

		<span class="cm">/* Slow path, intersegment interval is &quot;high&quot;. */</span>

		<span class="cm">/* If some rtt estimate is known, use it to bound delayed ack.</span>
<span class="cm">		 * Do not use inet_csk(sk)-&gt;icsk_rto here, use results of rtt measurements</span>
<span class="cm">		 * directly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">rtt</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">TCP_DELACK_MIN</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">rtt</span> <span class="o">&lt;</span> <span class="n">max_ato</span><span class="p">)</span>
				<span class="n">max_ato</span> <span class="o">=</span> <span class="n">rtt</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ato</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ato</span><span class="p">,</span> <span class="n">max_ato</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Stay within the limit we were given */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">ato</span><span class="p">;</span>

	<span class="cm">/* Use new timeout only if there wasn&#39;t a older one earlier. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="n">ICSK_ACK_TIMER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If delack timer was blocked or is about to expire,</span>
<span class="cm">		 * send ACK now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">blocked</span> <span class="o">||</span>
		    <span class="n">time_before_eq</span><span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">timeout</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="p">(</span><span class="n">ato</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">tcp_send_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_before</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">timeout</span><span class="p">))</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">timeout</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pending</span> <span class="o">|=</span> <span class="n">ICSK_ACK_SCHED</span> <span class="o">|</span> <span class="n">ICSK_ACK_TIMER</span><span class="p">;</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">sk_reset_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_delack_timer</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This routine sends an ack and also updates the window. */</span>
<span class="kt">void</span> <span class="nf">tcp_send_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buff</span><span class="p">;</span>

	<span class="cm">/* If we have been reset, we may not send again. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* We are not putting this on the write queue, so</span>
<span class="cm">	 * tcp_transmit_skb() will set the ownership to this</span>
<span class="cm">	 * sock.</span>
<span class="cm">	 */</span>
	<span class="n">buff</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">MAX_TCP_HEADER</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buff</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inet_csk_schedule_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span> <span class="o">=</span> <span class="n">TCP_ATO_MIN</span><span class="p">;</span>
		<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_DACK</span><span class="p">,</span>
					  <span class="n">TCP_DELACK_MAX</span><span class="p">,</span> <span class="n">TCP_RTO_MAX</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reserve space for headers and prepare control bits. */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">MAX_TCP_HEADER</span><span class="p">);</span>
	<span class="n">tcp_init_nondata_skb</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">tcp_acceptable_seq</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCPHDR_ACK</span><span class="p">);</span>

	<span class="cm">/* Send it off, this clears delayed acks for us. */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This routine sends a packet with an out of date sequence</span>
<span class="cm"> * number. It assumes the other end will try to ack it.</span>
<span class="cm"> *</span>
<span class="cm"> * Question: what should we make while urgent mode?</span>
<span class="cm"> * 4.4BSD forces sending single byte of data. We cannot send</span>
<span class="cm"> * out of window data, because we have SND.NXT==SND.MAX...</span>
<span class="cm"> *</span>
<span class="cm"> * Current solution: to send TWO zero-length segments in urgent mode:</span>
<span class="cm"> * one is with SEG.SEQ=SND.UNA to deliver urgent pointer, another is</span>
<span class="cm"> * out-of-date with SND.UNA-1 to probe window.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_xmit_probe_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">urgent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* We don&#39;t queue it, tcp_transmit_skb() sets ownership. */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">MAX_TCP_HEADER</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Reserve space for headers and set control bits. */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">MAX_TCP_HEADER</span><span class="p">);</span>
	<span class="cm">/* Use a previous sequence.  This should cause the other</span>
<span class="cm">	 * end to send an ack.  Don&#39;t queue or clone SKB, just</span>
<span class="cm">	 * send it.</span>
<span class="cm">	 */</span>
	<span class="n">tcp_init_nondata_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">-</span> <span class="o">!</span><span class="n">urgent</span><span class="p">,</span> <span class="n">TCPHDR_ACK</span><span class="p">);</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tcp_send_window_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snd_wl1</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snd_nxt</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">;</span>
		<span class="n">tcp_xmit_probe_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Initiate keepalive or window probe from timer. */</span>
<span class="kt">int</span> <span class="nf">tcp_write_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span> <span class="o">=</span> <span class="n">tcp_current_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seg_size</span> <span class="o">=</span> <span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">pushed_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">pushed_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>

		<span class="cm">/* We are probing the opening of a window</span>
<span class="cm">		 * but the window size is != 0</span>
<span class="cm">		 * must have been a result SWS avoidance ( sender )</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seg_size</span> <span class="o">&lt;</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">||</span>
		    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">mss</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seg_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">seg_size</span><span class="p">,</span> <span class="n">mss</span><span class="p">);</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCPHDR_PSH</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcp_fragment</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">seg_size</span><span class="p">,</span> <span class="n">mss</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="n">tcp_set_skb_tso_segs</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">mss</span><span class="p">);</span>

		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCPHDR_PSH</span><span class="p">;</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tcp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">tcp_event_new_data_sent</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_up</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">+</span> <span class="mh">0xFFFF</span><span class="p">))</span>
			<span class="n">tcp_xmit_probe_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">tcp_xmit_probe_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* A window probe timeout has occurred.  If window is not closed send</span>
<span class="cm"> * a partial packet else a zero probe.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_send_probe0</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">tcp_write_wakeup</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">||</span> <span class="o">!</span><span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Cancel probe timer, if it is not required. */</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_probes_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_backoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_backoff</span> <span class="o">&lt;</span> <span class="n">sysctl_tcp_retries2</span><span class="p">)</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_backoff</span><span class="o">++</span><span class="p">;</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_probes_out</span><span class="o">++</span><span class="p">;</span>
		<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_PROBE0</span><span class="p">,</span>
					  <span class="n">min</span><span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">&lt;&lt;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_backoff</span><span class="p">,</span> <span class="n">TCP_RTO_MAX</span><span class="p">),</span>
					  <span class="n">TCP_RTO_MAX</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If packet was not sent due to local congestion,</span>
<span class="cm">		 * do not backoff and do not remember icsk_probes_out.</span>
<span class="cm">		 * Let local senders to fight for local resources.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Use accumulated backoff yet.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_probes_out</span><span class="p">)</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_probes_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_PROBE0</span><span class="p">,</span>
					  <span class="n">min</span><span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">&lt;&lt;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_backoff</span><span class="p">,</span>
					      <span class="n">TCP_RESOURCE_PROBE_INTERVAL</span><span class="p">),</span>
					  <span class="n">TCP_RTO_MAX</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
