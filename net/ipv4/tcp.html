<!DOCTYPE html>
<html><head><title>joekychen/linux » net › ipv4 › tcp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tcp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  INET is implemented using the  BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *		Implementation of the Transmission Control Protocol(TCP).</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Ross Biro</span>
<span class="cm"> *		Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *		Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;</span>
<span class="cm"> *		Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;</span>
<span class="cm"> *		Florian La Roche, &lt;flla@stud.uni-sb.de&gt;</span>
<span class="cm"> *		Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;</span>
<span class="cm"> *		Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;</span>
<span class="cm"> *		Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;</span>
<span class="cm"> *		Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;</span>
<span class="cm"> *		Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;</span>
<span class="cm"> *		Jorge Cwik, &lt;jorge@laser.satlink.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Fixes:</span>
<span class="cm"> *		Alan Cox	:	Numerous verify_area() calls</span>
<span class="cm"> *		Alan Cox	:	Set the ACK bit on a reset</span>
<span class="cm"> *		Alan Cox	:	Stopped it crashing if it closed while</span>
<span class="cm"> *					sk-&gt;inuse=1 and was trying to connect</span>
<span class="cm"> *					(tcp_err()).</span>
<span class="cm"> *		Alan Cox	:	All icmp error handling was broken</span>
<span class="cm"> *					pointers passed where wrong and the</span>
<span class="cm"> *					socket was looked up backwards. Nobody</span>
<span class="cm"> *					tested any icmp error code obviously.</span>
<span class="cm"> *		Alan Cox	:	tcp_err() now handled properly. It</span>
<span class="cm"> *					wakes people on errors. poll</span>
<span class="cm"> *					behaves and the icmp error race</span>
<span class="cm"> *					has gone by moving it into sock.c</span>
<span class="cm"> *		Alan Cox	:	tcp_send_reset() fixed to work for</span>
<span class="cm"> *					everything not just packets for</span>
<span class="cm"> *					unknown sockets.</span>
<span class="cm"> *		Alan Cox	:	tcp option processing.</span>
<span class="cm"> *		Alan Cox	:	Reset tweaked (still not 100%) [Had</span>
<span class="cm"> *					syn rule wrong]</span>
<span class="cm"> *		Herp Rosmanith  :	More reset fixes</span>
<span class="cm"> *		Alan Cox	:	No longer acks invalid rst frames.</span>
<span class="cm"> *					Acking any kind of RST is right out.</span>
<span class="cm"> *		Alan Cox	:	Sets an ignore me flag on an rst</span>
<span class="cm"> *					receive otherwise odd bits of prattle</span>
<span class="cm"> *					escape still</span>
<span class="cm"> *		Alan Cox	:	Fixed another acking RST frame bug.</span>
<span class="cm"> *					Should stop LAN workplace lockups.</span>
<span class="cm"> *		Alan Cox	: 	Some tidyups using the new skb list</span>
<span class="cm"> *					facilities</span>
<span class="cm"> *		Alan Cox	:	sk-&gt;keepopen now seems to work</span>
<span class="cm"> *		Alan Cox	:	Pulls options out correctly on accepts</span>
<span class="cm"> *		Alan Cox	:	Fixed assorted sk-&gt;rqueue-&gt;next errors</span>
<span class="cm"> *		Alan Cox	:	PSH doesn&#39;t end a TCP read. Switched a</span>
<span class="cm"> *					bit to skb ops.</span>
<span class="cm"> *		Alan Cox	:	Tidied tcp_data to avoid a potential</span>
<span class="cm"> *					nasty.</span>
<span class="cm"> *		Alan Cox	:	Added some better commenting, as the</span>
<span class="cm"> *					tcp is hard to follow</span>
<span class="cm"> *		Alan Cox	:	Removed incorrect check for 20 * psh</span>
<span class="cm"> *	Michael O&#39;Reilly	:	ack &lt; copied bug fix.</span>
<span class="cm"> *	Johannes Stille		:	Misc tcp fixes (not all in yet).</span>
<span class="cm"> *		Alan Cox	:	FIN with no memory -&gt; CRASH</span>
<span class="cm"> *		Alan Cox	:	Added socket option proto entries.</span>
<span class="cm"> *					Also added awareness of them to accept.</span>
<span class="cm"> *		Alan Cox	:	Added TCP options (SOL_TCP)</span>
<span class="cm"> *		Alan Cox	:	Switched wakeup calls to callbacks,</span>
<span class="cm"> *					so the kernel can layer network</span>
<span class="cm"> *					sockets.</span>
<span class="cm"> *		Alan Cox	:	Use ip_tos/ip_ttl settings.</span>
<span class="cm"> *		Alan Cox	:	Handle FIN (more) properly (we hope).</span>
<span class="cm"> *		Alan Cox	:	RST frames sent on unsynchronised</span>
<span class="cm"> *					state ack error.</span>
<span class="cm"> *		Alan Cox	:	Put in missing check for SYN bit.</span>
<span class="cm"> *		Alan Cox	:	Added tcp_select_window() aka NET2E</span>
<span class="cm"> *					window non shrink trick.</span>
<span class="cm"> *		Alan Cox	:	Added a couple of small NET2E timer</span>
<span class="cm"> *					fixes</span>
<span class="cm"> *		Charles Hedrick :	TCP fixes</span>
<span class="cm"> *		Toomas Tamm	:	TCP window fixes</span>
<span class="cm"> *		Alan Cox	:	Small URG fix to rlogin ^C ack fight</span>
<span class="cm"> *		Charles Hedrick	:	Rewrote most of it to actually work</span>
<span class="cm"> *		Linus		:	Rewrote tcp_read() and URG handling</span>
<span class="cm"> *					completely</span>
<span class="cm"> *		Gerhard Koerting:	Fixed some missing timer handling</span>
<span class="cm"> *		Matthew Dillon  :	Reworked TCP machine states as per RFC</span>
<span class="cm"> *		Gerhard Koerting:	PC/TCP workarounds</span>
<span class="cm"> *		Adam Caldwell	:	Assorted timer/timing errors</span>
<span class="cm"> *		Matthew Dillon	:	Fixed another RST bug</span>
<span class="cm"> *		Alan Cox	:	Move to kernel side addressing changes.</span>
<span class="cm"> *		Alan Cox	:	Beginning work on TCP fastpathing</span>
<span class="cm"> *					(not yet usable)</span>
<span class="cm"> *		Arnt Gulbrandsen:	Turbocharged tcp_check() routine.</span>
<span class="cm"> *		Alan Cox	:	TCP fast path debugging</span>
<span class="cm"> *		Alan Cox	:	Window clamping</span>
<span class="cm"> *		Michael Riepe	:	Bug in tcp_check()</span>
<span class="cm"> *		Matt Dillon	:	More TCP improvements and RST bug fixes</span>
<span class="cm"> *		Matt Dillon	:	Yet more small nasties remove from the</span>
<span class="cm"> *					TCP code (Be very nice to this man if</span>
<span class="cm"> *					tcp finally works 100%) 8)</span>
<span class="cm"> *		Alan Cox	:	BSD accept semantics.</span>
<span class="cm"> *		Alan Cox	:	Reset on closedown bug.</span>
<span class="cm"> *	Peter De Schrijver	:	ENOTCONN check missing in tcp_sendto().</span>
<span class="cm"> *		Michael Pall	:	Handle poll() after URG properly in</span>
<span class="cm"> *					all cases.</span>
<span class="cm"> *		Michael Pall	:	Undo the last fix in tcp_read_urg()</span>
<span class="cm"> *					(multi URG PUSH broke rlogin).</span>
<span class="cm"> *		Michael Pall	:	Fix the multi URG PUSH problem in</span>
<span class="cm"> *					tcp_readable(), poll() after URG</span>
<span class="cm"> *					works now.</span>
<span class="cm"> *		Michael Pall	:	recv(...,MSG_OOB) never blocks in the</span>
<span class="cm"> *					BSD api.</span>
<span class="cm"> *		Alan Cox	:	Changed the semantics of sk-&gt;socket to</span>
<span class="cm"> *					fix a race and a signal problem with</span>
<span class="cm"> *					accept() and async I/O.</span>
<span class="cm"> *		Alan Cox	:	Relaxed the rules on tcp_sendto().</span>
<span class="cm"> *		Yury Shevchuk	:	Really fixed accept() blocking problem.</span>
<span class="cm"> *		Craig I. Hagan  :	Allow for BSD compatible TIME_WAIT for</span>
<span class="cm"> *					clients/servers which listen in on</span>
<span class="cm"> *					fixed ports.</span>
<span class="cm"> *		Alan Cox	:	Cleaned the above up and shrank it to</span>
<span class="cm"> *					a sensible code size.</span>
<span class="cm"> *		Alan Cox	:	Self connect lockup fix.</span>
<span class="cm"> *		Alan Cox	:	No connect to multicast.</span>
<span class="cm"> *		Ross Biro	:	Close unaccepted children on master</span>
<span class="cm"> *					socket close.</span>
<span class="cm"> *		Alan Cox	:	Reset tracing code.</span>
<span class="cm"> *		Alan Cox	:	Spurious resets on shutdown.</span>
<span class="cm"> *		Alan Cox	:	Giant 15 minute/60 second timer error</span>
<span class="cm"> *		Alan Cox	:	Small whoops in polling before an</span>
<span class="cm"> *					accept.</span>
<span class="cm"> *		Alan Cox	:	Kept the state trace facility since</span>
<span class="cm"> *					it&#39;s handy for debugging.</span>
<span class="cm"> *		Alan Cox	:	More reset handler fixes.</span>
<span class="cm"> *		Alan Cox	:	Started rewriting the code based on</span>
<span class="cm"> *					the RFC&#39;s for other useful protocol</span>
<span class="cm"> *					references see: Comer, KA9Q NOS, and</span>
<span class="cm"> *					for a reference on the difference</span>
<span class="cm"> *					between specifications and how BSD</span>
<span class="cm"> *					works see the 4.4lite source.</span>
<span class="cm"> *		A.N.Kuznetsov	:	Don&#39;t time wait on completion of tidy</span>
<span class="cm"> *					close.</span>
<span class="cm"> *		Linus Torvalds	:	Fin/Shutdown &amp; copied_seq changes.</span>
<span class="cm"> *		Linus Torvalds	:	Fixed BSD port reuse to work first syn</span>
<span class="cm"> *		Alan Cox	:	Reimplemented timers as per the RFC</span>
<span class="cm"> *					and using multiple timers for sanity.</span>
<span class="cm"> *		Alan Cox	:	Small bug fixes, and a lot of new</span>
<span class="cm"> *					comments.</span>
<span class="cm"> *		Alan Cox	:	Fixed dual reader crash by locking</span>
<span class="cm"> *					the buffers (much like datagram.c)</span>
<span class="cm"> *		Alan Cox	:	Fixed stuck sockets in probe. A probe</span>
<span class="cm"> *					now gets fed up of retrying without</span>
<span class="cm"> *					(even a no space) answer.</span>
<span class="cm"> *		Alan Cox	:	Extracted closing code better</span>
<span class="cm"> *		Alan Cox	:	Fixed the closing state machine to</span>
<span class="cm"> *					resemble the RFC.</span>
<span class="cm"> *		Alan Cox	:	More &#39;per spec&#39; fixes.</span>
<span class="cm"> *		Jorge Cwik	:	Even faster checksumming.</span>
<span class="cm"> *		Alan Cox	:	tcp_data() doesn&#39;t ack illegal PSH</span>
<span class="cm"> *					only frames. At least one pc tcp stack</span>
<span class="cm"> *					generates them.</span>
<span class="cm"> *		Alan Cox	:	Cache last socket.</span>
<span class="cm"> *		Alan Cox	:	Per route irtt.</span>
<span class="cm"> *		Matt Day	:	poll()-&gt;select() match BSD precisely on error</span>
<span class="cm"> *		Alan Cox	:	New buffers</span>
<span class="cm"> *		Marc Tamsky	:	Various sk-&gt;prot-&gt;retransmits and</span>
<span class="cm"> *					sk-&gt;retransmits misupdating fixed.</span>
<span class="cm"> *					Fixed tcp_write_timeout: stuck close,</span>
<span class="cm"> *					and TCP syn retries gets used now.</span>
<span class="cm"> *		Mark Yarvis	:	In tcp_read_wakeup(), don&#39;t send an</span>
<span class="cm"> *					ack if state is TCP_CLOSED.</span>
<span class="cm"> *		Alan Cox	:	Look up device on a retransmit - routes may</span>
<span class="cm"> *					change. Doesn&#39;t yet cope with MSS shrink right</span>
<span class="cm"> *					but it&#39;s a start!</span>
<span class="cm"> *		Marc Tamsky	:	Closing in closing fixes.</span>
<span class="cm"> *		Mike Shaver	:	RFC1122 verifications.</span>
<span class="cm"> *		Alan Cox	:	rcv_saddr errors.</span>
<span class="cm"> *		Alan Cox	:	Block double connect().</span>
<span class="cm"> *		Alan Cox	:	Small hooks for enSKIP.</span>
<span class="cm"> *		Alexey Kuznetsov:	Path MTU discovery.</span>
<span class="cm"> *		Alan Cox	:	Support soft errors.</span>
<span class="cm"> *		Alan Cox	:	Fix MTU discovery pathological case</span>
<span class="cm"> *					when the remote claims no mtu!</span>
<span class="cm"> *		Marc Tamsky	:	TCP_CLOSE fix.</span>
<span class="cm"> *		Colin (G3TNE)	:	Send a reset on syn ack replies in</span>
<span class="cm"> *					window but wrong (fixes NT lpd problems)</span>
<span class="cm"> *		Pedro Roque	:	Better TCP window handling, delayed ack.</span>
<span class="cm"> *		Joerg Reuter	:	No modification of locked buffers in</span>
<span class="cm"> *					tcp_do_retransmit()</span>
<span class="cm"> *		Eric Schenk	:	Changed receiver side silly window</span>
<span class="cm"> *					avoidance algorithm to BSD style</span>
<span class="cm"> *					algorithm. This doubles throughput</span>
<span class="cm"> *					against machines running Solaris,</span>
<span class="cm"> *					and seems to result in general</span>
<span class="cm"> *					improvement.</span>
<span class="cm"> *	Stefan Magdalinski	:	adjusted tcp_readable() to fix FIONREAD</span>
<span class="cm"> *	Willy Konynenberg	:	Transparent proxying support.</span>
<span class="cm"> *	Mike McLagan		:	Routing by source</span>
<span class="cm"> *		Keith Owens	:	Do proper merging with partial SKB&#39;s in</span>
<span class="cm"> *					tcp_do_sendmsg to avoid burstiness.</span>
<span class="cm"> *		Eric Schenk	:	Fix fast close down bug with</span>
<span class="cm"> *					shutdown() followed by close().</span>
<span class="cm"> *		Andi Kleen 	:	Make poll agree with SIGIO</span>
<span class="cm"> *	Salvatore Sanfilippo	:	Support SO_LINGER with linger == 1 and</span>
<span class="cm"> *					lingertime == 0 (RFC 793 ABORT Call)</span>
<span class="cm"> *	Hirokazu Takahashi	:	Use copy_from_user() instead of</span>
<span class="cm"> *					csum_and_copy_from_user() if possible.</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or(at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * Description of States:</span>
<span class="cm"> *</span>
<span class="cm"> *	TCP_SYN_SENT		sent a connection request, waiting for ack</span>
<span class="cm"> *</span>
<span class="cm"> *	TCP_SYN_RECV		received a connection request, sent ack,</span>
<span class="cm"> *				waiting for final ack in three-way handshake.</span>
<span class="cm"> *</span>
<span class="cm"> *	TCP_ESTABLISHED		connection established</span>
<span class="cm"> *</span>
<span class="cm"> *	TCP_FIN_WAIT1		our side has shutdown, waiting to complete</span>
<span class="cm"> *				transmission of remaining buffered data</span>
<span class="cm"> *</span>
<span class="cm"> *	TCP_FIN_WAIT2		all buffered data sent, waiting for remote</span>
<span class="cm"> *				to shutdown</span>
<span class="cm"> *</span>
<span class="cm"> *	TCP_CLOSING		both sides have shutdown but we still have</span>
<span class="cm"> *				data we have to finish sending</span>
<span class="cm"> *</span>
<span class="cm"> *	TCP_TIME_WAIT		timeout to catch resent junk before entering</span>
<span class="cm"> *				closed, can only be entered from FIN_WAIT2</span>
<span class="cm"> *				or CLOSING.  Required because the other end</span>
<span class="cm"> *				may not have gotten our last ACK causing it</span>
<span class="cm"> *				to retransmit the data packet (which we ignore)</span>
<span class="cm"> *</span>
<span class="cm"> *	TCP_CLOSE_WAIT		remote side has shutdown and is waiting for</span>
<span class="cm"> *				us to finish writing our data and to shutdown</span>
<span class="cm"> *				(we have to close() to move on to LAST_ACK)</span>
<span class="cm"> *</span>
<span class="cm"> *	TCP_LAST_ACK		out side has shutdown after remote has</span>
<span class="cm"> *				shutdown.  There may still be data in our</span>
<span class="cm"> *				buffer that we have to finish sending</span>
<span class="cm"> *</span>
<span class="cm"> *	TCP_CLOSE		socket is finished</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) &quot;TCP: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/splice.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/crypto.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;net/icmp.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#include &lt;net/xfrm.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/netdma.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/ioctls.h&gt;</span>

<span class="kt">int</span> <span class="n">sysctl_tcp_fin_timeout</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">TCP_FIN_TIMEOUT</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">tcp_orphan_count</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tcp_orphan_count</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">sysctl_tcp_wmem</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sysctl_tcp_rmem</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sysctl_tcp_wmem</span><span class="p">);</span>

<span class="n">atomic_long_t</span> <span class="n">tcp_memory_allocated</span><span class="p">;</span>	<span class="cm">/* Current allocated memory. */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_memory_allocated</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Current number of TCP sockets.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">tcp_sockets_allocated</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_sockets_allocated</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * TCP splice context</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tcp_splice_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Pressure flag: try to collapse.</span>
<span class="cm"> * Technical note: it is used by multiple contexts non atomically.</span>
<span class="cm"> * All the __sk_mem_schedule() is of this nature: accounting</span>
<span class="cm"> * is strict, actions are advisory and have some latency.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">tcp_memory_pressure</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_memory_pressure</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">tcp_enter_memory_pressure</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_memory_pressure</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NET_INC_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPMEMORYPRESSURES</span><span class="p">);</span>
		<span class="n">tcp_memory_pressure</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_enter_memory_pressure</span><span class="p">);</span>

<span class="cm">/* Convert seconds to retransmits based on initial and max timeout */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">secs_to_retrans</span><span class="p">(</span><span class="kt">int</span> <span class="n">seconds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rto_max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">seconds</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">period</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>

		<span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">seconds</span> <span class="o">&gt;</span> <span class="n">period</span> <span class="o">&amp;&amp;</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span><span class="o">++</span><span class="p">;</span>
			<span class="n">timeout</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">rto_max</span><span class="p">)</span>
				<span class="n">timeout</span> <span class="o">=</span> <span class="n">rto_max</span><span class="p">;</span>
			<span class="n">period</span> <span class="o">+=</span> <span class="n">timeout</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Convert retransmits to seconds based on initial and max timeout */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">retrans_to_secs</span><span class="p">(</span><span class="n">u8</span> <span class="n">retrans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rto_max</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">period</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retrans</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">retrans</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">timeout</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">rto_max</span><span class="p">)</span>
				<span class="n">timeout</span> <span class="o">=</span> <span class="n">rto_max</span><span class="p">;</span>
			<span class="n">period</span> <span class="o">+=</span> <span class="n">timeout</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">period</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Address-family independent initialization for a tcp_sock.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: A lot of things set to zero explicitly by call to</span>
<span class="cm"> *       sk_alloc() so need not be done here.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_init_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">);</span>
	<span class="n">tcp_init_xmit_timers</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tcp_prequeue_init</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">=</span> <span class="n">TCP_TIMEOUT_INIT</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span> <span class="o">=</span> <span class="n">TCP_TIMEOUT_INIT</span><span class="p">;</span>

	<span class="cm">/* So many TCP implementations out there (incorrectly) count the</span>
<span class="cm">	 * initial SYN frame in their delayed-ACK and congestion control</span>
<span class="cm">	 * algorithms that we must have the following bandaid to talk</span>
<span class="cm">	 * efficiently to them.  -DaveM</span>
<span class="cm">	 */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">TCP_INIT_CWND</span><span class="p">;</span>

	<span class="cm">/* See draft-stevens-tcpca-spec-01 for discussion of the</span>
<span class="cm">	 * initialization of these values.</span>
<span class="cm">	 */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">TCP_INFINITE_SSTHRESH</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_clamp</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span> <span class="o">=</span> <span class="n">TCP_MSS_DEFAULT</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span> <span class="o">=</span> <span class="n">sysctl_tcp_reordering</span><span class="p">;</span>
	<span class="n">tcp_enable_early_retrans</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tcp_init_congestion_ops</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">TCP_CLOSE</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span> <span class="o">=</span> <span class="n">sk_stream_write_space</span><span class="p">;</span>
	<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_USE_WRITE_QUEUE</span><span class="p">);</span>

	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_sync_mss</span> <span class="o">=</span> <span class="n">tcp_sync_mss</span><span class="p">;</span>

	<span class="cm">/* TCP Cookie Transactions */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_cookie_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Default, cookies without s_data_payload. */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span> <span class="o">=</span>
			<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="p">),</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Presumed zeroed, in order of appearance:</span>
<span class="cm">	 *	cookie_in_always, cookie_out_never,</span>
<span class="cm">	 *	s_data_constant, s_data_in, s_data_out</span>
<span class="cm">	 */</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">=</span> <span class="n">sysctl_tcp_wmem</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">=</span> <span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">sock_update_memcg</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk_sockets_allocated_inc</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_init_sock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Wait for a TCP event.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note that we don&#39;t need to lock the socket, as the upper poll layers</span>
<span class="cm"> *	take care of normal races (between the test and the event) and we don&#39;t</span>
<span class="cm"> *	go look at any of the socket buffers directly.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sock_poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">wait</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">inet_csk_listen_poll</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Socket is not locked. We are protected from async events</span>
<span class="cm">	 * by poll logic and correct handling of state changes</span>
<span class="cm">	 * made by other threads is impossible in any case.</span>
<span class="cm">	 */</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * POLLHUP is certainly not done right. But poll() doesn&#39;t</span>
<span class="cm">	 * have a notion of HUP in just one direction, and for a</span>
<span class="cm">	 * socket the read side is more interesting.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Some poll() documentation says that POLLHUP is incompatible</span>
<span class="cm">	 * with the POLLOUT/POLLWR flags, so somebody should check this</span>
<span class="cm">	 * all. But careful, it tends to be safer to return too many</span>
<span class="cm">	 * bits than too few, and you can easily break real applications</span>
<span class="cm">	 * if you don&#39;t tell them that something has hung up!</span>
<span class="cm">	 *</span>
<span class="cm">	 * Check-me.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Check number 1. POLLHUP is _UNMASKABLE_ event (see UNIX98 and</span>
<span class="cm">	 * our fs/select.c). It means that after we received EOF,</span>
<span class="cm">	 * poll always returns immediately, making impossible poll() on write()</span>
<span class="cm">	 * in state CLOSE_WAIT. One solution is evident --- to set POLLHUP</span>
<span class="cm">	 * if and only if shutdown has been made in both directions.</span>
<span class="cm">	 * Actually, it is interesting to look how Solaris and DUX</span>
<span class="cm">	 * solve this dilemma. I would prefer, if POLLHUP were maskable,</span>
<span class="cm">	 * then we could set it on SND_SHUTDOWN. BTW examples given</span>
<span class="cm">	 * in Stevens&#39; books assume exactly this behaviour, it explains</span>
<span class="cm">	 * why POLLHUP is incompatible with POLLOUT.	--ANK</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE. Check for TCP_CLOSE is added. The goal is to prevent</span>
<span class="cm">	 * blocking on fresh not-connected or disconnected socket. --ANK</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">==</span> <span class="n">SHUTDOWN_MASK</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span> <span class="o">|</span> <span class="n">POLLRDHUP</span><span class="p">;</span>

	<span class="cm">/* Connected? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">TCPF_SYN_SENT</span> <span class="o">|</span> <span class="n">TCPF_SYN_RECV</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">sock_rcvlowat</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_URGINLINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span><span class="p">)</span>
			<span class="n">target</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Potential race condition. If read of tp below will</span>
<span class="cm">		 * escape above sk-&gt;sk_state, we can be illegally awaken</span>
<span class="cm">		 * in SYN_* states. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sk_stream_wspace</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">sk_stream_min_wspace</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="cm">/* send SIGIO later */</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

				<span class="cm">/* Race breaker. If space is freed after</span>
<span class="cm">				 * wspace test but before the flags are set,</span>
<span class="cm">				 * IO signal will be lost.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sk_stream_wspace</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">sk_stream_min_wspace</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
					<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">&amp;</span> <span class="n">TCP_URG_VALID</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLPRI</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* This barrier is coupled with smp_wmb() in tcp_reset() */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLERR</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_poll</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">tcp_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">answ</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCINQ</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPF_SYN_SENT</span> <span class="o">|</span> <span class="n">TCPF_SYN_RECV</span><span class="p">))</span>
			<span class="n">answ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_URGINLINE</span><span class="p">)</span> <span class="o">||</span>
			 <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">||</span>
			 <span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">)</span> <span class="o">||</span>
			 <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

			<span class="n">answ</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">;</span>

			<span class="cm">/* Subtract 1, if FIN is in queue. */</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">answ</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="p">)</span>
				<span class="n">answ</span> <span class="o">-=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">answ</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">;</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCATMARK</span>:
		<span class="n">answ</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCOUTQ</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPF_SYN_SENT</span> <span class="o">|</span> <span class="n">TCPF_SYN_RECV</span><span class="p">))</span>
			<span class="n">answ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">answ</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCOUTQNSD</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPF_SYN_SENT</span> <span class="o">|</span> <span class="n">TCPF_SYN_RECV</span><span class="p">))</span>
			<span class="n">answ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">answ</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">answ</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_ioctl</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_mark_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCPHDR_PSH</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">pushed_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">forced_push</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">after</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">pushed_seq</span> <span class="o">+</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_window</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_entail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_skb_cb</span> <span class="o">*</span><span class="n">tcb</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">seq</span>     <span class="o">=</span> <span class="n">tcb</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">;</span>
	<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">=</span> <span class="n">TCPHDR_ACK</span><span class="p">;</span>
	<span class="n">tcb</span><span class="o">-&gt;</span><span class="n">sacked</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb_header_release</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">tcp_add_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span> <span class="o">&amp;</span> <span class="n">TCP_NAGLE_PUSH</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_NAGLE_PUSH</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_mark_urg</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_OOB</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_up</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mss_now</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">nonagle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_MORE</span><span class="p">)</span> <span class="o">||</span> <span class="n">forced_push</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
			<span class="n">tcp_mark_push</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tcp_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>

		<span class="n">tcp_mark_urg</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">__tcp_push_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_MORE</span><span class="p">)</span> <span class="o">?</span> <span class="n">TCP_NAGLE_CORK</span> <span class="o">:</span> <span class="n">nonagle</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_splice_data_recv</span><span class="p">(</span><span class="n">read_descriptor_t</span> <span class="o">*</span><span class="n">rd_desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_splice_state</span> <span class="o">*</span><span class="n">tss</span> <span class="o">=</span> <span class="n">rd_desc</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">skb_splice_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">tss</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">rd_desc</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span>
			      <span class="n">tss</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rd_desc</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__tcp_splice_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcp_splice_state</span> <span class="o">*</span><span class="n">tss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Store TCP splice context information in read_descriptor_t. */</span>
	<span class="n">read_descriptor_t</span> <span class="n">rd_desc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">arg</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">tss</span><span class="p">,</span>
		<span class="p">.</span><span class="n">count</span>	  <span class="o">=</span> <span class="n">tss</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">tcp_read_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rd_desc</span><span class="p">,</span> <span class="n">tcp_splice_data_recv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  tcp_splice_read - splice data from TCP socket to a pipe</span>
<span class="cm"> * @sock:	socket to splice from</span>
<span class="cm"> * @ppos:	position (not valid)</span>
<span class="cm"> * @pipe:	pipe to splice to</span>
<span class="cm"> * @len:	number of bytes to splice</span>
<span class="cm"> * @flags:	splice modifier flags</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Will read pages from given socket and fill them into a pipe.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">ssize_t</span> <span class="nf">tcp_splice_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_splice_state</span> <span class="n">tss</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">pipe</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">,</span>
		<span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">spliced</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">sock_rps_record_flow</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t seek on a socket input</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">ppos</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">spliced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_rcvtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tss</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__tcp_splice_read</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tss</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spliced</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DONE</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * This occurs when user tries to read</span>
<span class="cm">				 * from never connected socket.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DONE</span><span class="p">))</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sk_wait_data</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeo</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tss</span><span class="p">.</span><span class="n">len</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">spliced</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spliced</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">spliced</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_splice_read</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">sk_stream_alloc_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* The TCP header must be at least 32-bit aligned.  */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb_fclone</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk_wmem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Make sure that we have exactly size bytes</span>
<span class="cm">			 * available to the caller, no more, no less.</span>
<span class="cm">			 */</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">avail_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">enter_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sk_stream_moderate_sndbuf</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tcp_xmit_size_goal</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">mss_now</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">large_allowed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">xmit_size_goal</span><span class="p">,</span> <span class="n">old_size_goal</span><span class="p">;</span>

	<span class="n">xmit_size_goal</span> <span class="o">=</span> <span class="n">mss_now</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">large_allowed</span> <span class="o">&amp;&amp;</span> <span class="n">sk_can_gso</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">xmit_size_goal</span> <span class="o">=</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_gso_max_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
				  <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">net_header_len</span> <span class="o">-</span>
				  <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ext_hdr_len</span> <span class="o">-</span>
				  <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span><span class="p">);</span>

		<span class="n">xmit_size_goal</span> <span class="o">=</span> <span class="n">tcp_bound_to_half_wnd</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">xmit_size_goal</span><span class="p">);</span>

		<span class="cm">/* We try hard to avoid divides here */</span>
		<span class="n">old_size_goal</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">xmit_size_goal_segs</span> <span class="o">*</span> <span class="n">mss_now</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">old_size_goal</span> <span class="o">&lt;=</span> <span class="n">xmit_size_goal</span> <span class="o">&amp;&amp;</span>
			   <span class="n">old_size_goal</span> <span class="o">+</span> <span class="n">mss_now</span> <span class="o">&gt;</span> <span class="n">xmit_size_goal</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">xmit_size_goal</span> <span class="o">=</span> <span class="n">old_size_goal</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">xmit_size_goal_segs</span> <span class="o">=</span> <span class="n">xmit_size_goal</span> <span class="o">/</span> <span class="n">mss_now</span><span class="p">;</span>
			<span class="n">xmit_size_goal</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">xmit_size_goal_segs</span> <span class="o">*</span> <span class="n">mss_now</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">xmit_size_goal</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_send_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">size_goal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mss_now</span><span class="p">;</span>

	<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tcp_current_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="o">*</span><span class="n">size_goal</span> <span class="o">=</span> <span class="n">tcp_xmit_size_goal</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_OOB</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">mss_now</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">do_tcp_sendpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">poffset</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">psize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">size_goal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">copied</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>

	<span class="cm">/* Wait for a connection to finish. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">TCPF_ESTABLISHED</span> <span class="o">|</span> <span class="n">TCPF_CLOSE_WAIT</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">sk_stream_wait_connect</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeo</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tcp_send_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size_goal</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">||</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">psize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">poffset</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">copy</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">poffset</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">bool</span> <span class="n">can_coalesce</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">copy</span> <span class="o">=</span> <span class="n">size_goal</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">new_segment:</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_stream_memory_free</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">wait_for_sndbuf</span><span class="p">;</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="n">sk_stream_alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">wait_for_memory</span><span class="p">;</span>

			<span class="n">skb_entail</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">size_goal</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">i</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
		<span class="n">can_coalesce</span> <span class="o">=</span> <span class="n">skb_can_coalesce</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_coalesce</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcp_mark_push</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">new_segment</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_wmem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">copy</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">wait_for_memory</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">can_coalesce</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_frag_size_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">copy</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copied</span><span class="p">)</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPHDR_PSH</span><span class="p">;</span>

		<span class="n">copied</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">poffset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">psize</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">size_goal</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_OOB</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">forced_push</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcp_mark_push</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">__tcp_push_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">TCP_NAGLE_PUSH</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">tcp_push_one</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>
		<span class="k">continue</span><span class="p">;</span>

<span class="nl">wait_for_sndbuf:</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="nl">wait_for_memory:</span>
		<span class="n">tcp_push</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSG_MORE</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">TCP_NAGLE_PUSH</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">sk_stream_wait_memory</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeo</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">do_error</span><span class="p">;</span>

		<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tcp_send_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size_goal</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_SENDPAGE_NOTLAST</span><span class="p">))</span>
		<span class="n">tcp_push</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>

<span class="nl">do_error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="k">return</span> <span class="n">sk_stream_error</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tcp_sendpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">&amp;</span> <span class="n">NETIF_F_SG</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">&amp;</span> <span class="n">NETIF_F_ALL_CSUM</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sock_no_sendpage</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					<span class="n">flags</span><span class="p">);</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">do_tcp_sendpages</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_sendpage</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">select_size</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk_can_gso</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Small frames wont use a full page:</span>
<span class="cm">			 * Payload will immediately follow tcp header.</span>
<span class="cm">			 */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">SKB_WITH_OVERHEAD</span><span class="p">(</span><span class="mi">2048</span> <span class="o">-</span> <span class="n">MAX_TCP_HEADER</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">pgbreak</span> <span class="o">=</span> <span class="n">SKB_MAX_HEAD</span><span class="p">(</span><span class="n">MAX_TCP_HEADER</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;=</span> <span class="n">pgbreak</span> <span class="o">&amp;&amp;</span>
			    <span class="n">tmp</span> <span class="o">&lt;=</span> <span class="n">pgbreak</span> <span class="o">+</span> <span class="p">(</span><span class="n">MAX_SKB_FRAGS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="n">pgbreak</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tcp_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iovlen</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">copied</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mss_now</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size_goal</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">sg</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="p">;</span>
	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>

	<span class="cm">/* Wait for a connection to finish. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">TCPF_ESTABLISHED</span> <span class="o">|</span> <span class="n">TCPF_CLOSE_WAIT</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">sk_stream_wait_connect</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeo</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair_queue</span> <span class="o">==</span> <span class="n">TCP_RECV_QUEUE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="n">tcp_send_rcvq</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair_queue</span> <span class="o">==</span> <span class="n">TCP_NO_QUEUE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

		<span class="cm">/* &#39;common&#39; sending to sendq */</span>
	<span class="p">}</span>

	<span class="cm">/* This should be in poll */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tcp_send_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size_goal</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Ok commence sending. */</span>
	<span class="n">iovlen</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span><span class="p">;</span>
	<span class="n">iov</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">;</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">||</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">sg</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">&amp;</span> <span class="n">NETIF_F_SG</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">iovlen</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">seglen</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>

		<span class="n">iov</span><span class="o">++</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">seglen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">copy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">size_goal</span><span class="p">;</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_NONE</span><span class="p">)</span>
					<span class="n">max</span> <span class="o">=</span> <span class="n">mss_now</span><span class="p">;</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">max</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">new_segment:</span>
				<span class="cm">/* Allocate new segment. If the interface is SG,</span>
<span class="cm">				 * allocate skb fitting to single page.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_stream_memory_free</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">wait_for_sndbuf</span><span class="p">;</span>

				<span class="n">skb</span> <span class="o">=</span> <span class="n">sk_stream_alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
							  <span class="n">select_size</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sg</span><span class="p">),</span>
							  <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">wait_for_memory</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 * Check whether we can use HW checksum.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">&amp;</span> <span class="n">NETIF_F_ALL_CSUM</span><span class="p">)</span>
					<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>

				<span class="n">skb_entail</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">size_goal</span><span class="p">;</span>
				<span class="n">max</span> <span class="o">=</span> <span class="n">size_goal</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Try to append data to the end of skb. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">seglen</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">seglen</span><span class="p">;</span>

			<span class="cm">/* Where to copy to? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_availroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* We have some space in skb head. Superb! */</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">skb_availroom</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">skb_add_data_nocache</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">do_fault</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">bool</span> <span class="n">merge</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_page</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">off</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="n">off</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_off</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">skb_can_coalesce</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">off</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="n">off</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* We can extend the last page</span>
<span class="cm">					 * fragment. */</span>
					<span class="n">merge</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MAX_SKB_FRAGS</span> <span class="o">||</span> <span class="o">!</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Need to add new fragment and cannot</span>
<span class="cm">					 * do this because interface is non-SG,</span>
<span class="cm">					 * or because all the page slots are</span>
<span class="cm">					 * busy. */</span>
					<span class="n">tcp_mark_push</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">new_segment</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">==</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
						<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_page</span> <span class="o">=</span> <span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
						<span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">off</span><span class="p">)</span>
					<span class="n">copy</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_wmem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">copy</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">wait_for_memory</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Allocate new cache page. */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">page</span> <span class="o">=</span> <span class="n">sk_stream_alloc_page</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
						<span class="k">goto</span> <span class="n">wait_for_memory</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Time to copy data. We are close to</span>
<span class="cm">				 * the end! */</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">skb_copy_to_page_nocache</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
							       <span class="n">page</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* If this page was new, give it to the</span>
<span class="cm">					 * socket so it does not get leaked.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_page</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
						<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">goto</span> <span class="n">do_error</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Update the skb. */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">merge</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">skb_frag_size_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">copy</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_page</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">+</span> <span class="n">copy</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
						<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_off</span> <span class="o">=</span> <span class="n">off</span> <span class="o">+</span> <span class="n">copy</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copied</span><span class="p">)</span>
				<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPHDR_PSH</span><span class="p">;</span>

			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">from</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">copied</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">seglen</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iovlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">max</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_OOB</span><span class="p">)</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">forced_push</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">tcp_mark_push</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
				<span class="n">__tcp_push_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">TCP_NAGLE_PUSH</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
				<span class="n">tcp_push_one</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>

<span class="nl">wait_for_sndbuf:</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="nl">wait_for_memory:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">))</span>
				<span class="n">tcp_push</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSG_MORE</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">TCP_NAGLE_PUSH</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">sk_stream_wait_memory</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeo</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">do_error</span><span class="p">;</span>

			<span class="n">mss_now</span> <span class="o">=</span> <span class="n">tcp_send_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size_goal</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">))</span>
		<span class="n">tcp_push</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span><span class="p">);</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>

<span class="nl">do_fault:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_unlink_write_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
		<span class="cm">/* It is the one place in all of TCP, except connection</span>
<span class="cm">		 * reset, where we can be unlinking the send_head.</span>
<span class="cm">		 */</span>
		<span class="n">tcp_check_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">sk_wmem_free_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">do_error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sk_stream_error</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_sendmsg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Handle reading urgent data. BSD has very simple semantics for</span>
<span class="cm"> *	this, no blocking and very strange errors 8)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_recv_urg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* No URG data to read. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_URGINLINE</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">||</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">==</span> <span class="n">TCP_URG_READ</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>	<span class="cm">/* Yes this is right ! */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DONE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">&amp;</span> <span class="n">TCP_URG_VALID</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">=</span> <span class="n">TCP_URG_READ</span><span class="p">;</span>

		<span class="cm">/* Read urgent data. */</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_OOB</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_TRUNC</span><span class="p">))</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_toiovec</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_TRUNC</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span> <span class="o">||</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Fixed the recv(..., MSG_OOB) behaviour.  BSD docs and</span>
<span class="cm">	 * the available implementations agree in this case:</span>
<span class="cm">	 * this call should never block, independent of the</span>
<span class="cm">	 * blocking state of the socket.</span>
<span class="cm">	 * Mike &lt;pall@rz.uni-karlsruhe.de&gt;</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_peek_sndq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* XXX -- need to support SO_PEEK_OFF */</span>

	<span class="n">skb_queue_walk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">copied</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">?:</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Clean up the receive buffer for full frames taken by the user,</span>
<span class="cm"> * then send an ACK if necessary.  COPIED is the number of bytes</span>
<span class="cm"> * tcp_recvmsg has given to the user so far, it speeds up the</span>
<span class="cm"> * calculation of whether or not we must ACK for the sake of</span>
<span class="cm"> * a window update.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_cleanup_rbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">copied</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">time_to_ack</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>

	<span class="n">WARN</span><span class="p">(</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">),</span>
	     <span class="s">&quot;cleanup rbuf bug: copied %X seq %X rcvnxt %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk_ack_scheduled</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		   <span class="cm">/* Delayed ACKs frequently hit locked sockets during bulk</span>
<span class="cm">		    * receive. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">blocked</span> <span class="o">||</span>
		    <span class="cm">/* Once-per-two-segments ACK was not sent by tcp_input.c */</span>
		    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span> <span class="o">&gt;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">rcv_mss</span> <span class="o">||</span>
		    <span class="cm">/*</span>
<span class="cm">		     * If this read emptied read buffer, we send ACK, if</span>
<span class="cm">		     * connection is not bidirectional, user drained</span>
<span class="cm">		     * receive buffer and there was a small segment</span>
<span class="cm">		     * in queue.</span>
<span class="cm">		     */</span>
		    <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		     <span class="p">((</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="n">ICSK_ACK_PUSHED2</span><span class="p">)</span> <span class="o">||</span>
		      <span class="p">((</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="n">ICSK_ACK_PUSHED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		      <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)))</span>
			<span class="n">time_to_ack</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We send an ACK if we can now advertise a non-zero window</span>
<span class="cm">	 * which has been raised &quot;significantly&quot;.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Even if window raised up to infinity, do not send window open ACK</span>
<span class="cm">	 * in states, where we will not receive more. It is useless.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">time_to_ack</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__u32</span> <span class="n">rcv_window_now</span> <span class="o">=</span> <span class="n">tcp_receive_window</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

		<span class="cm">/* Optimize, __tcp_select_window() is not cheap. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rcv_window_now</span> <span class="o">&lt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__u32</span> <span class="n">new_window</span> <span class="o">=</span> <span class="n">__tcp_select_window</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

			<span class="cm">/* Send ACK now, if this read freed lots of space</span>
<span class="cm">			 * in our buffer. Certainly, new_window is new window.</span>
<span class="cm">			 * We can advertise it now, if it is not less than current one.</span>
<span class="cm">			 * &quot;Lots&quot; means &quot;at least twice&quot; here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_window</span> <span class="o">&amp;&amp;</span> <span class="n">new_window</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rcv_window_now</span><span class="p">)</span>
				<span class="n">time_to_ack</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_to_ack</span><span class="p">)</span>
		<span class="n">tcp_send_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_prequeue_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">NET_INC_STATS_USER</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPPREQUEUED</span><span class="p">);</span>

	<span class="cm">/* RX process wants to run with disabled BHs, though it is not</span>
<span class="cm">	 * necessary */</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">prequeue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">sk_backlog_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>

	<span class="cm">/* Clear memory counter. */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_DMA</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_service_net_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">bool</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_cookie_t</span> <span class="n">done</span><span class="p">,</span> <span class="n">used</span><span class="p">;</span>
	<span class="n">dma_cookie_t</span> <span class="n">last_issued</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">last_issued</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_cookie</span><span class="p">;</span>
	<span class="n">dma_async_memcpy_issue_pending</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dma_async_memcpy_complete</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span><span class="p">,</span>
					      <span class="n">last_issued</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">used</span><span class="p">)</span> <span class="o">==</span> <span class="n">DMA_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Safe to free early-copied skbs now */</span>
			<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_async_wait_queue</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_async_wait_queue</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			       <span class="p">(</span><span class="n">dma_async_is_complete</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dma_cookie</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span>
						      <span class="n">used</span><span class="p">)</span> <span class="o">==</span> <span class="n">DMA_SUCCESS</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_async_wait_queue</span><span class="p">);</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_recv_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">skb_queue_walk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">seq</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">syn</span><span class="p">)</span>
			<span class="n">offset</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">||</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">off</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine provides an alternative to tcp_recvmsg() for routines</span>
<span class="cm"> * that would like to handle copying from skbuffs directly in &#39;sendfile&#39;</span>
<span class="cm"> * fashion.</span>
<span class="cm"> * Note:</span>
<span class="cm"> *	- It is assumed that the socket was locked by the caller.</span>
<span class="cm"> *	- The routine does not block.</span>
<span class="cm"> *	- At present, there is no support for reading OOB data</span>
<span class="cm"> *	  or for &#39;peeking&#39; the socket using this routine</span>
<span class="cm"> *	  (although both would be easy to implement).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tcp_read_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">read_descriptor_t</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
		  <span class="n">sk_read_actor_t</span> <span class="n">recv_actor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_recv_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">used</span><span class="p">;</span>
			<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
			<span class="cm">/* Stop reading if we hit a patch of urgent data */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">urg_offset</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span> <span class="o">-</span> <span class="n">seq</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">urg_offset</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
					<span class="n">len</span> <span class="o">=</span> <span class="n">urg_offset</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">used</span> <span class="o">=</span> <span class="n">recv_actor</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copied</span><span class="p">)</span>
					<span class="n">copied</span> <span class="o">=</span> <span class="n">used</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">seq</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>
				<span class="n">copied</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>
				<span class="n">offset</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * If recv_actor drops the lock (e.g. TCP splice</span>
<span class="cm">			 * receive) the skb pointer might be invalid when</span>
<span class="cm">			 * getting here: tcp_collapse might have deleted it</span>
<span class="cm">			 * while aggregating skbs from the socket queue.</span>
<span class="cm">			 */</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_recv_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seq</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span> <span class="o">||</span> <span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span> <span class="o">!=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sk_eat_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="o">++</span><span class="n">seq</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sk_eat_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>

	<span class="n">tcp_rcv_space_adjust</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Clean up data we have read: This will do ACK frames. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tcp_cleanup_rbuf</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_read_sock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	This routine copies from a sock struct into the user buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *	Technical note: in 2.3 we work on _locked_ socket, so that</span>
<span class="cm"> *	tricks with *seq access order and skb-&gt;users are not required.</span>
<span class="cm"> *	Probably, code can be easily improved even more.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tcp_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">peek_seq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">target</span><span class="p">;</span>		<span class="cm">/* Read at least this many bytes */</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">user_recv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">copied_early</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">urg_hole</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_rcvtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nonblock</span><span class="p">);</span>

	<span class="cm">/* Urgent data needs to be handled specially. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_OOB</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">recv_urg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair_queue</span> <span class="o">==</span> <span class="n">TCP_SEND_QUEUE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">recv_sndq</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair_queue</span> <span class="o">==</span> <span class="n">TCP_NO_QUEUE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* &#39;common&#39; recv queue MSG_PEEK-ing */</span>
	<span class="p">}</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">peek_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">;</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">peek_seq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">target</span> <span class="o">=</span> <span class="n">sock_rcvlowat</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_WAITALL</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_DMA</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">available</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">available</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="o">*</span><span class="n">seq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">available</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">sysctl_tcp_dma_copybreak</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">sysctl_tcp_low_latency</span> <span class="o">&amp;&amp;</span>
		    <span class="n">net_dma_find_channel</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">pinned_list</span> <span class="o">=</span>
					<span class="n">dma_pin_iovec_pages</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">preempt_enable_no_resched</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">offset</span><span class="p">;</span>

		<span class="cm">/* Are we at urgent data? Stop if we have read anything or have SIGURG pending. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span> <span class="o">==</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copied</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">copied</span> <span class="o">=</span> <span class="n">timeo</span> <span class="o">?</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">timeo</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Next get a buffer. */</span>

		<span class="n">skb_queue_walk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Now that we have two receive queues this</span>
<span class="cm">			 * shouldn&#39;t happen.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">),</span>
				 <span class="s">&quot;recvmsg bug: copied %X seq %X rcvnxt %X fl %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">,</span>
				 <span class="n">flags</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">seq</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">syn</span><span class="p">)</span>
				<span class="n">offset</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">found_ok_skb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">found_fin_ok</span><span class="p">;</span>
			<span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">),</span>
			     <span class="s">&quot;recvmsg bug 2: copied %X seq %X rcvnxt %X fl %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Well, if we have backlog, try to process it now yet. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">tail</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copied</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">||</span>
			    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">timeo</span> <span class="o">||</span>
			    <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DONE</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">copied</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DONE</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* This occurs when user tries to read</span>
<span class="cm">					 * from never connected socket.</span>
<span class="cm">					 */</span>
					<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">copied</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">tcp_cleanup_rbuf</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysctl_tcp_low_latency</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">task</span> <span class="o">==</span> <span class="n">user_recv</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Install new reader */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">user_recv</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MSG_TRUNC</span> <span class="o">|</span> <span class="n">MSG_PEEK</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">user_recv</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">user_recv</span><span class="p">;</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">iov</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MSG_PEEK</span> <span class="o">|</span> <span class="n">MSG_TRUNC</span><span class="p">)));</span>

			<span class="cm">/* Ugly... If prequeue is not empty, we have to</span>
<span class="cm">			 * process it before releasing socket, otherwise</span>
<span class="cm">			 * order will be broken at second iteration.</span>
<span class="cm">			 * More elegant solution is required!!!</span>
<span class="cm">			 *</span>
<span class="cm">			 * Look: we have the following (pseudo)queues:</span>
<span class="cm">			 *</span>
<span class="cm">			 * 1. packets in flight</span>
<span class="cm">			 * 2. backlog</span>
<span class="cm">			 * 3. prequeue</span>
<span class="cm">			 * 4. receive_queue</span>
<span class="cm">			 *</span>
<span class="cm">			 * Each queue can be processed only if the next ones</span>
<span class="cm">			 * are empty. At this point we have empty receive_queue.</span>
<span class="cm">			 * But prequeue _can_ be not empty after 2nd iteration,</span>
<span class="cm">			 * when we jumped to start of loop because backlog</span>
<span class="cm">			 * processing added something to receive_queue.</span>
<span class="cm">			 * We cannot release_sock(), because backlog contains</span>
<span class="cm">			 * packets arrived _after_ prequeued ones.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Shortly, algorithm is clear --- to process all</span>
<span class="cm">			 * the queues in order. We could make it more directly,</span>
<span class="cm">			 * requeueing packets from backlog to prequeue, if</span>
<span class="cm">			 * is not empty. It is more elegant, but eats cycles,</span>
<span class="cm">			 * unfortunately.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">prequeue</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">do_prequeue</span><span class="p">;</span>

			<span class="cm">/* __ Set realtime policy in scheduler __ */</span>
		<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_DMA</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span><span class="p">)</span>
			<span class="n">dma_async_memcpy_issue_pending</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Do not sleep, just process backlog. */</span>
			<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sk_wait_data</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeo</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_DMA</span>
		<span class="n">tcp_service_net_dma</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>  <span class="cm">/* Don&#39;t block */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">wakeup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">user_recv</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">chunk</span><span class="p">;</span>

			<span class="cm">/* __ Restore normal policy in scheduler __ */</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">NET_ADD_STATS_USER</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPDIRECTCOPYFROMBACKLOG</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
				<span class="n">len</span> <span class="o">-=</span> <span class="n">chunk</span><span class="p">;</span>
				<span class="n">copied</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">prequeue</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">do_prequeue:</span>
				<span class="n">tcp_prequeue_process</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">NET_ADD_STATS_USER</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
					<span class="n">len</span> <span class="o">-=</span> <span class="n">chunk</span><span class="p">;</span>
					<span class="n">copied</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">peek_seq</span> <span class="o">-</span> <span class="n">copied</span> <span class="o">-</span> <span class="n">urg_hole</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">net_dbg_ratelimited</span><span class="p">(</span><span class="s">&quot;TCP(%s:%d): Application bug, race in MSG_PEEK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					    <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
					    <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
			<span class="n">peek_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">continue</span><span class="p">;</span>

	<span class="nl">found_ok_skb:</span>
		<span class="cm">/* Ok so how much can we use? */</span>
		<span class="n">used</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">used</span><span class="p">)</span>
			<span class="n">used</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* Do we have urgent data here? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">urg_offset</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span> <span class="o">-</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">urg_offset</span> <span class="o">&lt;</span> <span class="n">used</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urg_offset</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_URGINLINE</span><span class="p">))</span> <span class="p">{</span>
						<span class="o">++*</span><span class="n">seq</span><span class="p">;</span>
						<span class="n">urg_hole</span><span class="o">++</span><span class="p">;</span>
						<span class="n">offset</span><span class="o">++</span><span class="p">;</span>
						<span class="n">used</span><span class="o">--</span><span class="p">;</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">)</span>
							<span class="k">goto</span> <span class="n">skip_copy</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">used</span> <span class="o">=</span> <span class="n">urg_offset</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_TRUNC</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_DMA</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">pinned_list</span><span class="p">)</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span> <span class="o">=</span> <span class="n">net_dma_find_channel</span><span class="p">();</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_cookie</span> <span class="o">=</span> <span class="n">dma_skb_copy_datagram_iovec</span><span class="p">(</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">pinned_list</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_cookie</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

					<span class="n">pr_alert</span><span class="p">(</span><span class="s">&quot;%s: dma_cookie &lt; 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						 <span class="n">__func__</span><span class="p">);</span>

					<span class="cm">/* Exception. Bailout! */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copied</span><span class="p">)</span>
						<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">dma_async_memcpy_issue_pending</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">used</span><span class="p">)</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
					<span class="n">copied_early</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

			<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
			<span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
						<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">used</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Exception. Bailout! */</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copied</span><span class="p">)</span>
						<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">seq</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>
		<span class="n">copied</span> <span class="o">+=</span> <span class="n">used</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">used</span><span class="p">;</span>

		<span class="n">tcp_rcv_space_adjust</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

<span class="nl">skip_copy:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">&amp;&amp;</span> <span class="n">after</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tcp_fast_path_check</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found_fin_ok</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sk_eat_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">copied_early</span><span class="p">);</span>
			<span class="n">copied_early</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">continue</span><span class="p">;</span>

	<span class="nl">found_fin_ok:</span>
		<span class="cm">/* Process the FIN. */</span>
		<span class="o">++*</span><span class="n">seq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sk_eat_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">copied_early</span><span class="p">);</span>
			<span class="n">copied_early</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">user_recv</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">prequeue</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">chunk</span><span class="p">;</span>

			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">copied</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">len</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">tcp_prequeue_process</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">NET_ADD_STATS_USER</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPDIRECTCOPYFROMPREQUEUE</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
				<span class="n">len</span> <span class="o">-=</span> <span class="n">chunk</span><span class="p">;</span>
				<span class="n">copied</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_DMA</span>
	<span class="n">tcp_service_net_dma</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>  <span class="cm">/* Wait for queue to drain */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">pinned_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_unpin_iovec_pages</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">pinned_list</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">pinned_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* According to UNIX98, msg_name/msg_namelen are ignored</span>
<span class="cm">	 * on connected socket. I was just happy when found this 8) --ANK</span>
<span class="cm">	 */</span>

	<span class="cm">/* Clean up data we have read: This will do ACK frames. */</span>
	<span class="n">tcp_cleanup_rbuf</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">recv_urg:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">tcp_recv_urg</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">recv_sndq:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">tcp_peek_sndq</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_recvmsg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">tcp_set_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">oldstate</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCP_ESTABLISHED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">oldstate</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
			<span class="n">TCP_INC_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_CURRESTAB</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_CLOSE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">oldstate</span> <span class="o">==</span> <span class="n">TCP_CLOSE_WAIT</span> <span class="o">||</span> <span class="n">oldstate</span> <span class="o">==</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
			<span class="n">TCP_INC_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_ESTABRESETS</span><span class="p">);</span>

		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">unhash</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_bind_hash</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_BINDPORT_LOCK</span><span class="p">))</span>
			<span class="n">inet_put_port</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldstate</span> <span class="o">==</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
			<span class="n">TCP_DEC_STATS</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_CURRESTAB</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Change state AFTER socket is unhashed to avoid closed</span>
<span class="cm">	 * socket sitting in hash tables.</span>
<span class="cm">	 */</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

<span class="cp">#ifdef STATE_TRACE</span>
	<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;TCP sk=%p, State %s -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">statename</span><span class="p">[</span><span class="n">oldstate</span><span class="p">],</span> <span class="n">statename</span><span class="p">[</span><span class="n">state</span><span class="p">]);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tcp_set_state</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	State processing on a close. This implements the state shift for</span>
<span class="cm"> *	sending our FIN frame. Note that we only send a FIN for some</span>
<span class="cm"> *	states. A shutdown() may have already sent the FIN, or we may be</span>
<span class="cm"> *	closed.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">new_state</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="cm">/* current state:        new state:      action:	*/</span>
  <span class="cm">/* (Invalid)		*/</span> <span class="n">TCP_CLOSE</span><span class="p">,</span>
  <span class="cm">/* TCP_ESTABLISHED	*/</span> <span class="n">TCP_FIN_WAIT1</span> <span class="o">|</span> <span class="n">TCP_ACTION_FIN</span><span class="p">,</span>
  <span class="cm">/* TCP_SYN_SENT	*/</span> <span class="n">TCP_CLOSE</span><span class="p">,</span>
  <span class="cm">/* TCP_SYN_RECV	*/</span> <span class="n">TCP_FIN_WAIT1</span> <span class="o">|</span> <span class="n">TCP_ACTION_FIN</span><span class="p">,</span>
  <span class="cm">/* TCP_FIN_WAIT1	*/</span> <span class="n">TCP_FIN_WAIT1</span><span class="p">,</span>
  <span class="cm">/* TCP_FIN_WAIT2	*/</span> <span class="n">TCP_FIN_WAIT2</span><span class="p">,</span>
  <span class="cm">/* TCP_TIME_WAIT	*/</span> <span class="n">TCP_CLOSE</span><span class="p">,</span>
  <span class="cm">/* TCP_CLOSE		*/</span> <span class="n">TCP_CLOSE</span><span class="p">,</span>
  <span class="cm">/* TCP_CLOSE_WAIT	*/</span> <span class="n">TCP_LAST_ACK</span>  <span class="o">|</span> <span class="n">TCP_ACTION_FIN</span><span class="p">,</span>
  <span class="cm">/* TCP_LAST_ACK	*/</span> <span class="n">TCP_LAST_ACK</span><span class="p">,</span>
  <span class="cm">/* TCP_LISTEN		*/</span> <span class="n">TCP_CLOSE</span><span class="p">,</span>
  <span class="cm">/* TCP_CLOSING	*/</span> <span class="n">TCP_CLOSING</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_close_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">new_state</span><span class="p">[</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">next</span> <span class="o">&amp;</span> <span class="n">TCP_STATE_MASK</span><span class="p">;</span>

	<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ns</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">next</span> <span class="o">&amp;</span> <span class="n">TCP_ACTION_FIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Shutdown the sending side of a connection. Much like close except</span>
<span class="cm"> *	that we don&#39;t receive shut down or sock_set_flag(sk, SOCK_DEAD).</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">tcp_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*	We need to grab some memory, and put together a FIN,</span>
<span class="cm">	 *	and then put it into the queue to be sent.</span>
<span class="cm">	 *		Tim MacKenzie(tym@dibbler.cs.monash.edu.au) 4 Dec &#39;92.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">how</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* If we&#39;ve already sent a FIN, or it&#39;s a closed state, skip this. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="o">&amp;</span>
	    <span class="p">(</span><span class="n">TCPF_ESTABLISHED</span> <span class="o">|</span> <span class="n">TCPF_SYN_SENT</span> <span class="o">|</span>
	     <span class="n">TCPF_SYN_RECV</span> <span class="o">|</span> <span class="n">TCPF_CLOSE_WAIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Clear out any half completed packets.  FIN if needed. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_close_state</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">tcp_send_fin</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_shutdown</span><span class="p">);</span>

<span class="n">bool</span> <span class="nf">tcp_check_oom</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">too_many_orphans</span><span class="p">,</span> <span class="n">out_of_socket_memory</span><span class="p">;</span>

	<span class="n">too_many_orphans</span> <span class="o">=</span> <span class="n">tcp_too_many_orphans</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
	<span class="n">out_of_socket_memory</span> <span class="o">=</span> <span class="n">tcp_out_of_memory</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">too_many_orphans</span><span class="p">)</span>
		<span class="n">net_info_ratelimited</span><span class="p">(</span><span class="s">&quot;too many orphaned sockets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out_of_socket_memory</span><span class="p">)</span>
		<span class="n">net_info_ratelimited</span><span class="p">(</span><span class="s">&quot;out of memory -- consider tuning tcp_mem</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">too_many_orphans</span> <span class="o">||</span> <span class="n">out_of_socket_memory</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tcp_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data_was_unread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">=</span> <span class="n">SHUTDOWN_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CLOSE</span><span class="p">);</span>

		<span class="cm">/* Special case. */</span>
		<span class="n">inet_csk_listen_stop</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">adjudge_to_death</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*  We need to flush the recv. buffs.  We do this only on the</span>
<span class="cm">	 *  descriptor close, not protocol-sourced closes, because the</span>
<span class="cm">	 *  reader process may not have drained the data yet!</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">len</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">-</span>
			  <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">;</span>
		<span class="n">data_was_unread</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sk_mem_reclaim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* If socket has been already reset (e.g. in tcp_reset()) - kill it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">adjudge_to_death</span><span class="p">;</span>

	<span class="cm">/* As outlined in RFC 2525, section 2.17, we send a RST here because</span>
<span class="cm">	 * data was lost. To witness the awful effects of the old behavior of</span>
<span class="cm">	 * always doing a FIN, run an older 2.1.x kernel or 2.0.x, start a bulk</span>
<span class="cm">	 * GET in an FTP client, suspend the process, wait for the client to</span>
<span class="cm">	 * advertise a zero window, then kill -9 the FTP client, wheee...</span>
<span class="cm">	 * Note: timeout is always zero in such a case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">data_was_unread</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Unread data was tossed, zap the connection. */</span>
		<span class="n">NET_INC_STATS_USER</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPABORTONCLOSE</span><span class="p">);</span>
		<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CLOSE</span><span class="p">);</span>
		<span class="n">tcp_send_active_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_LINGER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lingertime</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check zero linger _after_ checking for unread data. */</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">NET_INC_STATS_USER</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPABORTONDATA</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcp_close_state</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We FIN if the application ate all the data before</span>
<span class="cm">		 * zapping the connection.</span>
<span class="cm">		 */</span>

		<span class="cm">/* RED-PEN. Formally speaking, we have broken TCP state</span>
<span class="cm">		 * machine. State transitions:</span>
<span class="cm">		 *</span>
<span class="cm">		 * TCP_ESTABLISHED -&gt; TCP_FIN_WAIT1</span>
<span class="cm">		 * TCP_SYN_RECV	-&gt; TCP_FIN_WAIT1 (forget it, it&#39;s impossible)</span>
<span class="cm">		 * TCP_CLOSE_WAIT -&gt; TCP_LAST_ACK</span>
<span class="cm">		 *</span>
<span class="cm">		 * are legal only when FIN has been sent (i.e. in window),</span>
<span class="cm">		 * rather than queued out of window. Purists blame.</span>
<span class="cm">		 *</span>
<span class="cm">		 * F.e. &quot;RFC state&quot; is ESTABLISHED,</span>
<span class="cm">		 * if Linux state is FIN-WAIT-1, but FIN is still not sent.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The visible declinations are that sometimes</span>
<span class="cm">		 * we enter time-wait state, when it is not required really</span>
<span class="cm">		 * (harmless), do not send active resets, when they are</span>
<span class="cm">		 * required by specs (TCP_ESTABLISHED, TCP_CLOSE_WAIT, when</span>
<span class="cm">		 * they look as CLOSING or LAST_ACK for Linux)</span>
<span class="cm">		 * Probably, I missed some more holelets.</span>
<span class="cm">		 * 						--ANK</span>
<span class="cm">		 */</span>
		<span class="n">tcp_send_fin</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sk_stream_wait_close</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>

<span class="nl">adjudge_to_death:</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">;</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sock_orphan</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* It is the last release_sock in its life. It will remove backlog. */</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>


	<span class="cm">/* Now socket is owned by kernel and we acquire BH lock</span>
<span class="cm">	   to finish close. No need to check for user refs.</span>
<span class="cm">	 */</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>

	<span class="n">percpu_counter_inc</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">orphan_count</span><span class="p">);</span>

	<span class="cm">/* Have we already been destroyed by a softirq or backlog? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">TCP_CLOSE</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*	This is a (useful) BSD violating of the RFC. There is a</span>
<span class="cm">	 *	problem with TCP as specified in that the other end could</span>
<span class="cm">	 *	keep a socket open forever with no application left this end.</span>
<span class="cm">	 *	We use a 3 minute timeout (about the same as BSD) then kill</span>
<span class="cm">	 *	our end. If they send after that then tough - BUT: long enough</span>
<span class="cm">	 *	that we won&#39;t make the old 4*rto = almost no time - whoops</span>
<span class="cm">	 *	reset mistake.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	Nope, it was not mistake. It is really desired behaviour</span>
<span class="cm">	 *	f.e. on http servers, when such sockets are useless, but</span>
<span class="cm">	 *	consume significant resources. Let&#39;s do it with special</span>
<span class="cm">	 *	linger2	option.					--ANK</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_FIN_WAIT2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">linger2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CLOSE</span><span class="p">);</span>
			<span class="n">tcp_send_active_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
					<span class="n">LINUX_MIB_TCPABORTONLINGER</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">const</span> <span class="kt">int</span> <span class="n">tmo</span> <span class="o">=</span> <span class="n">tcp_fin_time</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tmo</span> <span class="o">&gt;</span> <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">inet_csk_reset_keepalive_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
						<span class="n">tmo</span> <span class="o">-</span> <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">tcp_time_wait</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_FIN_WAIT2</span><span class="p">,</span> <span class="n">tmo</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_CLOSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk_mem_reclaim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_check_oom</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CLOSE</span><span class="p">);</span>
			<span class="n">tcp_send_active_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
					<span class="n">LINUX_MIB_TCPABORTONMEMORY</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span>
		<span class="n">inet_csk_destroy_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* Otherwise, socket is reprieved until protocol close. */</span>

<span class="nl">out:</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_close</span><span class="p">);</span>

<span class="cm">/* These states need RST on ABORT according to RFC793 */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_need_reset</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">state</span><span class="p">)</span> <span class="o">&amp;</span>
	       <span class="p">(</span><span class="n">TCPF_ESTABLISHED</span> <span class="o">|</span> <span class="n">TCPF_CLOSE_WAIT</span> <span class="o">|</span> <span class="n">TCPF_FIN_WAIT1</span> <span class="o">|</span>
		<span class="n">TCPF_FIN_WAIT2</span> <span class="o">|</span> <span class="n">TCPF_SYN_RECV</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tcp_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_state</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_state</span> <span class="o">!=</span> <span class="n">TCP_CLOSE</span><span class="p">)</span>
		<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CLOSE</span><span class="p">);</span>

	<span class="cm">/* ABORT function of RFC793 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inet_csk_listen_stop</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">ECONNABORTED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcp_need_reset</span><span class="p">(</span><span class="n">old_state</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">old_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPF_CLOSING</span> <span class="o">|</span> <span class="n">TCPF_LAST_ACK</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* The last check adjusts for discrepancy of Linux wrt. RFC</span>
<span class="cm">		 * states</span>
<span class="cm">		 */</span>
		<span class="n">tcp_send_active_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">gfp_any</span><span class="p">());</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">ECONNRESET</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_state</span> <span class="o">==</span> <span class="n">TCP_SYN_SENT</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">ECONNRESET</span><span class="p">;</span>

	<span class="n">tcp_clear_xmit_timers</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="n">tcp_write_queue_purge</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NET_DMA</span>
	<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_async_wait_queue</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_dport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_BINDADDR_LOCK</span><span class="p">))</span>
		<span class="n">inet_reset_saddr</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DONE</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span> <span class="o">+=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_window</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_backoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_probes_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">TCP_INFINITE_SSTHRESH</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CA_Open</span><span class="p">);</span>
	<span class="n">tcp_clear_retrans</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">inet_csk_delack_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tcp_init_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">));</span>
	<span class="n">__sk_dst_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_num</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_bind_hash</span><span class="p">);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_report</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_disconnect</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_can_repair_sock</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPF_CLOSE</span> <span class="o">|</span> <span class="n">TCPF_ESTABLISHED</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_repair_options_est</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">tcp_repair_opt</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optbuf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_repair_opt</span> <span class="n">opt</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span> <span class="n">optbuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">optbuf</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">opt_code</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TCPOPT_MSS</span>:
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span> <span class="o">=</span> <span class="n">opt</span><span class="p">.</span><span class="n">opt_val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TCPOPT_WINDOW</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">opt_val</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>

			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">snd_wscale</span> <span class="o">=</span> <span class="n">opt</span><span class="p">.</span><span class="n">opt_val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TCPOPT_SACK_PERM</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">opt_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">sack_ok</span> <span class="o">|=</span> <span class="n">TCP_SACK_SEEN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_fack</span><span class="p">)</span>
				<span class="n">tcp_enable_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TCPOPT_TIMESTAMP</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">opt_val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">tstamp_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Socket option code for TCP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_tcp_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* These are data/string values, all the others are ints */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">optname</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCP_CONGESTION</span>: <span class="p">{</span>
		<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">TCP_CA_NAME_MAX</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">val</span> <span class="o">=</span> <span class="n">strncpy_from_user</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
					<span class="n">min_t</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="n">TCP_CA_NAME_MAX</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">optlen</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">name</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tcp_set_congestion_control</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">TCP_COOKIE_TRANSACTIONS</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcp_cookie_transactions</span> <span class="n">ctd</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">tcp_cookie_values</span> <span class="o">*</span><span class="n">cvp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ctd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">optlen</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctd</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctd</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_used</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_value</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_s_data_desired</span> <span class="o">&gt;</span> <span class="n">TCP_MSS_DESIRED</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_cookie_desired</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* default to global value */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="mh">0x1</span> <span class="o">&amp;</span> <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_cookie_desired</span><span class="p">)</span> <span class="o">||</span>
			   <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_cookie_desired</span> <span class="o">&gt;</span> <span class="n">TCP_COOKIE_MAX</span> <span class="o">||</span>
			   <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_cookie_desired</span> <span class="o">&lt;</span> <span class="n">TCP_COOKIE_MIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">TCP_COOKIE_OUT_NEVER</span> <span class="o">&amp;</span> <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Supercedes all other values */</span>
			<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span>
					 <span class="n">tcp_cookie_values_release</span><span class="p">);</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">cookie_in_always</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* false */</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">cookie_out_never</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* true */</span>
			<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Allocate ancillary memory before locking.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_used</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">sysctl_tcp_cookie_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
		      <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_cookie_desired</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
		      <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_s_data_desired</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">cvp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cvp</span><span class="p">)</span> <span class="o">+</span> <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_used</span><span class="p">,</span>
				      <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cvp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">cookie_in_always</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">TCP_COOKIE_IN_ALWAYS</span> <span class="o">&amp;</span> <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_flags</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">cookie_out_never</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* false */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cvp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Changed values are recorded by a changed</span>
<span class="cm">				 * pointer, ensuring the cookie will differ,</span>
<span class="cm">				 * without separately hashing each value later.</span>
<span class="cm">				 */</span>
				<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span>
					 <span class="n">tcp_cookie_values_release</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">cvp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cvp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_desired</span> <span class="o">=</span> <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_cookie_desired</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_payload</span><span class="p">,</span> <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_value</span><span class="p">,</span>
				       <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_used</span><span class="p">);</span>
				<span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_desired</span> <span class="o">=</span> <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_used</span><span class="p">;</span>
				<span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_constant</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* true */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* No constant payload data. */</span>
				<span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_desired</span> <span class="o">=</span> <span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_s_data_desired</span><span class="p">;</span>
				<span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_constant</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* false */</span>
			<span class="p">}</span>

			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span> <span class="o">=</span> <span class="n">cvp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="cm">/* fallthru */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">optname</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCP_MAXSEG</span>:
		<span class="cm">/* Values greater than interface MTU won&#39;t take effect. However</span>
<span class="cm">		 * at the point when this call is done we typically don&#39;t yet</span>
<span class="cm">		 * know which interface is going to be used */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">TCP_MIN_MSS</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">MAX_TCP_WINDOW</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">user_mss</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_NODELAY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* TCP_NODELAY is weaker than TCP_CORK, so that</span>
<span class="cm">			 * this option on corked socket is remembered, but</span>
<span class="cm">			 * it is not activated until cork is cleared.</span>
<span class="cm">			 *</span>
<span class="cm">			 * However, when TCP_NODELAY is set we make</span>
<span class="cm">			 * an explicit push, which overrides even TCP_CORK</span>
<span class="cm">			 * for currently queued segments.</span>
<span class="cm">			 */</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span> <span class="o">|=</span> <span class="n">TCP_NAGLE_OFF</span><span class="o">|</span><span class="n">TCP_NAGLE_PUSH</span><span class="p">;</span>
			<span class="n">tcp_push_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_NAGLE_OFF</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_THIN_LINEAR_TIMEOUTS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">thin_lto</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_THIN_DUPACK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">thin_dupack</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">thin_dupack</span><span class="p">)</span>
				<span class="n">tcp_disable_early_retrans</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_REPAIR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_can_repair_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span> <span class="o">=</span> <span class="n">SK_FORCE_REUSE</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair_queue</span> <span class="o">=</span> <span class="n">TCP_NO_QUEUE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span> <span class="o">=</span> <span class="n">SK_NO_REUSE</span><span class="p">;</span>
			<span class="n">tcp_send_window_probe</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_REPAIR_QUEUE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">TCP_QUEUES_NR</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair_queue</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_QUEUE_SEQ</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_CLOSE</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair_queue</span> <span class="o">==</span> <span class="n">TCP_SEND_QUEUE</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair_queue</span> <span class="o">==</span> <span class="n">TCP_RECV_QUEUE</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_REPAIR_OPTIONS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">tcp_repair_options_est</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">tcp_repair_opt</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">,</span>
					<span class="n">optlen</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_CORK</span>:
		<span class="cm">/* When set indicates to always queue non-full frames.</span>
<span class="cm">		 * Later the user clears this option and we transmit</span>
<span class="cm">		 * any pending partial frames in the queue.  This is</span>
<span class="cm">		 * meant to be used alongside sendfile() to get properly</span>
<span class="cm">		 * filled frames when the user (for example) must write</span>
<span class="cm">		 * out headers with a write() call first and then use</span>
<span class="cm">		 * sendfile to send out the data parts.</span>
<span class="cm">		 *</span>
<span class="cm">		 * TCP_CORK can be set together with TCP_NODELAY and it is</span>
<span class="cm">		 * stronger than TCP_NODELAY.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span> <span class="o">|=</span> <span class="n">TCP_NAGLE_CORK</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_NAGLE_CORK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span><span class="o">&amp;</span><span class="n">TCP_NAGLE_OFF</span><span class="p">)</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span> <span class="o">|=</span> <span class="n">TCP_NAGLE_PUSH</span><span class="p">;</span>
			<span class="n">tcp_push_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_KEEPIDLE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">MAX_TCP_KEEPIDLE</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">keepalive_time</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_KEEPOPEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="o">&amp;</span>
			      <span class="p">(</span><span class="n">TCPF_CLOSE</span> <span class="o">|</span> <span class="n">TCPF_LISTEN</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">keepalive_time_elapsed</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">keepalive_time</span> <span class="o">&gt;</span> <span class="n">elapsed</span><span class="p">)</span>
					<span class="n">elapsed</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">keepalive_time</span> <span class="o">-</span> <span class="n">elapsed</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">elapsed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">inet_csk_reset_keepalive_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_KEEPINTVL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">MAX_TCP_KEEPINTVL</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">keepalive_intvl</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_KEEPCNT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">MAX_TCP_KEEPCNT</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">keepalive_probes</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_SYNCNT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">MAX_TCP_SYNCNT</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_syn_retries</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_LINGER2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">linger2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">sysctl_tcp_fin_timeout</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">linger2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">linger2</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_DEFER_ACCEPT</span>:
		<span class="cm">/* Translate value in seconds to number of retransmits */</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_accept_queue</span><span class="p">.</span><span class="n">rskq_defer_accept</span> <span class="o">=</span>
			<span class="n">secs_to_retrans</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">TCP_TIMEOUT_INIT</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">,</span>
					<span class="n">TCP_RTO_MAX</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_WINDOW_CLAMP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_CLOSE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">SOCK_MIN_RCVBUF</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">?</span>
						<span class="n">SOCK_MIN_RCVBUF</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_QUICKACK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="o">&amp;</span>
			    <span class="p">(</span><span class="n">TCPF_ESTABLISHED</span> <span class="o">|</span> <span class="n">TCPF_CLOSE_WAIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">inet_csk_ack_scheduled</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pending</span> <span class="o">|=</span> <span class="n">ICSK_ACK_PUSHED</span><span class="p">;</span>
				<span class="n">tcp_cleanup_rbuf</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
					<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
	<span class="k">case</span> <span class="n">TCP_MD5SIG</span>:
		<span class="cm">/* Read the IP-&gt;Key mappings from userspace */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">af_specific</span><span class="o">-&gt;</span><span class="n">md5_parse</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">TCP_USER_TIMEOUT</span>:
		<span class="cm">/* Cap the max timeout in ms TCP will retry/retrans</span>
<span class="cm">		 * before giving up and aborting (ETIMEDOUT) a connection.</span>
<span class="cm">		 */</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_user_timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tcp_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">SOL_TCP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span>
						     <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_tcp_setsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_setsockopt</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="kt">int</span> <span class="nf">compat_tcp_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">SOL_TCP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">inet_csk_compat_setsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span>
						  <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_tcp_setsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">compat_tcp_setsockopt</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Return information about state of tcp endpoint in API format. */</span>
<span class="kt">void</span> <span class="nf">tcp_get_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcp_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">now</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">));</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_state</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_ca_state</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_retransmits</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_probes</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_probes_out</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_backoff</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_backoff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">tstamp_ok</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_options</span> <span class="o">|=</span> <span class="n">TCPI_OPT_TIMESTAMPS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_options</span> <span class="o">|=</span> <span class="n">TCPI_OPT_SACK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">wscale_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_options</span> <span class="o">|=</span> <span class="n">TCPI_OPT_WSCALE</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_snd_wscale</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">snd_wscale</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_rcv_wscale</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_OK</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_options</span> <span class="o">|=</span> <span class="n">TCPI_OPT_ECN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_SEEN</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_options</span> <span class="o">|=</span> <span class="n">TCPI_OPT_ECN_SEEN</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_rto</span> <span class="o">=</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_ato</span> <span class="o">=</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_snd_mss</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_rcv_mss</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">rcv_mss</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_unacked</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_sacked</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_unacked</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_sacked</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_lost</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_retrans</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_fackets</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_last_data_sent</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lsndtime</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_last_data_recv</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">lrcvtime</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_last_ack_recv</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_tstamp</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_pmtu</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_pmtu_cookie</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_rcv_ssthresh</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_rtt</span> <span class="o">=</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_rttvar</span> <span class="o">=</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">2</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_snd_ssthresh</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_snd_cwnd</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_advmss</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_reordering</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_rcv_rtt</span> <span class="o">=</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_rtt_est</span><span class="p">.</span><span class="n">rtt</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_rcv_space</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcvq_space</span><span class="p">.</span><span class="n">space</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">tcpi_total_retrans</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">total_retrans</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tcp_get_info</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_tcp_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">optname</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCP_MAXSEG</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPF_CLOSE</span> <span class="o">|</span> <span class="n">TCPF_LISTEN</span><span class="p">)))</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">user_mss</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_NODELAY</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span><span class="o">&amp;</span><span class="n">TCP_NAGLE_OFF</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_CORK</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span><span class="o">&amp;</span><span class="n">TCP_NAGLE_CORK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_KEEPIDLE</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">keepalive_time_when</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_KEEPINTVL</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">keepalive_intvl_when</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_KEEPCNT</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">keepalive_probes</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_SYNCNT</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_syn_retries</span> <span class="o">?</span> <span class="o">:</span> <span class="n">sysctl_tcp_syn_retries</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_LINGER2</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">linger2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">?</span> <span class="o">:</span> <span class="n">sysctl_tcp_fin_timeout</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_DEFER_ACCEPT</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">retrans_to_secs</span><span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_accept_queue</span><span class="p">.</span><span class="n">rskq_defer_accept</span><span class="p">,</span>
				      <span class="n">TCP_TIMEOUT_INIT</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">,</span> <span class="n">TCP_RTO_MAX</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_WINDOW_CLAMP</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_INFO</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcp_info</span> <span class="n">info</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">tcp_get_info</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">TCP_QUICKACK</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="o">!</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_CONGESTION</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">TCP_CA_NAME_MAX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_COOKIE_TRANSACTIONS</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcp_cookie_transactions</span> <span class="n">ctd</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">tcp_cookie_values</span> <span class="o">*</span><span class="n">cvp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctd</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctd</span><span class="p">));</span>
		<span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">cookie_in_always</span> <span class="o">?</span>
				   <span class="n">TCP_COOKIE_IN_ALWAYS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
				<span class="o">|</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">cookie_out_never</span> <span class="o">?</span>
				   <span class="n">TCP_COOKIE_OUT_NEVER</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cvp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_in</span> <span class="o">?</span>
					    <span class="n">TCP_S_DATA_IN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
					 <span class="o">|</span> <span class="p">(</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_out</span> <span class="o">?</span>
					    <span class="n">TCP_S_DATA_OUT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_cookie_desired</span> <span class="o">=</span> <span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_desired</span><span class="p">;</span>
			<span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_s_data_desired</span> <span class="o">=</span> <span class="n">cvp</span><span class="o">-&gt;</span><span class="n">s_data_desired</span><span class="p">;</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			       <span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_pair_size</span><span class="p">);</span>
			<span class="n">ctd</span><span class="p">.</span><span class="n">tcpct_used</span> <span class="o">=</span> <span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_pair_size</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ctd</span><span class="p">),</span> <span class="n">optlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ctd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctd</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">case</span> <span class="n">TCP_THIN_LINEAR_TIMEOUTS</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">thin_lto</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_THIN_DUPACK</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">thin_dupack</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_REPAIR</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_REPAIR_QUEUE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair_queue</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_QUEUE_SEQ</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair_queue</span> <span class="o">==</span> <span class="n">TCP_SEND_QUEUE</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">repair_queue</span> <span class="o">==</span> <span class="n">TCP_RECV_QUEUE</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_USER_TIMEOUT</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_user_timeout</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tcp_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">SOL_TCP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span>
						     <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_tcp_getsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_getsockopt</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="kt">int</span> <span class="nf">compat_tcp_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
			  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">SOL_TCP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">inet_csk_compat_getsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span>
						  <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_tcp_getsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">compat_tcp_getsockopt</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_tso_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">segs</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">thlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">thlen</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">thlen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">oldlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span><span class="o">~</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">thlen</span><span class="p">);</span>

	<span class="n">mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">mss</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_gso_ok</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span> <span class="o">|</span> <span class="n">NETIF_F_GSO_ROBUST</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Packet is from an untrusted source, reset gso_segs. */</span>
		<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span>
			     <span class="o">~</span><span class="p">(</span><span class="n">SKB_GSO_TCPV4</span> <span class="o">|</span>
			       <span class="n">SKB_GSO_DODGY</span> <span class="o">|</span>
			       <span class="n">SKB_GSO_TCP_ECN</span> <span class="o">|</span>
			       <span class="n">SKB_GSO_TCPV6</span> <span class="o">|</span>
			       <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
			     <span class="o">!</span><span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SKB_GSO_TCPV4</span> <span class="o">|</span> <span class="n">SKB_GSO_TCPV6</span><span class="p">))))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">mss</span><span class="p">);</span>

		<span class="n">segs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">segs</span> <span class="o">=</span> <span class="n">skb_segment</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">segs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">oldlen</span> <span class="o">+</span> <span class="p">(</span><span class="n">thlen</span> <span class="o">+</span> <span class="n">mss</span><span class="p">));</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">segs</span><span class="p">;</span>
	<span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">fin</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">psh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">th</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_fold</span><span class="p">((</span><span class="n">__force</span> <span class="n">__wsum</span><span class="p">)((</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">+</span>
				       <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">delta</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
			<span class="n">th</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span>
			     <span class="n">csum_fold</span><span class="p">(</span><span class="n">csum_partial</span><span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
						    <span class="n">thlen</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">));</span>

		<span class="n">seq</span> <span class="o">+=</span> <span class="n">mss</span><span class="p">;</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">th</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">cwr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">oldlen</span> <span class="o">+</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span><span class="p">)</span> <span class="o">+</span>
		      <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
	<span class="n">th</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="o">~</span><span class="n">csum_fold</span><span class="p">((</span><span class="n">__force</span> <span class="n">__wsum</span><span class="p">)((</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">delta</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
		<span class="n">th</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="n">csum_fold</span><span class="p">(</span><span class="n">csum_partial</span><span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
						   <span class="n">thlen</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">));</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">segs</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_tso_segment</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="nf">tcp_gro_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">pp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">thlen</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">off</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">off</span> <span class="o">=</span> <span class="n">skb_gro_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">hlen</span> <span class="o">=</span> <span class="n">off</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">);</span>
	<span class="n">th</span> <span class="o">=</span> <span class="n">skb_gro_header_fast</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_gro_header_hard</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">th</span> <span class="o">=</span> <span class="n">skb_gro_header_slow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">thlen</span> <span class="o">=</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">hlen</span> <span class="o">=</span> <span class="n">off</span> <span class="o">+</span> <span class="n">thlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_gro_header_hard</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">th</span> <span class="o">=</span> <span class="n">skb_gro_header_slow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_gro_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">thlen</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">skb_gro_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">tcp_flag_word</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span> <span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">same_flow</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">th2</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">^</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">th2</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">same_flow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">goto</span> <span class="n">out_check_final</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="n">flush</span> <span class="o">=</span> <span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">;</span>
	<span class="n">flush</span> <span class="o">|=</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">int</span><span class="p">)(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCP_FLAG_CWR</span><span class="p">);</span>
	<span class="n">flush</span> <span class="o">|=</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">int</span><span class="p">)((</span><span class="n">flags</span> <span class="o">^</span> <span class="n">tcp_flag_word</span><span class="p">(</span><span class="n">th2</span><span class="p">))</span> <span class="o">&amp;</span>
		  <span class="o">~</span><span class="p">(</span><span class="n">TCP_FLAG_CWR</span> <span class="o">|</span> <span class="n">TCP_FLAG_FIN</span> <span class="o">|</span> <span class="n">TCP_FLAG_PSH</span><span class="p">));</span>
	<span class="n">flush</span> <span class="o">|=</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">int</span><span class="p">)(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ack_seq</span> <span class="o">^</span> <span class="n">th2</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">thlen</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">flush</span> <span class="o">|=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">th</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">^</span>
			 <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">th2</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>

	<span class="n">flush</span> <span class="o">|=</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">mss</span><span class="p">;</span>
	<span class="n">flush</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ntohl</span><span class="p">(</span><span class="n">th2</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="n">skb_gro_len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">^</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">||</span> <span class="n">skb_gro_receive</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mss</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_check_final</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="n">th2</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">tcp_flag_word</span><span class="p">(</span><span class="n">th2</span><span class="p">)</span> <span class="o">|=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCP_FLAG_FIN</span> <span class="o">|</span> <span class="n">TCP_FLAG_PSH</span><span class="p">);</span>

<span class="nl">out_check_final:</span>
	<span class="n">flush</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">mss</span><span class="p">;</span>
	<span class="n">flush</span> <span class="o">|=</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">int</span><span class="p">)(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCP_FLAG_URG</span> <span class="o">|</span> <span class="n">TCP_FLAG_PSH</span> <span class="o">|</span>
					<span class="n">TCP_FLAG_RST</span> <span class="o">|</span> <span class="n">TCP_FLAG_SYN</span> <span class="o">|</span>
					<span class="n">TCP_FLAG_FIN</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">same_flow</span> <span class="o">||</span> <span class="n">flush</span><span class="p">))</span>
		<span class="n">pp</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flush</span> <span class="o">|=</span> <span class="n">flush</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_gro_receive</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">tcp_gro_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_start</span> <span class="o">=</span> <span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">,</span> <span class="n">check</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>

	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">cwr</span><span class="p">)</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">|=</span> <span class="n">SKB_GSO_TCP_ECN</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_gro_complete</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tcp_md5sig_users</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">tcp_md5sig_pool</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__tcp_free_md5sig_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">pool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">md5_desc</span><span class="p">.</span><span class="n">tfm</span><span class="p">)</span>
			<span class="n">crypto_free_hash</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">md5_desc</span><span class="p">.</span><span class="n">tfm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tcp_free_md5sig_pool</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">tcp_md5sig_users</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pool</span> <span class="o">=</span> <span class="n">tcp_md5sig_pool</span><span class="p">;</span>
		<span class="n">tcp_md5sig_pool</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="p">)</span>
		<span class="n">__tcp_free_md5sig_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_free_md5sig_pool</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="n">__percpu</span> <span class="o">*</span>
<span class="nf">__tcp_alloc_md5sig_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>

	<span class="n">pool</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_md5sig_pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">crypto_hash</span> <span class="o">*</span><span class="n">hash</span><span class="p">;</span>

		<span class="n">hash</span> <span class="o">=</span> <span class="n">crypto_alloc_hash</span><span class="p">(</span><span class="s">&quot;md5&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CRYPTO_ALG_ASYNC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">hash</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">md5_desc</span><span class="p">.</span><span class="n">tfm</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pool</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="n">__tcp_free_md5sig_pool</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="n">__percpu</span> <span class="o">*</span><span class="nf">tcp_alloc_md5sig_pool</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">alloc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>
	<span class="n">pool</span> <span class="o">=</span> <span class="n">tcp_md5sig_pool</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_md5sig_users</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">alloc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_md5sig_users</span><span class="o">--</span><span class="p">;</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>
		<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we cannot hold spinlock here because this may sleep. */</span>
		<span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">=</span> <span class="n">__tcp_alloc_md5sig_pool</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcp_md5sig_users</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pool</span> <span class="o">=</span> <span class="n">tcp_md5sig_pool</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* oops, it has already been assigned. */</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>
			<span class="n">__tcp_free_md5sig_pool</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tcp_md5sig_pool</span> <span class="o">=</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pool</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_alloc_md5sig_pool</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> *	tcp_get_md5sig_pool - get md5sig_pool for this user</span>
<span class="cm"> *</span>
<span class="cm"> *	We use percpu structure, so if we succeed, we exit with preemption</span>
<span class="cm"> *	and BH disabled, to make sure another thread or softirq handling</span>
<span class="cm"> *	wont try to get same context.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="o">*</span><span class="nf">tcp_get_md5sig_pool</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">tcp_md5sig_pool</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">tcp_md5sig_users</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_md5sig_pool_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_get_md5sig_pool</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">tcp_put_md5sig_pool</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="n">tcp_free_md5sig_pool</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_put_md5sig_pool</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">tcp_md5_hash_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="o">*</span><span class="n">hp</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* We are not allowed to change tcphdr, make a local copy */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">hdr</span><span class="p">.</span><span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* options aren&#39;t included in the hash */</span>
	<span class="n">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">crypto_hash_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">md5_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_md5_hash_header</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">tcp_md5_hash_skb_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="o">*</span><span class="n">hp</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hash_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">md5_desc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">head_data_len</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">header_len</span> <span class="o">?</span>
					   <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">header_len</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">shi</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag_iter</span><span class="p">;</span>

	<span class="n">sg_init_table</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">sg_set_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">tp</span><span class="p">)</span> <span class="o">+</span> <span class="n">header_len</span><span class="p">,</span> <span class="n">head_data_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crypto_hash_update</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">head_data_len</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">shi</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shi</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">skb_frag_page</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="n">sg_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">crypto_hash_update</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag_iter</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_md5_hash_skb_data</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">frag_iter</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_md5_hash_skb_data</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">tcp_md5_hash_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_md5sig_pool</span> <span class="o">*</span><span class="n">hp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_md5sig_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="n">sg</span><span class="p">;</span>

	<span class="n">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">keylen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">crypto_hash_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">md5_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">keylen</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_md5_hash_key</span><span class="p">);</span>

<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * Each Responder maintains up to two secret values concurrently for</span>
<span class="cm"> * efficient secret rollover.  Each secret value has 4 states:</span>
<span class="cm"> *</span>
<span class="cm"> * Generating.  (tcp_secret_generating != tcp_secret_primary)</span>
<span class="cm"> *    Generates new Responder-Cookies, but not yet used for primary</span>
<span class="cm"> *    verification.  This is a short-term state, typically lasting only</span>
<span class="cm"> *    one round trip time (RTT).</span>
<span class="cm"> *</span>
<span class="cm"> * Primary.  (tcp_secret_generating == tcp_secret_primary)</span>
<span class="cm"> *    Used both for generation and primary verification.</span>
<span class="cm"> *</span>
<span class="cm"> * Retiring.  (tcp_secret_retiring != tcp_secret_secondary)</span>
<span class="cm"> *    Used for verification, until the first failure that can be</span>
<span class="cm"> *    verified by the newer Generating secret.  At that time, this</span>
<span class="cm"> *    cookie&#39;s state is changed to Secondary, and the Generating</span>
<span class="cm"> *    cookie&#39;s state is changed to Primary.  This is a short-term state,</span>
<span class="cm"> *    typically lasting only one round trip time (RTT).</span>
<span class="cm"> *</span>
<span class="cm"> * Secondary.  (tcp_secret_retiring == tcp_secret_secondary)</span>
<span class="cm"> *    Used for secondary verification, after primary verification</span>
<span class="cm"> *    failures.  This state lasts no more than twice the Maximum Segment</span>
<span class="cm"> *    Lifetime (2MSL).  Then, the secret is discarded.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tcp_cookie_secret</span> <span class="p">{</span>
	<span class="cm">/* The secret is divided into two parts.  The digest part is the</span>
<span class="cm">	 * equivalent of previously hashing a secret and saving the state,</span>
<span class="cm">	 * and serves as an initialization vector (IV).  The message part</span>
<span class="cm">	 * serves as the trailing secret.</span>
<span class="cm">	 */</span>
	<span class="n">u32</span>				<span class="n">secrets</span><span class="p">[</span><span class="n">COOKIE_WORKSPACE_WORDS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>			<span class="n">expires</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define TCP_SECRET_1MSL (HZ * TCP_PAWS_MSL)</span>
<span class="cp">#define TCP_SECRET_2MSL (HZ * TCP_PAWS_MSL * 2)</span>
<span class="cp">#define TCP_SECRET_LIFE (HZ * 600)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tcp_cookie_secret</span> <span class="n">tcp_secret_one</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tcp_cookie_secret</span> <span class="n">tcp_secret_two</span><span class="p">;</span>

<span class="cm">/* Essentially a circular list, without dynamic allocation. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tcp_cookie_secret</span> <span class="o">*</span><span class="n">tcp_secret_generating</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tcp_cookie_secret</span> <span class="o">*</span><span class="n">tcp_secret_primary</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tcp_cookie_secret</span> <span class="o">*</span><span class="n">tcp_secret_retiring</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tcp_cookie_secret</span> <span class="o">*</span><span class="n">tcp_secret_secondary</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">tcp_secret_locker</span><span class="p">);</span>

<span class="cm">/* Select a pseudo-random word in the cookie workspace.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">tcp_cookie_work</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ws</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ws</span><span class="p">[</span><span class="n">COOKIE_DIGEST_WORDS</span> <span class="o">+</span> <span class="p">((</span><span class="n">COOKIE_MESSAGE_WORDS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ws</span><span class="p">[</span><span class="n">n</span><span class="p">])];</span>
<span class="p">}</span>

<span class="cm">/* Fill bakery[COOKIE_WORKSPACE_WORDS] with generator, updating as needed.</span>
<span class="cm"> * Called in softirq context.</span>
<span class="cm"> * Returns: 0 for success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tcp_cookie_generator</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">bakery</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffy</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffy</span><span class="p">,</span> <span class="n">tcp_secret_generating</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_secret_locker</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffy</span><span class="p">,</span> <span class="n">tcp_secret_generating</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* refreshed by another */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">bakery</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">tcp_secret_generating</span><span class="o">-&gt;</span><span class="n">secrets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			       <span class="n">COOKIE_WORKSPACE_WORDS</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* still needs refreshing */</span>
			<span class="n">get_random_bytes</span><span class="p">(</span><span class="n">bakery</span><span class="p">,</span> <span class="n">COOKIE_WORKSPACE_WORDS</span><span class="p">);</span>

			<span class="cm">/* The first time, paranoia assumes that the</span>
<span class="cm">			 * randomization function isn&#39;t as strong.  But,</span>
<span class="cm">			 * this secret initialization is delayed until</span>
<span class="cm">			 * the last possible moment (packet arrival).</span>
<span class="cm">			 * Although that time is observable, it is</span>
<span class="cm">			 * unpredictably variable.  Mash in the most</span>
<span class="cm">			 * volatile clock bits available, and expire the</span>
<span class="cm">			 * secret extra quickly.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tcp_secret_primary</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">==</span>
				     <span class="n">tcp_secret_secondary</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">timespec</span> <span class="n">tv</span><span class="p">;</span>

				<span class="n">getnstimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
				<span class="n">bakery</span><span class="p">[</span><span class="n">COOKIE_DIGEST_WORDS</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="o">^=</span>
					<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>

				<span class="n">tcp_secret_secondary</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffy</span>
					<span class="o">+</span> <span class="n">TCP_SECRET_1MSL</span>
					<span class="o">+</span> <span class="p">(</span><span class="mh">0x0f</span> <span class="o">&amp;</span> <span class="n">tcp_cookie_work</span><span class="p">(</span><span class="n">bakery</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">tcp_secret_secondary</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffy</span>
					<span class="o">+</span> <span class="n">TCP_SECRET_LIFE</span>
					<span class="o">+</span> <span class="p">(</span><span class="mh">0xff</span> <span class="o">&amp;</span> <span class="n">tcp_cookie_work</span><span class="p">(</span><span class="n">bakery</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
				<span class="n">tcp_secret_primary</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffy</span>
					<span class="o">+</span> <span class="n">TCP_SECRET_2MSL</span>
					<span class="o">+</span> <span class="p">(</span><span class="mh">0x1f</span> <span class="o">&amp;</span> <span class="n">tcp_cookie_work</span><span class="p">(</span><span class="n">bakery</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_secret_secondary</span><span class="o">-&gt;</span><span class="n">secrets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			       <span class="n">bakery</span><span class="p">,</span> <span class="n">COOKIE_WORKSPACE_WORDS</span><span class="p">);</span>

			<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">tcp_secret_generating</span><span class="p">,</span>
					   <span class="n">tcp_secret_secondary</span><span class="p">);</span>
			<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">tcp_secret_retiring</span><span class="p">,</span>
					   <span class="n">tcp_secret_primary</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Neither call_rcu() nor synchronize_rcu() needed.</span>
<span class="cm">			 * Retiring data is not freed.  It is replaced after</span>
<span class="cm">			 * further (locked) pointer updates, and a quiet time</span>
<span class="cm">			 * (minimum 1MSL, maximum LIFE - 2MSL).</span>
<span class="cm">			 */</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_secret_locker</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rcu_read_lock_bh</span><span class="p">();</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">bakery</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">tcp_secret_generating</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">secrets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		       <span class="n">COOKIE_WORKSPACE_WORDS</span><span class="p">);</span>
		<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_cookie_generator</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">tcp_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_SYN_SENT</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_SYN_RECV</span><span class="p">)</span>
		<span class="n">TCP_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_ATTEMPTFAILS</span><span class="p">);</span>

	<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CLOSE</span><span class="p">);</span>
	<span class="n">tcp_clear_xmit_timers</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">=</span> <span class="n">SHUTDOWN_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">inet_csk_destroy_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">tcp_done</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tcp_congestion_ops</span> <span class="n">tcp_reno</span><span class="p">;</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thash_entries</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">set_thash_entries</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">kstrtoul</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thash_entries</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;thash_entries=&quot;</span><span class="p">,</span> <span class="n">set_thash_entries</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">tcp_init_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">nr_free_buffer_pages</span><span class="p">()</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="mi">128UL</span><span class="p">);</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ipv4</span><span class="p">.</span><span class="n">sysctl_tcp_mem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ipv4</span><span class="p">.</span><span class="n">sysctl_tcp_mem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">ipv4</span><span class="p">.</span><span class="n">sysctl_tcp_mem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">ipv4</span><span class="p">.</span><span class="n">sysctl_tcp_mem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">tcp_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_rshare</span><span class="p">,</span> <span class="n">max_wshare</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">jiffy</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_skb_cb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">));</span>

	<span class="n">percpu_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_sockets_allocated</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">percpu_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_orphan_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">bind_bucket_cachep</span> <span class="o">=</span>
		<span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;tcp_bind_bucket&quot;</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_bind_bucket</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
				  <span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Size and allocate the main established and bind bucket</span>
<span class="cm">	 * hash tables.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The methodology is similar to that of the buffer cache.</span>
<span class="cm">	 */</span>
	<span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">ehash</span> <span class="o">=</span>
		<span class="n">alloc_large_system_hash</span><span class="p">(</span><span class="s">&quot;TCP established&quot;</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_ehash_bucket</span><span class="p">),</span>
					<span class="n">thash_entries</span><span class="p">,</span>
					<span class="p">(</span><span class="n">totalram_pages</span> <span class="o">&gt;=</span> <span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">?</span>
					<span class="mi">13</span> <span class="o">:</span> <span class="mi">15</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">ehash_mask</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="n">thash_entries</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">ehash_mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_HLIST_NULLS_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">ehash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chain</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">INIT_HLIST_NULLS_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">ehash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">twchain</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inet_ehash_locks_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_hashinfo</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;TCP: failed to alloc ehash_locks&quot;</span><span class="p">);</span>
	<span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">bhash</span> <span class="o">=</span>
		<span class="n">alloc_large_system_hash</span><span class="p">(</span><span class="s">&quot;TCP bind&quot;</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">inet_bind_hashbucket</span><span class="p">),</span>
					<span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">ehash_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					<span class="p">(</span><span class="n">totalram_pages</span> <span class="o">&gt;=</span> <span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">?</span>
					<span class="mi">13</span> <span class="o">:</span> <span class="mi">15</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">bhash_size</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
	<span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">bhash_size</span> <span class="o">=</span> <span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">bhash_size</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">bhash_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">bhash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">bhash</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chain</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="n">cnt</span> <span class="o">=</span> <span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">ehash_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">tcp_death_row</span><span class="p">.</span><span class="n">sysctl_max_tw_buckets</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">sysctl_tcp_max_orphans</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">sysctl_max_syn_backlog</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">/</span> <span class="mi">256</span><span class="p">);</span>

	<span class="n">tcp_init_mem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">);</span>
	<span class="cm">/* Set per-socket limits to no more than 1/128 the pressure threshold */</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="n">nr_free_buffer_pages</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">max_wshare</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">4UL</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="n">max_rshare</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">6UL</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>

	<span class="n">sysctl_tcp_wmem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SK_MEM_QUANTUM</span><span class="p">;</span>
	<span class="n">sysctl_tcp_wmem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
	<span class="n">sysctl_tcp_wmem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="n">max_wshare</span><span class="p">);</span>

	<span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SK_MEM_QUANTUM</span><span class="p">;</span>
	<span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">87380</span><span class="p">;</span>
	<span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">87380</span><span class="p">,</span> <span class="n">max_rshare</span><span class="p">);</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;Hash tables configured (established %u bind %u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">ehash_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tcp_hashinfo</span><span class="p">.</span><span class="n">bhash_size</span><span class="p">);</span>

	<span class="n">tcp_register_congestion_control</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_reno</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_secret_one</span><span class="p">.</span><span class="n">secrets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tcp_secret_one</span><span class="p">.</span><span class="n">secrets</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_secret_two</span><span class="p">.</span><span class="n">secrets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tcp_secret_two</span><span class="p">.</span><span class="n">secrets</span><span class="p">));</span>
	<span class="n">tcp_secret_one</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffy</span><span class="p">;</span> <span class="cm">/* past due */</span>
	<span class="n">tcp_secret_two</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffy</span><span class="p">;</span> <span class="cm">/* past due */</span>
	<span class="n">tcp_secret_generating</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tcp_secret_one</span><span class="p">;</span>
	<span class="n">tcp_secret_primary</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tcp_secret_one</span><span class="p">;</span>
	<span class="n">tcp_secret_retiring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tcp_secret_two</span><span class="p">;</span>
	<span class="n">tcp_secret_secondary</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tcp_secret_two</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
