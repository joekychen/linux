<!DOCTYPE html>
<html><head><title>joekychen/linux » net › ipv4 › fib_trie.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fib_trie.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *   as published by the Free Software Foundation; either version</span>
<span class="cm"> *   2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   Robert Olsson &lt;robert.olsson@its.uu.se&gt; Uppsala Universitet</span>
<span class="cm"> *     &amp; Swedish University of Agricultural Sciences.</span>
<span class="cm"> *</span>
<span class="cm"> *   Jens Laas &lt;jens.laas@data.slu.se&gt; Swedish University of</span>
<span class="cm"> *     Agricultural Sciences.</span>
<span class="cm"> *</span>
<span class="cm"> *   Hans Liss &lt;hans.liss@its.uu.se&gt;  Uppsala Universitet</span>
<span class="cm"> *</span>
<span class="cm"> * This work is based on the LPC-trie which is originally described in:</span>
<span class="cm"> *</span>
<span class="cm"> * An experimental study of compression methods for dynamic tries</span>
<span class="cm"> * Stefan Nilsson and Matti Tikkanen. Algorithmica, 33(1):19-33, 2002.</span>
<span class="cm"> * http://www.csc.kth.se/~snilsson/software/dyntrie2/</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * IP-address lookup using LC-tries. Stefan Nilsson and Gunnar Karlsson</span>
<span class="cm"> * IEEE Journal on Selected Areas in Communications, 17(6):1083-1092, June 1999</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Code from fib_hash has been reused which includes the following header:</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  INET is implemented using the  BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *		IPv4 FIB: lookup engine and maintenance routines.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * Substantial contributions to this work comes from:</span>
<span class="cm"> *</span>
<span class="cm"> *		David S. Miller, &lt;davem@davemloft.net&gt;</span>
<span class="cm"> *		Stephen Hemminger &lt;shemminger@osdl.org&gt;</span>
<span class="cm"> *		Paul E. McKenney &lt;paulmck@us.ibm.com&gt;</span>
<span class="cm"> *		Patrick McHardy &lt;kaber@trash.net&gt;</span>
<span class="cm"> */</span>

<span class="cp">#define VERSION &quot;0.409&quot;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/sockios.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/inetdevice.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/netlink.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;net/protocol.h&gt;</span>
<span class="cp">#include &lt;net/route.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/ip_fib.h&gt;</span>
<span class="cp">#include &quot;fib_lookup.h&quot;</span>

<span class="cp">#define MAX_STAT_DEPTH 32</span>

<span class="cp">#define KEYLENGTH (8*sizeof(t_key))</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t_key</span><span class="p">;</span>

<span class="cp">#define T_TNODE 0</span>
<span class="cp">#define T_LEAF  1</span>
<span class="cp">#define NODE_TYPE_MASK	0x1UL</span>
<span class="cp">#define NODE_TYPE(node) ((node)-&gt;parent &amp; NODE_TYPE_MASK)</span>

<span class="cp">#define IS_TNODE(n) (!(n-&gt;parent &amp; T_LEAF))</span>
<span class="cp">#define IS_LEAF(n) (n-&gt;parent &amp; T_LEAF)</span>

<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">t_key</span> <span class="n">key</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">leaf</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">t_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">leaf_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hlist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">plen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask_plen</span><span class="p">;</span> <span class="cm">/* ntohl(inet_make_mask(plen)) */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">falh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tnode</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">t_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pos</span><span class="p">;</span>		<span class="cm">/* 2log(KEYLENGTH) bits needed */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bits</span><span class="p">;</span>		<span class="cm">/* 2log(KEYLENGTH) bits needed */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">full_children</span><span class="p">;</span>	<span class="cm">/* KEYLENGTH bits needed */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">empty_children</span><span class="p">;</span>	<span class="cm">/* KEYLENGTH bits needed */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tnode_free</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
<span class="k">struct</span> <span class="n">trie_use_stats</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gets</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">backtrack</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">semantic_match_passed</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">semantic_match_miss</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">null_node_hit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resize_node_skipped</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">trie_stat</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">totdepth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxdepth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tnodes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">leaves</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nullpointers</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prefixes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nodesizes</span><span class="p">[</span><span class="n">MAX_STAT_DEPTH</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">trie</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">trie</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
	<span class="k">struct</span> <span class="n">trie_use_stats</span> <span class="n">stats</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">put_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">tnode_put_child_reorg</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">wasfull</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">inflate</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">halve</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">);</span>
<span class="cm">/* tnodes to free after resize(); protected by RTNL */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tnode_free_head</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="n">tnode_free_size</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * synchronize_rcu after call_rcu for that many pages; it should be especially</span>
<span class="cm"> * useful before resizing the root node with PREEMPT_NONE configs; the value was</span>
<span class="cm"> * obtained experimentally, aiming to avoid visible slowdown.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">sync_pages</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">fn_alias_kmem</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">trie_leaf_kmem</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * caller must hold RTNL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="nf">node_parent</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">rcu_dereference_index_check</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">lockdep_rtnl_is_held</span><span class="p">());</span>

	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)(</span><span class="n">parent</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">NODE_TYPE_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * caller must hold RCU read lock or RTNL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="nf">node_parent_rcu</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">rcu_dereference_index_check</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">rcu_read_lock_held</span><span class="p">()</span> <span class="o">||</span>
							   <span class="n">lockdep_rtnl_is_held</span><span class="p">());</span>

	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)(</span><span class="n">parent</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">NODE_TYPE_MASK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Same as rcu_assign_pointer</span>
<span class="cm"> * but that macro() assumes that value is a pointer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">node_set_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ptr</span> <span class="o">|</span> <span class="n">NODE_TYPE</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * caller must hold RTNL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="nf">tnode_get_child</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rtnl_dereference</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * caller must hold RCU read lock or RTNL</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="nf">tnode_get_child_rcu</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rcu_dereference_rtnl</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tnode_child_length</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">t_key</span> <span class="nf">mask_pfx</span><span class="p">(</span><span class="n">t_key</span> <span class="n">k</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">KEYLENGTH</span><span class="o">-</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">KEYLENGTH</span><span class="o">-</span><span class="n">l</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">t_key</span> <span class="nf">tkey_extract_bits</span><span class="p">(</span><span class="n">t_key</span> <span class="n">a</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">KEYLENGTH</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">t_key</span><span class="p">)(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">KEYLENGTH</span> <span class="o">-</span> <span class="n">bits</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tkey_equals</span><span class="p">(</span><span class="n">t_key</span> <span class="n">a</span><span class="p">,</span> <span class="n">t_key</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tkey_sub_equals</span><span class="p">(</span><span class="n">t_key</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">,</span> <span class="n">t_key</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">KEYLENGTH</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="n">KEYLENGTH</span> <span class="o">?</span> <span class="n">KEYLENGTH</span> <span class="o">:</span> <span class="n">bits</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">KEYLENGTH</span> <span class="o">-</span> <span class="n">bits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tkey_mismatch</span><span class="p">(</span><span class="n">t_key</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">t_key</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">t_key</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diff</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">diff</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">KEYLENGTH</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  To understand this stuff, an understanding of keys and all their bits is</span>
<span class="cm">  necessary. Every node in the trie has a key associated with it, but not</span>
<span class="cm">  all of the bits in that key are significant.</span>

<span class="cm">  Consider a node &#39;n&#39; and its parent &#39;tp&#39;.</span>

<span class="cm">  If n is a leaf, every bit in its key is significant. Its presence is</span>
<span class="cm">  necessitated by path compression, since during a tree traversal (when</span>
<span class="cm">  searching for a leaf - unless we are doing an insertion) we will completely</span>
<span class="cm">  ignore all skipped bits we encounter. Thus we need to verify, at the end of</span>
<span class="cm">  a potentially successful search, that we have indeed been walking the</span>
<span class="cm">  correct key path.</span>

<span class="cm">  Note that we can never &quot;miss&quot; the correct key in the tree if present by</span>
<span class="cm">  following the wrong path. Path compression ensures that segments of the key</span>
<span class="cm">  that are the same for all keys with a given prefix are skipped, but the</span>
<span class="cm">  skipped part *is* identical for each node in the subtrie below the skipped</span>
<span class="cm">  bit! trie_insert() in this implementation takes care of that - note the</span>
<span class="cm">  call to tkey_sub_equals() in trie_insert().</span>

<span class="cm">  if n is an internal node - a &#39;tnode&#39; here, the various parts of its key</span>
<span class="cm">  have many different meanings.</span>

<span class="cm">  Example:</span>
<span class="cm">  _________________________________________________________________</span>
<span class="cm">  | i | i | i | i | i | i | i | N | N | N | S | S | S | S | S | C |</span>
<span class="cm">  -----------------------------------------------------------------</span>
<span class="cm">    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15</span>

<span class="cm">  _________________________________________________________________</span>
<span class="cm">  | C | C | C | u | u | u | u | u | u | u | u | u | u | u | u | u |</span>
<span class="cm">  -----------------------------------------------------------------</span>
<span class="cm">   16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31</span>

<span class="cm">  tp-&gt;pos = 7</span>
<span class="cm">  tp-&gt;bits = 3</span>
<span class="cm">  n-&gt;pos = 15</span>
<span class="cm">  n-&gt;bits = 4</span>

<span class="cm">  First, let&#39;s just ignore the bits that come before the parent tp, that is</span>
<span class="cm">  the bits from 0 to (tp-&gt;pos-1). They are *known* but at this point we do</span>
<span class="cm">  not use them for anything.</span>

<span class="cm">  The bits from (tp-&gt;pos) to (tp-&gt;pos + tp-&gt;bits - 1) - &quot;N&quot;, above - are the</span>
<span class="cm">  index into the parent&#39;s child array. That is, they will be used to find</span>
<span class="cm">  &#39;n&#39; among tp&#39;s children.</span>

<span class="cm">  The bits from (tp-&gt;pos + tp-&gt;bits) to (n-&gt;pos - 1) - &quot;S&quot; - are skipped bits</span>
<span class="cm">  for the node n.</span>

<span class="cm">  All the bits we have seen so far are significant to the node n. The rest</span>
<span class="cm">  of the bits are really not needed or indeed known in n-&gt;key.</span>

<span class="cm">  The bits from (n-&gt;pos) to (n-&gt;pos + n-&gt;bits - 1) - &quot;C&quot; - are the index into</span>
<span class="cm">  n&#39;s child array, and will of course be different for each child.</span>


<span class="cm">  The rest of the bits, from (n-&gt;pos + n-&gt;bits) onward, are completely unknown</span>
<span class="cm">  at this point.</span>

<span class="cm">*/</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">check_tnode</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">tn</span> <span class="o">&amp;&amp;</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">+</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">halve_threshold</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">inflate_threshold</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">halve_threshold_root</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">inflate_threshold_root</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__alias_free_mem</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fib_alias</span> <span class="o">*</span><span class="n">fa</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib_alias</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">fn_alias_kmem</span><span class="p">,</span> <span class="n">fa</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">alias_free_mem_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_alias</span> <span class="o">*</span><span class="n">fa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">__alias_free_mem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__leaf_free_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">trie_leaf_kmem</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">__leaf_free_rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_leaf_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">leaf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="nf">tnode_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__tnode_vfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__tnode_free_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span><span class="p">)</span> <span class="o">+</span>
		      <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">__tnode_vfree</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tnode_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_LEAF</span><span class="p">(</span><span class="n">tn</span><span class="p">))</span>
		<span class="n">free_leaf</span><span class="p">((</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="p">)</span> <span class="n">tn</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">rcu</span><span class="p">,</span> <span class="n">__tnode_free_rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tnode_free_safe</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">IS_LEAF</span><span class="p">(</span><span class="n">tn</span><span class="p">));</span>
	<span class="n">tn</span><span class="o">-&gt;</span><span class="n">tnode_free</span> <span class="o">=</span> <span class="n">tnode_free_head</span><span class="p">;</span>
	<span class="n">tnode_free_head</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
	<span class="n">tnode_free_size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span><span class="p">)</span> <span class="o">+</span>
			   <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tnode_free_flush</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">tn</span> <span class="o">=</span> <span class="n">tnode_free_head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tnode_free_head</span> <span class="o">=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">tnode_free</span><span class="p">;</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">tnode_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tnode_free</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tnode_free_size</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">sync_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tnode_free_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">synchronize_rcu</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="nf">leaf_new</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">trie_leaf_kmem</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">T_LEAF</span><span class="p">;</span>
		<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="nf">leaf_info_new</span><span class="p">(</span><span class="kt">int</span> <span class="n">plen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf_info</span><span class="p">),</span>  <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">li</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">li</span><span class="o">-&gt;</span><span class="n">plen</span> <span class="o">=</span> <span class="n">plen</span><span class="p">;</span>
		<span class="n">li</span><span class="o">-&gt;</span><span class="n">mask_plen</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">inet_make_mask</span><span class="p">(</span><span class="n">plen</span><span class="p">));</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">li</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="nf">tnode_new</span><span class="p">(</span><span class="n">t_key</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span> <span class="o">=</span> <span class="n">tnode_alloc</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">T_TNODE</span><span class="p">;</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">;</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">full_children</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">empty_children</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">bits</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;AT %p s=%zu %zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span><span class="p">),</span>
		 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check whether a tnode &#39;n&#39; is &quot;full&quot;, i.e. it is an internal node</span>
<span class="cm"> * and no bits are skipped. See discussion in dyntree paper p. 6</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tnode_full</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">IS_LEAF</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">((</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">==</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">put_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tnode_put_child_reorg</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

 <span class="cm">/*</span>
<span class="cm">  * Add a child at position i overwriting the old value.</span>
<span class="cm">  * Update the value of full_children and empty_children.</span>
<span class="cm">  */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tnode_put_child_reorg</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">wasfull</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">chi</span> <span class="o">=</span> <span class="n">rtnl_dereference</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="kt">int</span> <span class="n">isfull</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>

	<span class="cm">/* update emptyChildren */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">chi</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">empty_children</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">chi</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">empty_children</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* update fullChildren */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wasfull</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">wasfull</span> <span class="o">=</span> <span class="n">tnode_full</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span> <span class="n">chi</span><span class="p">);</span>

	<span class="n">isfull</span> <span class="o">=</span> <span class="n">tnode_full</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wasfull</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isfull</span><span class="p">)</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">full_children</span><span class="o">--</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wasfull</span> <span class="o">&amp;&amp;</span> <span class="n">isfull</span><span class="p">)</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">full_children</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="n">node_set_parent</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">tn</span><span class="p">);</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define MAX_WORK 10</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="nf">resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">old_tn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inflate_threshold_use</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">halve_threshold_use</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_work</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tn</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;In tnode_resize %p inflate_threshold=%d threshold=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">tn</span><span class="p">,</span> <span class="n">inflate_threshold</span><span class="p">,</span> <span class="n">halve_threshold</span><span class="p">);</span>

	<span class="cm">/* No children */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">empty_children</span> <span class="o">==</span> <span class="n">tnode_child_length</span><span class="p">(</span><span class="n">tn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tnode_free_safe</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* One child */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">empty_children</span> <span class="o">==</span> <span class="n">tnode_child_length</span><span class="p">(</span><span class="n">tn</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">one_child</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Double as long as the resulting node has a number of</span>
<span class="cm">	 * nonempty nodes that are above the threshold.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * From &quot;Implementing a dynamic compressed trie&quot; by Stefan Nilsson of</span>
<span class="cm">	 * the Helsinki University of Technology and Matti Tikkanen of Nokia</span>
<span class="cm">	 * Telecommunications, page 6:</span>
<span class="cm">	 * &quot;A node is doubled if the ratio of non-empty children to all</span>
<span class="cm">	 * children in the *doubled* node is at least &#39;high&#39;.&quot;</span>
<span class="cm">	 *</span>
<span class="cm">	 * &#39;high&#39; in this instance is the variable &#39;inflate_threshold&#39;. It</span>
<span class="cm">	 * is expressed as a percentage, so we multiply it with</span>
<span class="cm">	 * tnode_child_length() and instead of multiplying by 2 (since the</span>
<span class="cm">	 * child array will be doubled by inflate()) and multiplying</span>
<span class="cm">	 * the left-hand side by 100 (to handle the percentage thing) we</span>
<span class="cm">	 * multiply the left-hand side by 50.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The left-hand side may look a bit weird: tnode_child_length(tn)</span>
<span class="cm">	 * - tn-&gt;empty_children is of course the number of non-null children</span>
<span class="cm">	 * in the current node. tn-&gt;full_children is the number of &quot;full&quot;</span>
<span class="cm">	 * children, that is non-null tnodes with a skip value of 0.</span>
<span class="cm">	 * All of those will be doubled in the resulting inflated tnode, so</span>
<span class="cm">	 * we just count them one extra time here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A clearer way to write this would be:</span>
<span class="cm">	 *</span>
<span class="cm">	 * to_be_doubled = tn-&gt;full_children;</span>
<span class="cm">	 * not_to_be_doubled = tnode_child_length(tn) - tn-&gt;empty_children -</span>
<span class="cm">	 *     tn-&gt;full_children;</span>
<span class="cm">	 *</span>
<span class="cm">	 * new_child_length = tnode_child_length(tn) * 2;</span>
<span class="cm">	 *</span>
<span class="cm">	 * new_fill_factor = 100 * (not_to_be_doubled + 2*to_be_doubled) /</span>
<span class="cm">	 *      new_child_length;</span>
<span class="cm">	 * if (new_fill_factor &gt;= inflate_threshold)</span>
<span class="cm">	 *</span>
<span class="cm">	 * ...and so on, tho it would mess up the while () loop.</span>
<span class="cm">	 *</span>
<span class="cm">	 * anyway,</span>
<span class="cm">	 * 100 * (not_to_be_doubled + 2*to_be_doubled) / new_child_length &gt;=</span>
<span class="cm">	 *      inflate_threshold</span>
<span class="cm">	 *</span>
<span class="cm">	 * avoid a division:</span>
<span class="cm">	 * 100 * (not_to_be_doubled + 2*to_be_doubled) &gt;=</span>
<span class="cm">	 *      inflate_threshold * new_child_length</span>
<span class="cm">	 *</span>
<span class="cm">	 * expand not_to_be_doubled and to_be_doubled, and shorten:</span>
<span class="cm">	 * 100 * (tnode_child_length(tn) - tn-&gt;empty_children +</span>
<span class="cm">	 *    tn-&gt;full_children) &gt;= inflate_threshold * new_child_length</span>
<span class="cm">	 *</span>
<span class="cm">	 * expand new_child_length:</span>
<span class="cm">	 * 100 * (tnode_child_length(tn) - tn-&gt;empty_children +</span>
<span class="cm">	 *    tn-&gt;full_children) &gt;=</span>
<span class="cm">	 *      inflate_threshold * tnode_child_length(tn) * 2</span>
<span class="cm">	 *</span>
<span class="cm">	 * shorten again:</span>
<span class="cm">	 * 50 * (tn-&gt;full_children + tnode_child_length(tn) -</span>
<span class="cm">	 *    tn-&gt;empty_children) &gt;= inflate_threshold *</span>
<span class="cm">	 *    tnode_child_length(tn)</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>

	<span class="n">check_tnode</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>

	<span class="cm">/* Keep root node larger  */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_parent</span><span class="p">((</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">tn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inflate_threshold_use</span> <span class="o">=</span> <span class="n">inflate_threshold_root</span><span class="p">;</span>
		<span class="n">halve_threshold_use</span> <span class="o">=</span> <span class="n">halve_threshold_root</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inflate_threshold_use</span> <span class="o">=</span> <span class="n">inflate_threshold</span><span class="p">;</span>
		<span class="n">halve_threshold_use</span> <span class="o">=</span> <span class="n">halve_threshold</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">max_work</span> <span class="o">=</span> <span class="n">MAX_WORK</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">full_children</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>  <span class="n">max_work</span><span class="o">--</span> <span class="o">&amp;&amp;</span>
		<span class="mi">50</span> <span class="o">*</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">full_children</span> <span class="o">+</span> <span class="n">tnode_child_length</span><span class="p">(</span><span class="n">tn</span><span class="p">)</span>
		      <span class="o">-</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">empty_children</span><span class="p">)</span>
		<span class="o">&gt;=</span> <span class="n">inflate_threshold_use</span> <span class="o">*</span> <span class="n">tnode_child_length</span><span class="p">(</span><span class="n">tn</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">old_tn</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
		<span class="n">tn</span> <span class="o">=</span> <span class="n">inflate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tn</span> <span class="o">=</span> <span class="n">old_tn</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">resize_node_skipped</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">check_tnode</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>

	<span class="cm">/* Return if at least one inflate is run */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_work</span> <span class="o">!=</span> <span class="n">MAX_WORK</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">tn</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Halve as long as the number of empty children in this</span>
<span class="cm">	 * node is above threshold.</span>
<span class="cm">	 */</span>

	<span class="n">max_work</span> <span class="o">=</span> <span class="n">MAX_WORK</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>  <span class="n">max_work</span><span class="o">--</span> <span class="o">&amp;&amp;</span>
	       <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">tnode_child_length</span><span class="p">(</span><span class="n">tn</span><span class="p">)</span> <span class="o">-</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">empty_children</span><span class="p">)</span> <span class="o">&lt;</span>
	       <span class="n">halve_threshold_use</span> <span class="o">*</span> <span class="n">tnode_child_length</span><span class="p">(</span><span class="n">tn</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">old_tn</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
		<span class="n">tn</span> <span class="o">=</span> <span class="n">halve</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tn</span> <span class="o">=</span> <span class="n">old_tn</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">resize_node_skipped</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="cm">/* Only one child remains */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">empty_children</span> <span class="o">==</span> <span class="n">tnode_child_length</span><span class="p">(</span><span class="n">tn</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">one_child:</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tnode_child_length</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

			<span class="n">n</span> <span class="o">=</span> <span class="n">rtnl_dereference</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* compress one level */</span>

			<span class="n">node_set_parent</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">tnode_free_safe</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">tn</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">tnode_clean_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tofree</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tnode_child_length</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tofree</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">rtnl_dereference</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tofree</span><span class="p">)</span>
			<span class="n">tnode_free</span><span class="p">(</span><span class="n">tofree</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tnode_free</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="nf">inflate</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">oldtnode</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">olen</span> <span class="o">=</span> <span class="n">tnode_child_length</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;In inflate</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">tn</span> <span class="o">=</span> <span class="n">tnode_new</span><span class="p">(</span><span class="n">oldtnode</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">oldtnode</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">oldtnode</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Preallocate and store tnodes before the actual work so we</span>
<span class="cm">	 * don&#39;t get into an inconsistent state if memory allocation</span>
<span class="cm">	 * fails. In case of failure we return the oldnode and  inflate</span>
<span class="cm">	 * of tnode is ignored.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">olen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

		<span class="n">inode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">tnode_get_child</span><span class="p">(</span><span class="n">oldtnode</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span>
		    <span class="n">IS_TNODE</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">==</span> <span class="n">oldtnode</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">oldtnode</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">&amp;&amp;</span>
		    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
			<span class="n">t_key</span> <span class="n">m</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">KEYLENGTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>

			<span class="n">left</span> <span class="o">=</span> <span class="n">tnode_new</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">&amp;</span><span class="p">(</span><span class="o">~</span><span class="n">m</span><span class="p">),</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					 <span class="n">inode</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

			<span class="n">right</span> <span class="o">=</span> <span class="n">tnode_new</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">|</span><span class="n">m</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tnode_free</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">left</span><span class="p">);</span>
			<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">right</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">olen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">tnode_get_child</span><span class="p">(</span><span class="n">oldtnode</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

		<span class="cm">/* An empty child */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* A leaf or an internal node with skipped bits */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_LEAF</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&gt;</span>
		   <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
					      <span class="n">oldtnode</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">oldtnode</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span>
					      <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* An internal node with two children */</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">node</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">rtnl_dereference</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
			<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">rtnl_dereference</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

			<span class="n">tnode_free_safe</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* An internal node with more than two children */</span>

		<span class="cm">/* We will replace this node &#39;inode&#39; with two new</span>
<span class="cm">		 * ones, &#39;left&#39; and &#39;right&#39;, each with half of the</span>
<span class="cm">		 * original children. The two new nodes will have</span>
<span class="cm">		 * a position one bit further down the key and this</span>
<span class="cm">		 * means that the &quot;significant&quot; part of their keys</span>
<span class="cm">		 * (see the discussion near the top of this file)</span>
<span class="cm">		 * will differ by one bit, which will be &quot;0&quot; in</span>
<span class="cm">		 * left&#39;s key and &quot;1&quot; in right&#39;s key. Since we are</span>
<span class="cm">		 * moving the key position by one step, the bit that</span>
<span class="cm">		 * we are moving away from - the bit at position</span>
<span class="cm">		 * (inode-&gt;pos) - is the one that will differ between</span>
<span class="cm">		 * left and right. So... we synthesize that bit in the</span>
<span class="cm">		 * two  new keys.</span>
<span class="cm">		 * The mask &#39;m&#39; below will be a single &quot;one&quot; bit at</span>
<span class="cm">		 * the position (inode-&gt;pos)</span>
<span class="cm">		 */</span>

		<span class="cm">/* Use the old key, but set the new significant</span>
<span class="cm">		 *   bit to zero.</span>
<span class="cm">		 */</span>

		<span class="n">left</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">tnode_get_child</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="p">);</span>

		<span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">tnode_get_child</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">right</span><span class="p">);</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">tnode_child_length</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">rtnl_dereference</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">j</span><span class="p">]));</span>
			<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">rtnl_dereference</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">size</span><span class="p">]));</span>
		<span class="p">}</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">resize</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">left</span><span class="p">));</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">resize</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">right</span><span class="p">));</span>

		<span class="n">tnode_free_safe</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tnode_free_safe</span><span class="p">(</span><span class="n">oldtnode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tn</span><span class="p">;</span>
<span class="nl">nomem:</span>
	<span class="n">tnode_clean_free</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="nf">halve</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">oldtnode</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">olen</span> <span class="o">=</span> <span class="n">tnode_child_length</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;In halve</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">tn</span> <span class="o">=</span> <span class="n">tnode_new</span><span class="p">(</span><span class="n">oldtnode</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">oldtnode</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">oldtnode</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Preallocate and store tnodes before the actual work so we</span>
<span class="cm">	 * don&#39;t get into an inconsistent state if memory allocation</span>
<span class="cm">	 * fails. In case of failure we return the oldnode and halve</span>
<span class="cm">	 * of tnode is ignored.</span>
<span class="cm">	 */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">olen</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">tnode_get_child</span><span class="p">(</span><span class="n">oldtnode</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">right</span> <span class="o">=</span> <span class="n">tnode_get_child</span><span class="p">(</span><span class="n">oldtnode</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Two nonempty children */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">newn</span><span class="p">;</span>

			<span class="n">newn</span> <span class="o">=</span> <span class="n">tnode_new</span><span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newn</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

			<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">newn</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">olen</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">newBinNode</span><span class="p">;</span>

		<span class="n">left</span> <span class="o">=</span> <span class="n">tnode_get_child</span><span class="p">(</span><span class="n">oldtnode</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">right</span> <span class="o">=</span> <span class="n">tnode_get_child</span><span class="p">(</span><span class="n">oldtnode</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* At least one of the children is empty */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>    <span class="cm">/* Both are empty */</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Two nonempty children */</span>
		<span class="n">newBinNode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">tnode_get_child</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">newBinNode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">newBinNode</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">resize</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">newBinNode</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">tnode_free_safe</span><span class="p">(</span><span class="n">oldtnode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tn</span><span class="p">;</span>
<span class="nl">nomem:</span>
	<span class="n">tnode_clean_free</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* readside must use rcu_read_lock currently dump routines</span>
<span class="cm"> via get_fa_head and dump */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="nf">find_leaf_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">plen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">plen</span> <span class="o">==</span> <span class="n">plen</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">li</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">get_fa_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">plen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="n">find_leaf_info</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">li</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_leaf_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hlist_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">plen</span> <span class="o">&gt;</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">plen</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">last</span> <span class="o">=</span> <span class="n">li</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">)</span>
			<span class="n">hlist_add_after_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">hlist_add_before_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* rcu_read_lock needs to be hold by caller from readside */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span>
<span class="nf">fib_find_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">rcu_dereference_rtnl</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trie</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>  <span class="n">NODE_TYPE</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">T_TNODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>

		<span class="n">check_tnode</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tkey_sub_equals</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">-</span><span class="n">pos</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">tnode_get_child_rcu</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span>
						<span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
								  <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span>
								  <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Case we have found a leaf. Compare prefixes */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">IS_LEAF</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tkey_equals</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">trie_rebalance</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">wasfull</span><span class="p">;</span>
	<span class="n">t_key</span> <span class="n">cindex</span><span class="p">,</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">tn</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tp</span> <span class="o">=</span> <span class="n">node_parent</span><span class="p">((</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">tn</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cindex</span> <span class="o">=</span> <span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
		<span class="n">wasfull</span> <span class="o">=</span> <span class="n">tnode_full</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tnode_get_child</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cindex</span><span class="p">));</span>
		<span class="n">tn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">resize</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">tn</span><span class="p">);</span>

		<span class="n">tnode_put_child_reorg</span><span class="p">((</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">tp</span><span class="p">,</span> <span class="n">cindex</span><span class="p">,</span>
				      <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">tn</span><span class="p">,</span> <span class="n">wasfull</span><span class="p">);</span>

		<span class="n">tp</span> <span class="o">=</span> <span class="n">node_parent</span><span class="p">((</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">tn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="p">)</span>
			<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trie</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">tn</span><span class="p">);</span>

		<span class="n">tnode_free_flush</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">tn</span> <span class="o">=</span> <span class="n">tp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Handle last (top) tnode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_TNODE</span><span class="p">(</span><span class="n">tn</span><span class="p">))</span>
		<span class="n">tn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">resize</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">tn</span><span class="p">);</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trie</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">tn</span><span class="p">);</span>
	<span class="n">tnode_free_flush</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* only used from updater-side */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">fib_insert_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">plen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">newpos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">tn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">missbit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">fa_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span><span class="p">;</span>
	<span class="n">t_key</span> <span class="n">cindex</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">rtnl_dereference</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trie</span><span class="p">);</span>

	<span class="cm">/* If we point to NULL, stop. Either the tree is empty and we should</span>
<span class="cm">	 * just put a new leaf in if, or we have reached an empty child slot,</span>
<span class="cm">	 * and we should just put our new leaf in that.</span>
<span class="cm">	 * If we point to a T_TNODE, check if it matches our key. Note that</span>
<span class="cm">	 * a T_TNODE might be skipping any number of bits - its &#39;pos&#39; need</span>
<span class="cm">	 * not be the parent&#39;s &#39;pos&#39;+&#39;bits&#39;!</span>
<span class="cm">	 *</span>
<span class="cm">	 * If it does match the current key, get pos/bits from it, extract</span>
<span class="cm">	 * the index from our key, push the T_TNODE and walk the tree.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If it doesn&#39;t, we have to replace it with a new T_TNODE.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If we point to a T_LEAF, it might or might not have the same key</span>
<span class="cm">	 * as we do. If it does, just change the value, update the T_LEAF&#39;s</span>
<span class="cm">	 * value, and return it.</span>
<span class="cm">	 * If it doesn&#39;t, we need to replace it with a T_TNODE.</span>
<span class="cm">	 */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>  <span class="n">NODE_TYPE</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">T_TNODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>

		<span class="n">check_tnode</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tkey_sub_equals</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">-</span><span class="n">pos</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tp</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">tnode_get_child</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span>
					    <span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
							      <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span>
							      <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">));</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">node_parent</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">tn</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * n  ----&gt; NULL, LEAF or TNODE</span>
<span class="cm">	 *</span>
<span class="cm">	 * tp is n&#39;s (parent) ----&gt; NULL or TNODE</span>
<span class="cm">	 */</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tp</span> <span class="o">&amp;&amp;</span> <span class="n">IS_LEAF</span><span class="p">(</span><span class="n">tp</span><span class="p">));</span>

	<span class="cm">/* Case 1: n is a leaf. Compare prefixes */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">IS_LEAF</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tkey_equals</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">li</span> <span class="o">=</span> <span class="n">leaf_info_new</span><span class="p">(</span><span class="n">plen</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">li</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">fa_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">;</span>
		<span class="n">insert_leaf_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">li</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">leaf_new</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">li</span> <span class="o">=</span> <span class="n">leaf_info_new</span><span class="p">(</span><span class="n">plen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">li</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_leaf</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fa_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">;</span>
	<span class="n">insert_leaf_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">li</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trie</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Case 2: n is NULL, and will just insert a new leaf */</span>

		<span class="n">node_set_parent</span><span class="p">((</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">l</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>

		<span class="n">cindex</span> <span class="o">=</span> <span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">tp</span><span class="p">,</span> <span class="n">cindex</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">l</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Case 3: n is a LEAF or a TNODE and the key doesn&#39;t match. */</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Add a new tnode here</span>
<span class="cm">		 *  first tnode need some special handling</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="p">)</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">+</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">newpos</span> <span class="o">=</span> <span class="n">tkey_mismatch</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
			<span class="n">tn</span> <span class="o">=</span> <span class="n">tnode_new</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">newpos</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">newpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tn</span> <span class="o">=</span> <span class="n">tnode_new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">newpos</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* First tnode */</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_leaf_info</span><span class="p">(</span><span class="n">li</span><span class="p">);</span>
			<span class="n">free_leaf</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">node_set_parent</span><span class="p">((</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">tn</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>

		<span class="n">missbit</span> <span class="o">=</span> <span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">newpos</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">missbit</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">l</span><span class="p">);</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">missbit</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cindex</span> <span class="o">=</span> <span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
			<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">tp</span><span class="p">,</span> <span class="n">cindex</span><span class="p">,</span>
				  <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">tn</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trie</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">tn</span><span class="p">);</span>
			<span class="n">tp</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;fib_trie tp=%p pos=%d, bits=%d, key=%0x plen=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tp</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>

	<span class="cm">/* Rebalance the trie */</span>

	<span class="n">trie_rebalance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">fa_head</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Caller must hold RTNL.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fib_table_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib_config</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="p">)</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fib_alias</span> <span class="o">*</span><span class="n">fa</span><span class="p">,</span> <span class="o">*</span><span class="n">new_fa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">fa_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fib_info</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">plen</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_dst_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tos</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_tos</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_dst</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Insert table=%u %08x/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_id</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">inet_make_mask</span><span class="p">(</span><span class="n">plen</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">fi</span> <span class="o">=</span> <span class="n">fib_create_info</span><span class="p">(</span><span class="n">cfg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fi</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">fib_find_node</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="n">fa</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fa_head</span> <span class="o">=</span> <span class="n">get_fa_head</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
		<span class="n">fa</span> <span class="o">=</span> <span class="n">fib_find_alias</span><span class="p">(</span><span class="n">fa_head</span><span class="p">,</span> <span class="n">tos</span><span class="p">,</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_priority</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Now fa, if non-NULL, points to the first fib alias</span>
<span class="cm">	 * with the same keys [prefix,tos,priority], if such key already</span>
<span class="cm">	 * exists or to the node before which we will insert new one.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If fa is NULL, we will need to allocate a new one and</span>
<span class="cm">	 * insert to the head of f.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If f is NULL, no fib node matched the destination key</span>
<span class="cm">	 * and we need to allocate a new one of those as well.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fa</span> <span class="o">&amp;&amp;</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_tos</span> <span class="o">==</span> <span class="n">tos</span> <span class="o">&amp;&amp;</span>
	    <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="o">-&gt;</span><span class="n">fib_priority</span> <span class="o">==</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_priority</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fib_alias</span> <span class="o">*</span><span class="n">fa_first</span><span class="p">,</span> <span class="o">*</span><span class="n">fa_match</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_nlflags</span> <span class="o">&amp;</span> <span class="n">NLM_F_EXCL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* We have 2 goals:</span>
<span class="cm">		 * 1. Find exact match for type, scope, fib_info to avoid</span>
<span class="cm">		 * duplicate routes</span>
<span class="cm">		 * 2. Find next &#39;fa&#39; (or head), NLM_F_APPEND inserts before it</span>
<span class="cm">		 */</span>
		<span class="n">fa_match</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">fa_first</span> <span class="o">=</span> <span class="n">fa</span><span class="p">;</span>
		<span class="n">fa</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib_alias</span><span class="p">,</span> <span class="n">fa_list</span><span class="p">);</span>
		<span class="n">list_for_each_entry_continue</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fa_head</span><span class="p">,</span> <span class="n">fa_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_tos</span> <span class="o">!=</span> <span class="n">tos</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="o">-&gt;</span><span class="n">fib_priority</span> <span class="o">!=</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_priority</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_type</span> <span class="o">==</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_type</span> <span class="o">&amp;&amp;</span>
			    <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span> <span class="o">==</span> <span class="n">fi</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fa_match</span> <span class="o">=</span> <span class="n">fa</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_nlflags</span> <span class="o">&amp;</span> <span class="n">NLM_F_REPLACE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fib_info</span> <span class="o">*</span><span class="n">fi_drop</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">state</span><span class="p">;</span>

			<span class="n">fa</span> <span class="o">=</span> <span class="n">fa_first</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fa_match</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">fa</span> <span class="o">==</span> <span class="n">fa_match</span><span class="p">)</span>
					<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
			<span class="n">new_fa</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">fn_alias_kmem</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_fa</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">fi_drop</span> <span class="o">=</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="p">;</span>
			<span class="n">new_fa</span><span class="o">-&gt;</span><span class="n">fa_tos</span> <span class="o">=</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_tos</span><span class="p">;</span>
			<span class="n">new_fa</span><span class="o">-&gt;</span><span class="n">fa_info</span> <span class="o">=</span> <span class="n">fi</span><span class="p">;</span>
			<span class="n">new_fa</span><span class="o">-&gt;</span><span class="n">fa_type</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_type</span><span class="p">;</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_state</span><span class="p">;</span>
			<span class="n">new_fa</span><span class="o">-&gt;</span><span class="n">fa_state</span> <span class="o">=</span> <span class="n">state</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FA_S_ACCESSED</span><span class="p">;</span>

			<span class="n">list_replace_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_fa</span><span class="o">-&gt;</span><span class="n">fa_list</span><span class="p">);</span>
			<span class="n">alias_free_mem_rcu</span><span class="p">(</span><span class="n">fa</span><span class="p">);</span>

			<span class="n">fib_release_info</span><span class="p">(</span><span class="n">fi_drop</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">FA_S_ACCESSED</span><span class="p">)</span>
				<span class="n">rt_cache_flush</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_nlinfo</span><span class="p">.</span><span class="n">nl_net</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">rtmsg_fib</span><span class="p">(</span><span class="n">RTM_NEWROUTE</span><span class="p">,</span> <span class="n">htonl</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">new_fa</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span>
				<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_nlinfo</span><span class="p">,</span> <span class="n">NLM_F_REPLACE</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">succeeded</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Error if we find a perfect match which</span>
<span class="cm">		 * uses the same scope, type, and nexthop</span>
<span class="cm">		 * information.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fa_match</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_nlflags</span> <span class="o">&amp;</span> <span class="n">NLM_F_APPEND</span><span class="p">))</span>
			<span class="n">fa</span> <span class="o">=</span> <span class="n">fa_first</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_nlflags</span> <span class="o">&amp;</span> <span class="n">NLM_F_CREATE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="n">new_fa</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">fn_alias_kmem</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_fa</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">new_fa</span><span class="o">-&gt;</span><span class="n">fa_info</span> <span class="o">=</span> <span class="n">fi</span><span class="p">;</span>
	<span class="n">new_fa</span><span class="o">-&gt;</span><span class="n">fa_tos</span> <span class="o">=</span> <span class="n">tos</span><span class="p">;</span>
	<span class="n">new_fa</span><span class="o">-&gt;</span><span class="n">fa_type</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_type</span><span class="p">;</span>
	<span class="n">new_fa</span><span class="o">-&gt;</span><span class="n">fa_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Insert new entry to the list.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fa_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fa_head</span> <span class="o">=</span> <span class="n">fib_insert_node</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fa_head</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_new_fa</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">plen</span><span class="p">)</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_num_default</span><span class="o">++</span><span class="p">;</span>

	<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_fa</span><span class="o">-&gt;</span><span class="n">fa_list</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">fa</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_list</span> <span class="o">:</span> <span class="n">fa_head</span><span class="p">));</span>

	<span class="n">rt_cache_flush</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_nlinfo</span><span class="p">.</span><span class="n">nl_net</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">rtmsg_fib</span><span class="p">(</span><span class="n">RTM_NEWROUTE</span><span class="p">,</span> <span class="n">htonl</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">new_fa</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_id</span><span class="p">,</span>
		  <span class="o">&amp;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_nlinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">succeeded:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_new_fa:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">fn_alias_kmem</span><span class="p">,</span> <span class="n">new_fa</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">fib_release_info</span><span class="p">(</span><span class="n">fi</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* should be called with rcu_read_lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span>
		      <span class="n">t_key</span> <span class="n">key</span><span class="p">,</span>  <span class="k">const</span> <span class="k">struct</span> <span class="n">flowi4</span> <span class="o">*</span><span class="n">flp</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">fib_result</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fib_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hhead</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">hhead</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fib_alias</span> <span class="o">*</span><span class="n">fa</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">!=</span> <span class="p">(</span><span class="n">key</span> <span class="o">&amp;</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">mask_plen</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">,</span> <span class="n">fa_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fib_info</span> <span class="o">*</span><span class="n">fi</span> <span class="o">=</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">nhsel</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_tos</span> <span class="o">&amp;&amp;</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_tos</span> <span class="o">!=</span> <span class="n">flp</span><span class="o">-&gt;</span><span class="n">flowi4_tos</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_dead</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="o">-&gt;</span><span class="n">fib_scope</span> <span class="o">&lt;</span> <span class="n">flp</span><span class="o">-&gt;</span><span class="n">flowi4_scope</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">fib_alias_accessed</span><span class="p">(</span><span class="n">fa</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">fib_props</span><span class="p">[</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_type</span><span class="p">].</span><span class="n">error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">semantic_match_passed</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_flags</span> <span class="o">&amp;</span> <span class="n">RTNH_F_DEAD</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">nhsel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nhsel</span> <span class="o">&lt;</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_nhs</span><span class="p">;</span> <span class="n">nhsel</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">fib_nh</span> <span class="o">*</span><span class="n">nh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_nh</span><span class="p">[</span><span class="n">nhsel</span><span class="p">];</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">nh</span><span class="o">-&gt;</span><span class="n">nh_flags</span> <span class="o">&amp;</span> <span class="n">RTNH_F_DEAD</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flp</span><span class="o">-&gt;</span><span class="n">flowi4_oif</span> <span class="o">&amp;&amp;</span> <span class="n">flp</span><span class="o">-&gt;</span><span class="n">flowi4_oif</span> <span class="o">!=</span> <span class="n">nh</span><span class="o">-&gt;</span><span class="n">nh_oif</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
				<span class="n">t</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">semantic_match_passed</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">prefixlen</span> <span class="o">=</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">plen</span><span class="p">;</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">nh_sel</span> <span class="o">=</span> <span class="n">nhsel</span><span class="p">;</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_type</span><span class="p">;</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">scope</span> <span class="o">=</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="o">-&gt;</span><span class="n">fib_scope</span><span class="p">;</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">fi</span> <span class="o">=</span> <span class="n">fi</span><span class="p">;</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
				<span class="n">res</span><span class="o">-&gt;</span><span class="n">fa_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fib_flags</span> <span class="o">&amp;</span> <span class="n">FIB_LOOKUP_NOREF</span><span class="p">))</span>
					<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_clntref</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">semantic_match_miss</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fib_table_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">flowi4</span> <span class="o">*</span><span class="n">flp</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">fib_result</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fib_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="p">)</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">pn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bits</span><span class="p">;</span>
	<span class="n">t_key</span> <span class="n">key</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">flp</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">chopped_off</span><span class="p">;</span>
	<span class="n">t_key</span> <span class="n">cindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_prefix_length</span> <span class="o">=</span> <span class="n">KEYLENGTH</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">cn</span><span class="p">;</span>
	<span class="n">t_key</span> <span class="n">pref_mismatch</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trie</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">gets</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Just a leaf? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_LEAF</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">check_leaf</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">flp</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">fib_flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">chopped_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">pn</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="n">pn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chopped_off</span><span class="p">)</span>
			<span class="n">cindex</span> <span class="o">=</span> <span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">mask_pfx</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">current_prefix_length</span><span class="p">),</span>
						   <span class="n">pos</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">tnode_get_child_rcu</span><span class="p">(</span><span class="n">pn</span><span class="p">,</span> <span class="n">cindex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">null_node_hit</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="k">goto</span> <span class="n">backtrace</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_LEAF</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">check_leaf</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">flp</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">fib_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">backtrace</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s a tnode, and we can do some extra checks here if we</span>
<span class="cm">		 * like, to avoid descending into a dead-end branch.</span>
<span class="cm">		 * This tnode is in the parent&#39;s child array at index</span>
<span class="cm">		 * key[p_pos..p_pos+p_bits] but potentially with some bits</span>
<span class="cm">		 * chopped off, so in reality the index may be just a</span>
<span class="cm">		 * subprefix, padded with zero at the end.</span>
<span class="cm">		 * We can also take a look at any skipped bits in this</span>
<span class="cm">		 * tnode - everything up to p_pos is supposed to be ok,</span>
<span class="cm">		 * and the non-chopped bits of the index (se previous</span>
<span class="cm">		 * paragraph) are also guaranteed ok, but the rest is</span>
<span class="cm">		 * considered unknown.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The skipped bits are key[pos+bits..cn-&gt;pos].</span>
<span class="cm">		 */</span>

		<span class="cm">/* If current_prefix_length &lt; pos+bits, we are already doing</span>
<span class="cm">		 * actual prefix  matching, which means everything from</span>
<span class="cm">		 * pos+(bits-chopped_off) onward must be zero along some</span>
<span class="cm">		 * branch of this subtree - otherwise there is *no* valid</span>
<span class="cm">		 * prefix present. Here we can only check the skipped</span>
<span class="cm">		 * bits. Remember, since we have already indexed into the</span>
<span class="cm">		 * parent&#39;s child array, we know that the bits we chopped of</span>
<span class="cm">		 * *are* zero.</span>
<span class="cm">		 */</span>

		<span class="cm">/* NOTA BENE: Checking only skipped bits</span>
<span class="cm">		   for the new node here */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">current_prefix_length</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="o">+</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">current_prefix_length</span><span class="p">,</span>
						<span class="n">cn</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">-</span> <span class="n">current_prefix_length</span><span class="p">)</span>
			    <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
				<span class="k">goto</span> <span class="n">backtrace</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If chopped_off=0, the index is fully validated and we</span>
<span class="cm">		 * only need to look at the skipped bits for this, the new,</span>
<span class="cm">		 * tnode. What we actually want to do is to find out if</span>
<span class="cm">		 * these skipped bits match our key perfectly, or if we will</span>
<span class="cm">		 * have to count on finding a matching prefix further down,</span>
<span class="cm">		 * because if we do, we would like to have some way of</span>
<span class="cm">		 * verifying the existence of such a prefix at this point.</span>
<span class="cm">		 */</span>

		<span class="cm">/* The only thing we can do at this point is to verify that</span>
<span class="cm">		 * any such matching prefix can indeed be a prefix to our</span>
<span class="cm">		 * key, and if the bits in the node we are inspecting that</span>
<span class="cm">		 * do not match our key are not ZERO, this cannot be true.</span>
<span class="cm">		 * Thus, find out where there is a mismatch (before cn-&gt;pos)</span>
<span class="cm">		 * and verify that all the mismatching bits are zero in the</span>
<span class="cm">		 * new tnode&#39;s key.</span>
<span class="cm">		 */</span>

		<span class="cm">/*</span>
<span class="cm">		 * Note: We aren&#39;t very concerned about the piece of</span>
<span class="cm">		 * the key that precede pn-&gt;pos+pn-&gt;bits, since these</span>
<span class="cm">		 * have already been checked. The bits after cn-&gt;pos</span>
<span class="cm">		 * aren&#39;t checked since these are by definition</span>
<span class="cm">		 * &quot;unknown&quot; at this point. Thus, what we want to see</span>
<span class="cm">		 * is if we are about to enter the &quot;prefix matching&quot;</span>
<span class="cm">		 * state, and in that case verify that the skipped</span>
<span class="cm">		 * bits that will prevail throughout this subtree are</span>
<span class="cm">		 * zero, as they have to be if we are to find a</span>
<span class="cm">		 * matching prefix.</span>
<span class="cm">		 */</span>

		<span class="n">pref_mismatch</span> <span class="o">=</span> <span class="n">mask_pfx</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">^</span> <span class="n">key</span><span class="p">,</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * In short: If skipped bits in this node do not match</span>
<span class="cm">		 * the search key, enter the &quot;prefix matching&quot;</span>
<span class="cm">		 * state.directly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pref_mismatch</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">mp</span> <span class="o">=</span> <span class="n">KEYLENGTH</span> <span class="o">-</span> <span class="n">fls</span><span class="p">(</span><span class="n">pref_mismatch</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">cn</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">-</span> <span class="n">mp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">backtrace</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">current_prefix_length</span> <span class="o">&gt;=</span> <span class="n">cn</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">)</span>
				<span class="n">current_prefix_length</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="p">;</span> <span class="cm">/* Descend */</span>
		<span class="n">chopped_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">continue</span><span class="p">;</span>

<span class="nl">backtrace:</span>
		<span class="n">chopped_off</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* As zero don&#39;t change the child key (cindex) */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">chopped_off</span> <span class="o">&lt;=</span> <span class="n">pn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)</span>
		       <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cindex</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">chopped_off</span><span class="o">-</span><span class="mi">1</span><span class="p">))))</span>
			<span class="n">chopped_off</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Decrease current_... with bits chopped off */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current_prefix_length</span> <span class="o">&gt;</span> <span class="n">pn</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">pn</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">-</span> <span class="n">chopped_off</span><span class="p">)</span>
			<span class="n">current_prefix_length</span> <span class="o">=</span> <span class="n">pn</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">pn</span><span class="o">-&gt;</span><span class="n">bits</span>
				<span class="o">-</span> <span class="n">chopped_off</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Either we do the actual chop off according or if we have</span>
<span class="cm">		 * chopped off all bits in this tnode walk up to our parent.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chopped_off</span> <span class="o">&lt;=</span> <span class="n">pn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cindex</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">chopped_off</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node_parent_rcu</span><span class="p">((</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">pn</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

			<span class="cm">/* Get Child&#39;s index */</span>
			<span class="n">cindex</span> <span class="o">=</span> <span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">pn</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
			<span class="n">pn</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
			<span class="n">chopped_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">backtrack</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="k">goto</span> <span class="n">backtrace</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">failed:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">fib_table_lookup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the leaf and return parent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">trie_leaf_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">node_parent</span><span class="p">((</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">l</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;entering trie_leaf_remove(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t_key</span> <span class="n">cindex</span> <span class="o">=</span> <span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span>
		<span class="n">put_child</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">tp</span><span class="p">,</span> <span class="n">cindex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">trie_rebalance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trie</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">free_leaf</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Caller must hold RTNL.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fib_table_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib_config</span> <span class="o">*</span><span class="n">cfg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="p">)</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_data</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">plen</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_dst_len</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tos</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_tos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fib_alias</span> <span class="o">*</span><span class="n">fa</span><span class="p">,</span> <span class="o">*</span><span class="n">fa_to_delete</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">fa_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_dst</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">inet_make_mask</span><span class="p">(</span><span class="n">plen</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">fib_find_node</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="n">fa_head</span> <span class="o">=</span> <span class="n">get_fa_head</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
	<span class="n">fa</span> <span class="o">=</span> <span class="n">fib_find_alias</span><span class="p">(</span><span class="n">fa_head</span><span class="p">,</span> <span class="n">tos</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fa</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Deleting %08x/%d tos=%d t=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span> <span class="n">tos</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

	<span class="n">fa_to_delete</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fa</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_list</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib_alias</span><span class="p">,</span> <span class="n">fa_list</span><span class="p">);</span>
	<span class="n">list_for_each_entry_continue</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fa_head</span><span class="p">,</span> <span class="n">fa_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fib_info</span> <span class="o">*</span><span class="n">fi</span> <span class="o">=</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_tos</span> <span class="o">!=</span> <span class="n">tos</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_type</span> <span class="o">||</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_type</span> <span class="o">==</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_type</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_scope</span> <span class="o">==</span> <span class="n">RT_SCOPE_NOWHERE</span> <span class="o">||</span>
		     <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="o">-&gt;</span><span class="n">fib_scope</span> <span class="o">==</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_scope</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_prefsrc</span> <span class="o">||</span>
		     <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_prefsrc</span> <span class="o">==</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_prefsrc</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_protocol</span> <span class="o">||</span>
		     <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_protocol</span> <span class="o">==</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_protocol</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">fib_nh_match</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fa_to_delete</span> <span class="o">=</span> <span class="n">fa</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fa_to_delete</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>

	<span class="n">fa</span> <span class="o">=</span> <span class="n">fa_to_delete</span><span class="p">;</span>
	<span class="n">rtmsg_fib</span><span class="p">(</span><span class="n">RTM_DELROUTE</span><span class="p">,</span> <span class="n">htonl</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">fa</span><span class="p">,</span> <span class="n">plen</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_id</span><span class="p">,</span>
		  <span class="o">&amp;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_nlinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">fib_find_node</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="n">li</span> <span class="o">=</span> <span class="n">find_leaf_info</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>

	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">plen</span><span class="p">)</span>
		<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_num_default</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">fa_head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hlist_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
		<span class="n">free_leaf_info</span><span class="p">(</span><span class="n">li</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
		<span class="n">trie_leaf_remove</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_state</span> <span class="o">&amp;</span> <span class="n">FA_S_ACCESSED</span><span class="p">)</span>
		<span class="n">rt_cache_flush</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">fc_nlinfo</span><span class="p">.</span><span class="n">nl_net</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">fib_release_info</span><span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="p">);</span>
	<span class="n">alias_free_mem_rcu</span><span class="p">(</span><span class="n">fa</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">trie_flush_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fib_alias</span> <span class="o">*</span><span class="n">fa</span><span class="p">,</span> <span class="o">*</span><span class="n">fa_node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fa_node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">fa_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fib_info</span> <span class="o">*</span><span class="n">fi</span> <span class="o">=</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fi</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_flags</span> <span class="o">&amp;</span> <span class="n">RTNH_F_DEAD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_list</span><span class="p">);</span>
			<span class="n">fib_release_info</span><span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="p">);</span>
			<span class="n">alias_free_mem_rcu</span><span class="p">(</span><span class="n">fa</span><span class="p">);</span>
			<span class="n">found</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">trie_flush_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">lih</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">lih</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">found</span> <span class="o">+=</span> <span class="n">trie_flush_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hlist_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
			<span class="n">free_leaf_info</span><span class="p">(</span><span class="n">li</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan for the next right leaf starting at node p-&gt;child[idx]</span>
<span class="cm"> * Since we have back pointer, no recursion necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="nf">leaf_walk_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">t_key</span> <span class="n">idx</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span> <span class="o">=</span> <span class="n">tnode_get_child_rcu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">idx</span><span class="o">++</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">IS_LEAF</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">prefetch</span><span class="p">(</span><span class="n">rcu_dereference_rtnl</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">idx</span><span class="p">]));</span>
				<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="p">)</span> <span class="n">c</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Rescan start scanning in new node */</span>
			<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">c</span><span class="p">;</span>
			<span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Node empty, walk back up to parent */</span>
		<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">node_parent_rcu</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* Root of trie */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="nf">trie_firstleaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span><span class="n">rcu_dereference_rtnl</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trie</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_LEAF</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>          <span class="cm">/* trie is just a leaf */</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">leaf_walk_rcu</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="nf">trie_nextleaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="n">l</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">node_parent_rcu</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* trie with just one leaf */</span>

	<span class="k">return</span> <span class="n">leaf_walk_rcu</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="nf">trie_leafindex</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">trie_firstleaf</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">index</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">trie_nextleaf</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Caller must hold RTNL.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fib_table_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="p">)</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="o">*</span><span class="n">ll</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">trie_firstleaf</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">l</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">trie_nextleaf</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">found</span> <span class="o">+=</span> <span class="n">trie_flush_leaf</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&amp;&amp;</span> <span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ll</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
			<span class="n">trie_leaf_remove</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ll</span><span class="p">);</span>
		<span class="n">ll</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ll</span> <span class="o">&amp;&amp;</span> <span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ll</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span>
		<span class="n">trie_leaf_remove</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ll</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;trie_flush found=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">fib_free_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fn_trie_dump_fa</span><span class="p">(</span><span class="n">t_key</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">plen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">fah</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">s_i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fib_alias</span> <span class="o">*</span><span class="n">fa</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="n">xkey</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="n">s_i</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* rcu_read_lock is hold by caller */</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fah</span><span class="p">,</span> <span class="n">fa_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s_i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fib_dump_info</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">NETLINK_CB</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">,</span>
				  <span class="n">cb</span><span class="o">-&gt;</span><span class="n">nlh</span><span class="o">-&gt;</span><span class="n">nlmsg_seq</span><span class="p">,</span>
				  <span class="n">RTM_NEWROUTE</span><span class="p">,</span>
				  <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_id</span><span class="p">,</span>
				  <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_type</span><span class="p">,</span>
				  <span class="n">xkey</span><span class="p">,</span>
				  <span class="n">plen</span><span class="p">,</span>
				  <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_tos</span><span class="p">,</span>
				  <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="p">,</span> <span class="n">NLM_F_MULTI</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fn_trie_dump_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">s_i</span><span class="p">;</span>

	<span class="n">s_i</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* rcu_read_lock is hold by caller */</span>
	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s_i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">s_i</span><span class="p">)</span>
			<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fn_trie_dump_fa</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">plen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fib_table_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">netlink_callback</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="p">)</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_data</span><span class="p">;</span>
	<span class="n">t_key</span> <span class="n">key</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="cm">/* Dump starting at last key.</span>
<span class="cm">	 * Note: 0.0.0.0/0 (ie default) is first key.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">trie_firstleaf</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Normally, continue from last key, but if that is missing</span>
<span class="cm">		 * fallback to using slow rescan</span>
<span class="cm">		 */</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">fib_find_node</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="p">)</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">trie_leafindex</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fn_trie_dump_leaf</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">tb</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">cb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">++</span><span class="n">count</span><span class="p">;</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">trie_nextleaf</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">fib_trie_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fn_alias_kmem</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;ip_fib_alias&quot;</span><span class="p">,</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_alias</span><span class="p">),</span>
					  <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">trie_leaf_kmem</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;ip_fib_trie&quot;</span><span class="p">,</span>
					   <span class="n">max</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span><span class="p">),</span>
					       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf_info</span><span class="p">)),</span>
					   <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="nf">fib_trie_table</span><span class="p">(</span><span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">tb</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_table</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span><span class="p">),</span>
		     <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_default</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_num_default</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="p">)</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_data</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">tb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/* Depth first Trie walk iterator */</span>
<span class="k">struct</span> <span class="n">fib_trie_iter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_net_private</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="nf">fib_trie_get_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_trie_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">tnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cindex</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/* A single entry routing table */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tn</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;get_next iter={node=%p index=%d depth=%d}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">iter</span><span class="o">-&gt;</span><span class="n">tnode</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">);</span>
<span class="nl">rescan:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cindex</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">tnode_get_child_rcu</span><span class="p">(</span><span class="n">tn</span><span class="p">,</span> <span class="n">cindex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_LEAF</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tnode</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
				<span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">cindex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* push down one level */</span>
				<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>
				<span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="o">++</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">++</span><span class="n">cindex</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Current node exhausted, pop back up */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">node_parent_rcu</span><span class="p">((</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span><span class="n">tn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cindex</span> <span class="o">=</span> <span class="n">tkey_extract_bits</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">tn</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="o">--</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">rescan</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* got root? */</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="nf">fib_trie_get_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_trie_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">trie</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_TNODE</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tnode</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">trie_collect_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">trie_stat</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fib_trie_iter</span> <span class="n">iter</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">));</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">fib_trie_get_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">n</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fib_trie_get_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_LEAF</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">leaves</span><span class="o">++</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">totdepth</span> <span class="o">+=</span> <span class="n">iter</span><span class="p">.</span><span class="n">depth</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdepth</span><span class="p">)</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">maxdepth</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">depth</span><span class="p">;</span>

			<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span>
				<span class="o">++</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">prefixes</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">tnodes</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="n">MAX_STAT_DEPTH</span><span class="p">)</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">nodesizes</span><span class="p">[</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
					<span class="n">s</span><span class="o">-&gt;</span><span class="n">nullpointers</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	This outputs /proc/net/fib_triestats</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">trie_show_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">trie_stat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">pointers</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">avdepth</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">leaves</span><span class="p">)</span>
		<span class="n">avdepth</span> <span class="o">=</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">totdepth</span><span class="o">*</span><span class="mi">100</span> <span class="o">/</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">leaves</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">avdepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Aver depth:     %u.%02d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">avdepth</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="n">avdepth</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Max depth:      %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">maxdepth</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Leaves:         %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">leaves</span><span class="p">);</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">*</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">leaves</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Prefixes:       %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">prefixes</span><span class="p">);</span>
	<span class="n">bytes</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf_info</span><span class="p">)</span> <span class="o">*</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">prefixes</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Internal nodes: %u</span><span class="se">\n\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">tnodes</span><span class="p">);</span>
	<span class="n">bytes</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span><span class="p">)</span> <span class="o">*</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">tnodes</span><span class="p">;</span>

	<span class="n">max</span> <span class="o">=</span> <span class="n">MAX_STAT_DEPTH</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">max</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">nodesizes</span><span class="p">[</span><span class="n">max</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">max</span><span class="o">--</span><span class="p">;</span>

	<span class="n">pointers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">nodesizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  %u: %u&quot;</span><span class="p">,</span>  <span class="n">i</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">nodesizes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">pointers</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">nodesizes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">Pointers: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pointers</span><span class="p">);</span>

	<span class="n">bytes</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">pointers</span><span class="p">;</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Null ptrs: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat</span><span class="o">-&gt;</span><span class="n">nullpointers</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Total size: %u  kB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">+</span> <span class="mi">1023</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">trie_show_usage</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">trie_use_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Counters:</span><span class="se">\n</span><span class="s">---------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;gets = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">gets</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;backtracks = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">backtrack</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;semantic match passed = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">semantic_match_passed</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;semantic match miss = %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">semantic_match_miss</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;null node hit= %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">null_node_hit</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;skipped node resize = %u</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">resize_node_skipped</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/*  CONFIG_IP_FIB_TRIE_STATS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fib_table_print</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_id</span> <span class="o">==</span> <span class="n">RT_TABLE_LOCAL</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Local:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_id</span> <span class="o">==</span> <span class="n">RT_TABLE_MAIN</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Main:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Id %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_id</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">fib_triestat_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">)</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>
		   <span class="s">&quot;Basic info: size of leaf:&quot;</span>
		   <span class="s">&quot; %Zd bytes, size of tnode: %Zd bytes.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">FIB_TABLE_HASHSZ</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ipv4</span><span class="p">.</span><span class="n">fib_table_hash</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>

		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tb_hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="p">)</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_data</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">trie_stat</span> <span class="n">stat</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">fib_table_print</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">tb</span><span class="p">);</span>

			<span class="n">trie_collect_stats</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">);</span>
			<span class="n">trie_show_stats</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_IP_FIB_TRIE_STATS</span>
			<span class="n">trie_show_usage</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fib_triestat_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open_net</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">fib_triestat_seq_show</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fib_triestat_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>	<span class="o">=</span> <span class="n">fib_triestat_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>	<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>	<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release_net</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="nf">fib_trie_get_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fib_trie_iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">seq_file_net</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">FIB_TABLE_HASHSZ</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ipv4</span><span class="p">.</span><span class="n">fib_table_hash</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>

		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tb_hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">fib_trie_get_first</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span>
						    <span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="p">)</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_data</span><span class="p">);</span>
			     <span class="n">n</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fib_trie_get_next</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
					<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
				<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fib_trie_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">fib_trie_get_idx</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fib_trie_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fib_trie_iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">seq_file_net</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tb_node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="cm">/* next node in same table */</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">fib_trie_get_next</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">n</span><span class="p">;</span>

	<span class="cm">/* walk rest of this hash chain */</span>
	<span class="n">h</span> <span class="o">=</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_id</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FIB_TABLE_HASHSZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">tb_node</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">hlist_next_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_hlist</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">tb</span> <span class="o">=</span> <span class="n">hlist_entry</span><span class="p">(</span><span class="n">tb_node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fib_table</span><span class="p">,</span> <span class="n">tb_hlist</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">fib_trie_get_first</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="p">)</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* new hash chain */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">FIB_TABLE_HASHSZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">ipv4</span><span class="p">.</span><span class="n">fib_table_hash</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">tb_node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tb_hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">fib_trie_get_first</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="p">)</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">tb</span> <span class="o">=</span> <span class="n">tb</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fib_trie_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">seq_indent</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;   &quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">rtn_scope</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="k">enum</span> <span class="n">rt_scope_t</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RT_SCOPE_UNIVERSE</span>: <span class="k">return</span> <span class="s">&quot;universe&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RT_SCOPE_SITE</span>:	<span class="k">return</span> <span class="s">&quot;site&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RT_SCOPE_LINK</span>:	<span class="k">return</span> <span class="s">&quot;link&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RT_SCOPE_HOST</span>:	<span class="k">return</span> <span class="s">&quot;host&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RT_SCOPE_NOWHERE</span>:	<span class="k">return</span> <span class="s">&quot;nowhere&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;scope=%d&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">rtn_type_names</span><span class="p">[</span><span class="n">__RTN_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">RTN_UNSPEC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;UNSPEC&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RTN_UNICAST</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;UNICAST&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RTN_LOCAL</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;LOCAL&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RTN_BROADCAST</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;BROADCAST&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RTN_ANYCAST</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;ANYCAST&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RTN_MULTICAST</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;MULTICAST&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RTN_BLACKHOLE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;BLACKHOLE&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RTN_UNREACHABLE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;UNREACHABLE&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RTN_PROHIBIT</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;PROHIBIT&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RTN_THROW</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;THROW&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RTN_NAT</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;NAT&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">RTN_XRESOLVE</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;XRESOLVE&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">rtn_type</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">__RTN_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">rtn_type_names</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">rtn_type_names</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;type %u&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pretty print the trie */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fib_trie_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fib_trie_iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rt_trie_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_parent_rcu</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
		<span class="n">fib_table_print</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">tb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_TNODE</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="n">tn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tnode</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">__be32</span> <span class="n">prf</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">mask_pfx</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">));</span>

		<span class="n">seq_indent</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  +-- %pI4/%d %d %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">prf</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">bits</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">full_children</span><span class="p">,</span>
			   <span class="n">tn</span><span class="o">-&gt;</span><span class="n">empty_children</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="p">)</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
		<span class="n">__be32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

		<span class="n">seq_indent</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  |-- %pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

		<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fib_alias</span> <span class="o">*</span><span class="n">fa</span><span class="p">;</span>

			<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">,</span> <span class="n">fa_list</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">char</span> <span class="n">buf1</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">buf2</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

				<span class="n">seq_indent</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;  /%d %s %s&quot;</span><span class="p">,</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">plen</span><span class="p">,</span>
					   <span class="n">rtn_scope</span><span class="p">(</span><span class="n">buf1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf1</span><span class="p">),</span>
						     <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="o">-&gt;</span><span class="n">fib_scope</span><span class="p">),</span>
					   <span class="n">rtn_type</span><span class="p">(</span><span class="n">buf2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf2</span><span class="p">),</span>
						    <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_type</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_tos</span><span class="p">)</span>
					<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot; tos=%d&quot;</span><span class="p">,</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_tos</span><span class="p">);</span>
				<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">fib_trie_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>  <span class="o">=</span> <span class="n">fib_trie_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>   <span class="o">=</span> <span class="n">fib_trie_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>   <span class="o">=</span> <span class="n">fib_trie_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>   <span class="o">=</span> <span class="n">fib_trie_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fib_trie_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open_net</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fib_trie_seq_ops</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_trie_iter</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fib_trie_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>   <span class="o">=</span> <span class="n">fib_trie_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>   <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release_net</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fib_route_iter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_net_private</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">main_trie</span><span class="p">;</span>
	<span class="n">loff_t</span>	<span class="n">pos</span><span class="p">;</span>
	<span class="n">t_key</span>	<span class="n">key</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="nf">fib_route_get_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_route_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">main_trie</span><span class="p">;</span>

	<span class="cm">/* use cache location of last found key */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">fib_find_node</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)))</span>
		<span class="n">pos</span> <span class="o">-=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">trie_firstleaf</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">++</span><span class="p">;</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">trie_nextleaf</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>	<span class="cm">/* remember it */</span>
	<span class="k">else</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* forget it */</span>

	<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fib_route_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fib_route_iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fib_table</span> <span class="o">*</span><span class="n">tb</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">tb</span> <span class="o">=</span> <span class="n">fib_get_table</span><span class="p">(</span><span class="n">seq_file_net</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span> <span class="n">RT_TABLE_MAIN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">iter</span><span class="o">-&gt;</span><span class="n">main_trie</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">trie</span> <span class="o">*</span><span class="p">)</span> <span class="n">tb</span><span class="o">-&gt;</span><span class="n">tb_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SEQ_START_TOKEN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">fib_route_get_idx</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">fib_route_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fib_route_iter</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">trie_firstleaf</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">main_trie</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span><span class="o">++</span><span class="p">;</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">trie_nextleaf</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fib_route_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">fib_flag_trans</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">mask</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fib_info</span> <span class="o">*</span><span class="n">fi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">RTN_UNREACHABLE</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">RTN_PROHIBIT</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">RTF_REJECT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fi</span> <span class="o">&amp;&amp;</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_nh</span><span class="o">-&gt;</span><span class="n">nh_gw</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">RTF_GATEWAY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="n">htonl</span><span class="p">(</span><span class="mh">0xFFFFFFFF</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">RTF_HOST</span><span class="p">;</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">RTF_UP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	This outputs /proc/net/route.</span>
<span class="cm"> *	The format of the file is not supposed to be changed</span>
<span class="cm"> *	and needs to be same as fib_hash output to avoid breaking</span>
<span class="cm"> *	legacy utilities</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fib_route_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">leaf</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">leaf_info</span> <span class="o">*</span><span class="n">li</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-127s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;Iface</span><span class="se">\t</span><span class="s">Destination</span><span class="se">\t</span><span class="s">Gateway &quot;</span>
			   <span class="s">&quot;</span><span class="se">\t</span><span class="s">Flags</span><span class="se">\t</span><span class="s">RefCnt</span><span class="se">\t</span><span class="s">Use</span><span class="se">\t</span><span class="s">Metric</span><span class="se">\t</span><span class="s">Mask</span><span class="se">\t\t</span><span class="s">MTU&quot;</span>
			   <span class="s">&quot;</span><span class="se">\t</span><span class="s">Window</span><span class="se">\t</span><span class="s">IRTT&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">fib_alias</span> <span class="o">*</span><span class="n">fa</span><span class="p">;</span>
		<span class="n">__be32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">prefix</span><span class="p">;</span>

		<span class="n">mask</span> <span class="o">=</span> <span class="n">inet_make_mask</span><span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">plen</span><span class="p">);</span>
		<span class="n">prefix</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">falh</span><span class="p">,</span> <span class="n">fa_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">fib_info</span> <span class="o">*</span><span class="n">fi</span> <span class="o">=</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_info</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">fib_flag_trans</span><span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_type</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_type</span> <span class="o">==</span> <span class="n">RTN_BROADCAST</span>
			    <span class="o">||</span> <span class="n">fa</span><span class="o">-&gt;</span><span class="n">fa_type</span> <span class="o">==</span> <span class="n">RTN_MULTICAST</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">fi</span><span class="p">)</span>
				<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>
					 <span class="s">&quot;%s</span><span class="se">\t</span><span class="s">%08X</span><span class="se">\t</span><span class="s">%08X</span><span class="se">\t</span><span class="s">%04X</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%u</span><span class="se">\t</span><span class="s">&quot;</span>
					 <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">%08X</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%u</span><span class="se">\t</span><span class="s">%u%n&quot;</span><span class="p">,</span>
					 <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_dev</span> <span class="o">?</span> <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;*&quot;</span><span class="p">,</span>
					 <span class="n">prefix</span><span class="p">,</span>
					 <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_nh</span><span class="o">-&gt;</span><span class="n">nh_gw</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					 <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_priority</span><span class="p">,</span>
					 <span class="n">mask</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_advmss</span> <span class="o">?</span>
					  <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_advmss</span> <span class="o">+</span> <span class="mi">40</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
					 <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_window</span><span class="p">,</span>
					 <span class="n">fi</span><span class="o">-&gt;</span><span class="n">fib_rtt</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span>
					 <span class="s">&quot;*</span><span class="se">\t</span><span class="s">%08X</span><span class="se">\t</span><span class="s">%08X</span><span class="se">\t</span><span class="s">%04X</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%u</span><span class="se">\t</span><span class="s">&quot;</span>
					 <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">%08X</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%u</span><span class="se">\t</span><span class="s">%u%n&quot;</span><span class="p">,</span>
					 <span class="n">prefix</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					 <span class="n">mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%*s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">127</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">fib_route_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>  <span class="o">=</span> <span class="n">fib_route_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>   <span class="o">=</span> <span class="n">fib_route_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>   <span class="o">=</span> <span class="n">fib_route_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>   <span class="o">=</span> <span class="n">fib_route_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fib_route_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open_net</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fib_route_seq_ops</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fib_route_iter</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fib_route_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>   <span class="o">=</span> <span class="n">fib_route_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>   <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release_net</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__net_init</span> <span class="nf">fib_proc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_net_fops_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;fib_trie&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fib_trie_fops</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_net_fops_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;fib_triestat&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">fib_triestat_fops</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_net_fops_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;route&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fib_route_fops</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out3</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out3:</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;fib_triestat&quot;</span><span class="p">);</span>
<span class="nl">out2:</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;fib_trie&quot;</span><span class="p">);</span>
<span class="nl">out1:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__net_exit</span> <span class="nf">fib_proc_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;fib_trie&quot;</span><span class="p">);</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;fib_triestat&quot;</span><span class="p">);</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;route&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
