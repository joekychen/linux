<!DOCTYPE html>
<html><head><title>joekychen/linux » net › ipv4 › tcp_input.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>tcp_input.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  INET is implemented using the  BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *		Implementation of the Transmission Control Protocol(TCP).</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Ross Biro</span>
<span class="cm"> *		Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *		Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;</span>
<span class="cm"> *		Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;</span>
<span class="cm"> *		Florian La Roche, &lt;flla@stud.uni-sb.de&gt;</span>
<span class="cm"> *		Charles Hedrick, &lt;hedrick@klinzhai.rutgers.edu&gt;</span>
<span class="cm"> *		Linus Torvalds, &lt;torvalds@cs.helsinki.fi&gt;</span>
<span class="cm"> *		Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;</span>
<span class="cm"> *		Matthew Dillon, &lt;dillon@apollo.west.oic.com&gt;</span>
<span class="cm"> *		Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;</span>
<span class="cm"> *		Jorge Cwik, &lt;jorge@laser.satlink.net&gt;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Changes:</span>
<span class="cm"> *		Pedro Roque	:	Fast Retransmit/Recovery.</span>
<span class="cm"> *					Two receive queues.</span>
<span class="cm"> *					Retransmit queue handled by TCP.</span>
<span class="cm"> *					Better retransmit timer handling.</span>
<span class="cm"> *					New congestion avoidance.</span>
<span class="cm"> *					Header prediction.</span>
<span class="cm"> *					Variable renaming.</span>
<span class="cm"> *</span>
<span class="cm"> *		Eric		:	Fast Retransmit.</span>
<span class="cm"> *		Randy Scott	:	MSS option defines.</span>
<span class="cm"> *		Eric Schenk	:	Fixes to slow start algorithm.</span>
<span class="cm"> *		Eric Schenk	:	Yet another double ACK bug.</span>
<span class="cm"> *		Eric Schenk	:	Delayed ACK bug fixes.</span>
<span class="cm"> *		Eric Schenk	:	Floyd style fast retrans war avoidance.</span>
<span class="cm"> *		David S. Miller	:	Don&#39;t allow zero congestion window.</span>
<span class="cm"> *		Eric Schenk	:	Fix retransmitter so that it sends</span>
<span class="cm"> *					next packet on ack of previous packet.</span>
<span class="cm"> *		Andi Kleen	:	Moved open_request checking here</span>
<span class="cm"> *					and process RSTs for open_requests.</span>
<span class="cm"> *		Andi Kleen	:	Better prune_queue, and other fixes.</span>
<span class="cm"> *		Andrey Savochkin:	Fix RTT measurements in the presence of</span>
<span class="cm"> *					timestamps.</span>
<span class="cm"> *		Andrey Savochkin:	Check sequence numbers correctly when</span>
<span class="cm"> *					removing SACKs due to in sequence incoming</span>
<span class="cm"> *					data segments.</span>
<span class="cm"> *		Andi Kleen:		Make sure we never ack data there is not</span>
<span class="cm"> *					enough room for. Also make this condition</span>
<span class="cm"> *					a fatal error if it might still happen.</span>
<span class="cm"> *		Andi Kleen:		Add tcp_measure_rcv_mss to make</span>
<span class="cm"> *					connections with MSS&lt;min(MTU,ann. MSS)</span>
<span class="cm"> *					work without delayed acks.</span>
<span class="cm"> *		Andi Kleen:		Process packets with PSH set in the</span>
<span class="cm"> *					fast path.</span>
<span class="cm"> *		J Hadi Salim:		ECN support</span>
<span class="cm"> *	 	Andrei Gurtov,</span>
<span class="cm"> *		Pasi Sarolahti,</span>
<span class="cm"> *		Panu Kuhlberg:		Experimental audit of TCP (re)transmission</span>
<span class="cm"> *					engine. Lots of bugs are found.</span>
<span class="cm"> *		Pasi Sarolahti:		F-RTO for dealing with spurious RTOs</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) &quot;TCP: &quot; fmt</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;net/dst.h&gt;</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#include &lt;net/inet_common.h&gt;</span>
<span class="cp">#include &lt;linux/ipsec.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &lt;net/netdma.h&gt;</span>

<span class="kt">int</span> <span class="n">sysctl_tcp_timestamps</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_window_scaling</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_sack</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_fack</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_reordering</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">TCP_FASTRETRANS_THRESH</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sysctl_tcp_reordering</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_ecn</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sysctl_tcp_ecn</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_dsack</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_app_win</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_adv_win_scale</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sysctl_tcp_adv_win_scale</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">sysctl_tcp_stdurg</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_rfc1337</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_max_orphans</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">NR_FILE</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_frto</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_frto_response</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_nometrics_save</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">sysctl_tcp_thin_dupack</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">sysctl_tcp_moderate_rcvbuf</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_abc</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_tcp_early_retrans</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="cp">#define FLAG_DATA		0x01 </span><span class="cm">/* Incoming frame contained data.		*/</span><span class="cp"></span>
<span class="cp">#define FLAG_WIN_UPDATE		0x02 </span><span class="cm">/* Incoming ACK was a window update.	*/</span><span class="cp"></span>
<span class="cp">#define FLAG_DATA_ACKED		0x04 </span><span class="cm">/* This ACK acknowledged new data.		*/</span><span class="cp"></span>
<span class="cp">#define FLAG_RETRANS_DATA_ACKED	0x08 </span><span class="cm">/* &quot;&quot; &quot;&quot; some of which was retransmitted.	*/</span><span class="cp"></span>
<span class="cp">#define FLAG_SYN_ACKED		0x10 </span><span class="cm">/* This ACK acknowledged SYN.		*/</span><span class="cp"></span>
<span class="cp">#define FLAG_DATA_SACKED	0x20 </span><span class="cm">/* New SACK.				*/</span><span class="cp"></span>
<span class="cp">#define FLAG_ECE		0x40 </span><span class="cm">/* ECE in this ACK				*/</span><span class="cp"></span>
<span class="cp">#define FLAG_SLOWPATH		0x100 </span><span class="cm">/* Do not skip RFC checks for window update.*/</span><span class="cp"></span>
<span class="cp">#define FLAG_ONLY_ORIG_SACKED	0x200 </span><span class="cm">/* SACKs only non-rexmit sent before RTO */</span><span class="cp"></span>
<span class="cp">#define FLAG_SND_UNA_ADVANCED	0x400 </span><span class="cm">/* Snd_una was changed (!= FLAG_DATA_ACKED) */</span><span class="cp"></span>
<span class="cp">#define FLAG_DSACKING_ACK	0x800 </span><span class="cm">/* SACK blocks contained D-SACK info */</span><span class="cp"></span>
<span class="cp">#define FLAG_NONHEAD_RETRANS_ACKED	0x1000 </span><span class="cm">/* Non-head rexmitted data was ACKed */</span><span class="cp"></span>
<span class="cp">#define FLAG_SACK_RENEGING	0x2000 </span><span class="cm">/* snd_una advanced to a sacked seq */</span><span class="cp"></span>

<span class="cp">#define FLAG_ACKED		(FLAG_DATA_ACKED|FLAG_SYN_ACKED)</span>
<span class="cp">#define FLAG_NOT_DUP		(FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)</span>
<span class="cp">#define FLAG_CA_ALERT		(FLAG_DATA_SACKED|FLAG_ECE)</span>
<span class="cp">#define FLAG_FORWARD_PROGRESS	(FLAG_ACKED|FLAG_DATA_SACKED)</span>
<span class="cp">#define FLAG_ANY_PROGRESS	(FLAG_FORWARD_PROGRESS|FLAG_SND_UNA_ADVANCED)</span>

<span class="cp">#define TCP_REMNANT (TCP_FLAG_FIN|TCP_FLAG_URG|TCP_FLAG_SYN|TCP_FLAG_PSH)</span>
<span class="cp">#define TCP_HP_BITS (~(TCP_RESERVED_BITS|TCP_FLAG_PSH))</span>

<span class="cm">/* Adapt the MSS value used to make delayed ack decision to the</span>
<span class="cm"> * real world.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_measure_rcv_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lss</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">last_seg_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">last_seg_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* skb-&gt;len may jitter because of SACKs, even if peer</span>
<span class="cm">	 * sends good full-sized frames.</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">?</span> <span class="o">:</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">rcv_mss</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">rcv_mss</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Otherwise, we make more careful check taking into account,</span>
<span class="cm">		 * that SACKs block is variable.</span>
<span class="cm">		 *</span>
<span class="cm">		 * &quot;len&quot; is invariant segment length, including TCP header.</span>
<span class="cm">		 */</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">TCP_MSS_DEFAULT</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">||</span>
		    <span class="cm">/* If PSH is not set, packet should be</span>
<span class="cm">		     * full sized, provided peer TCP is not badly broken.</span>
<span class="cm">		     * This observation (if it is correct 8)) allows</span>
<span class="cm">		     * to handle super-low mtu links fairly.</span>
<span class="cm">		     */</span>
		    <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">TCP_MIN_MSS</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="p">(</span><span class="n">tcp_flag_word</span><span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">TCP_REMNANT</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* Subtract also invariant (if peer is RFC compliant),</span>
<span class="cm">			 * tcp header plus fixed timestamp option length.</span>
<span class="cm">			 * Resulting &quot;len&quot; is MSS free of SACK jitter.</span>
<span class="cm">			 */</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span><span class="p">;</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">last_seg_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">lss</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">rcv_mss</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pending</span> <span class="o">&amp;</span> <span class="n">ICSK_ACK_PUSHED</span><span class="p">)</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pending</span> <span class="o">|=</span> <span class="n">ICSK_ACK_PUSHED2</span><span class="p">;</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pending</span> <span class="o">|=</span> <span class="n">ICSK_ACK_PUSHED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_incr_quickack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">quickacks</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">rcv_mss</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">quickacks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">quickacks</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">quickacks</span> <span class="o">&gt;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">quick</span><span class="p">)</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">quick</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">quickacks</span><span class="p">,</span> <span class="n">TCP_MAX_QUICKACKS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_enter_quickack_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tcp_incr_quickack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span> <span class="o">=</span> <span class="n">TCP_ATO_MIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Send ACKs quickly, if &quot;quick&quot; count is not exhausted</span>
<span class="cm"> * and the session is not interactive.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_in_quickack_mode</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">quick</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">TCP_ECN_queue_cwr</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_OK</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">|=</span> <span class="n">TCP_ECN_QUEUE_CWR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">TCP_ECN_accept_cwr</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cwr</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_ECN_DEMAND_CWR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">TCP_ECN_withdraw_cwr</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_ECN_DEMAND_CWR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">TCP_ECN_check_ce</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_OK</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ip_dsfield</span> <span class="o">&amp;</span> <span class="n">INET_ECN_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INET_ECN_NOT_ECT</span>:
		<span class="cm">/* Funny extension: if ECT is not set on a segment,</span>
<span class="cm">		 * and we already seen ECT on a previous segment,</span>
<span class="cm">		 * it is probably a retransmit.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_SEEN</span><span class="p">)</span>
			<span class="n">tcp_enter_quickack_mode</span><span class="p">((</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">tp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INET_ECN_CE</span>:
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">|=</span> <span class="n">TCP_ECN_DEMAND_CWR</span><span class="p">;</span>
		<span class="cm">/* fallinto */</span>
	<span class="nl">default:</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">|=</span> <span class="n">TCP_ECN_SEEN</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">TCP_ECN_rcv_synack</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_OK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ece</span> <span class="o">||</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">cwr</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_ECN_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">TCP_ECN_rcv_syn</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_OK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ece</span> <span class="o">||</span> <span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">cwr</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_ECN_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">TCP_ECN_rcv_ecn_echo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ece</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ecn_flags</span> <span class="o">&amp;</span> <span class="n">TCP_ECN_OK</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Buffer size and advertised window tuning.</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Tuning sk-&gt;sk_sndbuf, when connection enters established state.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_fixup_sndbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sndmem</span> <span class="o">=</span> <span class="n">SKB_TRUESIZE</span><span class="p">(</span><span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span> <span class="o">+</span> <span class="n">MAX_TCP_HEADER</span><span class="p">);</span>

	<span class="n">sndmem</span> <span class="o">*=</span> <span class="n">TCP_INIT_CWND</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">&lt;</span> <span class="n">sndmem</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sndmem</span><span class="p">,</span> <span class="n">sysctl_tcp_wmem</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* 2. Tuning advertised window (window_clamp, rcv_ssthresh)</span>
<span class="cm"> *</span>
<span class="cm"> * All tcp_full_space() is split to two parts: &quot;network&quot; buffer, allocated</span>
<span class="cm"> * forward and advertised in receiver window (tp-&gt;rcv_wnd) and</span>
<span class="cm"> * &quot;application buffer&quot;, required to isolate scheduling/application</span>
<span class="cm"> * latencies from network.</span>
<span class="cm"> * window_clamp is maximal advertised window. It can be less than</span>
<span class="cm"> * tcp_full_space(), in this case tcp_full_space() - window_clamp</span>
<span class="cm"> * is reserved for &quot;application&quot; buffer. The less window_clamp is</span>
<span class="cm"> * the smoother our behaviour from viewpoint of network, but the lower</span>
<span class="cm"> * throughput and the higher sensitivity of the connection to losses. 8)</span>
<span class="cm"> *</span>
<span class="cm"> * rcv_ssthresh is more strict window_clamp used at &quot;slow start&quot;</span>
<span class="cm"> * phase to predict further behaviour of this connection.</span>
<span class="cm"> * It is used for two goals:</span>
<span class="cm"> * - to enforce header prediction at sender, even when application</span>
<span class="cm"> *   requires some significant &quot;application buffer&quot;. It is check #1.</span>
<span class="cm"> * - to prevent pruning of receive queue because of misprediction</span>
<span class="cm"> *   of receiver window. Check #2.</span>
<span class="cm"> *</span>
<span class="cm"> * The scheme does not work when sender sends good segments opening</span>
<span class="cm"> * window and then starts to feed us spaghetti. But it should work</span>
<span class="cm"> * in common situations. Otherwise, we have to rely on queue collapsing.</span>
<span class="cm"> */</span>

<span class="cm">/* Slow part of check#2. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__tcp_grow_window</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* Optimize this! */</span>
	<span class="kt">int</span> <span class="n">truesize</span> <span class="o">=</span> <span class="n">tcp_win_from_space</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">window</span> <span class="o">=</span> <span class="n">tcp_win_from_space</span><span class="p">(</span><span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span> <span class="o">&lt;=</span> <span class="n">window</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">truesize</span> <span class="o">&lt;=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">rcv_mss</span><span class="p">;</span>

		<span class="n">truesize</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">window</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_grow_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Check #1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span> <span class="o">&lt;</span> <span class="n">tcp_space</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">sk_under_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">incr</span><span class="p">;</span>

		<span class="cm">/* Check #2. Increase window, if skb with such overhead</span>
<span class="cm">		 * will fit to rcvbuf in future.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_win_from_space</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="n">incr</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">incr</span> <span class="o">=</span> <span class="n">__tcp_grow_window</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">incr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">incr</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">incr</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span> <span class="o">+</span> <span class="n">incr</span><span class="p">,</span>
					       <span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">);</span>
			<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">quick</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 3. Tuning rcvbuf, when connection enters established state. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_fixup_rcvbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">mss</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">icwnd</span> <span class="o">=</span> <span class="n">TCP_DEFAULT_INIT_RCVWND</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rcvmem</span><span class="p">;</span>

	<span class="cm">/* Limit to 10 segments if mss &lt;= 1460,</span>
<span class="cm">	 * or 14600/mss segments, with a minimum of two segments.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mss</span> <span class="o">&gt;</span> <span class="mi">1460</span><span class="p">)</span>
		<span class="n">icwnd</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="p">(</span><span class="mi">1460</span> <span class="o">*</span> <span class="n">TCP_DEFAULT_INIT_RCVWND</span><span class="p">)</span> <span class="o">/</span> <span class="n">mss</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

	<span class="n">rcvmem</span> <span class="o">=</span> <span class="n">SKB_TRUESIZE</span><span class="p">(</span><span class="n">mss</span> <span class="o">+</span> <span class="n">MAX_TCP_HEADER</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tcp_win_from_space</span><span class="p">(</span><span class="n">rcvmem</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mss</span><span class="p">)</span>
		<span class="n">rcvmem</span> <span class="o">+=</span> <span class="mi">128</span><span class="p">;</span>

	<span class="n">rcvmem</span> <span class="o">*=</span> <span class="n">icwnd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">&lt;</span> <span class="n">rcvmem</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rcvmem</span><span class="p">,</span> <span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* 4. Try to fixup all. It is made immediately after connection enters</span>
<span class="cm"> *    established state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_init_buffer_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">maxwin</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_RCVBUF_LOCK</span><span class="p">))</span>
		<span class="n">tcp_fixup_rcvbuf</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_SNDBUF_LOCK</span><span class="p">))</span>
		<span class="n">tcp_fixup_sndbuf</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcvq_space</span><span class="p">.</span><span class="n">space</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">;</span>

	<span class="n">maxwin</span> <span class="o">=</span> <span class="n">tcp_full_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">&gt;=</span> <span class="n">maxwin</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">maxwin</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_app_win</span> <span class="o">&amp;&amp;</span> <span class="n">maxwin</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxwin</span> <span class="o">-</span>
					       <span class="p">(</span><span class="n">maxwin</span> <span class="o">&gt;&gt;</span> <span class="n">sysctl_tcp_app_win</span><span class="p">),</span>
					       <span class="mi">4</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Force reservation of one segment. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_app_win</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">+</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span> <span class="o">&gt;</span> <span class="n">maxwin</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">,</span> <span class="n">maxwin</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 5. Recalculate window clamp after socket hit its memory bounds. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_clamp_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">quick</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">&lt;</span> <span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_RCVBUF_LOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">sk_under_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sk_memory_allocated</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sk_prot_mem_limits</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">),</span>
				    <span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">,</span> <span class="mi">2U</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialize RCV_MSS value.</span>
<span class="cm"> * RCV_MSS is an our guess about MSS used by the peer.</span>
<span class="cm"> * We haven&#39;t any direct information about the MSS.</span>
<span class="cm"> * It&#39;s better to underestimate the RCV_MSS rather than overestimate.</span>
<span class="cm"> * Overestimations make us ACKing less frequently than needed.</span>
<span class="cm"> * Underestimations are more easy to detect and fix by tcp_measure_rcv_mss().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_initialize_rcv_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hint</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">);</span>

	<span class="n">hint</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">hint</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="n">TCP_MSS_DEFAULT</span><span class="p">);</span>
	<span class="n">hint</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="n">TCP_MIN_MSS</span><span class="p">);</span>

	<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">rcv_mss</span> <span class="o">=</span> <span class="n">hint</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_initialize_rcv_mss</span><span class="p">);</span>

<span class="cm">/* Receiver &quot;autotuning&quot; code.</span>
<span class="cm"> *</span>
<span class="cm"> * The algorithm for RTT estimation w/o timestamps is based on</span>
<span class="cm"> * Dynamic Right-Sizing (DRS) by Wu Feng and Mike Fisk of LANL.</span>
<span class="cm"> * &lt;http://public.lanl.gov/radiant/pubs.html#DRS&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * More detail on this code can be found at</span>
<span class="cm"> * &lt;http://staff.psc.edu/jheffner/&gt;,</span>
<span class="cm"> * though this reference is out of date.  A new paper</span>
<span class="cm"> * is pending.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_rcv_rtt_update</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">sample</span><span class="p">,</span> <span class="kt">int</span> <span class="n">win_dep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">new_sample</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_rtt_est</span><span class="p">.</span><span class="n">rtt</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">m</span> <span class="o">=</span> <span class="n">sample</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_sample</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we sample in larger samples in the non-timestamp</span>
<span class="cm">		 * case, we could grossly overestimate the RTT especially</span>
<span class="cm">		 * with chatty applications or bulk transfer apps which</span>
<span class="cm">		 * are stalled on filesystem I/O.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Also, since we are only going for a minimum in the</span>
<span class="cm">		 * non-timestamp case, we do not smooth things out</span>
<span class="cm">		 * else with timestamps disabled convergence takes too</span>
<span class="cm">		 * long.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">win_dep</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m</span> <span class="o">-=</span> <span class="p">(</span><span class="n">new_sample</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
			<span class="n">new_sample</span> <span class="o">+=</span> <span class="n">m</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">m</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">new_sample</span><span class="p">)</span>
				<span class="n">new_sample</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* No previous measure. */</span>
		<span class="n">new_sample</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_rtt_est</span><span class="p">.</span><span class="n">rtt</span> <span class="o">!=</span> <span class="n">new_sample</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_rtt_est</span><span class="p">.</span><span class="n">rtt</span> <span class="o">=</span> <span class="n">new_sample</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_rcv_rtt_measure</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_rtt_est</span><span class="p">.</span><span class="n">time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">new_measure</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_rtt_est</span><span class="p">.</span><span class="n">seq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">tcp_rcv_rtt_update</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_rtt_est</span><span class="p">.</span><span class="n">time</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">new_measure:</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_rtt_est</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">+</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_rtt_est</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_rcv_rtt_measure_ts</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsecr</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">-</span>
	     <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&gt;=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">rcv_mss</span><span class="p">))</span>
		<span class="n">tcp_rcv_rtt_update</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsecr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function should be called every time data is copied to user space.</span>
<span class="cm"> * It calculates the appropriate TCP receive buffer space.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_rcv_space_adjust</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">space</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcvq_space</span><span class="p">.</span><span class="n">time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">new_measure</span><span class="p">;</span>

	<span class="n">time</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcvq_space</span><span class="p">.</span><span class="n">time</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_rtt_est</span><span class="p">.</span><span class="n">rtt</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_rtt_est</span><span class="p">.</span><span class="n">rtt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">space</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcvq_space</span><span class="p">.</span><span class="n">seq</span><span class="p">);</span>

	<span class="n">space</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcvq_space</span><span class="p">.</span><span class="n">space</span><span class="p">,</span> <span class="n">space</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcvq_space</span><span class="p">.</span><span class="n">space</span> <span class="o">!=</span> <span class="n">space</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rcvmem</span><span class="p">;</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcvq_space</span><span class="p">.</span><span class="n">space</span> <span class="o">=</span> <span class="n">space</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_moderate_rcvbuf</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_RCVBUF_LOCK</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">new_clamp</span> <span class="o">=</span> <span class="n">space</span><span class="p">;</span>

			<span class="cm">/* Receive space grows, normalize in order to</span>
<span class="cm">			 * take into account packet headers and sk_buff</span>
<span class="cm">			 * structure overhead.</span>
<span class="cm">			 */</span>
			<span class="n">space</span> <span class="o">/=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">space</span><span class="p">)</span>
				<span class="n">space</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">rcvmem</span> <span class="o">=</span> <span class="n">SKB_TRUESIZE</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span> <span class="o">+</span> <span class="n">MAX_TCP_HEADER</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">tcp_win_from_space</span><span class="p">(</span><span class="n">rcvmem</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">)</span>
				<span class="n">rcvmem</span> <span class="o">+=</span> <span class="mi">128</span><span class="p">;</span>
			<span class="n">space</span> <span class="o">*=</span> <span class="n">rcvmem</span><span class="p">;</span>
			<span class="n">space</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">sysctl_tcp_rmem</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">=</span> <span class="n">space</span><span class="p">;</span>

				<span class="cm">/* Make the window clamp follow along.  */</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">new_clamp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">new_measure:</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcvq_space</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcvq_space</span><span class="p">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* There is something which you must keep in mind when you analyze the</span>
<span class="cm"> * behavior of the tp-&gt;ato delayed ack timeout interval.  When a</span>
<span class="cm"> * connection starts up, we want to ack as quickly as possible.  The</span>
<span class="cm"> * problem is that &quot;good&quot; TCP&#39;s do slow start at the beginning of data</span>
<span class="cm"> * transmission.  The means that until we send the first few ACK&#39;s the</span>
<span class="cm"> * sender will sit on his end and only queue most of his data, because</span>
<span class="cm"> * he can only send snd_cwnd unacked packets at any given time.  For</span>
<span class="cm"> * each ACK we send, he increments snd_cwnd and transmits more of his</span>
<span class="cm"> * queue.  -DaveM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_event_data_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">inet_csk_schedule_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_measure_rcv_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">tcp_rcv_rtt_measure</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">now</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The _first_ data packet received, initialize</span>
<span class="cm">		 * delayed ACK engine.</span>
<span class="cm">		 */</span>
		<span class="n">tcp_incr_quickack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span> <span class="o">=</span> <span class="n">TCP_ATO_MIN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">lrcvtime</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;=</span> <span class="n">TCP_ATO_MIN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The fastest case is the first. */</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span> <span class="o">=</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">TCP_ATO_MIN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span> <span class="o">=</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span> <span class="o">&gt;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">)</span>
				<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Too long gap. Apparently sender failed to</span>
<span class="cm">			 * restart window, so that we send ACKs quickly.</span>
<span class="cm">			 */</span>
			<span class="n">tcp_incr_quickack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">sk_mem_reclaim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">lrcvtime</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

	<span class="n">TCP_ECN_check_ce</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">128</span><span class="p">)</span>
		<span class="n">tcp_grow_window</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called to compute a smoothed rtt estimate. The data fed to this</span>
<span class="cm"> * routine either comes from timestamps, or from segments that were</span>
<span class="cm"> * known _not_ to have been retransmitted [see Karn/Partridge</span>
<span class="cm"> * Proceedings SIGCOMM 87]. The algorithm is from the SIGCOMM 88</span>
<span class="cm"> * piece by Van Jacobson.</span>
<span class="cm"> * NOTE: the next three routines used to be one big routine.</span>
<span class="cm"> * To save cycles in the RFC 1323 implementation it was better to break</span>
<span class="cm"> * it up into three procedures. -- erics</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_rtt_estimator</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="n">__u32</span> <span class="n">mrtt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mrtt</span><span class="p">;</span> <span class="cm">/* RTT */</span>

	<span class="cm">/*	The following amusing code comes from Jacobson&#39;s</span>
<span class="cm">	 *	article in SIGCOMM &#39;88.  Note that rtt and mdev</span>
<span class="cm">	 *	are scaled versions of rtt and mean deviation.</span>
<span class="cm">	 *	This is designed to be as fast as possible</span>
<span class="cm">	 *	m stands for &quot;measurement&quot;.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	On a 1990 paper the rto value is changed to:</span>
<span class="cm">	 *	RTO = rtt + 4 * mdev</span>
<span class="cm">	 *</span>
<span class="cm">	 * Funny. This algorithm seems to be very broken.</span>
<span class="cm">	 * These formulae increase RTO, when it should be decreased, increase</span>
<span class="cm">	 * too slowly, when it should be increased quickly, decrease too quickly</span>
<span class="cm">	 * etc. I guess in BSD RTO takes ONE value, so that it is absolutely</span>
<span class="cm">	 * does not matter how to _calculate_ it. Seems, it was trap</span>
<span class="cm">	 * that VJ failed to avoid. 8)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span> <span class="o">-=</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>	<span class="cm">/* m is now error in rtt est */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">+=</span> <span class="n">m</span><span class="p">;</span>		<span class="cm">/* rtt = 7/8 rtt + 1/8 new */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">m</span> <span class="o">=</span> <span class="o">-</span><span class="n">m</span><span class="p">;</span>		<span class="cm">/* m is now abs(error) */</span>
			<span class="n">m</span> <span class="o">-=</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>   <span class="cm">/* similar update on mdev */</span>
			<span class="cm">/* This is similar to one of Eifel findings.</span>
<span class="cm">			 * Eifel blocks mdev updates when rtt decreases.</span>
<span class="cm">			 * This solution is a bit different: we use finer gain</span>
<span class="cm">			 * for mdev in this case (alpha*beta).</span>
<span class="cm">			 * Like Eifel it also prevents growth of rto,</span>
<span class="cm">			 * but also it limits too fast rto decreases,</span>
<span class="cm">			 * happening in pure Eifel.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">m</span> <span class="o">-=</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>   <span class="cm">/* similar update on mdev */</span>
		<span class="p">}</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span> <span class="o">+=</span> <span class="n">m</span><span class="p">;</span>	    	<span class="cm">/* mdev = 3/4 mdev + 1/4 new */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev_max</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev_max</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev_max</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span><span class="p">)</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev_max</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rtt_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev_max</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span><span class="p">)</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">-=</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev_max</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rtt_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev_max</span> <span class="o">=</span> <span class="n">tcp_rto_min</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* no previous measure. */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>	<span class="cm">/* take the measured time to be rtt */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* make sure rto = 3*rtt */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev_max</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span><span class="p">,</span> <span class="n">tcp_rto_min</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rtt_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Calculate rto without backoff.  This is the second half of Van Jacobson&#39;s</span>
<span class="cm"> * routine referred to above.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_set_rto</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* Old crap is replaced with new one. 8)</span>
<span class="cm">	 *</span>
<span class="cm">	 * More seriously:</span>
<span class="cm">	 * 1. If rtt variance happened to be less 50msec, it is hallucination.</span>
<span class="cm">	 *    It cannot be less due to utterly erratic ACK generation made</span>
<span class="cm">	 *    at least by solaris and freebsd. &quot;Erratic ACKs&quot; has _nothing_</span>
<span class="cm">	 *    to do with delayed acks, because at cwnd&gt;2 true delack timeout</span>
<span class="cm">	 *    is invisible. Actually, Linux-2.4 also generates erratic</span>
<span class="cm">	 *    ACKs in some circumstances.</span>
<span class="cm">	 */</span>
	<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">=</span> <span class="n">__tcp_set_rto</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="cm">/* 2. Fixups made earlier cannot be right.</span>
<span class="cm">	 *    If we do not estimate RTO correctly without them,</span>
<span class="cm">	 *    all the algo is pure shit and should be replaced</span>
<span class="cm">	 *    with correct one. It is exactly, which we pretend to do.</span>
<span class="cm">	 */</span>

	<span class="cm">/* NOTE: clamping at TCP_RTO_MIN is not required, current algo</span>
<span class="cm">	 * guarantees that rto is higher.</span>
<span class="cm">	 */</span>
	<span class="n">tcp_bound_rto</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Save metrics learned by this TCP session.</span>
<span class="cm">   This function is called only, when TCP finishes successfully</span>
<span class="cm">   i.e. when it enters TIME-WAIT or goes from LAST-ACK to CLOSE.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_update_metrics</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_nometrics_save</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dst_confirm</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">DST_HOST</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rtt</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_backoff</span> <span class="o">||</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This session failed to estimate rtt. Why?</span>
<span class="cm">			 * Probably, no packets returned in time.</span>
<span class="cm">			 * Reset our results.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTT</span><span class="p">)))</span>
				<span class="n">dst_metric_set</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rtt</span> <span class="o">=</span> <span class="n">dst_metric_rtt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTT</span><span class="p">);</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">rtt</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span><span class="p">;</span>

		<span class="cm">/* If newly calculated rtt larger than stored one,</span>
<span class="cm">		 * store new one. Otherwise, use EWMA. Remember,</span>
<span class="cm">		 * rtt overestimation is always better than underestimation.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTT</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">set_dst_metric_rtt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTT</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">set_dst_metric_rtt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTT</span><span class="p">,</span> <span class="n">rtt</span> <span class="o">-</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTTVAR</span><span class="p">)))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">var</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">m</span> <span class="o">=</span> <span class="o">-</span><span class="n">m</span><span class="p">;</span>

			<span class="cm">/* Scale deviation to rttvar fixed point */</span>
			<span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span><span class="p">)</span>
				<span class="n">m</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span><span class="p">;</span>

			<span class="n">var</span> <span class="o">=</span> <span class="n">dst_metric_rtt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTTVAR</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="n">var</span><span class="p">)</span>
				<span class="n">var</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">var</span> <span class="o">-=</span> <span class="p">(</span><span class="n">var</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>

			<span class="n">set_dst_metric_rtt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTTVAR</span><span class="p">,</span> <span class="n">var</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_in_initial_slowstart</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Slow start still did not finish. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">))</span>
				<span class="n">dst_metric_set</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_CWND</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&gt;</span> <span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_CWND</span><span class="p">))</span>
				<span class="n">dst_metric_set</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_CWND</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">&amp;&amp;</span>
			   <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_Open</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Cong. avoidance phase, cwnd is reliable. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">))</span>
				<span class="n">dst_metric_set</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">,</span>
					       <span class="n">max</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_CWND</span><span class="p">))</span>
				<span class="n">dst_metric_set</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_CWND</span><span class="p">,</span>
					       <span class="p">(</span><span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_CWND</span><span class="p">)</span> <span class="o">+</span>
						<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Else slow start did not finish, cwnd is non-sense,</span>
<span class="cm">			   ssthresh may be also invalid.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_CWND</span><span class="p">))</span>
				<span class="n">dst_metric_set</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_CWND</span><span class="p">,</span>
					       <span class="p">(</span><span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_CWND</span><span class="p">)</span> <span class="o">+</span>
						<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">&gt;</span> <span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">))</span>
				<span class="n">dst_metric_set</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_REORDERING</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_REORDERING</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span> <span class="o">&amp;&amp;</span>
			    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span> <span class="o">!=</span> <span class="n">sysctl_tcp_reordering</span><span class="p">)</span>
				<span class="n">dst_metric_set</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_REORDERING</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">__u32</span> <span class="nf">tcp_init_cwnd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u32</span> <span class="n">cwnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">dst</span> <span class="o">?</span> <span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_INITCWND</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cwnd</span><span class="p">)</span>
		<span class="n">cwnd</span> <span class="o">=</span> <span class="n">TCP_INIT_CWND</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="n">__u32</span><span class="p">,</span> <span class="n">cwnd</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_clamp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Set slow start threshold and cwnd not falling to slow start */</span>
<span class="kt">void</span> <span class="nf">tcp_enter_cwr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">set_ssthresh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">&lt;</span> <span class="n">TCP_CA_CWR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set_ssthresh</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span>
				   <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1U</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
		<span class="n">TCP_ECN_queue_cwr</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

		<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CA_CWR</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Packet counting of FACK is based on in-order assumptions, therefore TCP</span>
<span class="cm"> * disables it when reordering is detected</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_disable_fack</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* RFC3517 uses different metric in lost marker =&gt; reset on change */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">sack_ok</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCP_FACK_ENABLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Take a notice that peer is sending D-SACKs */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_dsack_seen</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">sack_ok</span> <span class="o">|=</span> <span class="n">TCP_DSACK_SEEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize metrics on socket. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_init_metrics</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>

	<span class="n">dst_confirm</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst_metric_locked</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_CWND</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_clamp</span> <span class="o">=</span> <span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_CWND</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_SSTHRESH</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_clamp</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_clamp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* ssthresh may have been reduced unnecessarily during.</span>
<span class="cm">		 * 3WHS. Restore it back to its initial default.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">TCP_INFINITE_SSTHRESH</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_REORDERING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span> <span class="o">!=</span> <span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_REORDERING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tcp_disable_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="n">tcp_disable_early_retrans</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span> <span class="o">=</span> <span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_REORDERING</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst_metric</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset</span><span class="p">;</span>

	<span class="cm">/* Initial rtt is determined from SYN,SYN-ACK.</span>
<span class="cm">	 * The segment is small and rtt may appear much</span>
<span class="cm">	 * less than real one. Use per-dst memory</span>
<span class="cm">	 * to make it more realistic.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A bit of theory. RTT is time passed after &quot;normal&quot; sized packet</span>
<span class="cm">	 * is sent until it is ACKed. In normal circumstances sending small</span>
<span class="cm">	 * packets force peer to delay ACKs and calculation is correct too.</span>
<span class="cm">	 * The algorithm is adaptive and, provided we follow specs, it</span>
<span class="cm">	 * NEVER underestimate RTT. BUT! If peer tries to make some clever</span>
<span class="cm">	 * tricks sort of &quot;quick acks&quot; for time long enough to decrease RTT</span>
<span class="cm">	 * to low value, and then abruptly stops to do it and starts to delay</span>
<span class="cm">	 * ACKs, wait for troubles.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst_metric_rtt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTT</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">=</span> <span class="n">dst_metric_rtt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTT</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rtt_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst_metric_rtt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTTVAR</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span> <span class="o">=</span> <span class="n">dst_metric_rtt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">RTAX_RTTVAR</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev_max</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span><span class="p">,</span> <span class="n">tcp_rto_min</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">tcp_set_rto</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="nl">reset:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* RFC6298: 5.7 We&#39;ve failed to get a valid RTT sample from</span>
<span class="cm">		 * 3WHS. This is most likely due to retransmission,</span>
<span class="cm">		 * including spurious one. Reset the RTO back to 3secs</span>
<span class="cm">		 * from the more aggressive 1sec to avoid more spurious</span>
<span class="cm">		 * retransmission.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mdev_max</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rttvar</span> <span class="o">=</span> <span class="n">TCP_TIMEOUT_FALLBACK</span><span class="p">;</span>
		<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">=</span> <span class="n">TCP_TIMEOUT_FALLBACK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Cut cwnd down to 1 per RFC5681 if SYN or SYN-ACK has been</span>
<span class="cm">	 * retransmitted. In light of RFC6298 more aggressive 1sec</span>
<span class="cm">	 * initRTO, we only reset cwnd when more than 1 SYN/SYN-ACK</span>
<span class="cm">	 * retransmission has occurred.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">total_retrans</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">tcp_init_cwnd</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_update_reordering</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">metric</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">int</span> <span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">mib_idx</span><span class="p">;</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">TCP_MAX_REORDERING</span><span class="p">,</span> <span class="n">metric</span><span class="p">);</span>

		<span class="cm">/* This exciting event is worth to be remembered. 8) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="p">)</span>
			<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPTSREORDER</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
			<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPRENOREORDER</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
			<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPFACKREORDER</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPSACKREORDER</span><span class="p">;</span>

		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">mib_idx</span><span class="p">);</span>
<span class="cp">#if FASTRETRANS_DEBUG &gt; 1</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Disorder%d %d %u f%u s%u rr%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">sack_ok</span><span class="p">,</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">?</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_retrans</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">tcp_disable_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tcp_disable_early_retrans</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This must be called before lost_out is incremented */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_verify_retransmit_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span>
		   <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">||</span>
	    <span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_high</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_high</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_skb_mark_lost</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPCB_LOST</span><span class="o">|</span><span class="n">TCPCB_SACKED_ACKED</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">tcp_verify_retransmit_hint</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">|=</span> <span class="n">TCPCB_LOST</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_skb_mark_lost_uncond_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_verify_retransmit_hint</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPCB_LOST</span><span class="o">|</span><span class="n">TCPCB_SACKED_ACKED</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">|=</span> <span class="n">TCPCB_LOST</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This procedure tags the retransmission queue when SACKs arrive.</span>
<span class="cm"> *</span>
<span class="cm"> * We have three tag bits: SACKED(S), RETRANS(R) and LOST(L).</span>
<span class="cm"> * Packets in queue with these bits set are counted in variables</span>
<span class="cm"> * sacked_out, retrans_out and lost_out, correspondingly.</span>
<span class="cm"> *</span>
<span class="cm"> * Valid combinations are:</span>
<span class="cm"> * Tag  InFlight	Description</span>
<span class="cm"> * 0	1		- orig segment is in flight.</span>
<span class="cm"> * S	0		- nothing flies, orig reached receiver.</span>
<span class="cm"> * L	0		- nothing flies, orig lost by net.</span>
<span class="cm"> * R	2		- both orig and retransmit are in flight.</span>
<span class="cm"> * L|R	1		- orig is lost, retransmit is in flight.</span>
<span class="cm"> * S|R  1		- orig reached receiver, retrans is still in flight.</span>
<span class="cm"> * (L|S|R is logically valid, it could occur when L|R is sacked,</span>
<span class="cm"> *  but it is equivalent to plain S and code short-curcuits it to S.</span>
<span class="cm"> *  L|S is logically invalid, it would mean -1 packet in flight 8))</span>
<span class="cm"> *</span>
<span class="cm"> * These 6 states form finite state machine, controlled by the following events:</span>
<span class="cm"> * 1. New ACK (+SACK) arrives. (tcp_sacktag_write_queue())</span>
<span class="cm"> * 2. Retransmission. (tcp_retransmit_skb(), tcp_xmit_retransmit_queue())</span>
<span class="cm"> * 3. Loss detection event of two flavors:</span>
<span class="cm"> *	A. Scoreboard estimator decided the packet is lost.</span>
<span class="cm"> *	   A&#39;. Reno &quot;three dupacks&quot; marks head of queue lost.</span>
<span class="cm"> *	   A&#39;&#39;. Its FACK modification, head until snd.fack is lost.</span>
<span class="cm"> *	B. SACK arrives sacking SND.NXT at the moment, when the</span>
<span class="cm"> *	   segment was retransmitted.</span>
<span class="cm"> * 4. D-SACK added new rule: D-SACK changes any tag to S.</span>
<span class="cm"> *</span>
<span class="cm"> * It is pleasant to note, that state diagram turns out to be commutative,</span>
<span class="cm"> * so that we are allowed not to be bothered by order of our actions,</span>
<span class="cm"> * when multiple events arrive simultaneously. (see the function below).</span>
<span class="cm"> *</span>
<span class="cm"> * Reordering detection.</span>
<span class="cm"> * --------------------</span>
<span class="cm"> * Reordering metric is maximal distance, which a packet can be displaced</span>
<span class="cm"> * in packet stream. With SACKs we can estimate it:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. SACK fills old hole and the corresponding segment was not</span>
<span class="cm"> *    ever retransmitted -&gt; reordering. Alas, we cannot use it</span>
<span class="cm"> *    when segment was retransmitted.</span>
<span class="cm"> * 2. The last flaw is solved with D-SACK. D-SACK arrives</span>
<span class="cm"> *    for retransmitted and already SACKed segment -&gt; reordering..</span>
<span class="cm"> * Both of these heuristics are not used in Loss state, when we cannot</span>
<span class="cm"> * account for retransmits accurately.</span>
<span class="cm"> *</span>
<span class="cm"> * SACK block validation.</span>
<span class="cm"> * ----------------------</span>
<span class="cm"> *</span>
<span class="cm"> * SACK block range validation checks that the received SACK block fits to</span>
<span class="cm"> * the expected sequence limits, i.e., it is between SND.UNA and SND.NXT.</span>
<span class="cm"> * Note that SND.UNA is not included to the range though being valid because</span>
<span class="cm"> * it means that the receiver is rather inconsistent with itself reporting</span>
<span class="cm"> * SACK reneging when it should advance SND.UNA. Such SACK block this is</span>
<span class="cm"> * perfectly valid, however, in light of RFC2018 which explicitly states</span>
<span class="cm"> * that &quot;SACK block MUST reflect the newest segment.  Even if the newest</span>
<span class="cm"> * segment is going to be discarded ...&quot;, not that it looks very clever</span>
<span class="cm"> * in case of head skb. Due to potentional receiver driven attacks, we</span>
<span class="cm"> * choose to avoid immediate execution of a walk in write queue due to</span>
<span class="cm"> * reneging and defer head skb&#39;s loss recovery to standard loss recovery</span>
<span class="cm"> * procedure that will eventually trigger (nothing forbids us doing this).</span>
<span class="cm"> *</span>
<span class="cm"> * Implements also blockage to start_seq wrap-around. Problem lies in the</span>
<span class="cm"> * fact that though start_seq (s) is before end_seq (i.e., not reversed),</span>
<span class="cm"> * there&#39;s no guarantee that it will be before snd_nxt (n). The problem</span>
<span class="cm"> * happens when start_seq resides between end_seq wrap (e_w) and snd_nxt</span>
<span class="cm"> * wrap (s_w):</span>
<span class="cm"> *</span>
<span class="cm"> *         &lt;- outs wnd -&gt;                          &lt;- wrapzone -&gt;</span>
<span class="cm"> *         u     e      n                         u_w   e_w  s n_w</span>
<span class="cm"> *         |     |      |                          |     |   |  |</span>
<span class="cm"> * |&lt;------------+------+----- TCP seqno space --------------+----------&gt;|</span>
<span class="cm"> * ...-- &lt;2^31 -&gt;|                                           |&lt;--------...</span>
<span class="cm"> * ...---- &gt;2^31 ------&gt;|                                    |&lt;--------...</span>
<span class="cm"> *</span>
<span class="cm"> * Current code wouldn&#39;t be vulnerable but it&#39;s better still to discard such</span>
<span class="cm"> * crazy SACK blocks. Doing this check for start_seq alone closes somewhat</span>
<span class="cm"> * similar case (end_seq after snd_nxt wrap) as earlier reversed check in</span>
<span class="cm"> * snd_nxt wrap -&gt; snd_una region will then become &quot;well defined&quot;, i.e.,</span>
<span class="cm"> * equal to the ideal case (infinite seqno space without wrap caused issues).</span>
<span class="cm"> *</span>
<span class="cm"> * With D-SACK the lower bound is extended to cover sequence space below</span>
<span class="cm"> * SND.UNA down to undo_marker, which is the last point of interest. Yet</span>
<span class="cm"> * again, D-SACK block must not to go across snd_una (for the same reason as</span>
<span class="cm"> * for the normal SACK blocks, explained above). But there all simplicity</span>
<span class="cm"> * ends, TCP might receive valid D-SACKs below that. As long as they reside</span>
<span class="cm"> * fully below undo_marker they do not affect behavior in anyway and can</span>
<span class="cm"> * therefore be safely ignored. In rare cases (which are more or less</span>
<span class="cm"> * theoretical ones), the D-SACK will nicely cross that boundary due to skb</span>
<span class="cm"> * fragmentation and packet reordering past skb&#39;s retransmission. To consider</span>
<span class="cm"> * them correctly, the acceptable range must be extended even more though</span>
<span class="cm"> * the exact amount is rather hard to quantify. However, tp-&gt;max_window can</span>
<span class="cm"> * be used as an exaggerated estimate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_is_sackblock_valid</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_dsack</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">start_seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">end_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Too far in future, or reversed (interpretation is ambiguous) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Nasty start_seq wrap-around check (see comments above) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* In outstanding window? ...This is valid exit for D-SACKs too.</span>
<span class="cm">	 * start_seq == snd_una is non-sensical (see comments above)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_dsack</span> <span class="o">||</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* ...Then it&#39;s D-SACK, and must reside below snd_una completely */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Too old */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Undo_marker boundary crossing (overestimates a lot). Known already:</span>
<span class="cm">	 *   start_seq &lt; undo_marker and end_seq &gt;= undo_marker.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">end_seq</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_window</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check for lost retransmit. This superb idea is borrowed from &quot;ratehalving&quot;.</span>
<span class="cm"> * Event &quot;B&quot;. Later note: FACK people cheated me again 8), we have to account</span>
<span class="cm"> * for reordering! Ugly, but should help.</span>
<span class="cm"> *</span>
<span class="cm"> * Search retransmitted skbs from write_queue that were sent when snd_nxt was</span>
<span class="cm"> * less than what is now known to be received by the other end (derived from</span>
<span class="cm"> * highest SACK block). Also calculate the lowest snd_nxt among the remaining</span>
<span class="cm"> * retransmitted skbs to avoid some costly processing per ACKs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_mark_lost_retrans</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_low_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">received_upto</span> <span class="o">=</span> <span class="n">tcp_highest_sack_seq</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">received_upto</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_retrans_low</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">TCP_CA_Recovery</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tcp_for_write_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ack_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_RETRANS</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* TODO: We would like to get rid of tcp_is_fack(tp) only</span>
<span class="cm">		 * constraint here (see above) but figuring out that at</span>
<span class="cm">		 * least tp-&gt;reordering SACK blocks reside between ack_seq</span>
<span class="cm">		 * and received_upto is not easy task to do cheaply with</span>
<span class="cm">		 * the available datastructures.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Whether FACK should check here for tp-&gt;reordering segs</span>
<span class="cm">		 * in-between one could argue for either way (it would be</span>
<span class="cm">		 * rather simple to implement as we could count fack_count</span>
<span class="cm">		 * during the walk and do tp-&gt;fackets_out - fack_count).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">received_upto</span><span class="p">,</span> <span class="n">ack_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPCB_SACKED_RETRANS</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">-=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

			<span class="n">tcp_skb_mark_lost_uncond_verify</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPLOSTRETRANSMIT</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">ack_seq</span><span class="p">,</span> <span class="n">new_low_seq</span><span class="p">))</span>
				<span class="n">new_low_seq</span> <span class="o">=</span> <span class="n">ack_seq</span><span class="p">;</span>
			<span class="n">cnt</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_retrans_low</span> <span class="o">=</span> <span class="n">new_low_seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_check_dsack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ack_skb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">tcp_sack_block_wire</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_sacks</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">prior_snd_una</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">start_seq_0</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">start_seq</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">end_seq_0</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">end_seq</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">dup_sack</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">start_seq_0</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">ack_skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dup_sack</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">tcp_dsack_seen</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPDSACKRECV</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num_sacks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">end_seq_1</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">end_seq</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">start_seq_1</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">start_seq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq_0</span><span class="p">,</span> <span class="n">end_seq_1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">start_seq_0</span><span class="p">,</span> <span class="n">start_seq_1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dup_sack</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">tcp_dsack_seen</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
			<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
					<span class="n">LINUX_MIB_TCPDSACKOFORECV</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* D-SACK for already forgotten data... Do dumb counting. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dup_sack</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_retrans</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq_0</span><span class="p">,</span> <span class="n">prior_snd_una</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">after</span><span class="p">(</span><span class="n">end_seq_0</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_retrans</span><span class="o">--</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dup_sack</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">tcp_sacktag_state</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">reord</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fack_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Check if skb is fully within the SACK block. In presence of GSO skbs,</span>
<span class="cm"> * the incoming SACK may not exactly match but we can find smaller MSS</span>
<span class="cm"> * aligned portion of it that matches. Therefore we might need to fragment</span>
<span class="cm"> * which may fail and creates some hassle (caller must handle error case</span>
<span class="cm"> * returns).</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME: this could be merged to shift decision code</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_match_skb_to_sack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">start_seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">end_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">in_sack</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pkt_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">;</span>

	<span class="n">in_sack</span> <span class="o">=</span> <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		  <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">in_sack</span> <span class="o">&amp;&amp;</span>
	    <span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">start_seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mss</span> <span class="o">=</span> <span class="n">tcp_skb_mss</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">in_sack</span> <span class="o">=</span> <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_sack</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pkt_len</span> <span class="o">=</span> <span class="n">start_seq</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&lt;</span> <span class="n">mss</span><span class="p">)</span>
				<span class="n">pkt_len</span> <span class="o">=</span> <span class="n">mss</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pkt_len</span> <span class="o">=</span> <span class="n">end_seq</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&lt;</span> <span class="n">mss</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Round if necessary so that SACKs cover only full MSSes</span>
<span class="cm">		 * and/or the remaining small portion (if present)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">&gt;</span> <span class="n">mss</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">new_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">pkt_len</span> <span class="o">/</span> <span class="n">mss</span><span class="p">)</span> <span class="o">*</span> <span class="n">mss</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_sack</span> <span class="o">&amp;&amp;</span> <span class="n">new_len</span> <span class="o">&lt;</span> <span class="n">pkt_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_len</span> <span class="o">+=</span> <span class="n">mss</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">new_len</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pkt_len</span> <span class="o">=</span> <span class="n">new_len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">tcp_fragment</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pkt_len</span><span class="p">,</span> <span class="n">mss</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">in_sack</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Mark the given newly-SACKed range as such, adjusting counters and hints. */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">tcp_sacktag_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">tcp_sacktag_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">u8</span> <span class="n">sacked</span><span class="p">,</span>
			  <span class="n">u32</span> <span class="n">start_seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">end_seq</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="n">dup_sack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">fack_count</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">fack_count</span><span class="p">;</span>

	<span class="cm">/* Account D-SACK for retransmitted packet. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dup_sack</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_RETRANS</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_retrans</span> <span class="o">&amp;&amp;</span>
		    <span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span><span class="p">))</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_retrans</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">)</span>
			<span class="n">state</span><span class="o">-&gt;</span><span class="n">reord</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">fack_count</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">reord</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Nothing to do; acked frame is about to be dropped (was ACKed). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sacked</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_RETRANS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* If the segment is not tagged as lost,</span>
<span class="cm">			 * we do not clear RETRANS, believing</span>
<span class="cm">			 * that retransmission is still in flight.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_LOST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sacked</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">TCPCB_LOST</span><span class="o">|</span><span class="n">TCPCB_SACKED_RETRANS</span><span class="p">);</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">-=</span> <span class="n">pcount</span><span class="p">;</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">-=</span> <span class="n">pcount</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_RETRANS</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* New sack for not retransmitted frame,</span>
<span class="cm">				 * which was in hole. It is reordering.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span>
					   <span class="n">tcp_highest_sack_seq</span><span class="p">(</span><span class="n">tp</span><span class="p">)))</span>
					<span class="n">state</span><span class="o">-&gt;</span><span class="n">reord</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">fack_count</span><span class="p">,</span>
							   <span class="n">state</span><span class="o">-&gt;</span><span class="n">reord</span><span class="p">);</span>

				<span class="cm">/* SACK enhanced F-RTO (RFC4138; Appendix B) */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_highmark</span><span class="p">))</span>
					<span class="n">state</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_ONLY_ORIG_SACKED</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_LOST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sacked</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPCB_LOST</span><span class="p">;</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">-=</span> <span class="n">pcount</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">sacked</span> <span class="o">|=</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_DATA_SACKED</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">+=</span> <span class="n">pcount</span><span class="p">;</span>

		<span class="n">fack_count</span> <span class="o">+=</span> <span class="n">pcount</span><span class="p">;</span>

		<span class="cm">/* Lost marker hint past SACKed? Tweak RFC3517 cnt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">before</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_cnt_hint</span> <span class="o">+=</span> <span class="n">pcount</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fack_count</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">=</span> <span class="n">fack_count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* D-SACK. We can detect redundant retransmission in S|R and plain R</span>
<span class="cm">	 * frames and clear it. undo_retrans is decreased above, L|R frames</span>
<span class="cm">	 * are accounted above as well.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dup_sack</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_RETRANS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sacked</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPCB_SACKED_RETRANS</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">-=</span> <span class="n">pcount</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sacked</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Shift newly-SACKed bytes from this skb to the immediately previous</span>
<span class="cm"> * already-SACKed sk_buff. Mark the newly-SACKed bytes as such.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_shifted_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">tcp_sacktag_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcount</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shifted</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">,</span>
			    <span class="n">bool</span> <span class="n">dup_sack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tcp_write_queue_prev</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">start_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>	<span class="cm">/* start of newly-SACKed */</span>
	<span class="n">u32</span> <span class="n">end_seq</span> <span class="o">=</span> <span class="n">start_seq</span> <span class="o">+</span> <span class="n">shifted</span><span class="p">;</span>	<span class="cm">/* end of newly-SACKed */</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pcount</span><span class="p">);</span>

	<span class="cm">/* Adjust counters and hints for the newly sacked sequence</span>
<span class="cm">	 * range but discard the return value since prev is already</span>
<span class="cm">	 * marked. We must tag the range first because the seq</span>
<span class="cm">	 * advancement below implicitly advances</span>
<span class="cm">	 * tcp_highest_sack_seq() when skb is highest_sack.</span>
<span class="cm">	 */</span>
	<span class="n">tcp_sacktag_one</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">,</span>
			<span class="n">start_seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">,</span> <span class="n">dup_sack</span><span class="p">,</span> <span class="n">pcount</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_cnt_hint</span> <span class="o">+=</span> <span class="n">pcount</span><span class="p">;</span>

	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">+=</span> <span class="n">shifted</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+=</span> <span class="n">shifted</span><span class="p">;</span>

	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">+=</span> <span class="n">pcount</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">&lt;</span> <span class="n">pcount</span><span class="p">);</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">-=</span> <span class="n">pcount</span><span class="p">;</span>

	<span class="cm">/* When we&#39;re adding to gso_segs == 1, gso_size will be zero,</span>
<span class="cm">	 * in theory this shouldn&#39;t be necessary but as long as DSACK</span>
<span class="cm">	 * code can come after this skb later on it&#39;s better to keep</span>
<span class="cm">	 * setting gso_size to something.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="n">mss</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_gso_type</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* CHECKME: To clear or not to clear? Mimics normal skb currently */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Difference in this won&#39;t matter, both ACKed by the same cumul. ACK */</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">|=</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_EVER_RETRANS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_SACKSHIFTED</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Whole SKB was eaten :-) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">scoreboard_skb_hint</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">scoreboard_skb_hint</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_cnt_hint</span> <span class="o">-=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">|=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tcp_flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_highest_sack</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">tcp_advance_highest_sack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">tcp_unlink_write_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">sk_wmem_free_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_SACKMERGED</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* I wish gso_size would have a bit more sane initialization than</span>
<span class="cm"> * something-or-zero which complicates things</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_skb_seglen</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">:</span> <span class="n">tcp_skb_mss</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Shifting pages past head area doesn&#39;t work */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">skb_can_shift</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Try collapsing SACK blocks spanning across multiple skbs to a single</span>
<span class="cm"> * skb.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_shift_skb_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">tcp_sacktag_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					  <span class="n">u32</span> <span class="n">start_seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">end_seq</span><span class="p">,</span>
					  <span class="n">bool</span> <span class="n">dup_sack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mss</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">in_sack</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_can_gso</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>

	<span class="cm">/* Normally R but no L won&#39;t result in plain S */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dup_sack</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPCB_LOST</span><span class="o">|</span><span class="n">TCPCB_SACKED_RETRANS</span><span class="p">))</span> <span class="o">==</span> <span class="n">TCPCB_SACKED_RETRANS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_can_shift</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>
	<span class="cm">/* This frame is about to be dropped (was ACKed). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>

	<span class="cm">/* Can only happen with delayed DSACK + discard craziness */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">tcp_write_queue_prev</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_TAGBITS</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>

	<span class="n">in_sack</span> <span class="o">=</span> <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		  <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_sack</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">pcount</span> <span class="o">=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">mss</span> <span class="o">=</span> <span class="n">tcp_skb_seglen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* TODO: Fix DSACKs to not fragment already SACKed and we can</span>
<span class="cm">		 * drop this restriction as unnecessary</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mss</span> <span class="o">!=</span> <span class="n">tcp_skb_seglen</span><span class="p">(</span><span class="n">prev</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">start_seq</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">noop</span><span class="p">;</span>
		<span class="cm">/* CHECKME: This is non-MSS split case only?, this will</span>
<span class="cm">		 * cause skipped skbs due to advancing loop btw, original</span>
<span class="cm">		 * has that feature too</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">noop</span><span class="p">;</span>

		<span class="n">in_sack</span> <span class="o">=</span> <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_sack</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* TODO: head merge to next could be attempted here</span>
<span class="cm">			 * if (!after(TCP_SKB_CB(skb)-&gt;end_seq, end_seq)),</span>
<span class="cm">			 * though it might not be worth of the additional hassle</span>
<span class="cm">			 *</span>
<span class="cm">			 * ...we can probably just fallback to what was done</span>
<span class="cm">			 * previously. We could try merging non-SACKed ones</span>
<span class="cm">			 * as well but it probably isn&#39;t going to buy off</span>
<span class="cm">			 * because later SACKs might again split them, and</span>
<span class="cm">			 * it would make skb timestamp tracking considerably</span>
<span class="cm">			 * harder problem.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">end_seq</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

		<span class="cm">/* MSS boundaries should be honoured or else pcount will</span>
<span class="cm">		 * severely break even though it makes things bit trickier.</span>
<span class="cm">		 * Optimize common case to avoid most of the divides</span>
<span class="cm">		 */</span>
		<span class="n">mss</span> <span class="o">=</span> <span class="n">tcp_skb_mss</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* TODO: Fix DSACKs to not fragment already SACKed and we can</span>
<span class="cm">		 * drop this restriction as unnecessary</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mss</span> <span class="o">!=</span> <span class="n">tcp_skb_seglen</span><span class="p">(</span><span class="n">prev</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">mss</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">mss</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">noop</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pcount</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">mss</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">pcount</span> <span class="o">*</span> <span class="n">mss</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* tcp_sacktag_one() won&#39;t SACK-tag ranges below snd_una */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_shift</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_shifted_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">pcount</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">mss</span><span class="p">,</span> <span class="n">dup_sack</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Hole filled allows collapsing with the next as well, this is very</span>
<span class="cm">	 * useful when hole on every nth skb pattern happens</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="n">tcp_write_queue_tail</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_next</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_can_shift</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_TAGBITS</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">mss</span> <span class="o">!=</span> <span class="n">tcp_skb_seglen</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shift</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pcount</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">tcp_shifted_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span> <span class="n">mss</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">fack_count</span> <span class="o">+=</span> <span class="n">pcount</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">prev</span><span class="p">;</span>

<span class="nl">noop:</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>

<span class="nl">fallback:</span>
	<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_SACKSHIFTFALLBACK</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_sacktag_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="o">*</span><span class="n">next_dup</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">tcp_sacktag_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">start_seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">end_seq</span><span class="p">,</span>
					<span class="n">bool</span> <span class="n">dup_sack_in</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">tcp_for_write_queue_from</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">in_sack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">dup_sack</span> <span class="o">=</span> <span class="n">dup_sack_in</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* queue is in-order =&gt; we can short-circuit the walk early */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">next_dup</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">next_dup</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">in_sack</span> <span class="o">=</span> <span class="n">tcp_match_skb_to_sack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
							<span class="n">next_dup</span><span class="o">-&gt;</span><span class="n">start_seq</span><span class="p">,</span>
							<span class="n">next_dup</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">in_sack</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">dup_sack</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* skb reference here is a bit tricky to get right, since</span>
<span class="cm">		 * shifting can eat and free both this skb and the next,</span>
<span class="cm">		 * so not even _safe variant of the loop is enough.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_sack</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">tcp_shift_skb_data</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span>
						 <span class="n">start_seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">,</span> <span class="n">dup_sack</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">skb</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">in_sack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">in_sack</span> <span class="o">=</span> <span class="n">tcp_match_skb_to_sack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
								<span class="n">start_seq</span><span class="p">,</span>
								<span class="n">end_seq</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">in_sack</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in_sack</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">=</span>
				<span class="n">tcp_sacktag_one</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
						<span class="n">state</span><span class="p">,</span>
						<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">,</span>
						<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span>
						<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span>
						<span class="n">dup_sack</span><span class="p">,</span>
						<span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span>
				    <span class="n">tcp_highest_sack_seq</span><span class="p">(</span><span class="n">tp</span><span class="p">)))</span>
				<span class="n">tcp_advance_highest_sack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">state</span><span class="o">-&gt;</span><span class="n">fack_count</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Avoid all extra work that is being done by sacktag while walking in</span>
<span class="cm"> * a normal way</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_sacktag_skip</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">tcp_sacktag_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">skip_to_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_for_write_queue_from</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">skip_to_seq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">state</span><span class="o">-&gt;</span><span class="n">fack_count</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_maybe_skipping_dsack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="o">*</span><span class="n">next_dup</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">tcp_sacktag_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
						<span class="n">u32</span> <span class="n">skip_to_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_dup</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">next_dup</span><span class="o">-&gt;</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">skip_to_seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_sacktag_skip</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">next_dup</span><span class="o">-&gt;</span><span class="n">start_seq</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_sacktag_walk</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span>
				       <span class="n">next_dup</span><span class="o">-&gt;</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">next_dup</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span>
				       <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_sack_cache_ok</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cache</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">recv_sack_cache</span> <span class="o">+</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">recv_sack_cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">tcp_sacktag_write_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ack_skb</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">prior_snd_una</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">ack_skb</span><span class="p">)</span> <span class="o">+</span>
				    <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">ack_skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sack_block_wire</span> <span class="o">*</span><span class="n">sp_wire</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sack_block_wire</span> <span class="o">*</span><span class="p">)(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="n">sp</span><span class="p">[</span><span class="n">TCP_NUM_SACKS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_sacktag_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_sacks</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">TCP_NUM_SACKS</span><span class="p">,</span> <span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">TCPOLEN_SACK_BASE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">used_sacks</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">found_dup_sack</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">first_sack_index</span><span class="p">;</span>

	<span class="n">state</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">state</span><span class="p">.</span><span class="n">reord</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span><span class="p">))</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcp_highest_sack_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">found_dup_sack</span> <span class="o">=</span> <span class="n">tcp_check_dsack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ack_skb</span><span class="p">,</span> <span class="n">sp_wire</span><span class="p">,</span>
					 <span class="n">num_sacks</span><span class="p">,</span> <span class="n">prior_snd_una</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_dup_sack</span><span class="p">)</span>
		<span class="n">state</span><span class="p">.</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_DSACKING_ACK</span><span class="p">;</span>

	<span class="cm">/* Eliminate too old ACKs, but take into</span>
<span class="cm">	 * account more or less fresh ones, they can</span>
<span class="cm">	 * contain valid SACK info.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">ack_skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">,</span> <span class="n">prior_snd_una</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_window</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">used_sacks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">first_sack_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_sacks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">dup_sack</span> <span class="o">=</span> <span class="o">!</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">found_dup_sack</span><span class="p">;</span>

		<span class="n">sp</span><span class="p">[</span><span class="n">used_sacks</span><span class="p">].</span><span class="n">start_seq</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp_wire</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start_seq</span><span class="p">);</span>
		<span class="n">sp</span><span class="p">[</span><span class="n">used_sacks</span><span class="p">].</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp_wire</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end_seq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_is_sackblock_valid</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">dup_sack</span><span class="p">,</span>
					    <span class="n">sp</span><span class="p">[</span><span class="n">used_sacks</span><span class="p">].</span><span class="n">start_seq</span><span class="p">,</span>
					    <span class="n">sp</span><span class="p">[</span><span class="n">used_sacks</span><span class="p">].</span><span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">mib_idx</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dup_sack</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span><span class="p">)</span>
					<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPDSACKIGNOREDNOUNDO</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPDSACKIGNOREDOLD</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Don&#39;t count olds caused by ACK reordering */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">ack_skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">used_sacks</span><span class="p">].</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPSACKDISCARD</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">mib_idx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">first_sack_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Ignore very old stuff early */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">used_sacks</span><span class="p">].</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">prior_snd_una</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">used_sacks</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* order SACK blocks to allow in order walk of the retrans queue */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">used_sacks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">start_seq</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">swap</span><span class="p">(</span><span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">sp</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>

				<span class="cm">/* Track where the first SACK block goes to */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">first_sack_index</span><span class="p">)</span>
					<span class="n">first_sack_index</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">state</span><span class="p">.</span><span class="n">fack_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* It&#39;s already past, so skip checking against it */</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">recv_sack_cache</span> <span class="o">+</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">recv_sack_cache</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">recv_sack_cache</span><span class="p">;</span>
		<span class="cm">/* Skip empty blocks in at head of the cache */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">tcp_sack_cache_ok</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">start_seq</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">)</span>
			<span class="n">cache</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">used_sacks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">start_seq</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start_seq</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">end_seq</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end_seq</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">dup_sack</span> <span class="o">=</span> <span class="p">(</span><span class="n">found_dup_sack</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">first_sack_index</span><span class="p">));</span>
		<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="o">*</span><span class="n">next_dup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_dup_sack</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">first_sack_index</span><span class="p">))</span>
			<span class="n">next_dup</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

		<span class="cm">/* Skip too early cached blocks */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">tcp_sack_cache_ok</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		       <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span>
			<span class="n">cache</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Can skip some work by looking recv_sack_cache? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_sack_cache_ok</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dup_sack</span> <span class="o">&amp;&amp;</span>
		    <span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">start_seq</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* Head todo? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">start_seq</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_sacktag_skip</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
						       <span class="n">start_seq</span><span class="p">);</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_sacktag_walk</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">next_dup</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
						       <span class="n">start_seq</span><span class="p">,</span>
						       <span class="n">cache</span><span class="o">-&gt;</span><span class="n">start_seq</span><span class="p">,</span>
						       <span class="n">dup_sack</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Rest of the block already fully processed? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">advance_sp</span><span class="p">;</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_maybe_skipping_dsack</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">next_dup</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
						       <span class="n">cache</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">);</span>

			<span class="cm">/* ...tail remains todo... */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcp_highest_sack_seq</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">==</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* ...but better entrypoint exists! */</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_highest_sack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">state</span><span class="p">.</span><span class="n">fack_count</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span><span class="p">;</span>
				<span class="n">cache</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">walk</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_sacktag_skip</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">);</span>
			<span class="cm">/* Check overlap against next cached too (past this one already) */</span>
			<span class="n">cache</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">tcp_highest_sack_seq</span><span class="p">(</span><span class="n">tp</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_highest_sack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">state</span><span class="p">.</span><span class="n">fack_count</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_sacktag_skip</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="n">start_seq</span><span class="p">);</span>

<span class="nl">walk:</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_sacktag_walk</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">next_dup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
				       <span class="n">start_seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">,</span> <span class="n">dup_sack</span><span class="p">);</span>

<span class="nl">advance_sp:</span>
		<span class="cm">/* SACK enhanced FRTO (RFC4138, Appendix B): Clearing correct</span>
<span class="cm">		 * due to in-order walk</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_highmark</span><span class="p">))</span>
			<span class="n">state</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLAG_ONLY_ORIG_SACKED</span><span class="p">;</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear the head of the cache sack blocks so we can skip it next time */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">recv_sack_cache</span><span class="p">)</span> <span class="o">-</span> <span class="n">used_sacks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">recv_sack_cache</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start_seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">recv_sack_cache</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end_seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">used_sacks</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">recv_sack_cache</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

	<span class="n">tcp_mark_lost_retrans</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">state</span><span class="p">.</span><span class="n">reord</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">TCP_CA_Loss</span><span class="p">)</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_highmark</span> <span class="o">||</span> <span class="n">after</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_highmark</span><span class="p">)))</span>
		<span class="n">tcp_update_reordering</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">-</span> <span class="n">state</span><span class="p">.</span><span class="n">reord</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">out:</span>

<span class="cp">#if FASTRETRANS_DEBUG &gt; 0</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">state</span><span class="p">.</span><span class="n">flag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Limits sacked_out so that sum with lost_out isn&#39;t ever larger than</span>
<span class="cm"> * packets_out. Returns false if sacked_out adjustement wasn&#39;t necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_limit_reno_sacked</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">holes</span><span class="p">;</span>

	<span class="n">holes</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span><span class="p">,</span> <span class="mi">1U</span><span class="p">);</span>
	<span class="n">holes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">holes</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">+</span> <span class="n">holes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">-</span> <span class="n">holes</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If we receive more dupacks than we expected counting segments</span>
<span class="cm"> * in assumption of absent reordering, interpret this as reordering.</span>
<span class="cm"> * The only another reason could be bug in receiver TCP.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_check_reno_reordering</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">addend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_limit_reno_sacked</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="n">tcp_update_reordering</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">+</span> <span class="n">addend</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Emulate SACKs for SACKless connection: account for a new dupack. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_add_reno_sack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="o">++</span><span class="p">;</span>
	<span class="n">tcp_check_reno_reordering</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Account for ACK, ACKing some data in Reno Recovery phase. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_remove_reno_sacks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">acked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">acked</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* One ACK acked hole. The rest eat duplicate ACKs. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">acked</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">-=</span> <span class="n">acked</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tcp_check_reno_reordering</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">acked</span><span class="p">);</span>
	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_reset_reno_sack</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_is_sackfrto</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sysctl_tcp_frto</span> <span class="o">==</span> <span class="mh">0x2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* F-RTO can only be used if TCP has never retransmitted anything other than</span>
<span class="cm"> * head (SACK enhanced variant from Appendix B of RFC4138 is more robust here)</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">tcp_use_frto</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sysctl_tcp_frto</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* MTU probe and F-RTO won&#39;t really play nicely along currently */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_sackfrto</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Avoid expensive walking of rexmit queue if possible */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_skb_is_last</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_next</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>	<span class="cm">/* Skips head */</span>
	<span class="n">tcp_for_write_queue_from</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_RETRANS</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="cm">/* Short-circuit when first non-SACKed skb has been checked */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* RTO occurred, but do not yet enter Loss state. Instead, defer RTO</span>
<span class="cm"> * recovery a bit and use heuristics in tcp_process_frto() to detect if</span>
<span class="cm"> * the RTO was spurious. Only clear SACKED_RETRANS of the head here to</span>
<span class="cm"> * keep retrans_out counting accurate (with SACK F-RTO, other than head</span>
<span class="cm"> * may still have that bit set); TCPCB_LOST and remaining SACKED_RETRANS</span>
<span class="cm"> * bits are handled if the Loss state is really to be entered (in</span>
<span class="cm"> * tcp_enter_frto_loss).</span>
<span class="cm"> *</span>
<span class="cm"> * Do like tcp_enter_loss() would; when RTO expires the second time it</span>
<span class="cm"> * does:</span>
<span class="cm"> *  &quot;Reduce ssthresh if it has not yet been made inside this window.&quot;</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_enter_frto</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">&amp;&amp;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">&lt;=</span> <span class="n">TCP_CA_Disorder</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_Loss</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span> <span class="o">=</span> <span class="n">tcp_current_ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="cm">/* Our state is too optimistic in ssthresh() call because cwnd</span>
<span class="cm">		 * is not reduced until tcp_enter_frto_loss() when previous F-RTO</span>
<span class="cm">		 * recovery has not yet completed. Pattern would be this: RTO,</span>
<span class="cm">		 * Cumulative ACK, RTO (2xRTO for the same segment does not end</span>
<span class="cm">		 * up here twice).</span>
<span class="cm">		 * RFC4138 should be more specific on what to do, even though</span>
<span class="cm">		 * RTO is quite unlikely to occur after the first Cumulative ACK</span>
<span class="cm">		 * due to back-off and complexity of triggering events ...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">stored_cwnd</span><span class="p">;</span>
			<span class="n">stored_cwnd</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">stored_cwnd</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* ... in theory, cong.control module could do &quot;any tricks&quot; in</span>
<span class="cm">		 * ssthresh(), which means that ca_state, lost bits and lost_out</span>
<span class="cm">		 * counter would have to be faked before the call occurs. We</span>
<span class="cm">		 * consider that too expensive, unlikely and hacky, so modules</span>
<span class="cm">		 * using these in ssthresh() must deal these incompatibility</span>
<span class="cm">		 * issues if they receives CA_EVENT_FRTO and frto_counter != 0</span>
<span class="cm">		 */</span>
		<span class="n">tcp_ca_event</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">CA_EVENT_FRTO</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_retrans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_RETRANS</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_RETRANS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPCB_SACKED_RETRANS</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">-=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="cm">/* Too bad if TCP was application limited */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span> <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Earlier loss recovery underway (see RFC4138; Appendix B).</span>
<span class="cm">	 * The last condition is necessary at least in tp-&gt;frto_counter case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_sackfrto</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">||</span>
	    <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPF_CA_Recovery</span><span class="o">|</span><span class="n">TCPF_CA_Loss</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
	    <span class="n">after</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_highmark</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_highmark</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CA_Disorder</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Enter Loss state after F-RTO was applied. Dupack arrived after RTO,</span>
<span class="cm"> * which indicates that we should follow the traditional RTO recovery,</span>
<span class="cm"> * i.e. mark everything lost and do go-back-N retransmission.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_enter_frto_loss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">allowed_segments</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="n">tcp_reset_reno_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">tcp_for_write_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPCB_LOST</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Count the retransmission made on RTO correctly (only when</span>
<span class="cm">		 * waiting for the first ACK and did not get it)...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_DATA_ACKED</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* For some reason this R-bit might get cleared? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_RETRANS</span><span class="p">)</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="cm">/* ...enter this if branch just for the first segment */</span>
			<span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_DATA_ACKED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_RETRANS</span><span class="p">)</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPCB_SACKED_RETRANS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Marking forward transmissions that were made after RTO lost</span>
<span class="cm">		 * can cause unnecessary retransmissions in some scenarios,</span>
<span class="cm">		 * SACK blocks will mitigate that in some but not in all cases.</span>
<span class="cm">		 * We used to not mark them but it was causing break-ups with</span>
<span class="cm">		 * receivers that do only in-order receival.</span>
<span class="cm">		 *</span>
<span class="cm">		 * TODO: we could detect presence of such receiver and select</span>
<span class="cm">		 * different behavior per flow.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">|=</span> <span class="n">TCPCB_LOST</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_high</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">+</span> <span class="n">allowed_segments</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">,</span>
			       <span class="n">sysctl_tcp_reordering</span><span class="p">);</span>
	<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CA_Loss</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="n">TCP_ECN_queue_cwr</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">tcp_clear_all_retrans_hints</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_clear_retrans_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_retrans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tcp_clear_retrans</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_clear_retrans_partial</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Enter Loss state. If &quot;how&quot; is not zero, forget all SACK information</span>
<span class="cm"> * and reset tags completely, otherwise preserve SACKs. If receiver</span>
<span class="cm"> * dropped its ofo queue, we will know this due to reneging detection.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_enter_loss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="cm">/* Reduce ssthresh if it has not yet been made inside this window. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">&lt;=</span> <span class="n">TCP_CA_Disorder</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_Loss</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span> <span class="o">=</span> <span class="n">tcp_current_ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tcp_ca_event</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">CA_EVENT_LOSS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span>	   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_cnt</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tcp_clear_retrans_partial</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="n">tcp_reset_reno_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">how</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Push undo marker, if it was plain RTO and nothing</span>
<span class="cm">		 * was retransmitted. */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tcp_clear_all_retrans_hints</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">tcp_for_write_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_RETRANS</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">TCPCB_TAGBITS</span><span class="p">)</span><span class="o">|</span><span class="n">TCPCB_SACKED_ACKED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="o">&amp;</span><span class="n">TCPCB_SACKED_ACKED</span><span class="p">)</span> <span class="o">||</span> <span class="n">how</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPCB_SACKED_ACKED</span><span class="p">;</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">|=</span> <span class="n">TCPCB_LOST</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_high</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">,</span>
			       <span class="n">sysctl_tcp_reordering</span><span class="p">);</span>
	<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CA_Loss</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="n">TCP_ECN_queue_cwr</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="cm">/* Abort F-RTO algorithm if one is in progress */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If ACK arrived pointing to a remembered SACK, it means that our</span>
<span class="cm"> * remembered SACKs do not reflect real state of receiver i.e.</span>
<span class="cm"> * receiver _host_ is heavily congested (or buggy).</span>
<span class="cm"> *</span>
<span class="cm"> * Do processing similar to RTO timeout.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_check_sack_reneging</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_SACK_RENEGING</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPSACKRENEGING</span><span class="p">);</span>

		<span class="n">tcp_enter_loss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tcp_retransmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
		<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_RETRANS</span><span class="p">,</span>
					  <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">,</span> <span class="n">TCP_RTO_MAX</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_fackets_out</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">?</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Heurestics to calculate number of duplicate ACKs. There&#39;s no dupACKs</span>
<span class="cm"> * counter when SACK is enabled (without SACK, sacked_out is used for</span>
<span class="cm"> * that purpose).</span>
<span class="cm"> *</span>
<span class="cm"> * Instead, with FACK TCP uses fackets_out that includes both SACKed</span>
<span class="cm"> * segments up to the highest received SACK block so far and holes in</span>
<span class="cm"> * between them.</span>
<span class="cm"> *</span>
<span class="cm"> * With reordering, holes may still be in flight, so RFC3517 recovery</span>
<span class="cm"> * uses pure sacked_out (total number of SACKed segments) even though</span>
<span class="cm"> * it violates the RFC that uses duplicate ACKs, often these are equal</span>
<span class="cm"> * but when e.g. out-of-window ACKs or packet duplication occurs,</span>
<span class="cm"> * they differ. Since neither occurs due to loss, TCP should really</span>
<span class="cm"> * ignore them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_dupack_heuristics</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">?</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">:</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_pause_early_retransmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">;</span>

	<span class="cm">/* Delay early retransmit and entering fast recovery for</span>
<span class="cm">	 * max(RTT/4, 2msec) unless ack has ECE mark, no RTT samples</span>
<span class="cm">	 * available, or RTO is scheduled to fire first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_early_retrans</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_ECE</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">delay</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">srtt</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">),</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_after</span><span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_timeout</span><span class="p">,</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">delay</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_RETRANS</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">TCP_RTO_MAX</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">early_retrans_delayed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_skb_timedout</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">&gt;</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_head_timedout</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&amp;&amp;</span>
	       <span class="n">tcp_skb_timedout</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Linux NewReno/SACK/FACK/ECN state machine.</span>
<span class="cm"> * --------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;Open&quot;	Normal state, no dubious events, fast path.</span>
<span class="cm"> * &quot;Disorder&quot;   In all the respects it is &quot;Open&quot;,</span>
<span class="cm"> *		but requires a bit more attention. It is entered when</span>
<span class="cm"> *		we see some SACKs or dupacks. It is split of &quot;Open&quot;</span>
<span class="cm"> *		mainly to move some processing from fast path to slow one.</span>
<span class="cm"> * &quot;CWR&quot;	CWND was reduced due to some Congestion Notification event.</span>
<span class="cm"> *		It can be ECN, ICMP source quench, local device congestion.</span>
<span class="cm"> * &quot;Recovery&quot;	CWND was reduced, we are fast-retransmitting.</span>
<span class="cm"> * &quot;Loss&quot;	CWND was reduced due to RTO timeout or SACK reneging.</span>
<span class="cm"> *</span>
<span class="cm"> * tcp_fastretrans_alert() is entered:</span>
<span class="cm"> * - each incoming ACK, if state is not &quot;Open&quot;</span>
<span class="cm"> * - when arrived ACK is unusual, namely:</span>
<span class="cm"> *	* SACK</span>
<span class="cm"> *	* Duplicate ACK.</span>
<span class="cm"> *	* ECN ECE.</span>
<span class="cm"> *</span>
<span class="cm"> * Counting packets in flight is pretty simple.</span>
<span class="cm"> *</span>
<span class="cm"> *	in_flight = packets_out - left_out + retrans_out</span>
<span class="cm"> *</span>
<span class="cm"> *	packets_out is SND.NXT-SND.UNA counted in packets.</span>
<span class="cm"> *</span>
<span class="cm"> *	retrans_out is number of retransmitted segments.</span>
<span class="cm"> *</span>
<span class="cm"> *	left_out is number of segments left network, but not ACKed yet.</span>
<span class="cm"> *</span>
<span class="cm"> *		left_out = sacked_out + lost_out</span>
<span class="cm"> *</span>
<span class="cm"> *     sacked_out: Packets, which arrived to receiver out of order</span>
<span class="cm"> *		   and hence not ACKed. With SACKs this number is simply</span>
<span class="cm"> *		   amount of SACKed data. Even without SACKs</span>
<span class="cm"> *		   it is easy to give pretty reliable estimate of this number,</span>
<span class="cm"> *		   counting duplicate ACKs.</span>
<span class="cm"> *</span>
<span class="cm"> *       lost_out: Packets lost by network. TCP has no explicit</span>
<span class="cm"> *		   &quot;loss notification&quot; feedback from network (for now).</span>
<span class="cm"> *		   It means that this number can be only _guessed_.</span>
<span class="cm"> *		   Actually, it is the heuristics to predict lossage that</span>
<span class="cm"> *		   distinguishes different algorithms.</span>
<span class="cm"> *</span>
<span class="cm"> *	F.e. after RTO, when all the queue is considered as lost,</span>
<span class="cm"> *	lost_out = packets_out and in_flight = retrans_out.</span>
<span class="cm"> *</span>
<span class="cm"> *		Essentially, we have now two algorithms counting</span>
<span class="cm"> *		lost packets.</span>
<span class="cm"> *</span>
<span class="cm"> *		FACK: It is the simplest heuristics. As soon as we decided</span>
<span class="cm"> *		that something is lost, we decide that _all_ not SACKed</span>
<span class="cm"> *		packets until the most forward SACK are lost. I.e.</span>
<span class="cm"> *		lost_out = fackets_out - sacked_out and left_out = fackets_out.</span>
<span class="cm"> *		It is absolutely correct estimate, if network does not reorder</span>
<span class="cm"> *		packets. And it loses any connection to reality when reordering</span>
<span class="cm"> *		takes place. We use FACK by default until reordering</span>
<span class="cm"> *		is suspected on the path to this destination.</span>
<span class="cm"> *</span>
<span class="cm"> *		NewReno: when Recovery is entered, we assume that one segment</span>
<span class="cm"> *		is lost (classic Reno). While we are in Recovery and</span>
<span class="cm"> *		a partial ACK arrives, we assume that one more packet</span>
<span class="cm"> *		is lost (NewReno). This heuristics are the same in NewReno</span>
<span class="cm"> *		and SACK.</span>
<span class="cm"> *</span>
<span class="cm"> *  Imagine, that&#39;s all! Forget about all this shamanism about CWND inflation</span>
<span class="cm"> *  deflation etc. CWND is real congestion window, never inflated, changes</span>
<span class="cm"> *  only according to classic VJ rules.</span>
<span class="cm"> *</span>
<span class="cm"> * Really tricky (and requiring careful tuning) part of algorithm</span>
<span class="cm"> * is hidden in functions tcp_time_to_recover() and tcp_xmit_retransmit_queue().</span>
<span class="cm"> * The first determines the moment _when_ we should reduce CWND and,</span>
<span class="cm"> * hence, slow down forward transmission. In fact, it determines the moment</span>
<span class="cm"> * when we decide that hole is caused by loss, rather than by a reorder.</span>
<span class="cm"> *</span>
<span class="cm"> * tcp_xmit_retransmit_queue() decides, _what_ we should retransmit to fill</span>
<span class="cm"> * holes, caused by lost packets.</span>
<span class="cm"> *</span>
<span class="cm"> * And the most logically complicated part of algorithm is undo</span>
<span class="cm"> * heuristics. We detect false retransmits due to both too early</span>
<span class="cm"> * fast retransmit (reordering) and underestimated RTO, analyzing</span>
<span class="cm"> * timestamps and D-SACKs. When we detect that some segments were</span>
<span class="cm"> * retransmitted by mistake and CWND reduction was wrong, we undo</span>
<span class="cm"> * window reduction and abort recovery phase. This logic is hidden</span>
<span class="cm"> * inside several functions named tcp_try_undo_&lt;something&gt;.</span>
<span class="cm"> */</span>

<span class="cm">/* This function decides, when we should leave Disordered state</span>
<span class="cm"> * and enter Recovery phase, reducing congestion window.</span>
<span class="cm"> *</span>
<span class="cm"> * Main question: may we further continue forward transmission</span>
<span class="cm"> * with the same cwnd?</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_time_to_recover</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">__u32</span> <span class="n">packets_out</span><span class="p">;</span>

	<span class="cm">/* Do not perform any recovery during F-RTO algorithm */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Trick#1: The loss is proven. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Not-A-Trick#2 : Classic rule... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_dupack_heuristics</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Trick#3 : when we use RFC2988 timer restart, fast</span>
<span class="cm">	 * retransmit can be triggered by timeout of queue head.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_head_timedout</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Trick#4: It is still not OK... But will it be useful to delay</span>
<span class="cm">	 * recovery more?</span>
<span class="cm">	 */</span>
	<span class="n">packets_out</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">packets_out</span> <span class="o">&lt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">&gt;=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">__u32</span><span class="p">,</span> <span class="n">packets_out</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">sysctl_tcp_reordering</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">tcp_may_send_now</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We have nothing to send. This connection is limited</span>
<span class="cm">		 * either by receiver window or by application.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If a thin stream is detected, retransmit after first</span>
<span class="cm">	 * received dupack. Employ only if SACK is supported in order</span>
<span class="cm">	 * to avoid possible corner-case series of spurious retransmissions</span>
<span class="cm">	 * Use only if there are no unsent data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">thin_dupack</span> <span class="o">||</span> <span class="n">sysctl_tcp_thin_dupack</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tcp_stream_is_thin</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_dupack_heuristics</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Trick#6: TCP early retransmit, per RFC5827.  To avoid spurious</span>
<span class="cm">	 * retransmissions due to small network reorderings, we implement</span>
<span class="cm">	 * Mitigation A.3 in the RFC and delay the retransmission for a short</span>
<span class="cm">	 * interval if appropriate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">do_early_retrans</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">==</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">tcp_may_send_now</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">tcp_pause_early_retransmit</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* New heuristics: it is possible only after we switched to restart timer</span>
<span class="cm"> * each time when something is ACKed. Hence, we can detect timed out packets</span>
<span class="cm"> * during fast retransmit without falling to slow start.</span>
<span class="cm"> *</span>
<span class="cm"> * Usefulness of this as is very questionable, since we should know which of</span>
<span class="cm"> * the segments is the next to timeout which is relatively expensive to find</span>
<span class="cm"> * in general case unless we add some data structure just for that. The</span>
<span class="cm"> * current approach certainly won&#39;t find the right one too often and when it</span>
<span class="cm"> * finally does find _something_ it usually marks large part of the window</span>
<span class="cm"> * right away (because a retransmission with a larger timestamp blocks the</span>
<span class="cm"> * loop from advancing). -ij</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_timeout_skbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">tcp_head_timedout</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">scoreboard_skb_hint</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">scoreboard_skb_hint</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_for_write_queue_from</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_skb_timedout</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">tcp_skb_mark_lost</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">scoreboard_skb_hint</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Detect loss in event &quot;A&quot; above by marking head of queue up as lost.</span>
<span class="cm"> * For FACK or non-SACK(Reno) senders, the first &quot;packets&quot; number of segments</span>
<span class="cm"> * are considered lost. For RFC3517 SACK, a segment is considered lost if it</span>
<span class="cm"> * has at least tp-&gt;reordering SACKed seqments above it; &quot;packets&quot; refers to</span>
<span class="cm"> * the maximum SACKed segments to pass before reaching this limit.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_mark_head_lost</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">packets</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mark_head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">oldcnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span><span class="p">;</span>
	<span class="cm">/* Use SACK to deduce losses of new sequences sent during recovery */</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">loss_high</span> <span class="o">=</span> <span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">?</span>  <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span> <span class="o">:</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">packets</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span><span class="p">;</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_cnt_hint</span><span class="p">;</span>
		<span class="cm">/* Head already handled? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mark_head</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span> <span class="o">!=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tcp_for_write_queue_from</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* TODO: do this better */</span>
		<span class="cm">/* this is not the most efficient way to do this... */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_cnt_hint</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">loss_high</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">oldcnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">||</span> <span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">))</span>
			<span class="n">cnt</span> <span class="o">+=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">packets</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">oldcnt</span> <span class="o">&gt;=</span> <span class="n">packets</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">tcp_fragment</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="p">(</span><span class="n">packets</span> <span class="o">-</span> <span class="n">oldcnt</span><span class="p">)</span> <span class="o">*</span> <span class="n">mss</span><span class="p">,</span> <span class="n">mss</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cnt</span> <span class="o">=</span> <span class="n">packets</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">tcp_skb_mark_lost</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mark_head</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Account newly detected lost packet(s) */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_update_scoreboard</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fast_rexmit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tcp_mark_head_lost</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">lost</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lost</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lost</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tcp_mark_head_lost</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">lost</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sacked_upto</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sacked_upto</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">tcp_mark_head_lost</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sacked_upto</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fast_rexmit</span><span class="p">)</span>
			<span class="n">tcp_mark_head_lost</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tcp_timeout_skbs</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* CWND moderation, preventing bursts due to too big ACKs</span>
<span class="cm"> * in dubious situations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_moderate_cwnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span>
			   <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">+</span> <span class="n">tcp_max_burst</span><span class="p">(</span><span class="n">tp</span><span class="p">));</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Lower bound on congestion window is slow start threshold</span>
<span class="cm"> * unless congestion avoidance choice decides to overide it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">tcp_cwnd_min</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_congestion_ops</span> <span class="o">*</span><span class="n">ca_ops</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ca_ops</span><span class="o">-&gt;</span><span class="n">min_cwnd</span> <span class="o">?</span> <span class="n">ca_ops</span><span class="o">-&gt;</span><span class="n">min_cwnd</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">:</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Decrease cwnd each second ack. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_cwnd_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">decr</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FLAG_ANY_PROGRESS</span> <span class="o">|</span> <span class="n">FLAG_DSACKING_ACK</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_NOT_DUP</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_cnt</span> <span class="o">=</span> <span class="n">decr</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">decr</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">decr</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&gt;</span> <span class="n">tcp_cwnd_min</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">-=</span> <span class="n">decr</span><span class="p">;</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span> <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Nothing was retransmitted or returned timestamp is less</span>
<span class="cm"> * than timestamp of the first retransmission.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_packet_delayed</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_stamp</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsecr</span> <span class="o">&amp;&amp;</span>
		 <span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsecr</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_stamp</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Undo procedures. */</span>

<span class="cp">#if FASTRETRANS_DEBUG &gt; 1</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">DBGUNDO</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Undo %s %pI4/%u c%u l%u ss%u/%u p%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">msg</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_daddr</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_dport</span><span class="p">),</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span> <span class="n">tcp_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">),</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_IPV6)</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ipv6_pinfo</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">inet6_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Undo %s %pI6/%u c%u l%u ss%u/%u p%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">msg</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_dport</span><span class="p">),</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span> <span class="n">tcp_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">),</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span><span class="p">,</span>
			 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define DBGUNDO(x...) do { } while (0)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_undo_cwr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">undo_ssthresh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">undo_cwnd</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">undo_cwnd</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">undo_ssthresh</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span><span class="p">;</span>
			<span class="n">TCP_ECN_withdraw_cwr</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_may_undo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_retrans</span> <span class="o">||</span> <span class="n">tcp_packet_delayed</span><span class="p">(</span><span class="n">tp</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* People celebrate: &quot;We love our President!&quot; */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_try_undo_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_may_undo</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">mib_idx</span><span class="p">;</span>

		<span class="cm">/* Happy end! We did not retransmit anything</span>
<span class="cm">		 * or our original transmission succeeded.</span>
<span class="cm">		 */</span>
		<span class="n">DBGUNDO</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_Loss</span> <span class="o">?</span> <span class="s">&quot;loss&quot;</span> <span class="o">:</span> <span class="s">&quot;retrans&quot;</span><span class="p">);</span>
		<span class="n">tcp_undo_cwr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_Loss</span><span class="p">)</span>
			<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPLOSSUNDO</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPFULLUNDO</span><span class="p">;</span>

		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">mib_idx</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Hold old state until something *above* high_seq</span>
<span class="cm">		 * is ACKed. For Reno it is MUST to prevent false</span>
<span class="cm">		 * fast retransmits (RFC2582). SACK TCP is safe. */</span>
		<span class="n">tcp_moderate_cwnd</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CA_Open</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Try to undo cwnd reduction, because D-SACKs acked all retransmitted data */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_try_undo_dsack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_retrans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DBGUNDO</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;D-SACK&quot;</span><span class="p">);</span>
		<span class="n">tcp_undo_cwr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPDSACKUNDO</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* We can clear retrans_stamp when there are no retransmissions in the</span>
<span class="cm"> * window. It would seem that it is trivially available for us in</span>
<span class="cm"> * tp-&gt;retrans_out, however, that kind of assumptions doesn&#39;t consider</span>
<span class="cm"> * what will happen if errors occur when sending retransmission for the</span>
<span class="cm"> * second time. ...It could the that such segment has only</span>
<span class="cm"> * TCPCB_EVER_RETRANS set at the present time. It seems that checking</span>
<span class="cm"> * the head skb is enough except for some reneging corner cases that</span>
<span class="cm"> * are not worth the effort.</span>
<span class="cm"> *</span>
<span class="cm"> * Main reason for all this complexity is the fact that connection dying</span>
<span class="cm"> * time now depends on the validity of the retrans_stamp, in particular,</span>
<span class="cm"> * that successive retransmissions of a segment must not advance</span>
<span class="cm"> * retrans_stamp under any conditions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_any_retrans_done</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_EVER_RETRANS</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Undo during fast recovery after partial ACK. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_try_undo_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">acked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* Partial ACK arrived. Force Hoe&#39;s retransmit. */</span>
	<span class="kt">int</span> <span class="n">failed</span> <span class="o">=</span> <span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tcp_fackets_out</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_may_undo</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Plain luck! Hole if filled with delayed</span>
<span class="cm">		 * packet, rather than with a retransmit.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_any_retrans_done</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">tcp_update_reordering</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tcp_fackets_out</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">+</span> <span class="n">acked</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">DBGUNDO</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;Hoe&quot;</span><span class="p">);</span>
		<span class="n">tcp_undo_cwr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPPARTIALUNDO</span><span class="p">);</span>

		<span class="cm">/* So... Do not make Hoe&#39;s retransmit yet.</span>
<span class="cm">		 * If the first packet was delayed, the rest</span>
<span class="cm">		 * ones are most probably delayed as well.</span>
<span class="cm">		 */</span>
		<span class="n">failed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">failed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Undo during loss recovery after partial ACK. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_try_undo_loss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_may_undo</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="n">tcp_for_write_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPCB_LOST</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">tcp_clear_all_retrans_hints</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

		<span class="n">DBGUNDO</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;partial loss&quot;</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcp_undo_cwr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPLOSSUNDO</span><span class="p">);</span>
		<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
			<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CA_Open</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_complete_cwr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Do not moderate cwnd if it&#39;s already undone in cwr or recovery. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_CWR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">);</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">&lt;</span> <span class="n">TCP_INFINITE_SSTHRESH</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* PRR algorithm. */</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">tcp_ca_event</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">CA_EVENT_COMPLETE_CWR</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_try_keep_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">TCP_CA_Open</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">||</span> <span class="n">tcp_any_retrans_done</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">TCP_CA_Disorder</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_try_to_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tcp_any_retrans_done</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_ECE</span><span class="p">)</span>
		<span class="n">tcp_enter_cwr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">TCP_CA_CWR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_try_keep_open</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">TCP_CA_Open</span><span class="p">)</span>
			<span class="n">tcp_moderate_cwnd</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tcp_cwnd_down</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_mtup_probe_failed</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">search_high</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_mtup_probe_success</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* FIXME: breaks with very large cwnd */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span> <span class="o">=</span> <span class="n">tcp_current_ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">*</span>
		       <span class="n">tcp_mss_to_mtu</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">)</span> <span class="o">/</span>
		       <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">tcp_current_ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">search_low</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span><span class="p">;</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tcp_sync_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_pmtu_cookie</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Do a simple retransmit without using the backoff mechanisms in</span>
<span class="cm"> * tcp_timer. This is used for path mtu discovery.</span>
<span class="cm"> * The socket is already locked here.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_simple_retransmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span> <span class="o">=</span> <span class="n">tcp_current_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">prior_lost</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span><span class="p">;</span>

	<span class="n">tcp_for_write_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_skb_seglen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mss</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_RETRANS</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">TCPCB_SACKED_RETRANS</span><span class="p">;</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">-=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">tcp_skb_mark_lost_uncond_verify</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tcp_clear_retrans_hints_partial</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prior_lost</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="n">tcp_limit_reno_sacked</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t muck with the congestion window here.</span>
<span class="cm">	 * Reason is that we do not increase amount of _data_</span>
<span class="cm">	 * in network, but units changed and effective</span>
<span class="cm">	 * cwnd/ssthresh really reduced now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">TCP_CA_Loss</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">tcp_current_ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CA_Loss</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tcp_xmit_retransmit_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_simple_retransmit</span><span class="p">);</span>

<span class="cm">/* This function implements the PRR algorithm, specifcally the PRR-SSRB</span>
<span class="cm"> * (proportional rate reduction with slow start reduction bound) as described in</span>
<span class="cm"> * http://www.ietf.org/id/draft-mathis-tcpm-proportional-rate-reduction-01.txt.</span>
<span class="cm"> * It computes the number of packets to send (sndcnt) based on packets newly</span>
<span class="cm"> * delivered:</span>
<span class="cm"> *   1) If the packets in flight is larger than ssthresh, PRR spreads the</span>
<span class="cm"> *	cwnd reductions across a full RTT.</span>
<span class="cm"> *   2) If packets in flight is lower than ssthresh (such as due to excess</span>
<span class="cm"> *	losses and/or application stalls), do not perform any further cwnd</span>
<span class="cm"> *	reductions, but instead slow start up to ssthresh.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_update_cwnd_in_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newly_acked_sacked</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">fast_rexmit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sndcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">-</span> <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">dividend</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">prr_delivered</span> <span class="o">+</span>
			       <span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_cwnd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sndcnt</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">dividend</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_cwnd</span><span class="p">)</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">prr_out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sndcnt</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span>
			       <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">prr_delivered</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">prr_out</span><span class="p">,</span>
				     <span class="n">newly_acked_sacked</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sndcnt</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">sndcnt</span><span class="p">,</span> <span class="p">(</span><span class="n">fast_rexmit</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">+</span> <span class="n">sndcnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_enter_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ece_ack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">mib_idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPRENORECOVERY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPSACKRECOVERY</span><span class="p">;</span>

	<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">mib_idx</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_retrans</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">&lt;</span> <span class="n">TCP_CA_CWR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ece_ack</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span> <span class="o">=</span> <span class="n">tcp_current_ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">TCP_ECN_queue_cwr</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_cwnd</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prr_delivered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prr_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CA_Recovery</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Process an event, which can update packets-in-flight not trivially.</span>
<span class="cm"> * Main goal of this function is to calculate new estimate for left_out,</span>
<span class="cm"> * taking into account both packets sitting in receiver&#39;s buffer and</span>
<span class="cm"> * packets lost by network.</span>
<span class="cm"> *</span>
<span class="cm"> * Besides that it does CWND reduction, when packet loss is detected</span>
<span class="cm"> * and changes state of machine.</span>
<span class="cm"> *</span>
<span class="cm"> * It does _not_ decide what to send, it is made in function</span>
<span class="cm"> * tcp_xmit_retransmit_queue().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_fastretrans_alert</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pkts_acked</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">newly_acked_sacked</span><span class="p">,</span> <span class="n">bool</span> <span class="n">is_dupack</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">do_lost</span> <span class="o">=</span> <span class="n">is_dupack</span> <span class="o">||</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_DATA_SACKED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">tcp_fackets_out</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">fast_rexmit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Now state machine starts.</span>
<span class="cm">	 * A. ECE, hence prohibit cwnd undoing, the reduction is required. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_ECE</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prior_ssthresh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* B. In all the states check for reneging SACKs. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_check_sack_reneging</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* C. Check consistency of the current state. */</span>
	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="cm">/* D. Check state exit conditions. State can be terminated</span>
<span class="cm">	 *    when high_seq is ACKed. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_Open</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TCP_CA_Loss</span>:
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcp_try_undo_recovery</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TCP_CA_CWR</span>:
			<span class="cm">/* CWR is to be held something *above* high_seq</span>
<span class="cm">			 * is ACKed for CWR bit to reach receiver. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">high_seq</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tcp_complete_cwr</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="n">tcp_set_ca_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CA_Open</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TCP_CA_Recovery</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
				<span class="n">tcp_reset_reno_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcp_try_undo_recovery</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="n">tcp_complete_cwr</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* E. Process state. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCP_CA_Recovery</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_SND_UNA_ADVANCED</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_dupack</span><span class="p">)</span>
				<span class="n">tcp_add_reno_sack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">do_lost</span> <span class="o">=</span> <span class="n">tcp_try_undo_partial</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">pkts_acked</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_CA_Loss</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_DATA_ACKED</span><span class="p">)</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_SND_UNA_ADVANCED</span><span class="p">)</span>
			<span class="n">tcp_reset_reno_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_try_undo_loss</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcp_moderate_cwnd</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
			<span class="n">tcp_xmit_retransmit_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">TCP_CA_Open</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="cm">/* Loss is undone; fall through to processing in Open state. */</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_SND_UNA_ADVANCED</span><span class="p">)</span>
				<span class="n">tcp_reset_reno_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_dupack</span><span class="p">)</span>
				<span class="n">tcp_add_reno_sack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">&lt;=</span> <span class="n">TCP_CA_Disorder</span><span class="p">)</span>
			<span class="n">tcp_try_undo_dsack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_time_to_recover</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcp_try_to_open</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* MTU probe failure: don&#39;t reduce cwnd */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">&lt;</span> <span class="n">TCP_CA_CWR</span> <span class="o">&amp;&amp;</span>
		    <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span> <span class="o">&amp;&amp;</span>
		    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mtu_probe</span><span class="p">.</span><span class="n">probe_seq_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcp_mtup_probe_failed</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="cm">/* Restores the reduction we did in tcp_mtup_probe() */</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="o">++</span><span class="p">;</span>
			<span class="n">tcp_simple_retransmit</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Otherwise enter Recovery state */</span>
		<span class="n">tcp_enter_recovery</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_ECE</span><span class="p">));</span>
		<span class="n">fast_rexmit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">do_lost</span> <span class="o">||</span> <span class="p">(</span><span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_head_timedout</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
		<span class="n">tcp_update_scoreboard</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">fast_rexmit</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">prr_delivered</span> <span class="o">+=</span> <span class="n">newly_acked_sacked</span><span class="p">;</span>
	<span class="n">tcp_update_cwnd_in_recovery</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">newly_acked_sacked</span><span class="p">,</span> <span class="n">fast_rexmit</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="n">tcp_xmit_retransmit_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tcp_valid_rtt_meas</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq_rtt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_rtt_estimator</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seq_rtt</span><span class="p">);</span>
	<span class="n">tcp_set_rto</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_backoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_valid_rtt_meas</span><span class="p">);</span>

<span class="cm">/* Read draft-ietf-tcplw-high-performance before mucking</span>
<span class="cm"> * with this code. (Supersedes RFC1323)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_ack_saw_tstamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* RTTM Rule: A TSecr value received in a segment is used to</span>
<span class="cm">	 * update the averaged RTT measurement only if the segment</span>
<span class="cm">	 * acknowledges some new data, i.e., only if it advances the</span>
<span class="cm">	 * left edge of the send window.</span>
<span class="cm">	 *</span>
<span class="cm">	 * See draft-ietf-tcplw-high-performance-00, section 3.3.</span>
<span class="cm">	 * 1998/04/10 Andrey V. Savochkin &lt;saw@msu.ru&gt;</span>
<span class="cm">	 *</span>
<span class="cm">	 * Changed: reset backoff as soon as we see the first valid sample.</span>
<span class="cm">	 * If we do not, we get strongly overestimated rto. With timestamps</span>
<span class="cm">	 * samples are accepted even from very old segments: f.e., when rtt=1</span>
<span class="cm">	 * increases to 8, we retransmit 5 times and after 8 seconds delayed</span>
<span class="cm">	 * answer arrives rto becomes 120 seconds! If at least one of segments</span>
<span class="cm">	 * in window is lost... Voila.	 			--ANK (010210)</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_valid_rtt_meas</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tcp_time_stamp</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsecr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_ack_no_tstamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq_rtt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We don&#39;t have a timestamp. Can only use</span>
<span class="cm">	 * packets that are not retransmitted to determine</span>
<span class="cm">	 * rtt estimates. Also, we must not reset the</span>
<span class="cm">	 * backoff for rto until we get a non-retransmitted</span>
<span class="cm">	 * packet. This allows us to deal with a situation</span>
<span class="cm">	 * where the network delay has increased suddenly.</span>
<span class="cm">	 * I.e. Karn&#39;s algorithm. (SIGCOMM &#39;87, p5.)</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_RETRANS_DATA_ACKED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tcp_valid_rtt_meas</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seq_rtt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_ack_update_rtt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">,</span>
				      <span class="k">const</span> <span class="n">s32</span> <span class="n">seq_rtt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/* Note that peer MAY send zero echo. In this case it is ignored. (rfc1323) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsecr</span><span class="p">)</span>
		<span class="n">tcp_ack_saw_tstamp</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">seq_rtt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tcp_ack_no_tstamp</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seq_rtt</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_cong_avoid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ack</span><span class="p">,</span> <span class="n">u32</span> <span class="n">in_flight</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="o">-&gt;</span><span class="n">cong_avoid</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">in_flight</span><span class="p">);</span>
	<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Restart timer after forward progress on connection.</span>
<span class="cm"> * RFC2988 recommends to restart timer to now+rto.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_rearm_rto</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inet_csk_clear_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_RETRANS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">rto</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">;</span>
		<span class="cm">/* Offset the time elapsed after installing regular RTO */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">early_retrans_delayed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">const</span> <span class="n">u32</span> <span class="n">rto_time_stamp</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">+</span> <span class="n">rto</span><span class="p">;</span>
			<span class="n">s32</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">s32</span><span class="p">)(</span><span class="n">rto_time_stamp</span> <span class="o">-</span> <span class="n">tcp_time_stamp</span><span class="p">);</span>
			<span class="cm">/* delta may not be positive if the socket is locked</span>
<span class="cm">			 * when the delayed ER timer fires and is rescheduled.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">rto</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_RETRANS</span><span class="p">,</span> <span class="n">rto</span><span class="p">,</span>
					  <span class="n">TCP_RTO_MAX</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">early_retrans_delayed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function is called when the delayed ER timer fires. TCP enters</span>
<span class="cm"> * fast recovery and performs fast-retransmit.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_resume_early_retransmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_rearm_rto</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Stop if ER is disabled after the delayed ER timer is scheduled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">do_early_retrans</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tcp_enter_recovery</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">tcp_update_scoreboard</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">tcp_xmit_retransmit_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* If we get here, the whole TSO packet has not been acked. */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">tcp_tso_acked</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">packets_acked</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">));</span>

	<span class="n">packets_acked</span> <span class="o">=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_trim_head</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">packets_acked</span> <span class="o">-=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">packets_acked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">packets_acked</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove acknowledged frames from the retransmission queue. If our packet</span>
<span class="cm"> * is before the ack sequence we can discard it as it&#39;s confirmed to have</span>
<span class="cm"> * arrived at the other end.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_clean_rtx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prior_fackets</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="n">prior_snd_una</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">now</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fully_acked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pkts_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reord</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">prior_sacked</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">seq_rtt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">ca_seq_rtt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">last_ackt</span> <span class="o">=</span> <span class="n">net_invalid_timestamp</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_write_queue_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span> <span class="o">!=</span> <span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcp_skb_cb</span> <span class="o">*</span><span class="n">scb</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">acked_pcount</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">sacked</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">;</span>

		<span class="cm">/* Determine how many packets and what bytes were acked, tso and else */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">acked_pcount</span> <span class="o">=</span> <span class="n">tcp_tso_acked</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">acked_pcount</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">fully_acked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">acked_pcount</span> <span class="o">=</span> <span class="n">tcp_skb_pcount</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_RETRANS</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_RETRANS</span><span class="p">)</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">-=</span> <span class="n">acked_pcount</span><span class="p">;</span>
			<span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_RETRANS_DATA_ACKED</span><span class="p">;</span>
			<span class="n">ca_seq_rtt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">seq_rtt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_DATA_ACKED</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">acked_pcount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
				<span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_NONHEAD_RETRANS_ACKED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ca_seq_rtt</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">when</span><span class="p">;</span>
			<span class="n">last_ackt</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">seq_rtt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">seq_rtt</span> <span class="o">=</span> <span class="n">ca_seq_rtt</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">))</span>
				<span class="n">reord</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">pkts_acked</span><span class="p">,</span> <span class="n">reord</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">-=</span> <span class="n">acked_pcount</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_LOST</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">-=</span> <span class="n">acked_pcount</span><span class="p">;</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">-=</span> <span class="n">acked_pcount</span><span class="p">;</span>
		<span class="n">pkts_acked</span> <span class="o">+=</span> <span class="n">acked_pcount</span><span class="p">;</span>

		<span class="cm">/* Initial outgoing SYN&#39;s get put onto the write_queue</span>
<span class="cm">		 * just like anything else we transmit.  It is not</span>
<span class="cm">		 * true data, and if we misinform our callers that</span>
<span class="cm">		 * this ACK acks real data, we will erroneously exit</span>
<span class="cm">		 * connection startup slow start one packet too</span>
<span class="cm">		 * quickly.  This is severely frowned upon behavior.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">tcp_flags</span> <span class="o">&amp;</span> <span class="n">TCPHDR_SYN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_DATA_ACKED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_SYN_ACKED</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fully_acked</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">tcp_unlink_write_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
		<span class="n">sk_wmem_free_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">scoreboard_skb_hint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retransmit_skb_hint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_skb_hint</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_up</span><span class="p">,</span> <span class="n">prior_snd_una</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">)))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_up</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">&amp;</span> <span class="n">TCPCB_SACKED_ACKED</span><span class="p">))</span>
		<span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_SACK_RENEGING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_ACKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_congestion_ops</span> <span class="o">*</span><span class="n">ca_ops</span>
			<span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_ops</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_mtup</span><span class="p">.</span><span class="n">probe_size</span> <span class="o">&amp;&amp;</span>
			     <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">mtu_probe</span><span class="p">.</span><span class="n">probe_seq_end</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">tcp_mtup_probe_success</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">tcp_ack_update_rtt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">seq_rtt</span><span class="p">);</span>
		<span class="n">tcp_rearm_rto</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_reno</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcp_remove_reno_sacks</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">pkts_acked</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">delta</span><span class="p">;</span>

			<span class="cm">/* Non-retransmitted hole got filled? That&#39;s reordering */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reord</span> <span class="o">&lt;</span> <span class="n">prior_fackets</span><span class="p">)</span>
				<span class="n">tcp_update_reordering</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">-</span> <span class="n">reord</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">delta</span> <span class="o">=</span> <span class="n">tcp_is_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">?</span> <span class="n">pkts_acked</span> <span class="o">:</span>
						  <span class="n">prior_sacked</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_cnt_hint</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_cnt_hint</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">pkts_acked</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ca_ops</span><span class="o">-&gt;</span><span class="n">pkts_acked</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">s32</span> <span class="n">rtt_us</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* Is the ACK triggering packet unambiguous? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_RETRANS_DATA_ACKED</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* High resolution needed and available? */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ca_ops</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCP_CONG_RTT_STAMP</span> <span class="o">&amp;&amp;</span>
				    <span class="o">!</span><span class="n">ktime_equal</span><span class="p">(</span><span class="n">last_ackt</span><span class="p">,</span>
						 <span class="n">net_invalid_timestamp</span><span class="p">()))</span>
					<span class="n">rtt_us</span> <span class="o">=</span> <span class="n">ktime_us_delta</span><span class="p">(</span><span class="n">ktime_get_real</span><span class="p">(),</span>
								<span class="n">last_ackt</span><span class="p">);</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ca_seq_rtt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">rtt_us</span> <span class="o">=</span> <span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">ca_seq_rtt</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">ca_ops</span><span class="o">-&gt;</span><span class="n">pkts_acked</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">pkts_acked</span><span class="p">,</span> <span class="n">rtt_us</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#if FASTRETRANS_DEBUG &gt; 0</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Leak l=%u %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span><span class="p">,</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span><span class="p">);</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lost_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Leak s=%u %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">,</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span><span class="p">);</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Leak r=%u %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span><span class="p">,</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span><span class="p">);</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">flag</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_ack_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Was it a usable window open? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tcp_wnd_end</span><span class="p">(</span><span class="n">tp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_backoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inet_csk_clear_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_PROBE0</span><span class="p">);</span>
		<span class="cm">/* Socket must be waked up by subsequent tcp_data_snd_check().</span>
<span class="cm">		 * This function is not for random using!</span>
<span class="cm">		 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_PROBE0</span><span class="p">,</span>
					  <span class="n">min</span><span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">&lt;&lt;</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_backoff</span><span class="p">,</span> <span class="n">TCP_RTO_MAX</span><span class="p">),</span>
					  <span class="n">TCP_RTO_MAX</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_ack_is_dubious</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_NOT_DUP</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_CA_ALERT</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">!=</span> <span class="n">TCP_CA_Open</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_may_raise_cwnd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_ECE</span><span class="p">)</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TCPF_CA_Recovery</span> <span class="o">|</span> <span class="n">TCPF_CA_CWR</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Check that window update is acceptable.</span>
<span class="cm"> * The function assumes that snd_una&lt;=ack&lt;=snd_next.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_may_update_window</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">u32</span> <span class="n">ack</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">ack_seq</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">u32</span> <span class="n">nwin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="n">after</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">after</span><span class="p">(</span><span class="n">ack_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wl1</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">ack_seq</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wl1</span> <span class="o">&amp;&amp;</span> <span class="n">nwin</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Update our send window.</span>
<span class="cm"> *</span>
<span class="cm"> * Window update algorithm, described in RFC793/RFC1122 (used in linux-2.2</span>
<span class="cm"> * and in FreeBSD. NetBSD&#39;s one is even worse.) is wrong.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_ack_update_window</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ack</span><span class="p">,</span>
				 <span class="n">u32</span> <span class="n">ack_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nwin</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">syn</span><span class="p">))</span>
		<span class="n">nwin</span> <span class="o">&lt;&lt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">snd_wscale</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_may_update_window</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">ack_seq</span><span class="p">,</span> <span class="n">nwin</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_WIN_UPDATE</span><span class="p">;</span>
		<span class="n">tcp_update_wl</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ack_seq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span> <span class="o">!=</span> <span class="n">nwin</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span> <span class="o">=</span> <span class="n">nwin</span><span class="p">;</span>

			<span class="cm">/* Note, it is the only place, where</span>
<span class="cm">			 * fast path is recovered for sending TCP.</span>
<span class="cm">			 */</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">pred_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tcp_fast_path_check</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">nwin</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_window</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_window</span> <span class="o">=</span> <span class="n">nwin</span><span class="p">;</span>
				<span class="n">tcp_sync_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_pmtu_cookie</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">=</span> <span class="n">ack</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">flag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* A very conservative spurious RTO response algorithm: reduce cwnd and</span>
<span class="cm"> * continue in congestion avoidance.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_conservative_spur_to_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">bytes_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">TCP_ECN_queue_cwr</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="n">tcp_moderate_cwnd</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* A conservative spurious RTO response algorithm: reduce cwnd using</span>
<span class="cm"> * rate halving and continue in congestion avoidance.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_ratehalving_spur_to_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_enter_cwr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_undo_spur_to_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_ECE</span><span class="p">)</span>
		<span class="n">tcp_ratehalving_spur_to_response</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tcp_undo_cwr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* F-RTO spurious RTO detection algorithm (RFC4138)</span>
<span class="cm"> *</span>
<span class="cm"> * F-RTO affects during two new ACKs following RTO (well, almost, see inline</span>
<span class="cm"> * comments). State (ACK number) is kept in frto_counter. When ACK advances</span>
<span class="cm"> * window (but not to or beyond highest sequence sent before RTO):</span>
<span class="cm"> *   On First ACK,  send two new segments out.</span>
<span class="cm"> *   On Second ACK, RTO was likely spurious. Do spurious response (response</span>
<span class="cm"> *                  algorithm is not part of the F-RTO detection algorithm</span>
<span class="cm"> *                  given in RFC4138 but can be selected separately).</span>
<span class="cm"> * Otherwise (basically on duplicate ACK), RTO was (likely) caused by a loss</span>
<span class="cm"> * and TCP falls back to conventional RTO recovery. F-RTO allows overriding</span>
<span class="cm"> * of Nagle, this is done using frto_counter states 2 and 3, when a new data</span>
<span class="cm"> * segment of any size sent during F-RTO, state 2 is upgraded to 3.</span>
<span class="cm"> *</span>
<span class="cm"> * Rationale: if the RTO was spurious, new ACKs should arrive from the</span>
<span class="cm"> * original window even after we transmit two new data segments.</span>
<span class="cm"> *</span>
<span class="cm"> * SACK version:</span>
<span class="cm"> *   on first step, wait until first cumulative ACK arrives, then move to</span>
<span class="cm"> *   the second step. In second step, the next ACK decides.</span>
<span class="cm"> *</span>
<span class="cm"> * F-RTO is implemented (mainly) in four functions:</span>
<span class="cm"> *   - tcp_use_frto() is used to determine if TCP is can use F-RTO</span>
<span class="cm"> *   - tcp_enter_frto() prepares TCP state on RTO if F-RTO is used, it is</span>
<span class="cm"> *     called when tcp_use_frto() showed green light</span>
<span class="cm"> *   - tcp_process_frto() handles incoming ACKs during F-RTO algorithm</span>
<span class="cm"> *   - tcp_enter_frto_loss() is called if there is not enough evidence</span>
<span class="cm"> *     to prove that the RTO is indeed spurious. It transfers the control</span>
<span class="cm"> *     from F-RTO to the conventional RTO recovery</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_process_frto</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_verify_left_out</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="cm">/* Duplicate the behavior from Loss state (fastretrans_alert) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_DATA_ACKED</span><span class="p">)</span>
		<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_NONHEAD_RETRANS_ACKED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_RETRANS_DATA_ACKED</span><span class="p">)))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_highmark</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tcp_enter_frto_loss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">3</span><span class="p">),</span> <span class="n">flag</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_is_sackfrto</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* RFC4138 shortcoming in step 2; should also have case c):</span>
<span class="cm">		 * ACK isn&#39;t duplicate nor advances window, e.g., opposite dir</span>
<span class="cm">		 * data, winupdate</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_ANY_PROGRESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_NOT_DUP</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_DATA_ACKED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcp_enter_frto_loss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">3</span><span class="p">),</span>
					    <span class="n">flag</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_DATA_ACKED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Prevent sending of new data. */</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span>
					   <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">));</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_FORWARD_PROGRESS</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_DATA_SACKED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		      <span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_ONLY_ORIG_SACKED</span><span class="p">))))</span> <span class="p">{</span>
			<span class="cm">/* RFC4138 shortcoming (see comment above) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_FORWARD_PROGRESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_NOT_DUP</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

			<span class="n">tcp_enter_frto_loss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* tcp_may_send_now needs to see updated state */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_may_send_now</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">tcp_enter_frto_loss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">sysctl_tcp_frto_response</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">tcp_undo_spur_to_response</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">tcp_conservative_spur_to_response</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">tcp_ratehalving_spur_to_response</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">undo_marker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPSPURIOUSRTOS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This routine deals with incoming acks, but not outgoing ones. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">prior_snd_una</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ack_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ack</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">is_dupack</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">prior_in_flight</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">prior_fackets</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prior_packets</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prior_sacked</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pkts_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">newly_acked_sacked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">frto_cwnd</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* If the ack is older than previous acks</span>
<span class="cm">	 * then we can probably ignore it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">prior_snd_una</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">old_ack</span><span class="p">;</span>

	<span class="cm">/* If the ack includes data we haven&#39;t sent yet, discard</span>
<span class="cm">	 * this segment (RFC793 Section 3.9).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">invalid_ack</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">early_retrans_delayed</span><span class="p">)</span>
		<span class="n">tcp_rearm_rto</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">prior_snd_una</span><span class="p">))</span>
		<span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_SND_UNA_ADVANCED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_tcp_abc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">&lt;</span> <span class="n">TCP_CA_CWR</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">bytes_acked</span> <span class="o">+=</span> <span class="n">ack</span> <span class="o">-</span> <span class="n">prior_snd_una</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_Loss</span><span class="p">)</span>
			<span class="cm">/* we assume just one segment left network */</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">bytes_acked</span> <span class="o">+=</span> <span class="n">min</span><span class="p">(</span><span class="n">ack</span> <span class="o">-</span> <span class="n">prior_snd_una</span><span class="p">,</span>
					       <span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">prior_fackets</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">fackets_out</span><span class="p">;</span>
	<span class="n">prior_in_flight</span> <span class="o">=</span> <span class="n">tcp_packets_in_flight</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_SLOWPATH</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">after</span><span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">prior_snd_una</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Window is constant, pure forward advance.</span>
<span class="cm">		 * No more checks are required.</span>
<span class="cm">		 * Note, we use the fact that SND.UNA&gt;=SND.WL2.</span>
<span class="cm">		 */</span>
		<span class="n">tcp_update_wl</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ack_seq</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">=</span> <span class="n">ack</span><span class="p">;</span>
		<span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_WIN_UPDATE</span><span class="p">;</span>

		<span class="n">tcp_ca_event</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">CA_EVENT_FAST_ACK</span><span class="p">);</span>

		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPHPACKS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ack_seq</span> <span class="o">!=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">)</span>
			<span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_DATA</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPPUREACKS</span><span class="p">);</span>

		<span class="n">flag</span> <span class="o">|=</span> <span class="n">tcp_ack_update_window</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">ack_seq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">)</span>
			<span class="n">flag</span> <span class="o">|=</span> <span class="n">tcp_sacktag_write_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">prior_snd_una</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">TCP_ECN_rcv_ecn_echo</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)))</span>
			<span class="n">flag</span> <span class="o">|=</span> <span class="n">FLAG_ECE</span><span class="p">;</span>

		<span class="n">tcp_ca_event</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">CA_EVENT_SLOW_ACK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We passed data and got it acked, remove any soft error</span>
<span class="cm">	 * log. Something worked...</span>
<span class="cm">	 */</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err_soft</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_probes_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_tstamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="n">prior_packets</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prior_packets</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_queue</span><span class="p">;</span>

	<span class="cm">/* See if we can take anything off of the retransmit queue. */</span>
	<span class="n">flag</span> <span class="o">|=</span> <span class="n">tcp_clean_rtx_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">prior_fackets</span><span class="p">,</span> <span class="n">prior_snd_una</span><span class="p">);</span>

	<span class="n">pkts_acked</span> <span class="o">=</span> <span class="n">prior_packets</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span><span class="p">;</span>
	<span class="n">newly_acked_sacked</span> <span class="o">=</span> <span class="p">(</span><span class="n">prior_packets</span> <span class="o">-</span> <span class="n">prior_sacked</span><span class="p">)</span> <span class="o">-</span>
			     <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_counter</span><span class="p">)</span>
		<span class="n">frto_cwnd</span> <span class="o">=</span> <span class="n">tcp_process_frto</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="cm">/* Guarantee sacktag reordering detection against wrap-arounds */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_highmark</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">frto_highmark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_ack_is_dubious</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Advance CWND, if state allows this. */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_DATA_ACKED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">frto_cwnd</span> <span class="o">&amp;&amp;</span>
		    <span class="n">tcp_may_raise_cwnd</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>
			<span class="n">tcp_cong_avoid</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">prior_in_flight</span><span class="p">);</span>
		<span class="n">is_dupack</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FLAG_SND_UNA_ADVANCED</span> <span class="o">|</span> <span class="n">FLAG_NOT_DUP</span><span class="p">));</span>
		<span class="n">tcp_fastretrans_alert</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">pkts_acked</span><span class="p">,</span> <span class="n">newly_acked_sacked</span><span class="p">,</span>
				      <span class="n">is_dupack</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_DATA_ACKED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">frto_cwnd</span><span class="p">)</span>
			<span class="n">tcp_cong_avoid</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">prior_in_flight</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_FORWARD_PROGRESS</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_NOT_DUP</span><span class="p">))</span>
		<span class="n">dst_confirm</span><span class="p">(</span><span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">no_queue:</span>
	<span class="cm">/* If data was DSACKed, see if we can undo a cwnd reduction. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">FLAG_DSACKING_ACK</span><span class="p">)</span>
		<span class="n">tcp_fastretrans_alert</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">pkts_acked</span><span class="p">,</span> <span class="n">newly_acked_sacked</span><span class="p">,</span>
				      <span class="n">is_dupack</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="cm">/* If this ack opens up a zero window, clear backoff.  It was</span>
<span class="cm">	 * being used to time the probes, and is probably far higher than</span>
<span class="cm">	 * it needs to be for normal retransmission.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_send_head</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">tcp_ack_probe</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">invalid_ack:</span>
	<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;Ack %u after %u:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="nl">old_ack:</span>
	<span class="cm">/* If data was SACKed, tag it and see if we should send more data.</span>
<span class="cm">	 * If data was DSACKed, see if we can undo a cwnd reduction.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flag</span> <span class="o">|=</span> <span class="n">tcp_sacktag_write_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">prior_snd_una</span><span class="p">);</span>
		<span class="n">newly_acked_sacked</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">sacked_out</span> <span class="o">-</span> <span class="n">prior_sacked</span><span class="p">;</span>
		<span class="n">tcp_fastretrans_alert</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">pkts_acked</span><span class="p">,</span> <span class="n">newly_acked_sacked</span><span class="p">,</span>
				      <span class="n">is_dupack</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;Ack %u before %u:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Look for tcp options. Normally only called on SYN and SYNACK packets.</span>
<span class="cm"> * But, this can also be called on packets in the established flow when</span>
<span class="cm"> * the fast version below fails.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_parse_options</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcp_options_received</span> <span class="o">*</span><span class="n">opt_rx</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">u8</span> <span class="o">**</span><span class="n">hvpp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">estab</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">);</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">th</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">saw_tstamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">opcode</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">opsize</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TCPOPT_EOL</span>:
			<span class="k">return</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TCPOPT_NOP</span>:	<span class="cm">/* Ref: RFC 793 section 3.1 */</span>
			<span class="n">length</span><span class="o">--</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">opsize</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">opsize</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="cm">/* &quot;silly options&quot; */</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">opsize</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>	<span class="cm">/* don&#39;t parse partial options */</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">TCPOPT_MSS</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">opsize</span> <span class="o">==</span> <span class="n">TCPOLEN_MSS</span> <span class="o">&amp;&amp;</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">estab</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">u16</span> <span class="n">in_mss</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">in_mss</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">user_mss</span> <span class="o">&amp;&amp;</span>
						    <span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">user_mss</span> <span class="o">&lt;</span> <span class="n">in_mss</span><span class="p">)</span>
							<span class="n">in_mss</span> <span class="o">=</span> <span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">user_mss</span><span class="p">;</span>
						<span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">mss_clamp</span> <span class="o">=</span> <span class="n">in_mss</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">TCPOPT_WINDOW</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">opsize</span> <span class="o">==</span> <span class="n">TCPOLEN_WINDOW</span> <span class="o">&amp;&amp;</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">&amp;&amp;</span>
				    <span class="o">!</span><span class="n">estab</span> <span class="o">&amp;&amp;</span> <span class="n">sysctl_tcp_window_scaling</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">__u8</span> <span class="n">snd_wscale</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">__u8</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
					<span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">wscale_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">snd_wscale</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">net_info_ratelimited</span><span class="p">(</span><span class="s">&quot;%s: Illegal window scaling value %d &gt;14 received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								     <span class="n">__func__</span><span class="p">,</span>
								     <span class="n">snd_wscale</span><span class="p">);</span>
						<span class="n">snd_wscale</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">snd_wscale</span> <span class="o">=</span> <span class="n">snd_wscale</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">TCPOPT_TIMESTAMP</span>:
				<span class="k">if</span> <span class="p">((</span><span class="n">opsize</span> <span class="o">==</span> <span class="n">TCPOLEN_TIMESTAMP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">((</span><span class="n">estab</span> <span class="o">&amp;&amp;</span> <span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">tstamp_ok</span><span class="p">)</span> <span class="o">||</span>
				     <span class="p">(</span><span class="o">!</span><span class="n">estab</span> <span class="o">&amp;&amp;</span> <span class="n">sysctl_tcp_timestamps</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">saw_tstamp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">rcv_tsval</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
					<span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">rcv_tsecr</span> <span class="o">=</span> <span class="n">get_unaligned_be32</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">TCPOPT_SACK_PERM</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">opsize</span> <span class="o">==</span> <span class="n">TCPOLEN_SACK_PERM</span> <span class="o">&amp;&amp;</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">&amp;&amp;</span>
				    <span class="o">!</span><span class="n">estab</span> <span class="o">&amp;&amp;</span> <span class="n">sysctl_tcp_sack</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">sack_ok</span> <span class="o">=</span> <span class="n">TCP_SACK_SEEN</span><span class="p">;</span>
					<span class="n">tcp_sack_reset</span><span class="p">(</span><span class="n">opt_rx</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">TCPOPT_SACK</span>:
				<span class="k">if</span> <span class="p">((</span><span class="n">opsize</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">TCPOLEN_SACK_BASE</span> <span class="o">+</span> <span class="n">TCPOLEN_SACK_PERBLOCK</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				   <span class="o">!</span><span class="p">((</span><span class="n">opsize</span> <span class="o">-</span> <span class="n">TCPOLEN_SACK_BASE</span><span class="p">)</span> <span class="o">%</span> <span class="n">TCPOLEN_SACK_PERBLOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				   <span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">sack_ok</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sacked</span> <span class="o">=</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">th</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
			<span class="k">case</span> <span class="n">TCPOPT_MD5SIG</span>:
				<span class="cm">/*</span>
<span class="cm">				 * The MD5 Hash has already been</span>
<span class="cm">				 * checked (see tcp_v{4,6}_do_rcv()).</span>
<span class="cm">				 */</span>
				<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="k">case</span> <span class="n">TCPOPT_COOKIE</span>:
				<span class="cm">/* This option is variable length.</span>
<span class="cm">				 */</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">opsize</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">TCPOLEN_COOKIE_BASE</span>:
					<span class="cm">/* not yet implemented */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">TCPOLEN_COOKIE_PAIR</span>:
					<span class="cm">/* not yet implemented */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">TCPOLEN_COOKIE_MIN</span><span class="o">+</span><span class="mi">0</span>:
				<span class="k">case</span> <span class="n">TCPOLEN_COOKIE_MIN</span><span class="o">+</span><span class="mi">2</span>:
				<span class="k">case</span> <span class="n">TCPOLEN_COOKIE_MIN</span><span class="o">+</span><span class="mi">4</span>:
				<span class="k">case</span> <span class="n">TCPOLEN_COOKIE_MIN</span><span class="o">+</span><span class="mi">6</span>:
				<span class="k">case</span> <span class="n">TCPOLEN_COOKIE_MAX</span>:
					<span class="cm">/* 16-bit multiple */</span>
					<span class="n">opt_rx</span><span class="o">-&gt;</span><span class="n">cookie_plus</span> <span class="o">=</span> <span class="n">opsize</span><span class="p">;</span>
					<span class="o">*</span><span class="n">hvpp</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="cm">/* ignore option */</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ptr</span> <span class="o">+=</span> <span class="n">opsize</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
			<span class="n">length</span> <span class="o">-=</span> <span class="n">opsize</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_parse_options</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_parse_aligned_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="p">)(</span><span class="n">th</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">htonl</span><span class="p">((</span><span class="n">TCPOPT_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">TCPOPT_NOP</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
			  <span class="o">|</span> <span class="p">(</span><span class="n">TCPOPT_TIMESTAMP</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">TCPOLEN_TIMESTAMP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">++</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsval</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
		<span class="o">++</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsecr</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Fast parse options. This hopes to only see timestamps.</span>
<span class="cm"> * If it is wrong it falls back on tcp_parse_options().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_fast_parse_options</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">**</span><span class="n">hvpp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* In the spirit of fast parsing, compare doff directly to constant</span>
<span class="cm">	 * values.  Because equality is used, short doff can be ignored here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">==</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">tstamp_ok</span> <span class="o">&amp;&amp;</span>
		   <span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">==</span> <span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">)</span> <span class="o">+</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_parse_aligned_timestamp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">th</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tcp_parse_options</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">,</span> <span class="n">hvpp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TCP_MD5SIG</span>
<span class="cm">/*</span>
<span class="cm"> * Parse MD5 Signature option</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="nf">tcp_parse_md5sig_option</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">th</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* If the TCP option is too short, we can short cut */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">TCPOLEN_MD5SIG</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">opcode</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">opsize</span><span class="p">;</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TCPOPT_EOL</span>:
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TCPOPT_NOP</span>:
			<span class="n">length</span><span class="o">--</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">opsize</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">opsize</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">opsize</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">TCPOPT_MD5SIG</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">opsize</span> <span class="o">==</span> <span class="n">TCPOLEN_MD5SIG</span> <span class="o">?</span> <span class="n">ptr</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">opsize</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">length</span> <span class="o">-=</span> <span class="n">opsize</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_parse_md5sig_option</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_store_ts_recent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsval</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_replace_ts_recent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* PAWS bug workaround wrt. ACK frames, the PAWS discard</span>
<span class="cm">		 * extra check below makes sure this can only happen</span>
<span class="cm">		 * for pure ACK frames.  -DaveM</span>
<span class="cm">		 *</span>
<span class="cm">		 * Not only, also it occurs for expired timestamps.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_paws_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">tcp_store_ts_recent</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Sorry, PAWS as specified is broken wrt. pure-ACKs -DaveM</span>
<span class="cm"> *</span>
<span class="cm"> * It is not fatal. If this ACK does _not_ change critical state (seqs, window)</span>
<span class="cm"> * it can pass through stack. So, the following predicate verifies that</span>
<span class="cm"> * this segment is not used for anything but congestion avoidance or</span>
<span class="cm"> * fast retransmit. Moreover, we even are able to eliminate most of such</span>
<span class="cm"> * second order effects, if we apply some small &quot;replay&quot; window (~RTO)</span>
<span class="cm"> * to timestamp space.</span>
<span class="cm"> *</span>
<span class="cm"> * All these measures still do not guarantee that we reject wrapped ACKs</span>
<span class="cm"> * on networks with high bandwidth, when sequence space is recycled fastly,</span>
<span class="cm"> * but it guarantees that such events will be very rare and do not affect</span>
<span class="cm"> * connection seriously. This doesn&#39;t look nice, but alas, PAWS is really</span>
<span class="cm"> * buggy extension.</span>
<span class="cm"> *</span>
<span class="cm"> * [ Later note. Even worse! It is buggy for segments _with_ data. RFC</span>
<span class="cm"> * states that events when retransmit arrives after original data are rare.</span>
<span class="cm"> * It is a blatant lie. VJ forgot about fast retransmit! 8)8) It is</span>
<span class="cm"> * the biggest problem on large power networks even with minor reordering.</span>
<span class="cm"> * OK, let&#39;s give it small replay window. If peer clock is even 1hz, it is safe</span>
<span class="cm"> * up to bandwidth of 18Gigabit/sec. 8) ]</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_disordered_ack</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ack</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="cm">/* 1. Pure ACK with correct sequence number. */</span>
		<span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span> <span class="o">==</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">)</span> <span class="o">&amp;&amp;</span>

		<span class="cm">/* 2. ... and duplicate ACK. */</span>
		<span class="n">ack</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">&amp;&amp;</span>

		<span class="cm">/* 3. ... and does not update window. */</span>
		<span class="o">!</span><span class="n">tcp_may_update_window</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ack</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">snd_wscale</span><span class="p">)</span> <span class="o">&amp;&amp;</span>

		<span class="cm">/* 4. ... and sits in replay window. */</span>
		<span class="p">(</span><span class="n">s32</span><span class="p">)(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsval</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_paws_discard</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">tcp_paws_check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">,</span> <span class="n">TCP_PAWS_WINDOW</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="o">!</span><span class="n">tcp_disordered_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check segment sequence number for validity.</span>
<span class="cm"> *</span>
<span class="cm"> * Segment controls are considered valid, if the segment</span>
<span class="cm"> * fits to the window after truncation to the window. Acceptability</span>
<span class="cm"> * of data (and SYN, FIN, of course) is checked separately.</span>
<span class="cm"> * See tcp_data_queue(), for example.</span>
<span class="cm"> *</span>
<span class="cm"> * Also, controls (RST is main one) are accepted using RCV.WUP instead</span>
<span class="cm"> * of RCV.NXT. Peer still did not advance his SND.UNA when we</span>
<span class="cm"> * delayed ACK, so that hisSND.UNA&lt;=ourRCV.WUP.</span>
<span class="cm"> * (borrowed from freebsd)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_sequence</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">end_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">+</span> <span class="n">tcp_receive_window</span><span class="p">(</span><span class="n">tp</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* When we get a reset we do this. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We want the right error as BSD sees it (and indeed as we do). */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCP_SYN_SENT</span>:
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">ECONNREFUSED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_CLOSE_WAIT</span>:
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">EPIPE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_CLOSE</span>:
		<span class="k">return</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">ECONNRESET</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* This barrier is coupled with smp_rmb() in tcp_poll() */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_report</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_done</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 	Process the FIN bit. This now behaves as it is supposed to work</span>
<span class="cm"> *	and the FIN takes effect when it is validly part of sequence</span>
<span class="cm"> *	space. Not before when we get holes.</span>
<span class="cm"> *</span>
<span class="cm"> *	If we are ESTABLISHED, a received fin moves us to CLOSE-WAIT</span>
<span class="cm"> *	(and thence onto LAST-ACK and finally, CLOSE, we never enter</span>
<span class="cm"> *	TIME-WAIT)</span>
<span class="cm"> *</span>
<span class="cm"> *	If we are in FINWAIT-1, a received FIN indicates simultaneous</span>
<span class="cm"> *	close and we go into CLOSING (and later onto TIME-WAIT)</span>
<span class="cm"> *</span>
<span class="cm"> *	If we are in FINWAIT-2, a received FIN moves us to TIME-WAIT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_fin</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">inet_csk_schedule_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">|=</span> <span class="n">RCV_SHUTDOWN</span><span class="p">;</span>
	<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DONE</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCP_SYN_RECV</span>:
	<span class="k">case</span> <span class="n">TCP_ESTABLISHED</span>:
		<span class="cm">/* Move to CLOSE_WAIT */</span>
		<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CLOSE_WAIT</span><span class="p">);</span>
		<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_CLOSE_WAIT</span>:
	<span class="k">case</span> <span class="n">TCP_CLOSING</span>:
		<span class="cm">/* Received a retransmission of the FIN, do</span>
<span class="cm">		 * nothing.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_LAST_ACK</span>:
		<span class="cm">/* RFC793: Remain in the LAST-ACK state. */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_FIN_WAIT1</span>:
		<span class="cm">/* This case occurs when a simultaneous close</span>
<span class="cm">		 * happens, we must ack the received FIN and</span>
<span class="cm">		 * enter the CLOSING state.</span>
<span class="cm">		 */</span>
		<span class="n">tcp_send_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_CLOSING</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_FIN_WAIT2</span>:
		<span class="cm">/* Received a FIN -- send ACK and enter TIME_WAIT. */</span>
		<span class="n">tcp_send_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tcp_time_wait</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_TIME_WAIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Only TCP_LISTEN and TCP_CLOSE are left, in these</span>
<span class="cm">		 * cases we should never reach this piece of code.</span>
<span class="cm">		 */</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Impossible, sk-&gt;sk_state=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* It _is_ possible, that we have something out-of-order _after_ FIN.</span>
<span class="cm">	 * Probably, we should reset in this case. For now drop them.</span>
<span class="cm">	 */</span>
	<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="n">tcp_sack_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">);</span>
	<span class="n">sk_mem_reclaim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="cm">/* Do not send POLL_HUP for half duplex close. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">==</span> <span class="n">SHUTDOWN_MASK</span> <span class="o">||</span>
		    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span>
			<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_WAITD</span><span class="p">,</span> <span class="n">POLL_HUP</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_WAITD</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">tcp_sack_extend</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">end_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">start_seq</span><span class="p">))</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">start_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">end_seq</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_dsack_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">end_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sysctl_tcp_dsack</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">mib_idx</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span>
			<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPDSACKOLDSENT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mib_idx</span> <span class="o">=</span> <span class="n">LINUX_MIB_TCPDSACKOFOSENT</span><span class="p">;</span>

		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">mib_idx</span><span class="p">);</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">dsack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">duplicate_sack</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">start_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">duplicate_sack</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">end_seq</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_dsack_extend</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">end_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">dsack</span><span class="p">)</span>
		<span class="n">tcp_dsack_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tcp_sack_extend</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">duplicate_sack</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_send_dupack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">!=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&amp;&amp;</span>
	    <span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_DELAYEDACKLOST</span><span class="p">);</span>
		<span class="n">tcp_enter_quickack_mode</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sysctl_tcp_dsack</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span>
				<span class="n">end_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">;</span>
			<span class="n">tcp_dsack_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tcp_send_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* These routines update the SACK block as out-of-order packets arrive or</span>
<span class="cm"> * in-order packets close up the sequence space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_sack_maybe_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">this_sack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">selective_acks</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="o">*</span><span class="n">swalk</span> <span class="o">=</span> <span class="n">sp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* See if the recent change to the first SACK eats into</span>
<span class="cm">	 * or hits the sequence space of other SACK blocks, if so coalesce.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">this_sack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">this_sack</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span><span class="p">;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_sack_extend</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">swalk</span><span class="o">-&gt;</span><span class="n">start_seq</span><span class="p">,</span> <span class="n">swalk</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="cm">/* Zap SWALK, by moving every further SACK up by one slot.</span>
<span class="cm">			 * Decrease num_sacks.</span>
<span class="cm">			 */</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span><span class="o">--</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">this_sack</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">sp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">this_sack</span><span class="o">++</span><span class="p">,</span> <span class="n">swalk</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_sack_new_ofo_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">end_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">selective_acks</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">cur_sacks</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_sack</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur_sacks</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">new_sack</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">this_sack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">this_sack</span> <span class="o">&lt;</span> <span class="n">cur_sacks</span><span class="p">;</span> <span class="n">this_sack</span><span class="o">++</span><span class="p">,</span> <span class="n">sp</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_sack_extend</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Rotate this_sack to the first one. */</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">this_sack</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">this_sack</span><span class="o">--</span><span class="p">,</span> <span class="n">sp</span><span class="o">--</span><span class="p">)</span>
				<span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">sp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur_sacks</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">tcp_sack_maybe_coalesce</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Could not find an adjacent existing SACK, build a new one,</span>
<span class="cm">	 * put it at the front, and shift everyone else down.  We</span>
<span class="cm">	 * always know there is at least one SACK present already here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the sack array is full, forget about the last one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_sack</span> <span class="o">&gt;=</span> <span class="n">TCP_NUM_SACKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">this_sack</span><span class="o">--</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span><span class="o">--</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">this_sack</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">this_sack</span><span class="o">--</span><span class="p">,</span> <span class="n">sp</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">sp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">new_sack:</span>
	<span class="cm">/* Build the new head SACK, and we&#39;re done. */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">start_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">end_seq</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* RCV.NXT advances, some SACKs should be eaten. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_sack_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sack_block</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">selective_acks</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">num_sacks</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">this_sack</span><span class="p">;</span>

	<span class="cm">/* Empty ofo queue, hence, all the SACKs are eaten. Clear. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">this_sack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">this_sack</span> <span class="o">&lt;</span> <span class="n">num_sacks</span><span class="p">;)</span> <span class="p">{</span>
		<span class="cm">/* Check if the start of the sack is covered by RCV.NXT. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">start_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

			<span class="cm">/* RCV.NXT must cover all the block! */</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">));</span>

			<span class="cm">/* Zap this SACK, by moving forward any other SACKS. */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">this_sack</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_sacks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">selective_acks</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">selective_acks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">num_sacks</span><span class="o">--</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">this_sack</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span> <span class="o">=</span> <span class="n">num_sacks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This one checks to see if we can put data from the</span>
<span class="cm"> * out_of_order queue into the receive_queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_ofo_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">__u32</span> <span class="n">dsack_high</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">dsack_high</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__u32</span> <span class="n">dsack</span> <span class="o">=</span> <span class="n">dsack_high</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">dsack_high</span><span class="p">))</span>
				<span class="n">dsack_high</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
			<span class="n">tcp_dsack_extend</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">dsack</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;ofo packet was already received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">);</span>
			<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;ofo requeuing : rcv_next %X seq %X - %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span>
			   <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">);</span>

		<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">);</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">)</span>
			<span class="n">tcp_fin</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">tcp_prune_ofo_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">tcp_prune_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_try_rmem_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">sk_rmem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_prune_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_rmem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_prune_ofo_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_rmem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tcp_try_coalesce - try to merge skb to prior one</span>
<span class="cm"> * @sk: socket</span>
<span class="cm"> * @to: prior buffer</span>
<span class="cm"> * @from: buffer to add in queue</span>
<span class="cm"> * @fragstolen: pointer to boolean</span>
<span class="cm"> *</span>
<span class="cm"> * Before queueing skb @from after @to, try to merge them</span>
<span class="cm"> * to reduce overall memory use and queue lengths, if cost is small.</span>
<span class="cm"> * Packets in ofo or receive queues can stay a long time.</span>
<span class="cm"> * Better try to coalesce them right now to avoid future collapses.</span>
<span class="cm"> * Returns true if caller should free @from instead of queueing it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_try_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="o">*</span><span class="n">fragstolen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">delta</span><span class="p">;</span>

	<span class="o">*</span><span class="n">fragstolen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Its possible this segment overlaps with prior segment in queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">to</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_try_coalesce</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">fragstolen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delta</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">atomic_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>
	<span class="n">sk_mem_charge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
	<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPRCVCOALESCE</span><span class="p">);</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">to</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">to</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_data_queue_ofo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">;</span>

	<span class="n">TCP_ECN_check_ce</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_try_rmem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* TODO: should increment a counter */</span>
		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Disable header prediction. */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">pred_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inet_csk_schedule_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;out of order segment: rcv_next %X seq %X - %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">);</span>

	<span class="n">skb1</span> <span class="o">=</span> <span class="n">skb_peek_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Initial out of order segment, build 1 SACK. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">selective_acks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">start_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">selective_acks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">end_seq</span> <span class="o">=</span>
						<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">==</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">fragstolen</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_try_coalesce</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb1</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fragstolen</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__skb_queue_after</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span> <span class="n">skb1</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">kfree_skb_partial</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fragstolen</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span> <span class="o">||</span>
		    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">selective_acks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">end_seq</span> <span class="o">!=</span> <span class="n">seq</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">add_sack</span><span class="p">;</span>

		<span class="cm">/* Common case: data arrive in order after hole. */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">selective_acks</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">end_seq</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find place to insert this segment. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_is_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span> <span class="n">skb1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skb1</span> <span class="o">=</span> <span class="n">skb_queue_prev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span> <span class="n">skb1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Do skb overlap to previous one? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb1</span> <span class="o">&amp;&amp;</span> <span class="n">before</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* All the bits are present. Drop. */</span>
			<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">tcp_dsack_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">add_sack</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Partial overlap. */</span>
			<span class="n">tcp_dsack_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span>
				      <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_is_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span>
					       <span class="n">skb1</span><span class="p">))</span>
				<span class="n">skb1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">skb1</span> <span class="o">=</span> <span class="n">skb_queue_prev</span><span class="p">(</span>
					<span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span>
					<span class="n">skb1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb1</span><span class="p">)</span>
		<span class="n">__skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__skb_queue_after</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span> <span class="n">skb1</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* And clean segments covered by new one as whole. */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb1</span> <span class="o">=</span> <span class="n">skb_queue_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcp_dsack_extend</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span>
					 <span class="n">end_seq</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">);</span>
		<span class="n">tcp_dsack_extend</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span>
				 <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">);</span>
		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb1</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">add_sack:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
		<span class="n">tcp_sack_new_ofo_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">end_seq</span><span class="p">);</span>
<span class="nl">end:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
		<span class="n">skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">tcp_queue_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hdrlen</span><span class="p">,</span>
		  <span class="n">bool</span> <span class="o">*</span><span class="n">fragstolen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">eaten</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="n">skb_peek_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>

	<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hdrlen</span><span class="p">);</span>
	<span class="n">eaten</span> <span class="o">=</span> <span class="p">(</span><span class="n">tail</span> <span class="o">&amp;&amp;</span>
		 <span class="n">tcp_try_coalesce</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">fragstolen</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eaten</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">eaten</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tcp_send_rcvq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fragstolen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_try_rmem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">),</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">th</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">));</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcpy_fromiovec</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>

	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_queue_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">th</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">fragstolen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">fragstolen</span><span class="p">);</span> <span class="cm">/* should not happen */</span>
		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

<span class="nl">err_free:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_data_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">eaten</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fragstolen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">==</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="n">skb_dst_drop</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">TCP_ECN_accept_cwr</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">dsack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*  Queue data for delivery to the user.</span>
<span class="cm">	 *  Packets in sequence go to the receive queue.</span>
<span class="cm">	 *  Out of sequence packets to the out_of_order_queue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_receive_window</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_of_window</span><span class="p">;</span>

		<span class="cm">/* Ok. In sequence. In window. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span> <span class="o">&amp;&amp;</span>
		    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">chunk</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					  <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>

			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

			<span class="n">local_bh_enable</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">iov</span><span class="p">,</span> <span class="n">chunk</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span> <span class="o">-=</span> <span class="n">chunk</span><span class="p">;</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>
				<span class="n">eaten</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
				<span class="n">tcp_rcv_space_adjust</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">local_bh_disable</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">eaten</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">queue_and_out:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eaten</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">tcp_try_rmem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

			<span class="n">eaten</span> <span class="o">=</span> <span class="n">tcp_queue_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fragstolen</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="n">tcp_event_data_recv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">)</span>
			<span class="n">tcp_fin</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcp_ofo_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

			<span class="cm">/* RFC2581. 4.2. SHOULD send immediate ACK, when</span>
<span class="cm">			 * gap in queue is filled.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">))</span>
				<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">num_sacks</span><span class="p">)</span>
			<span class="n">tcp_sack_remove</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

		<span class="n">tcp_fast_path_check</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">eaten</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">kfree_skb_partial</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fragstolen</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* A retransmit, 2nd most common case.  Force an immediate ack. */</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_DELAYEDACKLOST</span><span class="p">);</span>
		<span class="n">tcp_dsack_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">);</span>

<span class="nl">out_of_window:</span>
		<span class="n">tcp_enter_quickack_mode</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">inet_csk_schedule_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="nl">drop:</span>
		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Out of window. F.e. zero window probe. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">+</span> <span class="n">tcp_receive_window</span><span class="p">(</span><span class="n">tp</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_of_window</span><span class="p">;</span>

	<span class="n">tcp_enter_quickack_mode</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Partial packet, seq &lt; rcv_next &lt; end_seq */</span>
		<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;partial packet: rcv_next %X seq %X - %X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span>
			   <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">);</span>

		<span class="n">tcp_dsack_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">);</span>

		<span class="cm">/* If window is closed, drop tail of packet. But after</span>
<span class="cm">		 * remembering D-SACK for its head made in previous line.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_receive_window</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_of_window</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">queue_and_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tcp_data_queue_ofo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tcp_collapse_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_is_last</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">skb_queue_next</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPRCVCOLLAPSED</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Collapse contiguous sequence of skbs head..tail with</span>
<span class="cm"> * sequence numbers start..end.</span>
<span class="cm"> *</span>
<span class="cm"> * If tail is NULL, this means until the end of the list.</span>
<span class="cm"> *</span>
<span class="cm"> * Segments with FIN/SYN are not collapsed (only because this</span>
<span class="cm"> * simplifies code)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">tcp_collapse</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tail</span><span class="p">,</span>
	     <span class="n">u32</span> <span class="n">start</span><span class="p">,</span> <span class="n">u32</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">end_of_skbs</span><span class="p">;</span>

	<span class="cm">/* First, check that queue is collapsible and find</span>
<span class="cm">	 * the point where collapsing can be useful. */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
<span class="nl">restart:</span>
	<span class="n">end_of_skbs</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">skb_queue_walk_from_safe</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="n">tail</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* No new bits? It is possible on ofo queue. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_collapse_one</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* The first skb to collapse is:</span>
<span class="cm">		 * - not SYN/FIN and</span>
<span class="cm">		 * - bloated or contains data before &quot;start&quot; or</span>
<span class="cm">		 *   overlaps to the next one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fin</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">tcp_win_from_space</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">||</span>
		     <span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">start</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">end_of_skbs</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_is_last</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">skb_queue_next</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="n">tail</span> <span class="o">&amp;&amp;</span>
			    <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">!=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">next</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">end_of_skbs</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Decided to skip this, advance start seq. */</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end_of_skbs</span> <span class="o">||</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">||</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header</span> <span class="o">=</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">SKB_MAX_ORDER</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Too big header? This can happen with IPv6. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">copy</span><span class="p">)</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">nskb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">copy</span> <span class="o">+</span> <span class="n">header</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nskb</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">skb_set_mac_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
		<span class="n">skb_set_network_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="p">(</span><span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span>
					      <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">));</span>
		<span class="n">skb_set_transport_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="p">(</span><span class="n">skb_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span>
						<span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">));</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">header</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">nskb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">header</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">nskb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">));</span>
		<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">__skb_queue_before</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">nskb</span><span class="p">);</span>
		<span class="n">skb_set_owner_r</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

		<span class="cm">/* Copy data, releasing collapsed skbs. */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">size</span><span class="p">))</span>
					<span class="n">BUG</span><span class="p">();</span>
				<span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
				<span class="n">copy</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
				<span class="n">start</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">skb</span> <span class="o">=</span> <span class="n">tcp_collapse_one</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span> <span class="o">||</span>
				    <span class="n">skb</span> <span class="o">==</span> <span class="n">tail</span> <span class="o">||</span>
				    <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">||</span>
				    <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">)</span>
					<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Collapse ofo queue. Algorithm: select contiguous sequence of skbs</span>
<span class="cm"> * and tcp_collapse() them until all the queue is collapsed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_collapse_ofo_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">skb_queue_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>

		<span class="cm">/* Segment is terminated when we see gap or when</span>
<span class="cm">		 * we are at the end of all the queue. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span> <span class="o">||</span>
		    <span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcp_collapse</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">,</span>
				     <span class="n">head</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
			<span class="n">head</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="cm">/* Start new segment */</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
				<span class="n">start</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Purge the out-of-order queue.</span>
<span class="cm"> * Return true if queue was pruned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_prune_ofo_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">res</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_OFOPRUNED</span><span class="p">);</span>
		<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">);</span>

		<span class="cm">/* Reset SACK state.  A conforming SACK implementation will</span>
<span class="cm">		 * do the same at a timeout based retransmit.  When a connection</span>
<span class="cm">		 * is in a sad state like this, we care only about integrity</span>
<span class="cm">		 * of the connection not performance.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">sack_ok</span><span class="p">)</span>
			<span class="n">tcp_sack_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">);</span>
		<span class="n">sk_mem_reclaim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Reduce allocated memory if we can, trying to get</span>
<span class="cm"> * the socket within its memory limits again.</span>
<span class="cm"> *</span>
<span class="cm"> * Return less than zero if we should start dropping frames</span>
<span class="cm"> * until the socket owning process reads some of the data</span>
<span class="cm"> * to stabilize the situation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_prune_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;prune_queue: c=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">);</span>

	<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_PRUNECALLED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span>
		<span class="n">tcp_clamp_window</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sk_under_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_ssthresh</span><span class="p">,</span> <span class="mi">4U</span> <span class="o">*</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span><span class="p">);</span>

	<span class="n">tcp_collapse_ofo_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span>
		<span class="n">tcp_collapse</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span>
			     <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">),</span>
			     <span class="nb">NULL</span><span class="p">,</span>
			     <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">);</span>
	<span class="n">sk_mem_reclaim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Collapsing did not help, destructive actions follow.</span>
<span class="cm">	 * This must not ever occur. */</span>

	<span class="n">tcp_prune_ofo_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If we are really being abused, tell the caller to silently</span>
<span class="cm">	 * drop receive data on the floor.  It will get retransmitted</span>
<span class="cm">	 * and hopefully then we&#39;ll have sufficient space.</span>
<span class="cm">	 */</span>
	<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_RCVPRUNED</span><span class="p">);</span>

	<span class="cm">/* Massive buffer overcommit. */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">pred_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* RFC2861, slow part. Adjust cwnd, after it was not full during one rto.</span>
<span class="cm"> * As additional protections, we do not touch cwnd in retransmission phases,</span>
<span class="cm"> * and if application hit its sndbuf limit recently.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcp_cwnd_application_limited</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ca_state</span> <span class="o">==</span> <span class="n">TCP_CA_Open</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Limited by application or receiver window. */</span>
		<span class="n">u32</span> <span class="n">init_win</span> <span class="o">=</span> <span class="n">tcp_init_cwnd</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
		<span class="n">u32</span> <span class="n">win_used</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_used</span><span class="p">,</span> <span class="n">init_win</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">win_used</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_ssthresh</span> <span class="o">=</span> <span class="n">tcp_current_ssthresh</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span> <span class="o">+</span> <span class="n">win_used</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_should_expand_sndbuf</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* If the user specified a specific send buffer setting, do</span>
<span class="cm">	 * not modify it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="n">SOCK_SNDBUF_LOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* If we are under global TCP memory pressure, do not expand.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk_under_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* If we are under soft global TCP memory pressure, do not expand.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk_memory_allocated</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">sk_prot_mem_limits</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* If we filled the congestion window, do not expand.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">packets_out</span> <span class="o">&gt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* When incoming ACK allowed to free some skb from write_queue,</span>
<span class="cm"> * we remember this event in flag SOCK_QUEUE_SHRUNK and wake up socket</span>
<span class="cm"> * on the exit from tcp input handler.</span>
<span class="cm"> *</span>
<span class="cm"> * PROBLEM: sndbuf expansion does not work well with largesend.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_new_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_should_expand_sndbuf</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sndmem</span> <span class="o">=</span> <span class="n">SKB_TRUESIZE</span><span class="p">(</span><span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span>
						<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span><span class="p">,</span>
						<span class="n">tp</span><span class="o">-&gt;</span><span class="n">mss_cache</span><span class="p">)</span> <span class="o">+</span>
					  <span class="n">MAX_TCP_HEADER</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">demanded</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd</span><span class="p">,</span>
				     <span class="n">tp</span><span class="o">-&gt;</span><span class="n">reordering</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">sndmem</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">demanded</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sndmem</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">)</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sndmem</span><span class="p">,</span> <span class="n">sysctl_tcp_wmem</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_cwnd_stamp</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_check_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_QUEUE_SHRUNK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_QUEUE_SHRUNK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span> <span class="o">&amp;&amp;</span>
		    <span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">tcp_new_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_data_snd_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tcp_push_pending_frames</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tcp_check_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if sending an ack is needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__tcp_ack_snd_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ofo_possible</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	    <span class="cm">/* More than one full frame received... */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">rcv_mss</span> <span class="o">&amp;&amp;</span>
	     <span class="cm">/* ... and right edge of window advances far enough.</span>
<span class="cm">	      * (tcp_recvmsg() will send ACK otherwise). Or...</span>
<span class="cm">	      */</span>
	     <span class="n">__tcp_select_window</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wnd</span><span class="p">)</span> <span class="o">||</span>
	    <span class="cm">/* We ACK each frame or... */</span>
	    <span class="n">tcp_in_quickack_mode</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">||</span>
	    <span class="cm">/* We have out of order data. */</span>
	    <span class="p">(</span><span class="n">ofo_possible</span> <span class="o">&amp;&amp;</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">out_of_order_queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Then ack it now */</span>
		<span class="n">tcp_send_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Else, send delayed ack. */</span>
		<span class="n">tcp_send_delayed_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tcp_ack_snd_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inet_csk_ack_scheduled</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We sent a data segment already. */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">__tcp_ack_snd_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	This routine is only called when we have urgent data</span>
<span class="cm"> *	signaled. Its the &#39;slow&#39; part of tcp_urg. It could be</span>
<span class="cm"> *	moved inline now as tcp_urg is only called from one</span>
<span class="cm"> *	place. We handle URGent data wrong. We have to - as</span>
<span class="cm"> *	BSD still doesn&#39;t use the correction from RFC961.</span>
<span class="cm"> *	For 1003.1g we should support a new option TCP_STDURG to permit</span>
<span class="cm"> *	either form (or just set the sysctl tcp_stdurg).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_check_urg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">urg_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sysctl_tcp_stdurg</span><span class="p">)</span>
		<span class="n">ptr</span><span class="o">--</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">+=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>

	<span class="cm">/* Ignore urgent data that we&#39;ve already seen and read. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">,</span> <span class="n">ptr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Do not replay urg ptr.</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE: interesting situation not covered by specs.</span>
<span class="cm">	 * Misbehaving sender may send urg ptr, pointing to segment,</span>
<span class="cm">	 * which we already have in ofo queue. We are not able to fetch</span>
<span class="cm">	 * such data and will stay in TCP_URG_NOTYET until will be eaten</span>
<span class="cm">	 * by recvmsg(). Seems, we are not obliged to handle such wicked</span>
<span class="cm">	 * situations. But it is worth to think about possibility of some</span>
<span class="cm">	 * DoSes using some hypothetical application level deadlock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">before</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Do we already have a newer (or duplicate) urgent pointer? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Tell the world about our new urgent pointer. */</span>
	<span class="n">sk_send_sigurg</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* We may be adding urgent data when the last byte read was</span>
<span class="cm">	 * urgent. To do this requires some care. We cannot just ignore</span>
<span class="cm">	 * tp-&gt;copied_seq since we would read the last urgent byte again</span>
<span class="cm">	 * as data, nor can we alter copied_seq until this data arrives</span>
<span class="cm">	 * or we break the semantics of SIOCATMARK (and thus sockatmark())</span>
<span class="cm">	 *</span>
<span class="cm">	 * NOTE. Double Dutch. Rendering to plain English: author of comment</span>
<span class="cm">	 * above did something sort of 	send(&quot;A&quot;, MSG_OOB); send(&quot;B&quot;, MSG_OOB);</span>
<span class="cm">	 * and expect that both A and B disappear from stream. This is _wrong_.</span>
<span class="cm">	 * Though this happens in BSD with high probability, this is occasional.</span>
<span class="cm">	 * Any application relying on this is buggy. Note also, that fix &quot;works&quot;</span>
<span class="cm">	 * only in this artificial test. Insert some normal data between A and B and we will</span>
<span class="cm">	 * decline of BSD again. Verdict: it is better to remove to trap</span>
<span class="cm">	 * buggy users.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_URGINLINE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
			<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">=</span> <span class="n">TCP_URG_NOTYET</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="cm">/* Disable header prediction. */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">pred_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is the &#39;fast&#39; part of urgent handling. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tcp_urg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Check if we get a new urgent pointer - normally not. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">urg</span><span class="p">)</span>
		<span class="n">tcp_check_urg</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">th</span><span class="p">);</span>

	<span class="cm">/* Do we wait for any urgent data? - normally not... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">==</span> <span class="n">TCP_URG_NOTYET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_seq</span> <span class="o">-</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span>
			  <span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span><span class="p">;</span>

		<span class="cm">/* Is the urgent pointer pointing into this packet? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">urg_data</span> <span class="o">=</span> <span class="n">TCP_URG_VALID</span> <span class="o">|</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_copy_to_iovec</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chunk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_csum_unnecessary</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">iov</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">skb_copy_and_csum_datagram_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span>
						       <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">iov</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span> <span class="o">-=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">tcp_rcv_space_adjust</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__sum16</span> <span class="nf">__tcp_checksum_complete_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__sum16</span> <span class="n">result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">local_bh_enable</span><span class="p">();</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">__tcp_checksum_complete</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">__tcp_checksum_complete</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcp_checksum_complete_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">skb_csum_unnecessary</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">__tcp_checksum_complete_user</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_DMA</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">tcp_dma_try_early_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">hlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">chunk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dma_cookie</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">copied_early</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">wakeup</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">pinned_list</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span> <span class="o">=</span> <span class="n">net_dma_find_channel</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span> <span class="o">&amp;&amp;</span> <span class="n">skb_csum_unnecessary</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">dma_cookie</span> <span class="o">=</span> <span class="n">dma_skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_chan</span><span class="p">,</span>
							 <span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span>
							 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">iov</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span>
							 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">pinned_list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dma_cookie</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">dma_cookie</span> <span class="o">=</span> <span class="n">dma_cookie</span><span class="p">;</span>
		<span class="n">copied_early</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span> <span class="o">-=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">tcp_rcv_space_adjust</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">tcp_flag_word</span><span class="p">(</span><span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">TCP_FLAG_PSH</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">wakeup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">wakeup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">copied_early</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NET_DMA */</span><span class="cp"></span>

<span class="cm">/* Does PAWS and seqno based validation of an incoming segment, flags will</span>
<span class="cm"> * play significant role here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_validate_incoming</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="kt">int</span> <span class="n">syn_inerr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">hash_location</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* RFC1323: H1. Apply PAWS check first. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcp_fast_parse_options</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash_location</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tcp_paws_discard</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_PAWSESTABREJECTED</span><span class="p">);</span>
			<span class="n">tcp_send_dupack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Reset is accepted even if it did not pass PAWS. */</span>
	<span class="p">}</span>

	<span class="cm">/* Step 1: check sequence number */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_sequence</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* RFC793, page 37: &quot;In all states except SYN-SENT, all reset</span>
<span class="cm">		 * (RST) segments are validated by checking their SEQ-fields.&quot;</span>
<span class="cm">		 * And page 69: &quot;If an incoming segment is not acceptable,</span>
<span class="cm">		 * an acknowledgment should be sent in reply (unless the RST</span>
<span class="cm">		 * bit is set, if so drop the segment and return)&quot;.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">)</span>
			<span class="n">tcp_send_dupack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Step 2: check RST bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ts_recent update must be made after we are sure that the packet</span>
<span class="cm">	 * is in window.</span>
<span class="cm">	 */</span>
	<span class="n">tcp_replace_ts_recent</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>

	<span class="cm">/* step 3: check security and precedence [ignored] */</span>

	<span class="cm">/* step 4: Check for a SYN in window. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">syn_inerr</span><span class="p">)</span>
			<span class="n">TCP_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_INERRS</span><span class="p">);</span>
		<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPABORTONSYN</span><span class="p">);</span>
		<span class="n">tcp_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">discard:</span>
	<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	TCP receive function for the ESTABLISHED state.</span>
<span class="cm"> *</span>
<span class="cm"> *	It is split into a fast path and a slow path. The fast path is</span>
<span class="cm"> * 	disabled when:</span>
<span class="cm"> *	- A zero window was announced from us - zero window probing</span>
<span class="cm"> *        is only handled properly in the slow path.</span>
<span class="cm"> *	- Out of order segments arrived.</span>
<span class="cm"> *	- Urgent data is expected.</span>
<span class="cm"> *	- There is no buffer space left</span>
<span class="cm"> *	- Unexpected TCP flags/window values/header lengths are received</span>
<span class="cm"> *	  (detected by checking the TCP header against pred_flags)</span>
<span class="cm"> *	- Data is sent in both directions. Fast path only supports pure senders</span>
<span class="cm"> *	  or pure receivers (this means either the sequence number or the ack</span>
<span class="cm"> *	  value must stay constant)</span>
<span class="cm"> *	- Unexpected TCP option.</span>
<span class="cm"> *</span>
<span class="cm"> *	When these conditions are not satisfied it drops into a standard</span>
<span class="cm"> *	receive procedure patterned after RFC793 to handle all cases.</span>
<span class="cm"> *	The first three cases are guaranteed by proper pred_flags setting,</span>
<span class="cm"> *	the rest is checked inline. Fast processing is turned on in</span>
<span class="cm"> *	tcp_data_queue when everything is OK.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tcp_rcv_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Header prediction.</span>
<span class="cm">	 *	The code loosely follows the one in the famous</span>
<span class="cm">	 *	&quot;30 instruction TCP receive&quot; Van Jacobson mail.</span>
<span class="cm">	 *</span>
<span class="cm">	 *	Van&#39;s trick is to deposit buffers into socket queue</span>
<span class="cm">	 *	on a device interrupt, to call tcp_recv function</span>
<span class="cm">	 *	on the receive process context and checksum and copy</span>
<span class="cm">	 *	the buffer to user space. smart...</span>
<span class="cm">	 *</span>
<span class="cm">	 *	Our current scheme is not silly either but we take the</span>
<span class="cm">	 *	extra cost of the net_bh soft interrupt processing...</span>
<span class="cm">	 *	We do checksum and copy also but from device to kernel.</span>
<span class="cm">	 */</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*	pred_flags is 0xS?10 &lt;&lt; 16 + snd_wnd</span>
<span class="cm">	 *	if header_prediction is to be made</span>
<span class="cm">	 *	&#39;S&#39; will always be tp-&gt;tcp_header_len &gt;&gt; 2</span>
<span class="cm">	 *	&#39;?&#39; will be 0 for the fast path, otherwise pred_flags is 0 to</span>
<span class="cm">	 *  turn it off	(when there are holes in the receive</span>
<span class="cm">	 *	 space for instance)</span>
<span class="cm">	 *	PSH flag is ignored.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tcp_flag_word</span><span class="p">(</span><span class="n">th</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">TCP_HP_BITS</span><span class="p">)</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">pred_flags</span> <span class="o">&amp;&amp;</span>
	    <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">tcp_header_len</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span><span class="p">;</span>

		<span class="cm">/* Timestamp header prediction: tcp_header_len</span>
<span class="cm">		 * is automatically equal to th-&gt;doff*4 due to pred_flags</span>
<span class="cm">		 * match.</span>
<span class="cm">		 */</span>

		<span class="cm">/* Check timestamp */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_header_len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* No? Slow path! */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_parse_aligned_timestamp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">th</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">slow_path</span><span class="p">;</span>

			<span class="cm">/* If PAWS failed, check it more carefully in slow path */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">s32</span><span class="p">)(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsval</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">slow_path</span><span class="p">;</span>

			<span class="cm">/* DO NOT update ts_recent here, if checksum fails</span>
<span class="cm">			 * and timestamp was corrupted part, it will result</span>
<span class="cm">			 * in a hung connection since we will drop all</span>
<span class="cm">			 * future packets due to the PAWS test.</span>
<span class="cm">			 */</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">tcp_header_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Bulk data transfer: sender */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">tcp_header_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Predicted packet is in window by definition.</span>
<span class="cm">				 * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.</span>
<span class="cm">				 * Hence, check seq&lt;=rcv_wup reduces to:</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tcp_header_len</span> <span class="o">==</span>
				    <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span><span class="p">)</span>
					<span class="n">tcp_store_ts_recent</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

				<span class="cm">/* We know that such packets are checksummed</span>
<span class="cm">				 * on entry.</span>
<span class="cm">				 */</span>
				<span class="n">tcp_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">tcp_data_snd_check</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* Header too small */</span>
				<span class="n">TCP_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_INERRS</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">eaten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">copied_early</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bool</span> <span class="n">fragstolen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">&amp;&amp;</span>
			    <span class="n">len</span> <span class="o">-</span> <span class="n">tcp_header_len</span> <span class="o">&lt;=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_DMA</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tcp_dma_try_early_copy</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tcp_header_len</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">copied_early</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">eaten</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
<span class="cp">#endif</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">ucopy</span><span class="p">.</span><span class="n">task</span> <span class="o">==</span> <span class="n">current</span> <span class="o">&amp;&amp;</span>
				    <span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">copied_early</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcp_copy_to_iovec</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tcp_header_len</span><span class="p">))</span>
						<span class="n">eaten</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">eaten</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Predicted packet is in window by definition.</span>
<span class="cm">					 * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.</span>
<span class="cm">					 * Hence, check seq&lt;=rcv_wup reduces to:</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">tcp_header_len</span> <span class="o">==</span>
					    <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">+</span>
					     <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span><span class="p">)</span>
						<span class="n">tcp_store_ts_recent</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

					<span class="n">tcp_rcv_rtt_measure_ts</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

					<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tcp_header_len</span><span class="p">);</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span><span class="p">;</span>
					<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPHPHITSTOUSER</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">copied_early</span><span class="p">)</span>
					<span class="n">tcp_cleanup_rbuf</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eaten</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tcp_checksum_complete_user</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">csum_error</span><span class="p">;</span>

				<span class="cm">/* Predicted packet is in window by definition.</span>
<span class="cm">				 * seq == rcv_nxt and rcv_wup &lt;= rcv_nxt.</span>
<span class="cm">				 * Hence, check seq&lt;=rcv_wup reduces to:</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tcp_header_len</span> <span class="o">==</span>
				    <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span><span class="p">)</span>
					<span class="n">tcp_store_ts_recent</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

				<span class="n">tcp_rcv_rtt_measure_ts</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">step5</span><span class="p">;</span>

				<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPHPHITS</span><span class="p">);</span>

				<span class="cm">/* Bulk data transfer: receiver */</span>
				<span class="n">eaten</span> <span class="o">=</span> <span class="n">tcp_queue_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tcp_header_len</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">fragstolen</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">tcp_event_data_recv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Well, only one small jumplet in fast path... */</span>
				<span class="n">tcp_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FLAG_DATA</span><span class="p">);</span>
				<span class="n">tcp_data_snd_check</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inet_csk_ack_scheduled</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">no_ack</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copied_early</span> <span class="o">||</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span><span class="p">)</span>
				<span class="n">__tcp_ack_snd_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">no_ack:</span>
<span class="cp">#ifdef CONFIG_NET_DMA</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copied_early</span><span class="p">)</span>
				<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_async_wait_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">else</span>
<span class="cp">#endif</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eaten</span><span class="p">)</span>
				<span class="n">kfree_skb_partial</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">fragstolen</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">slow_path:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">doff</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span> <span class="n">tcp_checksum_complete_user</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">csum_error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Standard slow path.</span>
<span class="cm">	 */</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">tcp_validate_incoming</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">res</span><span class="p">;</span>

<span class="nl">step5:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ack</span> <span class="o">&amp;&amp;</span> <span class="n">tcp_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FLAG_SLOWPATH</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

	<span class="n">tcp_rcv_rtt_measure_ts</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Process urgent data. */</span>
	<span class="n">tcp_urg</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">th</span><span class="p">);</span>

	<span class="cm">/* step 7: process the segment text */</span>
	<span class="n">tcp_data_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">tcp_data_snd_check</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">tcp_ack_snd_check</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">csum_error:</span>
	<span class="n">TCP_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">TCP_MIB_INERRS</span><span class="p">);</span>

<span class="nl">discard:</span>
	<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_rcv_established</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">tcp_finish_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_ESTABLISHED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">security_inet_conn_established</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Make sure socket is routed, for correct metrics.  */</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">rebuild_header</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_init_metrics</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">tcp_init_congestion_control</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Prevent spurious tcp_cwnd_restart() on first data</span>
<span class="cm">	 * packet.</span>
<span class="cm">	 */</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lsndtime</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>

	<span class="n">tcp_init_buffer_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_KEEPOPEN</span><span class="p">))</span>
		<span class="n">inet_csk_reset_keepalive_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">keepalive_time_when</span><span class="p">(</span><span class="n">tp</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">snd_wscale</span><span class="p">)</span>
		<span class="n">__tcp_fast_path_on</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">pred_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_IO</span><span class="p">,</span> <span class="n">POLL_OUT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_rcv_synsent_state_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">hash_location</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tcp_cookie_values</span> <span class="o">*</span><span class="n">cvp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">cookie_values</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">saved_clamp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span><span class="p">;</span>

	<span class="n">tcp_parse_options</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash_location</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ack</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* rfc793:</span>
<span class="cm">		 * &quot;If the state is SYN-SENT then</span>
<span class="cm">		 *    first check the ACK bit</span>
<span class="cm">		 *      If the ACK bit is set</span>
<span class="cm">		 *	  If SEG.ACK =&lt; ISS, or SEG.ACK &gt; SND.NXT, send</span>
<span class="cm">		 *        a reset (unless the RST bit is set, if so drop</span>
<span class="cm">		 *        the segment and return)&quot;</span>
<span class="cm">		 *</span>
<span class="cm">		 *  We do not send data with SYN, so that RFC-correct</span>
<span class="cm">		 *  test reduces to:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_nxt</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">reset_and_undo</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsecr</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">between</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_tsecr</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">retrans_stamp</span><span class="p">,</span>
			     <span class="n">tcp_time_stamp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_PAWSACTIVEREJECTED</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">reset_and_undo</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Now ACK is acceptable.</span>
<span class="cm">		 *</span>
<span class="cm">		 * &quot;If the RST bit is set</span>
<span class="cm">		 *    If the ACK was acceptable then signal the user &quot;error:</span>
<span class="cm">		 *    connection reset&quot;, drop the segment, enter CLOSED state,</span>
<span class="cm">		 *    delete TCB, and return.&quot;</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcp_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* rfc793:</span>
<span class="cm">		 *   &quot;fifth, if neither of the SYN or RST bits is set then</span>
<span class="cm">		 *    drop the segment and return.&quot;</span>
<span class="cm">		 *</span>
<span class="cm">		 *    See note below!</span>
<span class="cm">		 *                                        --ANK(990513)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">discard_and_undo</span><span class="p">;</span>

		<span class="cm">/* rfc793:</span>
<span class="cm">		 *   &quot;If the SYN bit is on ...</span>
<span class="cm">		 *    are acceptable then ...</span>
<span class="cm">		 *    (our SYN has been ACKed), change the connection</span>
<span class="cm">		 *    state to ESTABLISHED...&quot;</span>
<span class="cm">		 */</span>

		<span class="n">TCP_ECN_rcv_synack</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">th</span><span class="p">);</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wl1</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
		<span class="n">tcp_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FLAG_SLOWPATH</span><span class="p">);</span>

		<span class="cm">/* Ok.. it&#39;s good. Set up sequence numbers and</span>
<span class="cm">		 * move to established.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* RFC1323: The window in SYN &amp; SYN/ACK segments is</span>
<span class="cm">		 * never scaled.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">);</span>
		<span class="n">tcp_init_wl</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">wscale_ok</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">snd_wscale</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">rcv_wscale</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">window_clamp</span><span class="p">,</span> <span class="mi">65535U</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">tstamp_ok</span>	   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">=</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span>	    <span class="o">-=</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">;</span>
			<span class="n">tcp_store_ts_recent</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcp_is_sack</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sysctl_tcp_fack</span><span class="p">)</span>
			<span class="n">tcp_enable_fack</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>

		<span class="n">tcp_mtup_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tcp_sync_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_pmtu_cookie</span><span class="p">);</span>
		<span class="n">tcp_initialize_rcv_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="cm">/* Remember, tcp_poll() does not lock socket!</span>
<span class="cm">		 * Change state from SYN-SENT only after copied_seq</span>
<span class="cm">		 * is initialized. */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cvp</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_pair_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">cookie_plus</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">cookie_size</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">cookie_plus</span>
					<span class="o">-</span> <span class="n">TCPOLEN_COOKIE_BASE</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">cookie_pair_size</span> <span class="o">=</span> <span class="n">cookie_size</span>
					     <span class="o">+</span> <span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_desired</span><span class="p">;</span>

			<span class="cm">/* A cookie extension option was sent and returned.</span>
<span class="cm">			 * Note that each incoming SYNACK replaces the</span>
<span class="cm">			 * Responder cookie.  The initial exchange is most</span>
<span class="cm">			 * fragile, as protection against spoofing relies</span>
<span class="cm">			 * entirely upon the sequence and timestamp (above).</span>
<span class="cm">			 * This replacement strategy allows the correct pair to</span>
<span class="cm">			 * pass through, while any others will be filtered via</span>
<span class="cm">			 * Responder verification later.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_pair</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cookie_pair_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_pair</span><span class="p">[</span><span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_desired</span><span class="p">],</span>
				       <span class="n">hash_location</span><span class="p">,</span> <span class="n">cookie_size</span><span class="p">);</span>
				<span class="n">cvp</span><span class="o">-&gt;</span><span class="n">cookie_pair_size</span> <span class="o">=</span> <span class="n">cookie_pair_size</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">smp_mb</span><span class="p">();</span>

		<span class="n">tcp_finish_connect</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_pending</span> <span class="o">||</span>
		    <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_accept_queue</span><span class="p">.</span><span class="n">rskq_defer_accept</span> <span class="o">||</span>
		    <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Save one ACK. Data will be ready after</span>
<span class="cm">			 * several ticks, if write_pending is set.</span>
<span class="cm">			 *</span>
<span class="cm">			 * It may be deleted, but with this feature tcpdumps</span>
<span class="cm">			 * look so _wonderfully_ clever, that I was not able</span>
<span class="cm">			 * to stand against the temptation 8)     --ANK</span>
<span class="cm">			 */</span>
			<span class="n">inet_csk_schedule_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">lrcvtime</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>
			<span class="n">tcp_enter_quickack_mode</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_DACK</span><span class="p">,</span>
						  <span class="n">TCP_DELACK_MAX</span><span class="p">,</span> <span class="n">TCP_RTO_MAX</span><span class="p">);</span>

<span class="nl">discard:</span>
			<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tcp_send_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* No ACK in the segment */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* rfc793:</span>
<span class="cm">		 * &quot;If the RST bit is set</span>
<span class="cm">		 *</span>
<span class="cm">		 *      Otherwise (no ACK) drop the segment and return.&quot;</span>
<span class="cm">		 */</span>

		<span class="k">goto</span> <span class="n">discard_and_undo</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* PAWS check. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">ts_recent_stamp</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tcp_paws_reject</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard_and_undo</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We see SYN without ACK. It is attempt of</span>
<span class="cm">		 * simultaneous connect with crossed SYNs.</span>
<span class="cm">		 * Particularly, it can be connect to self.</span>
<span class="cm">		 */</span>
		<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_SYN_RECV</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">tstamp_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">tcp_store_ts_recent</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">=</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tcp_header_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_wup</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* RFC1323: The window in SYN &amp; SYN/ACK segments is</span>
<span class="cm">		 * never scaled.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span>    <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wl1</span>    <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">max_window</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span><span class="p">;</span>

		<span class="n">TCP_ECN_rcv_syn</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">th</span><span class="p">);</span>

		<span class="n">tcp_mtup_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tcp_sync_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_pmtu_cookie</span><span class="p">);</span>
		<span class="n">tcp_initialize_rcv_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="n">tcp_send_synack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/* Note, we could accept data and URG from this segment.</span>
<span class="c">		 * There are no obstacles to make this.</span>
<span class="c">		 *</span>
<span class="c">		 * However, if we ignore data in ACKless segments sometimes,</span>
<span class="c">		 * we have no reasons to accept it sometimes.</span>
<span class="c">		 * Also, seems the code doing it in step6 of tcp_rcv_state_process</span>
<span class="c">		 * is not flawless. So, discard packet for sanity.</span>
<span class="c">		 * Uncomment this return to process the data.</span>
<span class="c">		 */</span>
<span class="c">		return -1;</span>
<span class="cp">#else</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="cm">/* &quot;fifth, if neither of the SYN or RST bits is set then</span>
<span class="cm">	 * drop the segment and return.&quot;</span>
<span class="cm">	 */</span>

<span class="nl">discard_and_undo:</span>
	<span class="n">tcp_clear_options</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span> <span class="o">=</span> <span class="n">saved_clamp</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

<span class="nl">reset_and_undo:</span>
	<span class="n">tcp_clear_options</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">mss_clamp</span> <span class="o">=</span> <span class="n">saved_clamp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	This function implements the receiving procedure of RFC 793 for</span>
<span class="cm"> *	all states except ESTABLISHED and TIME_WAIT.</span>
<span class="cm"> *	It&#39;s called from both tcp_v4_rcv and tcp_v6_rcv and should be</span>
<span class="cm"> *	address independent.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">tcp_rcv_state_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">saw_tstamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCP_CLOSE</span>:
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_LISTEN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ack</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">rst</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">syn</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">conn_request</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

			<span class="cm">/* Now we have several options: In theory there is</span>
<span class="cm">			 * nothing else in the frame. KA9Q has an option to</span>
<span class="cm">			 * send data with the syn, BSD accepts data with the</span>
<span class="cm">			 * syn up to the [to be] advertised window and</span>
<span class="cm">			 * Solaris 2.1 gives you a protocol error. For now</span>
<span class="cm">			 * we just ignore it, that fits the spec precisely</span>
<span class="cm">			 * and avoids incompatibilities. It would be nice in</span>
<span class="cm">			 * future to drop through and process the data.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Now that TTCP is starting to be used we ought to</span>
<span class="cm">			 * queue this data.</span>
<span class="cm">			 * But, this leaves one open to an easy denial of</span>
<span class="cm">			 * service attack, and SYN cookies can&#39;t defend</span>
<span class="cm">			 * against this problem. So, we drop the data</span>
<span class="cm">			 * in the interest of security over speed unless</span>
<span class="cm">			 * it&#39;s still in use.</span>
<span class="cm">			 */</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">TCP_SYN_SENT</span>:
		<span class="n">queued</span> <span class="o">=</span> <span class="n">tcp_rcv_synsent_state_process</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">queued</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">queued</span><span class="p">;</span>

		<span class="cm">/* Do step6 onward by hand. */</span>
		<span class="n">tcp_urg</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">th</span><span class="p">);</span>
		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">tcp_data_snd_check</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">tcp_validate_incoming</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">res</span><span class="p">;</span>

	<span class="cm">/* step 5: check the ACK field */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">ack</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">acceptable</span> <span class="o">=</span> <span class="n">tcp_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">FLAG_SLOWPATH</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TCP_SYN_RECV</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">acceptable</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">copied_seq</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">;</span>
				<span class="n">smp_mb</span><span class="p">();</span>
				<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_ESTABLISHED</span><span class="p">);</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

				<span class="cm">/* Note, that this wakeup is only for marginal</span>
<span class="cm">				 * crossed SYN case. Passively open sockets</span>
<span class="cm">				 * are not waked up, because sk-&gt;sk_sleep ==</span>
<span class="cm">				 * NULL and sk-&gt;sk_socket == NULL.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">)</span>
					<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
						      <span class="n">SOCK_WAKE_IO</span><span class="p">,</span> <span class="n">POLL_OUT</span><span class="p">);</span>

				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ack_seq</span><span class="p">;</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_wnd</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
					      <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">snd_wscale</span><span class="p">;</span>
				<span class="n">tcp_init_wl</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">rx_opt</span><span class="p">.</span><span class="n">tstamp_ok</span><span class="p">)</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">advmss</span> <span class="o">-=</span> <span class="n">TCPOLEN_TSTAMP_ALIGNED</span><span class="p">;</span>

				<span class="cm">/* Make sure socket is routed, for</span>
<span class="cm">				 * correct metrics.</span>
<span class="cm">				 */</span>
				<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">rebuild_header</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

				<span class="n">tcp_init_metrics</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

				<span class="n">tcp_init_congestion_control</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

				<span class="cm">/* Prevent spurious tcp_cwnd_restart() on</span>
<span class="cm">				 * first data packet.</span>
<span class="cm">				 */</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lsndtime</span> <span class="o">=</span> <span class="n">tcp_time_stamp</span><span class="p">;</span>

				<span class="n">tcp_mtup_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="n">tcp_initialize_rcv_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="n">tcp_init_buffer_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="n">tcp_fast_path_on</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TCP_FIN_WAIT1</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tcp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_FIN_WAIT2</span><span class="p">);</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">|=</span> <span class="n">SEND_SHUTDOWN</span><span class="p">;</span>
				<span class="n">dst_confirm</span><span class="p">(</span><span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span>
					<span class="cm">/* Wake up lingering close() */</span>
					<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="kt">int</span> <span class="n">tmo</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">linger2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
					    <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">!=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&amp;&amp;</span>
					     <span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">-</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">)))</span> <span class="p">{</span>
						<span class="n">tcp_done</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
						<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPABORTONDATA</span><span class="p">);</span>
						<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="n">tmo</span> <span class="o">=</span> <span class="n">tcp_fin_time</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">tmo</span> <span class="o">&gt;</span> <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">inet_csk_reset_keepalive_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tmo</span> <span class="o">-</span> <span class="n">TCP_TIMEWAIT_LEN</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">fin</span> <span class="o">||</span> <span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
						<span class="cm">/* Bad case. We could lose such FIN otherwise.</span>
<span class="cm">						 * It is not a big problem, but it looks confusing</span>
<span class="cm">						 * and not so rare event. We still can lose it now,</span>
<span class="cm">						 * if it spins in bh_lock_sock(), but it is really</span>
<span class="cm">						 * marginal case.</span>
<span class="cm">						 */</span>
						<span class="n">inet_csk_reset_keepalive_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">tmo</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">tcp_time_wait</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_FIN_WAIT2</span><span class="p">,</span> <span class="n">tmo</span><span class="p">);</span>
						<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TCP_CLOSING</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tcp_time_wait</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">TCP_TIME_WAIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">TCP_LAST_ACK</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">snd_una</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">write_seq</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tcp_update_metrics</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="n">tcp_done</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

	<span class="cm">/* step 6: check the URG bit */</span>
	<span class="n">tcp_urg</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">th</span><span class="p">);</span>

	<span class="cm">/* step 7: process the segment text */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCP_CLOSE_WAIT</span>:
	<span class="k">case</span> <span class="n">TCP_CLOSING</span>:
	<span class="k">case</span> <span class="n">TCP_LAST_ACK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">before</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_FIN_WAIT1</span>:
	<span class="k">case</span> <span class="n">TCP_FIN_WAIT2</span>:
		<span class="cm">/* RFC 793 says to queue data in these states,</span>
<span class="cm">		 * RFC 1122 says we MUST send a reset.</span>
<span class="cm">		 * BSD 4.4 also does reset.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">!=</span> <span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&amp;&amp;</span>
			    <span class="n">after</span><span class="p">(</span><span class="n">TCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">end_seq</span> <span class="o">-</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">fin</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">rcv_nxt</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">NET_INC_STATS_BH</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">LINUX_MIB_TCPABORTONDATA</span><span class="p">);</span>
				<span class="n">tcp_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">TCP_ESTABLISHED</span>:
		<span class="n">tcp_data_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* tcp_data could move socket to TIME-WAIT */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_CLOSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcp_data_snd_check</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">tcp_ack_snd_check</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">discard:</span>
		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_rcv_state_process</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
