<!DOCTYPE html>
<html><head><title>joekychen/linux » net › appletalk › ddp.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ddp.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	DDP:	An implementation of the AppleTalk DDP protocol for</span>
<span class="cm"> *		Ethernet &#39;ELAP&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> *		Alan Cox  &lt;alan@lxorguk.ukuu.org.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *		With more than a little assistance from</span>
<span class="cm"> *</span>
<span class="cm"> *		Wesley Craig &lt;netatalk@umich.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Fixes:</span>
<span class="cm"> *		Neil Horman		:	Added missing device ioctls</span>
<span class="cm"> *		Michael Callahan	:	Made routing work</span>
<span class="cm"> *		Wesley Craig		:	Fix probing to listen to a</span>
<span class="cm"> *						passed node id.</span>
<span class="cm"> *		Alan Cox		:	Added send/recvmsg support</span>
<span class="cm"> *		Alan Cox		:	Moved at. to protinfo in</span>
<span class="cm"> *						socket.</span>
<span class="cm"> *		Alan Cox		:	Added firewall hooks.</span>
<span class="cm"> *		Alan Cox		:	Supports new ARPHRD_LOOPBACK</span>
<span class="cm"> *		Christer Weinigel	: 	Routing and /proc fixes.</span>
<span class="cm"> *		Bradford Johnson	:	LocalTalk.</span>
<span class="cm"> *		Tom Dyas		:	Module support.</span>
<span class="cm"> *		Alan Cox		:	Hooks for PPP (based on the</span>
<span class="cm"> *						LocalTalk hook).</span>
<span class="cm"> *		Alan Cox		:	Posix bits</span>
<span class="cm"> *		Alan Cox/Mike Freeman	:	Possible fix to NBP problems</span>
<span class="cm"> *		Bradford Johnson	:	IP-over-DDP (experimental)</span>
<span class="cm"> *		Jay Schulist		:	Moved IP-over-DDP to its own</span>
<span class="cm"> *						driver file. (ipddp.c &amp; ipddp.h)</span>
<span class="cm"> *		Jay Schulist		:	Made work as module with</span>
<span class="cm"> *						AppleTalk drivers, cleaned it.</span>
<span class="cm"> *		Rob Newberry		:	Added proxy AARP and AARP</span>
<span class="cm"> *						procfs, moved probing to AARP</span>
<span class="cm"> *						module.</span>
<span class="cm"> *              Adrian Sun/</span>
<span class="cm"> *              Michael Zuelsdorff      :       fix for net.0 packets. don&#39;t</span>
<span class="cm"> *                                              allow illegal ether/tokentalk</span>
<span class="cm"> *                                              port assignment. we lose a</span>
<span class="cm"> *                                              valid localtalk port as a</span>
<span class="cm"> *                                              result.</span>
<span class="cm"> *		Arnaldo C. de Melo	:	Cleanup, in preparation for</span>
<span class="cm"> *						shared skb support 8)</span>
<span class="cm"> *		Arnaldo C. de Melo	:	Move proc stuff to atalk_proc.c,</span>
<span class="cm"> *						use seq_file</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/termios.h&gt;	</span><span class="cm">/* For TIOCOUTQ/INQ */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/datalink.h&gt;</span>
<span class="cp">#include &lt;net/psnap.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/tcp_states.h&gt;</span>
<span class="cp">#include &lt;net/route.h&gt;</span>
<span class="cp">#include &lt;linux/atalk.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>

<span class="k">struct</span> <span class="n">datalink_proto</span> <span class="o">*</span><span class="n">ddp_dl</span><span class="p">,</span> <span class="o">*</span><span class="n">aarp_dl</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">atalk_dgram_ops</span><span class="p">;</span>

<span class="cm">/**************************************************************************\</span>
<span class="cm">*                                                                          *</span>
<span class="cm">* Handlers for the socket list.                                            *</span>
<span class="cm">*                                                                          *</span>
<span class="cm">\**************************************************************************/</span>

<span class="n">HLIST_HEAD</span><span class="p">(</span><span class="n">atalk_sockets</span><span class="p">);</span>
<span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">atalk_sockets_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__atalk_insert_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk_add_node</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">atalk_sockets</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atalk_remove_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_sockets_lock</span><span class="p">);</span>
	<span class="n">sk_del_node_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_sockets_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">atalk_search_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">atif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_sockets_lock</span><span class="p">);</span>
	<span class="n">sk_for_each</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">atalk_sockets</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">atalk_sock</span> <span class="o">*</span><span class="n">at</span> <span class="o">=</span> <span class="n">at_sk</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">sat_port</span> <span class="o">!=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_port</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">==</span> <span class="n">ATADDR_ANYNET</span> <span class="o">&amp;&amp;</span>
		    <span class="n">to</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">ATADDR_BCAST</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">==</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_net</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_node</span> <span class="o">||</span>
		     <span class="n">to</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">ATADDR_BCAST</span> <span class="o">||</span>
		     <span class="n">to</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">ATADDR_ANYNODE</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>

		<span class="cm">/* XXXX.0 -- we got a request for this router. make sure</span>
<span class="cm">		 * that the node is appropriately set. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">ATADDR_ANYNODE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">to</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">!=</span> <span class="n">ATADDR_ANYNET</span> <span class="o">&amp;&amp;</span>
		    <span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">to</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_node</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_sockets_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * atalk_find_or_insert_socket - Try to find a socket matching ADDR</span>
<span class="cm"> * @sk - socket to insert in the list if it is not there already</span>
<span class="cm"> * @sat - address to search for</span>
<span class="cm"> *</span>
<span class="cm"> * Try to find a socket matching ADDR in the socket list, if found then return</span>
<span class="cm"> * it. If not, insert SK into the socket list.</span>
<span class="cm"> *</span>
<span class="cm"> * This entire operation must execute atomically.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">atalk_find_or_insert_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="n">sat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_sock</span> <span class="o">*</span><span class="n">at</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_sockets_lock</span><span class="p">);</span>
	<span class="n">sk_for_each</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">atalk_sockets</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">at</span> <span class="o">=</span> <span class="n">at_sk</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">at</span><span class="o">-&gt;</span><span class="n">src_net</span> <span class="o">==</span> <span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">&amp;&amp;</span>
		    <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_node</span> <span class="o">==</span> <span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">&amp;&amp;</span>
		    <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_port</span> <span class="o">==</span> <span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_port</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">__atalk_insert_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span> <span class="cm">/* Wheee, it&#39;s free, assign and insert. */</span>
<span class="nl">found:</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_sockets_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atalk_destroy_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk_has_allocations</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SOCK_DESTROY_TIME</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_timer</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atalk_destroy_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atalk_remove_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk_has_allocations</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_timer</span><span class="p">,</span> <span class="n">atalk_destroy_timer</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_timer</span><span class="p">.</span><span class="n">expires</span>	<span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">SOCK_DESTROY_TIME</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_timer</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************\</span>
<span class="cm">*                                                                          *</span>
<span class="cm">* Routing tables for the AppleTalk socket layer.                           *</span>
<span class="cm">*                                                                          *</span>
<span class="cm">\**************************************************************************/</span>

<span class="cm">/* Anti-deadlock ordering is atalk_routes_lock --&gt; iface_lock -DaveM */</span>
<span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">*</span><span class="n">atalk_routes</span><span class="p">;</span>
<span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">atalk_routes_lock</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">atalk_interfaces</span><span class="p">;</span>
<span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">atalk_interfaces_lock</span><span class="p">);</span>

<span class="cm">/* For probing devices or in a routerless network */</span>
<span class="k">struct</span> <span class="n">atalk_route</span> <span class="n">atrtr_default</span><span class="p">;</span>

<span class="cm">/* AppleTalk interface control */</span>
<span class="cm">/*</span>
<span class="cm"> * Drop a device. Doesn&#39;t drop any of its routes - that is the caller&#39;s</span>
<span class="cm"> * problem. Called when we down the interface or delete the address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">atif_drop_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">**</span><span class="n">iface</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atalk_interfaces</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_interfaces_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">atalk_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">iface</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_interfaces_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="nf">atif_add_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">atalk_addr</span> <span class="o">*</span><span class="n">sa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iface</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iface</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dev_hold</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">atalk_ptr</span> <span class="o">=</span> <span class="n">iface</span><span class="p">;</span>
	<span class="n">iface</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="o">*</span><span class="n">sa</span><span class="p">;</span>
	<span class="n">iface</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_interfaces_lock</span><span class="p">);</span>
	<span class="n">iface</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">atalk_interfaces</span><span class="p">;</span>
	<span class="n">atalk_interfaces</span> <span class="o">=</span> <span class="n">iface</span><span class="p">;</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_interfaces_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">iface</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Perform phase 2 AARP probing on our tentative address */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atif_probe_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">atif</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">netrange</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_lastnet</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_firstnet</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">probe_net</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_net</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">probe_node</span> <span class="o">=</span> <span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">netct</span><span class="p">,</span> <span class="n">nodect</span><span class="p">;</span>

	<span class="cm">/* Offset the network we start probing with */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">probe_net</span> <span class="o">==</span> <span class="n">ATADDR_ANYNET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">probe_net</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_firstnet</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netrange</span><span class="p">)</span>
			<span class="n">probe_net</span> <span class="o">+=</span> <span class="n">jiffies</span> <span class="o">%</span> <span class="n">netrange</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">probe_node</span> <span class="o">==</span> <span class="n">ATADDR_ANYNODE</span><span class="p">)</span>
		<span class="n">probe_node</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="cm">/* Scan the networks */</span>
	<span class="n">atif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">|=</span> <span class="n">ATIF_PROBE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">netct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">netct</span> <span class="o">&lt;=</span> <span class="n">netrange</span><span class="p">;</span> <span class="n">netct</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Sweep the available nodes from a given start */</span>
		<span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_net</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">probe_net</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">nodect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nodect</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">nodect</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">nodect</span> <span class="o">+</span> <span class="n">probe_node</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_node</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_node</span> <span class="o">&lt;</span> <span class="mi">254</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Probe a proposed address */</span>
				<span class="n">aarp_probe_network</span><span class="p">(</span><span class="n">atif</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATIF_PROBE_FAIL</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">atif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATIF_PROBE</span><span class="p">;</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">atif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATIF_PROBE_FAIL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">probe_net</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">probe_net</span> <span class="o">&gt;</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_lastnet</span><span class="p">))</span>
			<span class="n">probe_net</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_firstnet</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">atif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATIF_PROBE</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>	<span class="cm">/* Network is full... */</span>
<span class="p">}</span>


<span class="cm">/* Perform AARP probing for a proxy address */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atif_proxy_probe_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">atif</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">atalk_addr</span><span class="o">*</span> <span class="n">proxy_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">netrange</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_lastnet</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_firstnet</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* we probe the interface&#39;s network */</span>
	<span class="kt">int</span> <span class="n">probe_net</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_net</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">probe_node</span> <span class="o">=</span> <span class="n">ATADDR_ANYNODE</span><span class="p">;</span>	    <span class="cm">/* we&#39;ll take anything */</span>
	<span class="kt">int</span> <span class="n">netct</span><span class="p">,</span> <span class="n">nodect</span><span class="p">;</span>

	<span class="cm">/* Offset the network we start probing with */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">probe_net</span> <span class="o">==</span> <span class="n">ATADDR_ANYNET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">probe_net</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_firstnet</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netrange</span><span class="p">)</span>
			<span class="n">probe_net</span> <span class="o">+=</span> <span class="n">jiffies</span> <span class="o">%</span> <span class="n">netrange</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">probe_node</span> <span class="o">==</span> <span class="n">ATADDR_ANYNODE</span><span class="p">)</span>
		<span class="n">probe_node</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="cm">/* Scan the networks */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">netct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">netct</span> <span class="o">&lt;=</span> <span class="n">netrange</span><span class="p">;</span> <span class="n">netct</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Sweep the available nodes from a given start */</span>
		<span class="n">proxy_addr</span><span class="o">-&gt;</span><span class="n">s_net</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">probe_net</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">nodect</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nodect</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">nodect</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">proxy_addr</span><span class="o">-&gt;</span><span class="n">s_node</span> <span class="o">=</span> <span class="p">(</span><span class="n">nodect</span> <span class="o">+</span> <span class="n">probe_node</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">proxy_addr</span><span class="o">-&gt;</span><span class="n">s_node</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">proxy_addr</span><span class="o">-&gt;</span><span class="n">s_node</span> <span class="o">&lt;</span> <span class="mi">254</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Tell AARP to probe a proposed address */</span>
				<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">aarp_proxy_probe_network</span><span class="p">(</span><span class="n">atif</span><span class="p">,</span>
								    <span class="n">proxy_addr</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">probe_net</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">probe_net</span> <span class="o">&gt;</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_lastnet</span><span class="p">))</span>
			<span class="n">probe_net</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_firstnet</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>	<span class="cm">/* Network is full... */</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">atalk_addr</span> <span class="o">*</span><span class="nf">atalk_find_dev_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">atalk_ptr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">iface</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">atalk_addr</span> <span class="o">*</span><span class="nf">atalk_find_primary</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">fiface</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_addr</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Return a point-to-point interface only if</span>
<span class="cm">	 * there is no non-ptp interface available.</span>
<span class="cm">	 */</span>
	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_interfaces_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">iface</span> <span class="o">=</span> <span class="n">atalk_interfaces</span><span class="p">;</span> <span class="n">iface</span><span class="p">;</span> <span class="n">iface</span> <span class="o">=</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fiface</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_LOOPBACK</span><span class="p">))</span>
			<span class="n">fiface</span> <span class="o">=</span> <span class="n">iface</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IFF_LOOPBACK</span> <span class="o">|</span> <span class="n">IFF_POINTOPOINT</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fiface</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fiface</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atalk_interfaces</span><span class="p">)</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atalk_interfaces</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_interfaces_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find a match for &#39;any network&#39; - ie any of our interfaces with that</span>
<span class="cm"> * node number will do just nicely.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="nf">atalk_find_anynet</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">atalk_ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iface</span> <span class="o">||</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATIF_PROBE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">ATADDR_BCAST</span> <span class="o">&amp;&amp;</span>
	    <span class="n">iface</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_node</span> <span class="o">!=</span> <span class="n">node</span> <span class="o">&amp;&amp;</span>
	    <span class="n">node</span> <span class="o">!=</span> <span class="n">ATADDR_ANYNODE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">iface</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">iface</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Find a match for a specific network:node pair */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="nf">atalk_find_interface</span><span class="p">(</span><span class="n">__be16</span> <span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_interfaces_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">iface</span> <span class="o">=</span> <span class="n">atalk_interfaces</span><span class="p">;</span> <span class="n">iface</span><span class="p">;</span> <span class="n">iface</span> <span class="o">=</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">node</span> <span class="o">==</span> <span class="n">ATADDR_BCAST</span> <span class="o">||</span>
		     <span class="n">node</span> <span class="o">==</span> <span class="n">ATADDR_ANYNODE</span> <span class="o">||</span>
		     <span class="n">iface</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">iface</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_net</span> <span class="o">==</span> <span class="n">net</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATIF_PROBE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* XXXX.0 -- net.0 returns the iface associated with net */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">ATADDR_ANYNODE</span> <span class="o">&amp;&amp;</span> <span class="n">net</span> <span class="o">!=</span> <span class="n">ATADDR_ANYNET</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ntohs</span><span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_firstnet</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ntohs</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_lastnet</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_interfaces_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">iface</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Find a route for an AppleTalk packet. This ought to get cached in</span>
<span class="cm"> * the socket (later on...). We know about host routes and the fact</span>
<span class="cm"> * that a route must be direct to broadcast.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">*</span><span class="nf">atrtr_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">atalk_addr</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * we must search through all routes unless we find a</span>
<span class="cm">	 * host route, because some host routes might overlap</span>
<span class="cm">	 * network routes</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">*</span><span class="n">net_route</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_routes_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">atalk_routes</span><span class="p">;</span> <span class="n">r</span><span class="p">;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RTF_UP</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">.</span><span class="n">s_net</span> <span class="o">==</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">s_net</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RTF_HOST</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * if this host route is for the target,</span>
<span class="cm">				 * the we&#39;re done</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">s_node</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="cm">/*</span>
<span class="cm">				 * this route will work if there isn&#39;t a</span>
<span class="cm">				 * direct host route, so cache it</span>
<span class="cm">				 */</span>
				<span class="n">net_route</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we found a network route but not a direct host</span>
<span class="cm">	 * route, then return it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_route</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">net_route</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atrtr_default</span><span class="p">.</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atrtr_default</span><span class="p">;</span>
	<span class="k">else</span> <span class="cm">/* No route can be found */</span>
		<span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_routes_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Given an AppleTalk network, find the device to use. This can be</span>
<span class="cm"> * a simple lookup.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">atrtr_get_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">atalk_addr</span> <span class="o">*</span><span class="n">sa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">*</span><span class="n">atr</span> <span class="o">=</span> <span class="n">atrtr_find</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">atr</span> <span class="o">?</span> <span class="n">atr</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set up a default router */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">atrtr_set_default</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atrtr_default</span><span class="p">.</span><span class="n">dev</span>	     <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">atrtr_default</span><span class="p">.</span><span class="n">flags</span>	     <span class="o">=</span> <span class="n">RTF_UP</span><span class="p">;</span>
	<span class="n">atrtr_default</span><span class="p">.</span><span class="n">gateway</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">atrtr_default</span><span class="p">.</span><span class="n">gateway</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a router. Basically make sure it looks valid and stuff the</span>
<span class="cm"> * entry in the list. While it uses netranges we always set them to one</span>
<span class="cm"> * entry to work like netatalk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atrtr_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtentry</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">devhint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="n">ta</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">rt_dst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="n">ga</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">rt_gateway</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">iface</span><span class="p">,</span> <span class="o">*</span><span class="n">riface</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fixme: Raise/Lower a routing change semaphore for these</span>
<span class="cm">	 * operations.</span>
<span class="cm">	 */</span>

	<span class="cm">/* Validate the request */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">!=</span> <span class="n">AF_APPLETALK</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">devhint</span> <span class="o">&amp;&amp;</span> <span class="n">ga</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">!=</span> <span class="n">AF_APPLETALK</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Now walk the routing table and make our decisions */</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_routes_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">rt</span> <span class="o">=</span> <span class="n">atalk_routes</span><span class="p">;</span> <span class="n">rt</span><span class="p">;</span> <span class="n">rt</span> <span class="o">=</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">rt_flags</span> <span class="o">!=</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">==</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">.</span><span class="n">s_net</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RTF_HOST</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ta</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">.</span><span class="n">s_node</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devhint</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">riface</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_interfaces_lock</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">iface</span> <span class="o">=</span> <span class="n">atalk_interfaces</span><span class="p">;</span> <span class="n">iface</span><span class="p">;</span> <span class="n">iface</span> <span class="o">=</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">riface</span> <span class="o">&amp;&amp;</span>
			    <span class="n">ntohs</span><span class="p">(</span><span class="n">ga</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span><span class="p">)</span> <span class="o">&gt;=</span>
					<span class="n">ntohs</span><span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_firstnet</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">ntohs</span><span class="p">(</span><span class="n">ga</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span><span class="p">)</span> <span class="o">&lt;=</span>
					<span class="n">ntohs</span><span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">.</span><span class="n">nr_lastnet</span><span class="p">))</span>
				<span class="n">riface</span> <span class="o">=</span> <span class="n">iface</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ga</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">==</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_net</span> <span class="o">&amp;&amp;</span>
			    <span class="n">ga</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_node</span><span class="p">)</span>
				<span class="n">riface</span> <span class="o">=</span> <span class="n">iface</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_interfaces_lock</span><span class="p">);</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENETUNREACH</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">riface</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="n">devhint</span> <span class="o">=</span> <span class="n">riface</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rt</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rt</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="n">rt</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">atalk_routes</span><span class="p">;</span>
		<span class="n">atalk_routes</span> <span class="o">=</span> <span class="n">rt</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fill in the routing entry */</span>
	<span class="n">rt</span><span class="o">-&gt;</span><span class="n">target</span>  <span class="o">=</span> <span class="n">ta</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">;</span>
	<span class="n">dev_hold</span><span class="p">(</span><span class="n">devhint</span><span class="p">);</span>
	<span class="n">rt</span><span class="o">-&gt;</span><span class="n">dev</span>     <span class="o">=</span> <span class="n">devhint</span><span class="p">;</span>
	<span class="n">rt</span><span class="o">-&gt;</span><span class="n">flags</span>   <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">rt_flags</span><span class="p">;</span>
	<span class="n">rt</span><span class="o">-&gt;</span><span class="n">gateway</span> <span class="o">=</span> <span class="n">ga</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_routes_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Delete a route. Find it and discard it */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atrtr_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">atalk_addr</span> <span class="o">*</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">**</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atalk_routes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_routes_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">.</span><span class="n">s_net</span> <span class="o">==</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">s_net</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">&amp;</span><span class="n">RTF_GATEWAY</span><span class="p">)</span> <span class="o">||</span>
		     <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">s_node</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">dev_put</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_routes_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when a device is downed. Just throw away any routes</span>
<span class="cm"> * via it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">atrtr_device_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">**</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atalk_routes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_routes_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_routes_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atrtr_default</span><span class="p">.</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span>
		<span class="n">atrtr_set_default</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Actually down the interface */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atalk_dev_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atrtr_device_down</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* Remove all routes for the device */</span>
	<span class="n">aarp_device_down</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* Remove AARP entries for the device */</span>
	<span class="n">atif_drop_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* Remove the device */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A device event has occurred. Watch for devices going down and</span>
<span class="cm"> * delete our use of them (iface and route).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ddp_device_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_eq</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">NETDEV_DOWN</span><span class="p">)</span>
		<span class="cm">/* Discard any use of this */</span>
		<span class="n">atalk_dev_down</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ioctl calls. Shouldn&#39;t even need touching */</span>
<span class="cm">/* Device configuration ioctl calls */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atif_ioctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">aarp_mcast</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x09</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">atreq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_netrange</span> <span class="o">*</span><span class="n">nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="n">sa</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">atif</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ct</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtentry</span> <span class="n">rtdef</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">add_route</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atreq</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">atreq</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">__dev_get_by_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">atreq</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">atreq</span><span class="p">.</span><span class="n">ifr_addr</span><span class="p">;</span>
	<span class="n">atif</span> <span class="o">=</span> <span class="n">atalk_find_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCSIFADDR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">!=</span> <span class="n">AF_APPLETALK</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_ETHER</span> <span class="o">&amp;&amp;</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_LOOPBACK</span> <span class="o">&amp;&amp;</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_LOCALTLK</span> <span class="o">&amp;&amp;</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_PPP</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

		<span class="n">nr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atalk_netrange</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_zero</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">add_route</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * if this is a point-to-point iface, and we already</span>
<span class="cm">		 * have an iface for this AppleTalk address, then we</span>
<span class="cm">		 * should not add a route</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_POINTOPOINT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">atalk_find_interface</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span><span class="p">,</span>
					 <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;AppleTalk: point-to-point &quot;</span>
			       <span class="s">&quot;interface added with &quot;</span>
			       <span class="s">&quot;existing address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">add_route</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Phase 1 is fine on LocalTalk but we don&#39;t do</span>
<span class="cm">		 * EtherTalk phase 1. Anyone wanting to add it go ahead.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ARPHRD_ETHER</span> <span class="o">&amp;&amp;</span> <span class="n">nr</span><span class="o">-&gt;</span><span class="n">nr_phase</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">ATADDR_BCAST</span> <span class="o">||</span>
		    <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="mi">254</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atif</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Already setting address */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATIF_PROBE</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

			<span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span><span class="p">;</span>
			<span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span><span class="p">;</span>
			<span class="n">atrtr_device_down</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* Flush old routes */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">atif</span> <span class="o">=</span> <span class="n">atif_add_device</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atif</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span> <span class="o">=</span> <span class="o">*</span><span class="n">nr</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if the chosen address is used. If so we</span>
<span class="cm">		 * error and atalkd will try another.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_LOOPBACK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_POINTOPOINT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">atif_probe_device</span><span class="p">(</span><span class="n">atif</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atif_drop_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Hey it worked - add the direct routes */</span>
		<span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rtdef</span><span class="p">.</span><span class="n">rt_gateway</span><span class="p">;</span>
		<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">=</span> <span class="n">AF_APPLETALK</span><span class="p">;</span>
		<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_net</span><span class="p">;</span>
		<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_node</span><span class="p">;</span>
		<span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rtdef</span><span class="p">.</span><span class="n">rt_dst</span><span class="p">;</span>
		<span class="n">rtdef</span><span class="p">.</span><span class="n">rt_flags</span> <span class="o">=</span> <span class="n">RTF_UP</span><span class="p">;</span>
		<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">=</span> <span class="n">AF_APPLETALK</span><span class="p">;</span>
		<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">ATADDR_ANYNODE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_LOOPBACK</span> <span class="o">||</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_POINTOPOINT</span><span class="p">)</span>
			<span class="n">rtdef</span><span class="p">.</span><span class="n">rt_flags</span> <span class="o">|=</span> <span class="n">RTF_HOST</span><span class="p">;</span>

		<span class="cm">/* Routerless initial state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr</span><span class="o">-&gt;</span><span class="n">nr_firstnet</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nr</span><span class="o">-&gt;</span><span class="n">nr_lastnet</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="mh">0xFFFE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">=</span> <span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_net</span><span class="p">;</span>
			<span class="n">atrtr_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtdef</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="n">atrtr_set_default</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">limit</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">nr</span><span class="o">-&gt;</span><span class="n">nr_lastnet</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">nr</span><span class="o">-&gt;</span><span class="n">nr_firstnet</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4096</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Too many routes/&quot;</span>
				       <span class="s">&quot;iface.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">add_route</span><span class="p">)</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">ct</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">nr</span><span class="o">-&gt;</span><span class="n">nr_firstnet</span><span class="p">);</span>
				     <span class="n">ct</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">ct</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>
					<span class="n">atrtr_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtdef</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
				<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">dev_mc_add_global</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">aarp_mcast</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCGIFADDR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atif</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

		<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">=</span> <span class="n">AF_APPLETALK</span><span class="p">;</span>
		<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span> <span class="o">=</span> <span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCGIFBRDADDR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atif</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

		<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">=</span> <span class="n">AF_APPLETALK</span><span class="p">;</span>
		<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">=</span> <span class="n">atif</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">.</span><span class="n">s_net</span><span class="p">;</span>
		<span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">ATADDR_BCAST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCATALKDIFADDR</span>:
	<span class="k">case</span> <span class="n">SIOCDIFADDR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">!=</span> <span class="n">AF_APPLETALK</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">atalk_dev_down</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCSARP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">!=</span> <span class="n">AF_APPLETALK</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * for now, we only support proxy AARP on ELAP;</span>
<span class="cm">		 * we should be able to do it for LocalTalk, too.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_ETHER</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * atif points to the current interface on this network;</span>
<span class="cm">		 * we aren&#39;t concerned about its current status (at</span>
<span class="cm">		 * least for now), but it has all the settings about</span>
<span class="cm">		 * the network we&#39;re going to probe. Consequently, it</span>
<span class="cm">		 * must exist.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atif</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

		<span class="n">nr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atalk_netrange</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">nets</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Phase 1 is fine on Localtalk but we don&#39;t do</span>
<span class="cm">		 * Ethertalk phase 1. Anyone wanting to add it go ahead.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ARPHRD_ETHER</span> <span class="o">&amp;&amp;</span> <span class="n">nr</span><span class="o">-&gt;</span><span class="n">nr_phase</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">ATADDR_BCAST</span> <span class="o">||</span>
		    <span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="mi">254</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if the chosen address is used. If so we</span>
<span class="cm">		 * error and ATCP will try another.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atif_proxy_probe_device</span><span class="p">(</span><span class="n">atif</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We now have an address on the local network, and</span>
<span class="cm">		 * the AARP code will defend it for us until we take it</span>
<span class="cm">		 * down. We don&#39;t set up any routes right now, because</span>
<span class="cm">		 * ATCP will install them manually via SIOCADDRT.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCDARP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">!=</span> <span class="n">AF_APPLETALK</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atif</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

		<span class="cm">/* give to aarp module to remove proxy entry */</span>
		<span class="n">aarp_proxy_remove</span><span class="p">(</span><span class="n">atif</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">atreq</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">atreq</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Routing ioctl() calls */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atrtr_ioctl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rtentry</span> <span class="n">rt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rt</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCDELRT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="p">.</span><span class="n">rt_dst</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">AF_APPLETALK</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">atrtr_delete</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="p">)</span>
				      <span class="o">&amp;</span><span class="n">rt</span><span class="p">.</span><span class="n">rt_dst</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SIOCADDRT</span>: <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="p">.</span><span class="n">rt_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">rt</span><span class="p">.</span><span class="n">rt_dev</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="n">dev</span> <span class="o">=</span> <span class="n">__dev_get_by_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">atrtr_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**************************************************************************\</span>
<span class="cm">*                                                                          *</span>
<span class="cm">* Handling for system calls applied via the various interfaces to an       *</span>
<span class="cm">* AppleTalk socket object.                                                 *</span>
<span class="cm">*                                                                          *</span>
<span class="cm">\**************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Checksum: This is &#39;optional&#39;. It&#39;s quite likely also a good</span>
<span class="cm"> * candidate for assembler hackery 8)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">atalk_sum_partial</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* This ought to be unwrapped neatly. I&#39;ll trust gcc for now */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">data</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sum</span> <span class="o">=</span> <span class="n">rol16</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  Checksum skb data --  similar to skb_checksum  */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">atalk_sum_skb</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag_iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">copy</span><span class="p">;</span>

	<span class="cm">/* checksum stuff in header space */</span>
	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">copy</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">sum</span> <span class="o">=</span> <span class="n">atalk_sum_partial</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* checksum stuff in frags */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>
		<span class="k">const</span> <span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
			<span class="n">sum</span> <span class="o">=</span> <span class="n">atalk_sum_partial</span><span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span>
						  <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag_iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">frag_iter</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">sum</span> <span class="o">=</span> <span class="n">atalk_sum_skb</span><span class="p">(</span><span class="n">frag_iter</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
					    <span class="n">copy</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be16</span> <span class="nf">atalk_checksum</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum</span><span class="p">;</span>

	<span class="cm">/* skip header 4 bytes */</span>
	<span class="n">sum</span> <span class="o">=</span> <span class="n">atalk_sum_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Use 0xFFFF for 0. 0 itself means none */</span>
	<span class="k">return</span> <span class="n">sum</span> <span class="o">?</span> <span class="n">htons</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">sum</span><span class="p">)</span> <span class="o">:</span> <span class="n">htons</span><span class="p">(</span><span class="mh">0xFFFF</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proto</span> <span class="n">ddp_proto</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	  <span class="o">=</span> <span class="s">&quot;DDP&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>	  <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">obj_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">atalk_sock</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Create a socket. Initialise the socket, blank the addresses</span>
<span class="cm"> * set the state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESOCKTNOSUPPORT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_eq</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do</span>
<span class="cm">	 * and gives you the full ELAP frame. Should be handy for CAP 8)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SOCK_RAW</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SOCK_DGRAM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">sk_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">PF_APPLETALK</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ddp_proto</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atalk_dgram_ops</span><span class="p">;</span>
	<span class="n">sock_init_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Checksums on by default */</span>
	<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Free a socket. No work needed */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="n">sock_orphan</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">atalk_destroy_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * atalk_pick_and_bind_port - Pick a source port when one is not given</span>
<span class="cm"> * @sk - socket to insert into the tables</span>
<span class="cm"> * @sat - address to search for</span>
<span class="cm"> *</span>
<span class="cm"> * Pick a source port when one is not given. If we can find a suitable free</span>
<span class="cm"> * one, we insert the socket into the tables using it.</span>
<span class="cm"> *</span>
<span class="cm"> * This whole operation must be atomic.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_pick_and_bind_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="n">sat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_sockets_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_port</span> <span class="o">=</span> <span class="n">ATPORT_RESERVED</span><span class="p">;</span>
	     <span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_port</span> <span class="o">&lt;</span> <span class="n">ATPORT_LAST</span><span class="p">;</span>
	     <span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_port</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

		<span class="n">sk_for_each</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">atalk_sockets</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">atalk_sock</span> <span class="o">*</span><span class="n">at</span> <span class="o">=</span> <span class="n">at_sk</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">at</span><span class="o">-&gt;</span><span class="n">src_net</span> <span class="o">==</span> <span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">&amp;&amp;</span>
			    <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_node</span> <span class="o">==</span> <span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">&amp;&amp;</span>
			    <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_port</span> <span class="o">==</span> <span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_port</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">try_next_port</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wheee, it&#39;s free, assign and insert. */</span>
		<span class="n">__atalk_insert_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">at_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">src_port</span> <span class="o">=</span> <span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_port</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">try_next_port:</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_sockets_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_autobind</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_sock</span> <span class="o">*</span><span class="n">at</span> <span class="o">=</span> <span class="n">at_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="n">sat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_addr</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">atalk_find_primary</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">s_net</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ATADDR_ANYNET</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">at</span><span class="o">-&gt;</span><span class="n">src_net</span>  <span class="o">=</span> <span class="n">sat</span><span class="p">.</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">s_net</span><span class="p">;</span>
	<span class="n">at</span><span class="o">-&gt;</span><span class="n">src_node</span> <span class="o">=</span> <span class="n">sat</span><span class="p">.</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">s_node</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">atalk_pick_and_bind_port</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set the address &#39;our end&#39; of the connection */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="p">)</span><span class="n">uaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_sock</span> <span class="o">*</span><span class="n">at</span> <span class="o">=</span> <span class="n">at_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">addr_len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">!=</span> <span class="n">AF_APPLETALK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ATADDR_ANYNET</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">atalk_addr</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">atalk_find_primary</span><span class="p">();</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">at</span><span class="o">-&gt;</span><span class="n">src_net</span>  <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">s_net</span><span class="p">;</span>
		<span class="n">at</span><span class="o">-&gt;</span><span class="n">src_node</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span><span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">s_node</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRNOTAVAIL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atalk_find_interface</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span><span class="p">,</span>
					  <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">at</span><span class="o">-&gt;</span><span class="n">src_net</span>  <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span><span class="p">;</span>
		<span class="n">at</span><span class="o">-&gt;</span><span class="n">src_node</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_port</span> <span class="o">==</span> <span class="n">ATADDR_ANYPORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">atalk_pick_and_bind_port</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">at</span><span class="o">-&gt;</span><span class="n">src_port</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_port</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atalk_find_or_insert_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Set the address we talk to */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">addr_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_sock</span> <span class="o">*</span><span class="n">at</span> <span class="o">=</span> <span class="n">at_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>   <span class="o">=</span> <span class="n">TCP_CLOSE</span><span class="p">;</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr_len</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="p">)</span><span class="n">uaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">!=</span> <span class="n">AF_APPLETALK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">ATADDR_BCAST</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_BROADCAST</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#if 1</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;atalk_connect: %s is broken and did not set SO_BROADCAST.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atalk_autobind</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENETUNREACH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atrtr_get_dev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">at</span><span class="o">-&gt;</span><span class="n">dest_port</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_port</span><span class="p">;</span>
	<span class="n">at</span><span class="o">-&gt;</span><span class="n">dest_net</span>  <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span><span class="p">;</span>
	<span class="n">at</span><span class="o">-&gt;</span><span class="n">dest_node</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span><span class="p">;</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span>  <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find the name of an AppleTalk socket. Just copy the right</span>
<span class="cm"> * fields into the sockaddr.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_getname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="o">*</span><span class="n">uaddr_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">peer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="n">sat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_sock</span> <span class="o">*</span><span class="n">at</span> <span class="o">=</span> <span class="n">at_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atalk_autobind</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="o">*</span><span class="n">uaddr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sat</span><span class="p">.</span><span class="n">sat_zero</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sat</span><span class="p">.</span><span class="n">sat_zero</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">sat</span><span class="p">.</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">dest_net</span><span class="p">;</span>
		<span class="n">sat</span><span class="p">.</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">dest_node</span><span class="p">;</span>
		<span class="n">sat</span><span class="p">.</span><span class="n">sat_port</span>	    <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">dest_port</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sat</span><span class="p">.</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_net</span><span class="p">;</span>
		<span class="n">sat</span><span class="p">.</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_node</span><span class="p">;</span>
		<span class="n">sat</span><span class="p">.</span><span class="n">sat_port</span>	    <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_port</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sat</span><span class="p">.</span><span class="n">sat_family</span> <span class="o">=</span> <span class="n">AF_APPLETALK</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sat</span><span class="p">));</span>

<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_IPDDP) || defined(CONFIG_IPDDP_MODULE)</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">int</span> <span class="nf">is_ip_over_ddp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">==</span> <span class="mi">22</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_ip_over_ddp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">__dev_get_by_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="s">&quot;ipddp0&quot;</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">stats</span><span class="p">;</span>

	<span class="cm">/* This needs to be able to handle ipddp&quot;N&quot; devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span>   <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">stats</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="mi">13</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>  <span class="cm">/* Send the SKB up to a higher place. */</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cm">/* make it easy for gcc to optimize this test out, i.e. kill the code */</span>
<span class="cp">#define is_ip_over_ddp(skb) 0</span>
<span class="cp">#define handle_ip_over_ddp(skb) 0</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_route_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">ddpehdr</span> <span class="o">*</span><span class="n">ddp</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">len_hops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_addr</span> <span class="n">ta</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t route multicast, etc., packets, or packets sent to &quot;this</span>
<span class="cm">	 * network&quot;</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">!=</span> <span class="n">PACKET_HOST</span> <span class="o">||</span> <span class="o">!</span><span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnet</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * FIXME:</span>
<span class="cm">		 *</span>
<span class="cm">		 * Can it ever happen that a packet is from a PPP iface and</span>
<span class="cm">		 * needs to be broadcast onto the default network?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ARPHRD_PPP</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;AppleTalk: didn&#39;t forward broadcast &quot;</span>
					  <span class="s">&quot;packet received from PPP iface</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_it</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ta</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnet</span><span class="p">;</span>
	<span class="n">ta</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnode</span><span class="p">;</span>

	<span class="cm">/* Route the packet */</span>
	<span class="n">rt</span> <span class="o">=</span> <span class="n">atrtr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ta</span><span class="p">);</span>
	<span class="cm">/* increment hops count */</span>
	<span class="n">len_hops</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">len_hops</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">15</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">free_it</span><span class="p">;</span>

	<span class="cm">/* FIXME: use skb-&gt;cb to be able to use shared skbs */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Route goes through another gateway, so set the target to the</span>
<span class="cm">	 * gateway instead.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RTF_GATEWAY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ta</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">gateway</span><span class="p">.</span><span class="n">s_net</span><span class="p">;</span>
		<span class="n">ta</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">gateway</span><span class="p">.</span><span class="n">s_node</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fix up skb-&gt;len field */</span>
	<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">origlen</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span> <span class="o">+</span>
			     <span class="n">ddp_dl</span><span class="o">-&gt;</span><span class="n">header_length</span> <span class="o">+</span> <span class="p">(</span><span class="n">len_hops</span> <span class="o">&amp;</span> <span class="mi">1023</span><span class="p">))));</span>

	<span class="cm">/* FIXME: use skb-&gt;cb to be able to use shared skbs */</span>
	<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_len_hops</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">len_hops</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send the buffer onwards</span>
<span class="cm">	 *</span>
<span class="cm">	 * Now we must always be careful. If it&#39;s come from LocalTalk to</span>
<span class="cm">	 * EtherTalk it might not fit</span>
<span class="cm">	 *</span>
<span class="cm">	 * Order matters here: If a packet has to be copied to make a new</span>
<span class="cm">	 * headroom (rare hopefully) then it won&#39;t need unsharing.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note. ddp-&gt; becomes invalid at the realloc.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">22</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* 22 bytes - 12 ether, 2 len, 3 802.2 5 snap */</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span> <span class="o">=</span> <span class="n">skb_realloc_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_unshare</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the buffer didn&#39;t vanish into the lack of space bitbucket we can</span>
<span class="cm">	 * send it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">aarp_send_ddp</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ta</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">NET_XMIT_DROP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
<span class="nl">free_it:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">drop:</span>
	<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	atalk_rcv - Receive a packet (in skb) from device dev</span>
<span class="cm"> *	@skb - packet received</span>
<span class="cm"> *	@dev - network device where the packet comes from</span>
<span class="cm"> *	@pt - packet type</span>
<span class="cm"> *</span>
<span class="cm"> *	Receive a packet (in skb) from device dev. This has come from the SNAP</span>
<span class="cm"> *	decoder, and on entry skb-&gt;transport_header is the DDP header, skb-&gt;len</span>
<span class="cm"> *	is the DDP header, skb-&gt;len is the DDP length. The physical headers</span>
<span class="cm"> *	have been extracted. PPP should probably pass frames marked as for this</span>
<span class="cm"> *	layer.  [ie ARPHRD_ETHERTALK]</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ddpehdr</span> <span class="o">*</span><span class="n">ddp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_iface</span> <span class="o">*</span><span class="n">atif</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="n">tosat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">origlen</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">len_hops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_eq</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t mangle buffer if shared */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_share_check</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Size check and make sure header is contiguous */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ddp</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="n">ddp</span> <span class="o">=</span> <span class="n">ddp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">len_hops</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_len_hops</span><span class="p">);</span>

	<span class="cm">/* Trim buffer in case of stray trailing data */</span>
	<span class="n">origlen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">len_hops</span> <span class="o">&amp;</span> <span class="mi">1023</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Size check to see if ddp-&gt;deh_len was crap</span>
<span class="cm">	 * (Otherwise we&#39;ll detonate most spectacularly</span>
<span class="cm">	 * in the middle of atalk_checksum() or recvmsg()).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ddp</span><span class="p">)</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">len_hops</span> <span class="o">&amp;</span> <span class="mi">1023</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;AppleTalk: dropping corrupted frame (deh_len=%u, &quot;</span>
			 <span class="s">&quot;skb-&gt;len=%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len_hops</span> <span class="o">&amp;</span> <span class="mi">1023</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Any checksums. Note we don&#39;t do htons() on this == is assumed to be</span>
<span class="cm">	 * valid for net byte orders all over the networking code...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_sum</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atalk_checksum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len_hops</span> <span class="o">&amp;</span> <span class="mi">1023</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_sum</span><span class="p">)</span>
		<span class="cm">/* Not a valid AppleTalk frame - dustbin time */</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="cm">/* Check the packet is aimed at us */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnet</span><span class="p">)</span>	<span class="cm">/* Net 0 is &#39;this network&#39; */</span>
		<span class="n">atif</span> <span class="o">=</span> <span class="n">atalk_find_anynet</span><span class="p">(</span><span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnode</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">atif</span> <span class="o">=</span> <span class="n">atalk_find_interface</span><span class="p">(</span><span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnet</span><span class="p">,</span> <span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atif</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not ours, so we route the packet via the correct</span>
<span class="cm">		 * AppleTalk iface</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">atalk_route_packet</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">ddp</span><span class="p">,</span> <span class="n">len_hops</span><span class="p">,</span> <span class="n">origlen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* if IP over DDP is not selected this code will be optimized out */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_ip_over_ddp</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">handle_ip_over_ddp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Which socket - atalk_search_socket() looks for a *full match*</span>
<span class="cm">	 * of the &lt;net, node, port&gt; tuple.</span>
<span class="cm">	 */</span>
	<span class="n">tosat</span><span class="p">.</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnet</span><span class="p">;</span>
	<span class="n">tosat</span><span class="p">.</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnode</span><span class="p">;</span>
	<span class="n">tosat</span><span class="p">.</span><span class="n">sat_port</span>	      <span class="o">=</span> <span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dport</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">atalk_search_socket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tosat</span><span class="p">,</span> <span class="n">atif</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span> <span class="cm">/* But not one of our sockets */</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="cm">/* Queue packet (standard) */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_queue_rcv_skb</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

<span class="nl">drop:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Receive a LocalTalk frame. We make some demands on the caller here.</span>
<span class="cm"> * Caller must provide enough headroom on the packet to pull the short</span>
<span class="cm"> * header and append a long one.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ltalk_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_eq</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">freeit</span><span class="p">;</span>

	<span class="cm">/* Expand any short form frames */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ddpehdr</span> <span class="o">*</span><span class="n">ddp</span><span class="p">;</span>
		<span class="cm">/* Find our address */</span>
		<span class="k">struct</span> <span class="n">atalk_addr</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">atalk_find_dev_addr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__be16</span><span class="p">)</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1023</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">freeit</span><span class="p">;</span>

		<span class="cm">/* Don&#39;t mangle buffer if shared */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_share_check</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The push leaves us with a ddephdr not an shdr, and</span>
<span class="cm">		 * handily the port bytes in the right place preset.</span>
<span class="cm">		 */</span>
		<span class="n">ddp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ddpehdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ddp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">);</span>

		<span class="cm">/* Now fill in the long header */</span>

		<span class="cm">/*</span>
<span class="cm">		 * These two first. The mac overlays the new source/dest</span>
<span class="cm">		 * network information so we MUST copy these before</span>
<span class="cm">		 * we write the network numbers !</span>
<span class="cm">		 */</span>

		<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnode</span> <span class="o">=</span> <span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>     <span class="cm">/* From physical header */</span>
		<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_snode</span> <span class="o">=</span> <span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>     <span class="cm">/* From physical header */</span>

		<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnet</span>  <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">s_net</span><span class="p">;</span>	<span class="cm">/* Network number */</span>
		<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_snet</span>  <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">s_net</span><span class="p">;</span>
		<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_sum</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* No checksum */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not sure about this bit...</span>
<span class="cm">		 */</span>
		<span class="cm">/* Non routable, so force a drop if we slip up later */</span>
		<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_len_hops</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="p">(</span><span class="n">DDP_MAXHOPS</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">atalk_rcv</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
<span class="nl">freeit:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_sock</span> <span class="o">*</span><span class="n">at</span> <span class="o">=</span> <span class="n">at_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="n">usat</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loopback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="n">local_satalk</span><span class="p">,</span> <span class="n">gsat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ddpehdr</span> <span class="o">*</span><span class="n">ddp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atalk_route</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MSG_DONTWAIT</span><span class="o">|</span><span class="n">MSG_CMSG_COMPAT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">DDP_MAXSZ</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">usat</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atalk_autobind</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">usat</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_family</span> <span class="o">!=</span> <span class="n">AF_APPLETALK</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="cm">/* netatalk didn&#39;t implement this check */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">ATADDR_BCAST</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_BROADCAST</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">usat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">local_satalk</span><span class="p">;</span>
		<span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_family</span>      <span class="o">=</span> <span class="n">AF_APPLETALK</span><span class="p">;</span>
		<span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_port</span>	      <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">dest_port</span><span class="p">;</span>
		<span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">dest_node</span><span class="p">;</span>
		<span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">dest_net</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Build a packet */</span>
	<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;SK %p: Got address.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* For headers */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ddpehdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">ddp_dl</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span> <span class="o">||</span> <span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">==</span> <span class="n">ATADDR_ANYNODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rt</span> <span class="o">=</span> <span class="n">atrtr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">atalk_addr</span> <span class="n">at_hint</span><span class="p">;</span>

		<span class="n">at_hint</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">at_hint</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_net</span><span class="p">;</span>

		<span class="n">rt</span> <span class="o">=</span> <span class="n">atrtr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at_hint</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ENETUNREACH</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;SK %p: Size needed %d, device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sk</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span><span class="p">;</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_alloc_send_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ddp_dl</span><span class="o">-&gt;</span><span class="n">header_length</span><span class="p">);</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;SK %p: Begin build.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="n">ddp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ddpehdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ddpehdr</span><span class="p">));</span>
	<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_len_hops</span>  <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ddp</span><span class="p">));</span>
	<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnet</span>  <span class="o">=</span> <span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span><span class="p">;</span>
	<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_snet</span>  <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_net</span><span class="p">;</span>
	<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnode</span> <span class="o">=</span> <span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span><span class="p">;</span>
	<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_snode</span> <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_node</span><span class="p">;</span>
	<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dport</span> <span class="o">=</span> <span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_port</span><span class="p">;</span>
	<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_sport</span> <span class="o">=</span> <span class="n">at</span><span class="o">-&gt;</span><span class="n">src_port</span><span class="p">;</span>

	<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;SK %p: Copy user data (%Zd bytes).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_no_check</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_sum</span> <span class="o">=</span> <span class="n">atalk_checksum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ddp</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Loopback broadcast packets to non gateway targets (ie routes</span>
<span class="cm">	 * to group we are in)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnode</span> <span class="o">==</span> <span class="n">ATADDR_BCAST</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RTF_GATEWAY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_LOOPBACK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb2</span> <span class="o">=</span> <span class="n">skb_copy</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">loopback</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;SK %p: send out(copy).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * If it fails it is queued/sent above in the aarp queue</span>
<span class="cm">			 */</span>
			<span class="n">aarp_send_ddp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_LOOPBACK</span> <span class="o">||</span> <span class="n">loopback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;SK %p: Loop back.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
		<span class="cm">/* loop back */</span>
		<span class="n">skb_orphan</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_dnode</span> <span class="o">==</span> <span class="n">ATADDR_BCAST</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">atalk_addr</span> <span class="n">at_lo</span><span class="p">;</span>

			<span class="n">at_lo</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">at_lo</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">rt</span> <span class="o">=</span> <span class="n">atrtr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">at_lo</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENETUNREACH</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dev</span> <span class="o">=</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ddp_dl</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">(</span><span class="n">ddp_dl</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;SK %p: send out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RTF_GATEWAY</span><span class="p">)</span> <span class="p">{</span>
		    <span class="n">gsat</span><span class="p">.</span><span class="n">sat_addr</span> <span class="o">=</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">gateway</span><span class="p">;</span>
		    <span class="n">usat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gsat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If it fails it is queued/sent above in the aarp queue</span>
<span class="cm">		 */</span>
		<span class="n">aarp_send_ddp</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">SOCK_DEBUG</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="s">&quot;SK %p: Done write (%Zd).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="n">sat</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_at</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ddpehdr</span> <span class="o">*</span><span class="n">ddp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_recv_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSG_DONTWAIT</span><span class="p">,</span>
						<span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* FIXME: use skb-&gt;cb to be able to use shared skbs */</span>
	<span class="n">ddp</span> <span class="o">=</span> <span class="n">ddp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_len_hops</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1023</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_RAW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ddp</span><span class="p">);</span>
		<span class="n">copied</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_TRUNC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sat</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_family</span>      <span class="o">=</span> <span class="n">AF_APPLETALK</span><span class="p">;</span>
			<span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_port</span>        <span class="o">=</span> <span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_sport</span><span class="p">;</span>
			<span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_node</span> <span class="o">=</span> <span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_snode</span><span class="p">;</span>
			<span class="n">sat</span><span class="o">-&gt;</span><span class="n">sat_addr</span><span class="p">.</span><span class="n">s_net</span>  <span class="o">=</span> <span class="n">ddp</span><span class="o">-&gt;</span><span class="n">deh_snet</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sat</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">skb_free_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>	<span class="cm">/* Free the datagram. */</span>

<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="o">:</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * AppleTalk ioctl calls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Protocol layer */</span>
		<span class="k">case</span> <span class="n">TIOCOUTQ</span>: <span class="p">{</span>
			<span class="kt">long</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">-</span> <span class="n">sk_wmem_alloc_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">amount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">argp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">TIOCINQ</span>: <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * These two are safe on a single CPU system as only</span>
<span class="cm">			 * user tasks fiddle here</span>
<span class="cm">			 */</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
			<span class="kt">long</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
				<span class="n">amount</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ddpehdr</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">argp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">SIOCGSTAMP</span>:
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sock_get_timestamp</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SIOCGSTAMPNS</span>:
			<span class="n">rc</span> <span class="o">=</span> <span class="n">sock_get_timestampns</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Routing */</span>
		<span class="k">case</span> <span class="n">SIOCADDRT</span>:
		<span class="k">case</span> <span class="n">SIOCDELRT</span>:
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">atrtr_ioctl</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Interface */</span>
		<span class="k">case</span> <span class="n">SIOCGIFADDR</span>:
		<span class="k">case</span> <span class="n">SIOCSIFADDR</span>:
		<span class="k">case</span> <span class="n">SIOCGIFBRDADDR</span>:
		<span class="k">case</span> <span class="n">SIOCATALKDIFADDR</span>:
		<span class="k">case</span> <span class="n">SIOCDIFADDR</span>:
		<span class="k">case</span> <span class="n">SIOCSARP</span>:		<span class="cm">/* proxy AARP */</span>
		<span class="k">case</span> <span class="n">SIOCDARP</span>:		<span class="cm">/* proxy AARP */</span>
			<span class="n">rtnl_lock</span><span class="p">();</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">atif_ioctl</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
			<span class="n">rtnl_unlock</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atalk_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * SIOCATALKDIFADDR is a SIOCPROTOPRIVATE ioctl number, so we</span>
<span class="cm">	 * cannot handle it in common code. The data we access if ifreq</span>
<span class="cm">	 * here is compatible, so we can simply call the native</span>
<span class="cm">	 * handler.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCATALKDIFADDR</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">atalk_ioctl</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">compat_ptr</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_proto_family</span> <span class="n">atalk_family_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span>		<span class="o">=</span> <span class="n">PF_APPLETALK</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span>		<span class="o">=</span> <span class="n">atalk_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">atalk_dgram_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span>		<span class="o">=</span> <span class="n">PF_APPLETALK</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">atalk_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">atalk_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>	<span class="o">=</span> <span class="n">atalk_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span>	<span class="o">=</span> <span class="n">sock_no_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span>		<span class="o">=</span> <span class="n">sock_no_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span>	<span class="o">=</span> <span class="n">atalk_getname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">datagram_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">atalk_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">atalk_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">listen</span>		<span class="o">=</span> <span class="n">sock_no_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">sock_no_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span>	<span class="o">=</span> <span class="n">sock_no_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span>	<span class="o">=</span> <span class="n">sock_no_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span>	<span class="o">=</span> <span class="n">atalk_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span>	<span class="o">=</span> <span class="n">atalk_recvmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span>	<span class="o">=</span> <span class="n">sock_no_sendpage</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">ddp_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>	<span class="o">=</span> <span class="n">ddp_device_event</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">packet_type</span> <span class="n">ltalk_packet_type</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">type</span>		<span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_LOCALTALK</span><span class="p">),</span>
	<span class="p">.</span><span class="n">func</span>		<span class="o">=</span> <span class="n">ltalk_rcv</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">packet_type</span> <span class="n">ppptalk_packet_type</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">type</span>		<span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_PPPTALK</span><span class="p">),</span>
	<span class="p">.</span><span class="n">func</span>		<span class="o">=</span> <span class="n">atalk_rcv</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ddp_snap_id</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0x08</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x07</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x9B</span> <span class="p">};</span>

<span class="cm">/* Export symbols for use by drivers when AppleTalk is a module */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">atrtr_get_dev</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">atalk_find_dev_addr</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">atalk_err_snap</span><span class="p">[]</span> <span class="n">__initconst</span> <span class="o">=</span>
	<span class="n">KERN_CRIT</span> <span class="s">&quot;Unable to register DDP with SNAP.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cm">/* Called by proto.c on kernel start up */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">atalk_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">proto_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddp_proto</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sock_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atalk_family_ops</span><span class="p">);</span>
	<span class="n">ddp_dl</span> <span class="o">=</span> <span class="n">register_snap_client</span><span class="p">(</span><span class="n">ddp_snap_id</span><span class="p">,</span> <span class="n">atalk_rcv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ddp_dl</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">atalk_err_snap</span><span class="p">);</span>

	<span class="n">dev_add_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ltalk_packet_type</span><span class="p">);</span>
	<span class="n">dev_add_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppptalk_packet_type</span><span class="p">);</span>

	<span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddp_notifier</span><span class="p">);</span>
	<span class="n">aarp_proto_init</span><span class="p">();</span>
	<span class="n">atalk_proc_init</span><span class="p">();</span>
	<span class="n">atalk_register_sysctl</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">atalk_init</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * No explicit module reference count manipulation is needed in the</span>
<span class="cm"> * protocol. Socket layer sets module reference count for us</span>
<span class="cm"> * and interfaces reference counting is done</span>
<span class="cm"> * by the network device layer.</span>
<span class="cm"> *</span>
<span class="cm"> * Ergo, before the AppleTalk module can be removed, all AppleTalk</span>
<span class="cm"> * sockets be closed from user space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">atalk_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SYSCTL</span>
	<span class="n">atalk_unregister_sysctl</span><span class="p">();</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSCTL */</span><span class="cp"></span>
	<span class="n">atalk_proc_exit</span><span class="p">();</span>
	<span class="n">aarp_cleanup_module</span><span class="p">();</span>	<span class="cm">/* General aarp clean-up. */</span>
	<span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddp_notifier</span><span class="p">);</span>
	<span class="n">dev_remove_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ltalk_packet_type</span><span class="p">);</span>
	<span class="n">dev_remove_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ppptalk_packet_type</span><span class="p">);</span>
	<span class="n">unregister_snap_client</span><span class="p">(</span><span class="n">ddp_dl</span><span class="p">);</span>
	<span class="n">sock_unregister</span><span class="p">(</span><span class="n">PF_APPLETALK</span><span class="p">);</span>
	<span class="n">proto_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ddp_proto</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">atalk_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;AppleTalk 0.20</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_NETPROTO</span><span class="p">(</span><span class="n">PF_APPLETALK</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
