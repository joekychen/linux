<!DOCTYPE html>
<html><head><title>joekychen/linux » net › llc › llc_sap.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>llc_sap.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * llc_sap.c - driver routines for SAP component.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1997 by Procom Technology, Inc.</span>
<span class="cm"> * 		 2001-2003 by Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program can be redistributed or modified under the terms of the</span>
<span class="cm"> * GNU General Public License as published by the Free Software Foundation.</span>
<span class="cm"> * This program is distributed without any warranty or implied warranty</span>
<span class="cm"> * of merchantability or fitness for a particular purpose.</span>
<span class="cm"> *</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;net/llc.h&gt;</span>
<span class="cp">#include &lt;net/llc_if.h&gt;</span>
<span class="cp">#include &lt;net/llc_conn.h&gt;</span>
<span class="cp">#include &lt;net/llc_pdu.h&gt;</span>
<span class="cp">#include &lt;net/llc_sap.h&gt;</span>
<span class="cp">#include &lt;net/llc_s_ac.h&gt;</span>
<span class="cp">#include &lt;net/llc_s_ev.h&gt;</span>
<span class="cp">#include &lt;net/llc_s_st.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/tcp_states.h&gt;</span>
<span class="cp">#include &lt;linux/llc.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">llc_mac_header_len</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">devtype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">devtype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ARPHRD_ETHER</span>:
	<span class="k">case</span> <span class="n">ARPHRD_LOOPBACK</span>:
		<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_alloc_frame - allocates sk_buff for frame</span>
<span class="cm"> *	@dev: network device this skb will be sent over</span>
<span class="cm"> *	@type: pdu type to allocate</span>
<span class="cm"> *	@data_size: data size to allocate</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocates an sk_buff for frame and initializes sk_buff fields.</span>
<span class="cm"> *	Returns allocated skb or %NULL when out of memory.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">llc_alloc_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">u8</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">hlen</span> <span class="o">=</span> <span class="n">type</span> <span class="o">==</span> <span class="n">LLC_PDU_TYPE_U</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">hlen</span> <span class="o">+=</span> <span class="n">llc_mac_header_len</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">hlen</span> <span class="o">+</span> <span class="n">data_size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>
		<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_802_2</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span>      <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">skb_set_owner_w</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">llc_save_primitive</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="n">prim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_llc</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

       <span class="cm">/* save primitive for use by the user. */</span>
	<span class="n">addr</span>		  <span class="o">=</span> <span class="n">llc_ui_skb_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">sllc_family</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">sllc_arphrd</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">sllc_test</span>   <span class="o">=</span> <span class="n">prim</span> <span class="o">==</span> <span class="n">LLC_TEST_PRIM</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">sllc_xid</span>    <span class="o">=</span> <span class="n">prim</span> <span class="o">==</span> <span class="n">LLC_XID_PRIM</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">sllc_ua</span>     <span class="o">=</span> <span class="n">prim</span> <span class="o">==</span> <span class="n">LLC_DATAUNIT_PRIM</span><span class="p">;</span>
	<span class="n">llc_pdu_decode_sa</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sllc_mac</span><span class="p">);</span>
	<span class="n">llc_pdu_decode_ssap</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sllc_sap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_sap_rtn_pdu - Informs upper layer on rx of an UI, XID or TEST pdu.</span>
<span class="cm"> *	@sap: pointer to SAP</span>
<span class="cm"> *	@skb: received pdu</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">llc_sap_rtn_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sap_state_ev</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">llc_sap_ev</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">llc_pdu_un</span> <span class="o">*</span><span class="n">pdu</span> <span class="o">=</span> <span class="n">llc_pdu_un_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">LLC_U_PDU_RSP</span><span class="p">(</span><span class="n">pdu</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LLC_1_PDU_CMD_TEST</span>:
		<span class="n">ev</span><span class="o">-&gt;</span><span class="n">prim</span> <span class="o">=</span> <span class="n">LLC_TEST_PRIM</span><span class="p">;</span>	<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LLC_1_PDU_CMD_XID</span>:
		<span class="n">ev</span><span class="o">-&gt;</span><span class="n">prim</span> <span class="o">=</span> <span class="n">LLC_XID_PRIM</span><span class="p">;</span>	<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LLC_1_PDU_CMD_UI</span>:
		<span class="n">ev</span><span class="o">-&gt;</span><span class="n">prim</span> <span class="o">=</span> <span class="n">LLC_DATAUNIT_PRIM</span><span class="p">;</span>	<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">ind_cfm_flag</span> <span class="o">=</span> <span class="n">LLC_IND</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_find_sap_trans - finds transition for event</span>
<span class="cm"> *	@sap: pointer to SAP</span>
<span class="cm"> *	@skb: happened event</span>
<span class="cm"> *</span>
<span class="cm"> *	This function finds transition that matches with happened event.</span>
<span class="cm"> *	Returns the pointer to found transition on success or %NULL for</span>
<span class="cm"> *	failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">llc_sap_state_trans</span> <span class="o">*</span><span class="nf">llc_find_sap_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_sap_state_trans</span> <span class="o">*</span><span class="n">rc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_sap_state_trans</span> <span class="o">**</span><span class="n">next_trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_sap_state</span> <span class="o">*</span><span class="n">curr_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">llc_sap_state_table</span><span class="p">[</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * Search thru events for this state until list exhausted or until</span>
<span class="cm">	 * its obvious the event is not valid for the current state</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">next_trans</span> <span class="o">=</span> <span class="n">curr_state</span><span class="o">-&gt;</span><span class="n">transitions</span><span class="p">;</span> <span class="n">next_trans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next_trans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">next_trans</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="cm">/* got event match; return it */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_exec_sap_trans_actions - execute actions related to event</span>
<span class="cm"> *	@sap: pointer to SAP</span>
<span class="cm"> *	@trans: pointer to transition that it&#39;s actions must be performed</span>
<span class="cm"> *	@skb: happened event.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function executes actions that is related to happened event.</span>
<span class="cm"> *	Returns 0 for success and 1 for failure of at least one action.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">llc_exec_sap_trans_actions</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">llc_sap_state_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc_sap_action_t</span> <span class="o">*</span><span class="n">next_action</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">ev_actions</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">next_action</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">next_action</span><span class="p">;</span> <span class="n">next_action</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">next_action</span><span class="p">)(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_sap_next_state - finds transition, execs actions &amp; change SAP state</span>
<span class="cm"> *	@sap: pointer to SAP</span>
<span class="cm"> *	@skb: happened event</span>
<span class="cm"> *</span>
<span class="cm"> *	This function finds transition that matches with happened event, then</span>
<span class="cm"> *	executes related actions and finally changes state of SAP. It returns</span>
<span class="cm"> *	0 on success and 1 for failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">llc_sap_next_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_sap_state_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;</span> <span class="n">LLC_NR_SAP_STATES</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">llc_find_sap_trans</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Got the state to which we next transition; perform the actions</span>
<span class="cm">	 * associated with this transition before actually transitioning to the</span>
<span class="cm">	 * next state</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">llc_exec_sap_trans_actions</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Transition SAP to next state if all actions execute successfully</span>
<span class="cm">	 */</span>
	<span class="n">sap</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">next_state</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_sap_state_process - sends event to SAP state machine</span>
<span class="cm"> *	@sap: sap to use</span>
<span class="cm"> *	@skb: pointer to occurred event</span>
<span class="cm"> *</span>
<span class="cm"> *	After executing actions of the event, upper layer will be indicated</span>
<span class="cm"> *	if needed(on receiving an UI frame). sk can be null for the</span>
<span class="cm"> *	datalink_proto case.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">llc_sap_state_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sap_state_ev</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">llc_sap_ev</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to hold the skb, because llc_sap_next_state</span>
<span class="cm">	 * will kfree it in the sending path and we need to</span>
<span class="cm">	 * look at the skb-&gt;cb, where we encode llc_sap_state_ev.</span>
<span class="cm">	 */</span>
	<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">ind_cfm_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc_sap_next_state</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">ind_cfm_flag</span> <span class="o">==</span> <span class="n">LLC_IND</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">llc_save_primitive</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">prim</span><span class="p">);</span>

			<span class="cm">/* queue skb to the user. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sock_queue_rcv_skb</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_build_and_send_test_pkt - TEST interface for upper layers.</span>
<span class="cm"> *	@sap: sap to use</span>
<span class="cm"> *	@skb: packet to send</span>
<span class="cm"> *	@dmac: destination mac address</span>
<span class="cm"> *	@dsap: destination sap</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called when upper layer wants to send a TEST pdu.</span>
<span class="cm"> *	Returns 0 for success, 1 otherwise.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">llc_build_and_send_test_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">dmac</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dsap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sap_state_ev</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">llc_sap_ev</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">.</span><span class="n">lsap</span> <span class="o">=</span> <span class="n">sap</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">.</span><span class="n">lsap</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">lsap</span> <span class="o">=</span> <span class="n">dsap</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">.</span><span class="n">mac</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">IFHWADDRLEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">mac</span><span class="p">,</span> <span class="n">dmac</span><span class="p">,</span> <span class="n">IFHWADDRLEN</span><span class="p">);</span>

	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">type</span>      <span class="o">=</span> <span class="n">LLC_SAP_EV_TYPE_PRIM</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">prim</span>      <span class="o">=</span> <span class="n">LLC_TEST_PRIM</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">prim_type</span> <span class="o">=</span> <span class="n">LLC_PRIM_TYPE_REQ</span><span class="p">;</span>
	<span class="n">llc_sap_state_process</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_build_and_send_xid_pkt - XID interface for upper layers</span>
<span class="cm"> *	@sap: sap to use</span>
<span class="cm"> *	@skb: packet to send</span>
<span class="cm"> *	@dmac: destination mac address</span>
<span class="cm"> *	@dsap: destination sap</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called when upper layer wants to send a XID pdu.</span>
<span class="cm"> *	Returns 0 for success, 1 otherwise.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">llc_build_and_send_xid_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="n">u8</span> <span class="o">*</span><span class="n">dmac</span><span class="p">,</span> <span class="n">u8</span> <span class="n">dsap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sap_state_ev</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">llc_sap_ev</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">.</span><span class="n">lsap</span> <span class="o">=</span> <span class="n">sap</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">.</span><span class="n">lsap</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">lsap</span> <span class="o">=</span> <span class="n">dsap</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">.</span><span class="n">mac</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">IFHWADDRLEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">mac</span><span class="p">,</span> <span class="n">dmac</span><span class="p">,</span> <span class="n">IFHWADDRLEN</span><span class="p">);</span>

	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">type</span>      <span class="o">=</span> <span class="n">LLC_SAP_EV_TYPE_PRIM</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">prim</span>      <span class="o">=</span> <span class="n">LLC_XID_PRIM</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">prim_type</span> <span class="o">=</span> <span class="n">LLC_PRIM_TYPE_REQ</span><span class="p">;</span>
	<span class="n">llc_sap_state_process</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_sap_rcv - sends received pdus to the sap state machine</span>
<span class="cm"> *	@sap: current sap component structure.</span>
<span class="cm"> *	@skb: received frame.</span>
<span class="cm"> *</span>
<span class="cm"> *	Sends received pdus to the sap state machine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">llc_sap_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sap_state_ev</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">llc_sap_ev</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">type</span>   <span class="o">=</span> <span class="n">LLC_SAP_EV_TYPE_PDU</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">reason</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
	<span class="n">llc_sap_state_process</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">llc_dgram_match</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
     <span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

     <span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_DGRAM</span> <span class="o">&amp;&amp;</span>
	  <span class="n">llc</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">.</span><span class="n">lsap</span> <span class="o">==</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">&amp;&amp;</span>
	  <span class="n">llc_mac_match</span><span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">.</span><span class="n">mac</span><span class="p">,</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_lookup_dgram - Finds dgram socket for the local sap/mac</span>
<span class="cm"> *	@sap: SAP</span>
<span class="cm"> *	@laddr: address of local LLC (MAC + SAP)</span>
<span class="cm"> *</span>
<span class="cm"> *	Search socket list of the SAP and finds connection using the local</span>
<span class="cm"> *	mac, and local sap. Returns pointer for socket found, %NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">llc_lookup_dgram</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">llc_sk_laddr_hashfn</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">laddr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="o">*</span><span class="n">laddr_hb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sk_laddr_hash</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>

	<span class="n">rcu_read_lock_bh</span><span class="p">();</span>
<span class="nl">again:</span>
	<span class="n">sk_nulls_for_each_rcu</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">laddr_hb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">llc_dgram_match</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Extra checks required by SLAB_DESTROY_BY_RCU */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">llc_sk</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sap</span> <span class="o">!=</span> <span class="n">sap</span> <span class="o">||</span>
				     <span class="o">!</span><span class="n">llc_dgram_match</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">rc</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">sock_put</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the nulls value we got at the end of this lookup is</span>
<span class="cm">	 * not the expected one, we must restart lookup.</span>
<span class="cm">	 * We probably met an item that was moved to another chain.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">get_nulls_value</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="n">slot</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">llc_mcast_match</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
     <span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

     <span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_DGRAM</span> <span class="o">&amp;&amp;</span>
	  <span class="n">llc</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">.</span><span class="n">lsap</span> <span class="o">==</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">&amp;&amp;</span>
	  <span class="n">llc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">llc_do_mcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">sock</span> <span class="o">**</span><span class="n">stack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb1</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sock_put</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">llc_sap_rcv</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb1</span><span class="p">,</span> <span class="n">stack</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 	llc_sap_mcast - Deliver multicast PDU&#39;s to all matching datagram sockets.</span>
<span class="cm"> *	@sap: SAP</span>
<span class="cm"> *	@laddr: address of local LLC (MAC + SAP)</span>
<span class="cm"> *</span>
<span class="cm"> *	Search socket list of the SAP and finds connections with same sap.</span>
<span class="cm"> *	Deliver clone to each.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">llc_sap_mcast</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="o">*</span><span class="n">stack</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">dev_hb</span> <span class="o">=</span> <span class="n">llc_sk_dev_hash</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">);</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">llc</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">dev_hb</span><span class="p">,</span> <span class="n">dev_hash_node</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">sk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">llc_mcast_match</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span>
			<span class="n">stack</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">llc_do_mcast</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">);</span>

	<span class="n">llc_do_mcast</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">llc_sap_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_addr</span> <span class="n">laddr</span><span class="p">;</span>

	<span class="n">llc_pdu_decode_da</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">laddr</span><span class="p">.</span><span class="n">mac</span><span class="p">);</span>
	<span class="n">llc_pdu_decode_dsap</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">laddr</span><span class="p">.</span><span class="n">lsap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">llc_mac_multicast</span><span class="p">(</span><span class="n">laddr</span><span class="p">.</span><span class="n">mac</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">llc_sap_mcast</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">laddr</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">llc_lookup_dgram</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">laddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">llc_sap_rcv</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
			<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
