<!DOCTYPE html>
<html><head><title>joekychen/linux » net › llc › llc_conn.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>llc_conn.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * llc_conn.c - Driver routines for connection component.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 1997 by Procom Technology, Inc.</span>
<span class="cm"> *		 2001-2003 by Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program can be redistributed or modified under the terms of the</span>
<span class="cm"> * GNU General Public License as published by the Free Software Foundation.</span>
<span class="cm"> * This program is distributed without any warranty or implied warranty</span>
<span class="cm"> * of merchantability or fitness for a particular purpose.</span>
<span class="cm"> *</span>
<span class="cm"> * See the GNU General Public License for more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/llc_sap.h&gt;</span>
<span class="cp">#include &lt;net/llc_conn.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/tcp_states.h&gt;</span>
<span class="cp">#include &lt;net/llc_c_ev.h&gt;</span>
<span class="cp">#include &lt;net/llc_c_ac.h&gt;</span>
<span class="cp">#include &lt;net/llc_c_st.h&gt;</span>
<span class="cp">#include &lt;net/llc_pdu.h&gt;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define dprintk(args...) printk(KERN_DEBUG args)</span>
<span class="cp">#else</span>
<span class="cp">#define dprintk(args...)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">llc_find_offset</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ev_type</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">llc_conn_send_pdus</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">llc_conn_service</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">llc_exec_conn_trans_actions</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">llc_conn_state_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">ev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">llc_conn_state_trans</span> <span class="o">*</span><span class="n">llc_qualify_conn_ev</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>

<span class="cm">/* Offset table on connection states transition diagram */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">llc_offset_table</span><span class="p">[</span><span class="n">NBR_CONN_STATES</span><span class="p">][</span><span class="n">NBR_CONN_EV</span><span class="p">];</span>

<span class="kt">int</span> <span class="n">sysctl_llc2_ack_timeout</span> <span class="o">=</span> <span class="n">LLC2_ACK_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_llc2_p_timeout</span> <span class="o">=</span> <span class="n">LLC2_P_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_llc2_rej_timeout</span> <span class="o">=</span> <span class="n">LLC2_REJ_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_llc2_busy_timeout</span> <span class="o">=</span> <span class="n">LLC2_BUSY_TIME</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_conn_state_process - sends event to connection state machine</span>
<span class="cm"> *	@sk: connection</span>
<span class="cm"> *	@skb: occurred event</span>
<span class="cm"> *</span>
<span class="cm"> *	Sends an event to connection state machine. After processing event</span>
<span class="cm"> *	(executing it&#39;s actions and changing state), upper layer will be</span>
<span class="cm"> *	indicated or confirmed, if needed. Returns 0 for success, 1 for</span>
<span class="cm"> *	failure. The socket lock has to be held before calling this function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">llc_conn_state_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">llc_conn_state_ev</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">llc_conn_ev</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to hold the skb, because llc_conn_service will kfree it in</span>
<span class="cm">	 * the sending path and we need to look at the skb-&gt;cb, where we encode</span>
<span class="cm">	 * llc_conn_state_ev.</span>
<span class="cm">	 */</span>
	<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">ind_prim</span> <span class="o">=</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">cfm_prim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Send event to state machine</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">llc_conn_service</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: llc_conn_service failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">ind_prim</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">cfm_prim</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* indicate or confirm not required */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_skb_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">ind_prim</span> <span class="o">&amp;&amp;</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">cfm_prim</span><span class="p">))</span> <span class="cm">/* Paranoia */</span>
		<span class="n">skb_get</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">ind_prim</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LLC_DATA_PRIM</span>:
		<span class="n">llc_save_primitive</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">LLC_DATA_PRIM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sock_queue_rcv_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * shouldn&#39;t happen</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: sock_queue_rcv_skb failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LLC_CONN_PRIM</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Can&#39;t be sock_queue_rcv_skb, because we have to leave the</span>
<span class="cm">		 * skb-&gt;sk pointing to the newly created struct sock in</span>
<span class="cm">		 * llc_conn_handler. -acme</span>
<span class="cm">		 */</span>
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LLC_DISC_PRIM</span>:
		<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span>       <span class="o">=</span> <span class="n">SHUTDOWN_MASK</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">state</span>  <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>          <span class="o">=</span> <span class="n">TCP_CLOSE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">);</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LLC_RESET_PRIM</span>:
		<span class="cm">/*</span>
<span class="cm">		 * FIXME:</span>
<span class="cm">		 * RESET is not being notified to upper layers for now</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: received a reset ind!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">ind_prim</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: received unknown %d prim!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">ind_prim</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* No indication */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">cfm_prim</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LLC_DATA_PRIM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">llc_data_accept_state</span><span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">llc</span><span class="o">-&gt;</span><span class="n">failed_data_req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LLC_CONN_PRIM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_SYN_SENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>         <span class="o">=</span> <span class="n">TCP_CLOSE</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>         <span class="o">=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LLC_DISC_PRIM</span>:
		<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>         <span class="o">=</span> <span class="n">TCP_CLOSE</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LLC_RESET_PRIM</span>:
		<span class="cm">/*</span>
<span class="cm">		 * FIXME:</span>
<span class="cm">		 * RESET is not being notified to upper layers for now</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: received a reset conf!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">cfm_prim</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: received unknown %d prim!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">cfm_prim</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out_skb_put</span><span class="p">;</span> <span class="cm">/* No confirmation */</span>
	<span class="p">}</span>
<span class="nl">out_kfree_skb:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">out_skb_put:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">llc_conn_send_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* queue PDU to send to MAC layer */</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">llc_conn_send_pdus</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_conn_rtn_pdu - sends received data pdu to upper layer</span>
<span class="cm"> *	@sk: Active connection</span>
<span class="cm"> *	@skb: Received data frame</span>
<span class="cm"> *</span>
<span class="cm"> *	Sends received data pdu to upper layer (by using indicate function).</span>
<span class="cm"> *	Prepares service parameters (prim and prim_data). calling indication</span>
<span class="cm"> *	function will be done in llc_conn_state_process.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">llc_conn_rtn_pdu</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_conn_state_ev</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">llc_conn_ev</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">ind_prim</span> <span class="o">=</span> <span class="n">LLC_DATA_PRIM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_conn_resend_i_pdu_as_cmd - resend all all unacknowledged I PDUs</span>
<span class="cm"> *	@sk: active connection</span>
<span class="cm"> *	@nr: NR</span>
<span class="cm"> *	@first_p_bit: p_bit value of first pdu</span>
<span class="cm"> *</span>
<span class="cm"> *	Resend all unacknowledged I PDUs, starting with the NR; send first as</span>
<span class="cm"> *	command PDU with P bit equal first_p_bit; if more than one send</span>
<span class="cm"> *	subsequent as command PDUs with P bit equal zero (0).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">llc_conn_resend_i_pdu_as_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">nr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">first_p_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_pdu_sn</span> <span class="o">*</span><span class="n">pdu</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">nbr_unack_pdus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">howmany_resend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">llc_conn_remove_acked_pdus</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nbr_unack_pdus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nbr_unack_pdus</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Process unack PDUs only if unack queue is not empty; remove</span>
<span class="cm">	 * appropriate PDUs, fix them up, and put them on mac_pdu_q.</span>
<span class="cm">	 */</span>
	<span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">pdu_unack_q</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pdu</span> <span class="o">=</span> <span class="n">llc_pdu_sn_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">llc_pdu_set_cmd_rsp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LLC_PDU_CMD</span><span class="p">);</span>
		<span class="n">llc_pdu_set_pf_bit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">first_p_bit</span><span class="p">);</span>
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">first_p_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">llc</span><span class="o">-&gt;</span><span class="n">vS</span> <span class="o">=</span> <span class="n">LLC_I_GET_NS</span><span class="p">(</span><span class="n">pdu</span><span class="p">);</span>
		<span class="n">howmany_resend</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">howmany_resend</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">llc</span><span class="o">-&gt;</span><span class="n">vS</span> <span class="o">=</span> <span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">vS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">LLC_2_SEQ_NBR_MODULO</span><span class="p">;</span>
	<span class="cm">/* any PDUs to re-send are queued up; start sending to MAC */</span>
	<span class="n">llc_conn_send_pdus</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="nl">out:</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_conn_resend_i_pdu_as_rsp - Resend all unacknowledged I PDUs</span>
<span class="cm"> *	@sk: active connection.</span>
<span class="cm"> *	@nr: NR</span>
<span class="cm"> *	@first_f_bit: f_bit value of first pdu.</span>
<span class="cm"> *</span>
<span class="cm"> *	Resend all unacknowledged I PDUs, starting with the NR; send first as</span>
<span class="cm"> *	response PDU with F bit equal first_f_bit; if more than one send</span>
<span class="cm"> *	subsequent as response PDUs with F bit equal zero (0).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">llc_conn_resend_i_pdu_as_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">nr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">first_f_bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">nbr_unack_pdus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">howmany_resend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">llc_conn_remove_acked_pdus</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nbr_unack_pdus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nbr_unack_pdus</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Process unack PDUs only if unack queue is not empty; remove</span>
<span class="cm">	 * appropriate PDUs, fix them up, and put them on mac_pdu_q</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">pdu_unack_q</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">llc_pdu_sn</span> <span class="o">*</span><span class="n">pdu</span> <span class="o">=</span> <span class="n">llc_pdu_sn_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">llc_pdu_set_cmd_rsp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LLC_PDU_RSP</span><span class="p">);</span>
		<span class="n">llc_pdu_set_pf_bit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">first_f_bit</span><span class="p">);</span>
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">first_f_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">llc</span><span class="o">-&gt;</span><span class="n">vS</span> <span class="o">=</span> <span class="n">LLC_I_GET_NS</span><span class="p">(</span><span class="n">pdu</span><span class="p">);</span>
		<span class="n">howmany_resend</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">howmany_resend</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">llc</span><span class="o">-&gt;</span><span class="n">vS</span> <span class="o">=</span> <span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">vS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">LLC_2_SEQ_NBR_MODULO</span><span class="p">;</span>
	<span class="cm">/* any PDUs to re-send are queued up; start sending to MAC */</span>
	<span class="n">llc_conn_send_pdus</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="nl">out:</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_conn_remove_acked_pdus - Removes acknowledged pdus from tx queue</span>
<span class="cm"> *	@sk: active connection</span>
<span class="cm"> *	nr: NR</span>
<span class="cm"> *	how_many_unacked: size of pdu_unack_q after removing acked pdus</span>
<span class="cm"> *</span>
<span class="cm"> *	Removes acknowledged pdus from transmit queue (pdu_unack_q). Returns</span>
<span class="cm"> *	the number of pdus that removed from queue.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">llc_conn_remove_acked_pdus</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">nr</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">how_many_unacked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pdu_pos</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_pdu_sn</span> <span class="o">*</span><span class="n">pdu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nbr_acked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">q_len</span> <span class="o">=</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">pdu_unack_q</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q_len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">pdu_unack_q</span><span class="p">);</span>
	<span class="n">pdu</span> <span class="o">=</span> <span class="n">llc_pdu_sn_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* finding position of last acked pdu in queue */</span>
	<span class="n">pdu_pos</span> <span class="o">=</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">LLC_2_SEQ_NBR_MODULO</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">nr</span> <span class="o">-</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">LLC_I_GET_NS</span><span class="p">(</span><span class="n">pdu</span><span class="p">))</span> <span class="o">%</span> <span class="n">LLC_2_SEQ_NBR_MODULO</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pdu_pos</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">pdu_unack_q</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">nbr_acked</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="o">*</span><span class="n">how_many_unacked</span> <span class="o">=</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">pdu_unack_q</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nbr_acked</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_conn_send_pdus - Sends queued PDUs</span>
<span class="cm"> *	@sk: active connection</span>
<span class="cm"> *</span>
<span class="cm"> *	Sends queued pdus to MAC layer for transmission.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">llc_conn_send_pdus</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">llc_pdu_sn</span> <span class="o">*</span><span class="n">pdu</span> <span class="o">=</span> <span class="n">llc_pdu_sn_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">LLC_PDU_TYPE_IS_I</span><span class="p">(</span><span class="n">pdu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_LOOPBACK</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb2</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

			<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pdu_unack_q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb2</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_conn_service - finds transition and changes state of connection</span>
<span class="cm"> *	@sk: connection</span>
<span class="cm"> *	@skb: happened event</span>
<span class="cm"> *</span>
<span class="cm"> *	This function finds transition that matches with happened event, then</span>
<span class="cm"> *	executes related actions and finally changes state of connection.</span>
<span class="cm"> *	Returns 0 for success, 1 for failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">llc_conn_service</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">llc_conn_state_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;</span> <span class="n">NBR_CONN_STATES</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">llc_qualify_conn_ev</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">llc_exec_conn_trans_actions</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">next_state</span> <span class="o">!=</span> <span class="n">NO_STATE_CHANGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">llc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">next_state</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">llc_data_accept_state</span><span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_qualify_conn_ev - finds transition for event</span>
<span class="cm"> *	@sk: connection</span>
<span class="cm"> *	@skb: happened event</span>
<span class="cm"> *</span>
<span class="cm"> *	This function finds transition that matches with happened event.</span>
<span class="cm"> *	Returns pointer to found transition on success, %NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">llc_conn_state_trans</span> <span class="o">*</span><span class="nf">llc_qualify_conn_ev</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
							<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_conn_state_trans</span> <span class="o">**</span><span class="n">next_trans</span><span class="p">;</span>
	<span class="n">llc_conn_ev_qfyr_t</span> <span class="o">*</span><span class="n">next_qualifier</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_conn_state_ev</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">llc_conn_ev</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">llc_conn_state</span> <span class="o">*</span><span class="n">curr_state</span> <span class="o">=</span>
					<span class="o">&amp;</span><span class="n">llc_conn_state_table</span><span class="p">[</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* search thru events for this state until</span>
<span class="cm">	 * list exhausted or until no more</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">next_trans</span> <span class="o">=</span> <span class="n">curr_state</span><span class="o">-&gt;</span><span class="n">transitions</span> <span class="o">+</span>
		<span class="n">llc_find_offset</span><span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	     <span class="p">(</span><span class="o">*</span><span class="n">next_trans</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">;</span> <span class="n">next_trans</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="o">*</span><span class="n">next_trans</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">)(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* got POSSIBLE event match; the event may require</span>
<span class="cm">			 * qualification based on the values of a number of</span>
<span class="cm">			 * state flags; if all qualifications are met (i.e.,</span>
<span class="cm">			 * if all qualifying functions return success, or 0,</span>
<span class="cm">			 * then this is THE event we&#39;re looking for</span>
<span class="cm">			 */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">next_qualifier</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">next_trans</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ev_qualifiers</span><span class="p">;</span>
			     <span class="n">next_qualifier</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">next_qualifier</span> <span class="o">&amp;&amp;</span>
			     <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">next_qualifier</span><span class="p">)(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span> <span class="n">next_qualifier</span><span class="o">++</span><span class="p">)</span>
				<span class="cm">/* nothing */</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next_qualifier</span> <span class="o">||</span> <span class="o">!*</span><span class="n">next_qualifier</span><span class="p">)</span>
				<span class="cm">/* all qualifiers executed successfully; this is</span>
<span class="cm">				 * our transition; return it so we can perform</span>
<span class="cm">				 * the associated actions &amp; change the state</span>
<span class="cm">				 */</span>
				<span class="k">return</span> <span class="o">*</span><span class="n">next_trans</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_exec_conn_trans_actions - executes related actions</span>
<span class="cm"> *	@sk: connection</span>
<span class="cm"> *	@trans: transition that it&#39;s actions must be performed</span>
<span class="cm"> *	@skb: event</span>
<span class="cm"> *</span>
<span class="cm"> *	Executes actions that is related to happened event. Returns 0 for</span>
<span class="cm"> *	success, 1 to indicate failure of at least one action.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">llc_exec_conn_trans_actions</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">llc_conn_state_trans</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc_conn_action_t</span> <span class="o">*</span><span class="n">next_action</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">next_action</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">ev_actions</span><span class="p">;</span>
	     <span class="n">next_action</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">next_action</span><span class="p">;</span> <span class="n">next_action</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc2</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">next_action</span><span class="p">)(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc2</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">rc2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc2</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">llc_estab_match</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">llc</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">.</span><span class="n">lsap</span> <span class="o">==</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">&amp;&amp;</span>
		<span class="n">llc</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">lsap</span> <span class="o">==</span> <span class="n">daddr</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">&amp;&amp;</span>
		<span class="n">llc_mac_match</span><span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">.</span><span class="n">mac</span><span class="p">,</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">llc_mac_match</span><span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">mac</span><span class="p">,</span> <span class="n">daddr</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__llc_lookup_established - Finds connection for the remote/local sap/mac</span>
<span class="cm"> *	@sap: SAP</span>
<span class="cm"> *	@daddr: address of remote LLC (MAC + SAP)</span>
<span class="cm"> *	@laddr: address of local LLC (MAC + SAP)</span>
<span class="cm"> *</span>
<span class="cm"> *	Search connection list of the SAP and finds connection using the remote</span>
<span class="cm"> *	mac, remote sap, local mac, and local sap. Returns pointer for</span>
<span class="cm"> *	connection found, %NULL otherwise.</span>
<span class="cm"> *	Caller has to make sure local_bh is disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">__llc_lookup_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">llc_sk_laddr_hashfn</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">laddr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="o">*</span><span class="n">laddr_hb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sk_laddr_hash</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">again:</span>
	<span class="n">sk_nulls_for_each_rcu</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">laddr_hb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">llc_estab_match</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Extra checks required by SLAB_DESTROY_BY_RCU */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">llc_sk</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sap</span> <span class="o">!=</span> <span class="n">sap</span> <span class="o">||</span>
				     <span class="o">!</span><span class="n">llc_estab_match</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">rc</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">sock_put</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the nulls value we got at the end of this lookup is</span>
<span class="cm">	 * not the expected one, we must restart lookup.</span>
<span class="cm">	 * We probably met an item that was moved to another chain.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">get_nulls_value</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="n">slot</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">llc_lookup_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">__llc_lookup_established</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">laddr</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">llc_listener_match</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span> <span class="o">&amp;&amp;</span>
		<span class="n">llc</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">.</span><span class="n">lsap</span> <span class="o">==</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">lsap</span> <span class="o">&amp;&amp;</span>
		<span class="n">llc_mac_match</span><span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">.</span><span class="n">mac</span><span class="p">,</span> <span class="n">laddr</span><span class="o">-&gt;</span><span class="n">mac</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">__llc_lookup_listener</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span> <span class="o">=</span> <span class="n">llc_sk_laddr_hashfn</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">laddr</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="o">*</span><span class="n">laddr_hb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sk_laddr_hash</span><span class="p">[</span><span class="n">slot</span><span class="p">];</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
<span class="nl">again:</span>
	<span class="n">sk_nulls_for_each_rcu</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">laddr_hb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">llc_listener_match</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Extra checks required by SLAB_DESTROY_BY_RCU */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">llc_sk</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sap</span> <span class="o">!=</span> <span class="n">sap</span> <span class="o">||</span>
				     <span class="o">!</span><span class="n">llc_listener_match</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">laddr</span><span class="p">,</span> <span class="n">rc</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">sock_put</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the nulls value we got at the end of this lookup is</span>
<span class="cm">	 * not the expected one, we must restart lookup.</span>
<span class="cm">	 * We probably met an item that was moved to another chain.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">get_nulls_value</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="n">slot</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_lookup_listener - Finds listener for local MAC + SAP</span>
<span class="cm"> *	@sap: SAP</span>
<span class="cm"> *	@laddr: address of local LLC (MAC + SAP)</span>
<span class="cm"> *</span>
<span class="cm"> *	Search connection list of the SAP and finds connection listening on</span>
<span class="cm"> *	local mac, and local sap. Returns pointer for parent socket found,</span>
<span class="cm"> *	%NULL otherwise.</span>
<span class="cm"> *	Caller has to make sure local_bh is disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">llc_lookup_listener</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">llc_addr</span> <span class="n">null_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">rc</span> <span class="o">=</span> <span class="n">__llc_lookup_listener</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">laddr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">__llc_lookup_listener</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">null_addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">__llc_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">daddr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">laddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">__llc_lookup_established</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="n">laddr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sk</span> <span class="o">?</span> <span class="o">:</span> <span class="n">llc_lookup_listener</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">laddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_data_accept_state - designates if in this state data can be sent.</span>
<span class="cm"> *	@state: state of connection.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 if data can be sent, 1 otherwise.</span>
<span class="cm"> */</span>
<span class="n">u8</span> <span class="nf">llc_data_accept_state</span><span class="p">(</span><span class="n">u8</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">state</span> <span class="o">!=</span> <span class="n">LLC_CONN_STATE_NORMAL</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">!=</span> <span class="n">LLC_CONN_STATE_BUSY</span> <span class="o">&amp;&amp;</span>
	       <span class="n">state</span> <span class="o">!=</span> <span class="n">LLC_CONN_STATE_REJ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_find_next_offset - finds offset for next category of transitions</span>
<span class="cm"> *	@state: state table.</span>
<span class="cm"> *	@offset: start offset.</span>
<span class="cm"> *</span>
<span class="cm"> *	Finds offset of next category of transitions in transition table.</span>
<span class="cm"> *	Returns the start index of next category.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u16</span> <span class="n">__init</span> <span class="nf">llc_find_next_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_conn_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">u16</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_conn_state_trans</span> <span class="o">**</span><span class="n">next_trans</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">next_trans</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">transitions</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	     <span class="p">(</span><span class="o">*</span><span class="n">next_trans</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">;</span> <span class="n">next_trans</span><span class="o">++</span><span class="p">)</span>
		<span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_build_offset_table - builds offset table of connection</span>
<span class="cm"> *</span>
<span class="cm"> *	Fills offset table of connection state transition table</span>
<span class="cm"> *	(llc_offset_table).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">llc_build_offset_table</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_conn_state</span> <span class="o">*</span><span class="n">curr_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="n">ev_type</span><span class="p">,</span> <span class="n">next_offset</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">state</span> <span class="o">&lt;</span> <span class="n">NBR_CONN_STATES</span><span class="p">;</span> <span class="n">state</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">llc_conn_state_table</span><span class="p">[</span><span class="n">state</span><span class="p">];</span>
		<span class="n">next_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">ev_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ev_type</span> <span class="o">&lt;</span> <span class="n">NBR_CONN_EV</span><span class="p">;</span> <span class="n">ev_type</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">llc_offset_table</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">ev_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_offset</span><span class="p">;</span>
			<span class="n">next_offset</span> <span class="o">+=</span> <span class="n">llc_find_next_offset</span><span class="p">(</span><span class="n">curr_state</span><span class="p">,</span>
							    <span class="n">next_offset</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_find_offset - finds start offset of category of transitions</span>
<span class="cm"> *	@state: state of connection</span>
<span class="cm"> *	@ev_type: type of happened event</span>
<span class="cm"> *</span>
<span class="cm"> *	Finds start offset of desired category of transitions. Returns the</span>
<span class="cm"> *	desired start offset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">llc_find_offset</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ev_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* at this stage, llc_offset_table[..][2] is not important. it is for</span>
<span class="cm">	 * init_pf_cycle and I don&#39;t know what is it.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ev_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LLC_CONN_EV_TYPE_PRIM</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">llc_offset_table</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LLC_CONN_EV_TYPE_PDU</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">llc_offset_table</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LLC_CONN_EV_TYPE_SIMPLE</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">llc_offset_table</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span> <span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LLC_CONN_EV_TYPE_P_TMR</span>:
	<span class="k">case</span> <span class="n">LLC_CONN_EV_TYPE_ACK_TMR</span>:
	<span class="k">case</span> <span class="n">LLC_CONN_EV_TYPE_REJ_TMR</span>:
	<span class="k">case</span> <span class="n">LLC_CONN_EV_TYPE_BUSY_TMR</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="n">llc_offset_table</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_sap_add_socket - adds a socket to a SAP</span>
<span class="cm"> *	@sap: SAP</span>
<span class="cm"> *	@sk: socket</span>
<span class="cm"> *</span>
<span class="cm"> *	This function adds a socket to the hash tables of a SAP.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">llc_sap_add_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">dev_hb</span> <span class="o">=</span> <span class="n">llc_sk_dev_hash</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="n">llc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hlist_nulls_head</span> <span class="o">*</span><span class="n">laddr_hb</span> <span class="o">=</span> <span class="n">llc_sk_laddr_hash</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">);</span>

	<span class="n">llc_sap_hold</span><span class="p">(</span><span class="n">sap</span><span class="p">);</span>
	<span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sap</span> <span class="o">=</span> <span class="n">sap</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">);</span>
	<span class="n">sap</span><span class="o">-&gt;</span><span class="n">sk_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sk_nulls_add_node_rcu</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">laddr_hb</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">dev_hash_node</span><span class="p">,</span> <span class="n">dev_hb</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_sap_remove_socket - removes a socket from SAP</span>
<span class="cm"> *	@sap: SAP</span>
<span class="cm"> *	@sk: socket</span>
<span class="cm"> *</span>
<span class="cm"> *	This function removes a connection from the hash tables of a SAP if</span>
<span class="cm"> *	the connection was in this list.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">llc_sap_remove_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">);</span>
	<span class="n">sk_nulls_del_node_init_rcu</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">dev_hash_node</span><span class="p">);</span>
	<span class="n">sap</span><span class="o">-&gt;</span><span class="n">sk_count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sap</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">);</span>
	<span class="n">llc_sap_put</span><span class="p">(</span><span class="n">sap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_conn_rcv - sends received pdus to the connection state machine</span>
<span class="cm"> *	@sk: current connection structure.</span>
<span class="cm"> *	@skb: received frame.</span>
<span class="cm"> *</span>
<span class="cm"> *	Sends received pdus to the connection state machine.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">llc_conn_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="o">*</span> <span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_conn_state_ev</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="n">llc_conn_ev</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">type</span>   <span class="o">=</span> <span class="n">LLC_CONN_EV_TYPE_PDU</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">reason</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">llc_conn_state_process</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">llc_create_incoming_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">llc_addr</span> <span class="o">*</span><span class="n">daddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span> <span class="o">=</span> <span class="n">llc_sk_alloc</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span>
					  <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">newllc</span><span class="p">,</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newsk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">newllc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newllc</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">,</span> <span class="n">daddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">newllc</span><span class="o">-&gt;</span><span class="n">laddr</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newllc</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">saddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">newllc</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">));</span>
	<span class="n">newllc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">dev_hold</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">llc_sap_add_socket</span><span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">sap</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>
	<span class="n">llc_sap_hold</span><span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">sap</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">newsk</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">llc_conn_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">llc_sap</span> <span class="o">*</span><span class="n">sap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_addr</span> <span class="n">saddr</span><span class="p">,</span> <span class="n">daddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">llc_pdu_decode_sa</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">saddr</span><span class="p">.</span><span class="n">mac</span><span class="p">);</span>
	<span class="n">llc_pdu_decode_ssap</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saddr</span><span class="p">.</span><span class="n">lsap</span><span class="p">);</span>
	<span class="n">llc_pdu_decode_da</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">daddr</span><span class="p">.</span><span class="n">mac</span><span class="p">);</span>
	<span class="n">llc_pdu_decode_dsap</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">.</span><span class="n">lsap</span><span class="p">);</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">__llc_lookup</span><span class="p">(</span><span class="n">sap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This has to be done here and not at the upper layer -&gt;accept</span>
<span class="cm">	 * method because of the way the PROCOM state machine works:</span>
<span class="cm">	 * it needs to set several state variables (see, for instance,</span>
<span class="cm">	 * llc_adm_actions_2 in net/llc/llc_c_st.c) and send a packet to</span>
<span class="cm">	 * the originator of the new connection, and this state has to be</span>
<span class="cm">	 * in the newly created struct sock private area. -acme</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span> <span class="o">=</span> <span class="n">llc_create_incoming_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
							      <span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">daddr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newsk</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">drop_unlock</span><span class="p">;</span>
		<span class="n">skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Can&#39;t be skb_set_owner_r, this will be done at the</span>
<span class="cm">		 * llc_conn_state_process function, later on, when we will use</span>
<span class="cm">		 * skb_queue_rcv_skb to send it to upper layers, this is</span>
<span class="cm">		 * another trick required to cope with how the PROCOM state</span>
<span class="cm">		 * machine works. -acme</span>
<span class="cm">		 */</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">llc_conn_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: adding to backlog...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">llc_set_backlog_type</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LLC_PACKET</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk_add_backlog</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">drop_unlock</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">drop:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">drop_unlock:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#undef LLC_REFCNT_DEBUG</span>
<span class="cp">#ifdef LLC_REFCNT_DEBUG</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">llc_sock_nr</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_backlog_rcv - Processes rx frames and expired timers.</span>
<span class="cm"> *	@sk: LLC sock (p8022 connection)</span>
<span class="cm"> *	@skb: queued rx frame or event</span>
<span class="cm"> *</span>
<span class="cm"> *	This function processes frames that has received and timers that has</span>
<span class="cm"> *	expired during sending an I pdu (refer to data_req_handler).  frames</span>
<span class="cm"> *	queue by llc_rcv function (llc_mac.c) and timers queue by timer</span>
<span class="cm"> *	callback functions(llc_c_ac.c).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">llc_backlog_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">llc_backlog_type</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="n">LLC_PACKET</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="cm">/* not closed */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">llc_conn_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">llc_backlog_type</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="n">LLC_EVENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* timer expiration event */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>  <span class="cm">/* not closed */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">llc_conn_state_process</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: invalid skb in backlog</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">out_kfree_skb:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *     llc_sk_init - Initializes a socket with default llc values.</span>
<span class="cm"> *     @sk: socket to initialize.</span>
<span class="cm"> *</span>
<span class="cm"> *     Initializes a socket with default llc values.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">llc_sk_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="o">*</span> <span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">state</span>    <span class="o">=</span> <span class="n">LLC_CONN_STATE_ADM</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">inc_cntr</span> <span class="o">=</span> <span class="n">llc</span><span class="o">-&gt;</span><span class="n">dec_cntr</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">dec_step</span> <span class="o">=</span> <span class="n">llc</span><span class="o">-&gt;</span><span class="n">connect_step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">ack_timer</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">llc_conn_ack_tmr_cb</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">ack_timer</span><span class="p">.</span><span class="n">expire</span>	      <span class="o">=</span> <span class="n">sysctl_llc2_ack_timeout</span><span class="p">;</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">pf_cycle_timer</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">llc_conn_pf_cycle_tmr_cb</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">pf_cycle_timer</span><span class="p">.</span><span class="n">expire</span>	   <span class="o">=</span> <span class="n">sysctl_llc2_p_timeout</span><span class="p">;</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">rej_sent_timer</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">llc_conn_rej_tmr_cb</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">rej_sent_timer</span><span class="p">.</span><span class="n">expire</span>	   <span class="o">=</span> <span class="n">sysctl_llc2_rej_timeout</span><span class="p">;</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">busy_state_timer</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">llc_conn_busy_tmr_cb</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">busy_state_timer</span><span class="p">.</span><span class="n">expire</span>	     <span class="o">=</span> <span class="n">sysctl_llc2_busy_timeout</span><span class="p">;</span>

	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">n2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>   <span class="cm">/* max retransmit */</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">k</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>   <span class="cm">/* tx win size, will adjust dynam */</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">rw</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span> <span class="cm">/* rx win size (opt and equal to</span>
<span class="cm">			* tx_win of remote LLC) */</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">pdu_unack_q</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog_rcv</span> <span class="o">=</span> <span class="n">llc_backlog_rcv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_sk_alloc - Allocates LLC sock</span>
<span class="cm"> *	@family: upper layer protocol family</span>
<span class="cm"> *	@priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc)</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocates a LLC sock and initializes it. Returns the new LLC sock</span>
<span class="cm"> *	or %NULL if there&#39;s no memory available for one</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">llc_sk_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">prot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">llc_sk_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sock_init_data</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
<span class="cp">#ifdef LLC_REFCNT_DEBUG</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc_sock_nr</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;LLC socket %p created in %s, now we have %d alive</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc_sock_nr</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_sk_free - Frees a LLC socket</span>
<span class="cm"> *	@sk - socket to free</span>
<span class="cm"> *</span>
<span class="cm"> *	Frees a LLC socket</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">llc_sk_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">LLC_CONN_OUT_OF_SVC</span><span class="p">;</span>
	<span class="cm">/* Stop all (possibly) running timers */</span>
	<span class="n">llc_conn_ac_stop_all_timers</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_LLC_CONN_ALLOC</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: unackq=%d, txq=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">pdu_unack_q</span><span class="p">),</span>
		<span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">);</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">pdu_unack_q</span><span class="p">);</span>
<span class="cp">#ifdef LLC_REFCNT_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Destruction of LLC sock %p delayed in %s, cnt=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sk</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">));</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%d LLC sockets are still alive</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc_sock_nr</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc_sock_nr</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;LLC socket %p released in %s, %d are still alive</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc_sock_nr</span><span class="p">));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	llc_sk_reset - resets a connection</span>
<span class="cm"> *	@sk: LLC socket to reset</span>
<span class="cm"> *</span>
<span class="cm"> *	Resets a connection to the out of service state. Stops its timers</span>
<span class="cm"> *	and frees any frames in the queues of the connection.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">llc_sk_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">llc_sock</span> <span class="o">*</span><span class="n">llc</span> <span class="o">=</span> <span class="n">llc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">llc_conn_ac_stop_all_timers</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">);</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">llc</span><span class="o">-&gt;</span><span class="n">pdu_unack_q</span><span class="p">);</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">remote_busy_flag</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">cause_flag</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">retry_count</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc_conn_set_p_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">f_flag</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">s_flag</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">ack_pf</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">first_pdu_Ns</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">ack_must_be_send</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">dec_step</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">inc_cntr</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">dec_cntr</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">X</span>			<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">failed_data_req</span>	<span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="n">llc</span><span class="o">-&gt;</span><span class="n">last_nr</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
