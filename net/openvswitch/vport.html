<!DOCTYPE html>
<html><head><title>joekychen/linux » net › openvswitch › vport.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>vport.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (c) 2007-2011 Nicira Networks.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of version 2 of the GNU General Public</span>
<span class="cm"> * License as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef VPORT_H</span>
<span class="cp">#define VPORT_H 1</span>

<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/openvswitch.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/u64_stats_sync.h&gt;</span>

<span class="cp">#include &quot;datapath.h&quot;</span>

<span class="k">struct</span> <span class="n">vport</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vport_parms</span><span class="p">;</span>

<span class="cm">/* The following definitions are for users of the vport subsytem: */</span>

<span class="kt">int</span> <span class="n">ovs_vport_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ovs_vport_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="n">ovs_vport_add</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">vport_parms</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ovs_vport_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="n">ovs_vport_locate</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">ovs_vport_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ovs_vport_stats</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ovs_vport_set_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">options</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ovs_vport_get_options</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">ovs_vport_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>

<span class="cm">/* The following definitions are for implementers of vport devices: */</span>

<span class="k">struct</span> <span class="n">vport_percpu_stats</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">rx_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_packets</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_packets</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">u64_stats_sync</span> <span class="n">sync</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vport_err_stats</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">rx_dropped</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rx_errors</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_dropped</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">tx_errors</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vport - one port within a datapath</span>
<span class="cm"> * @rcu: RCU callback head for deferred destruction.</span>
<span class="cm"> * @port_no: Index into @dp&#39;s @ports array.</span>
<span class="cm"> * @dp: Datapath to which this port belongs.</span>
<span class="cm"> * @node: Element in @dp&#39;s @port_list.</span>
<span class="cm"> * @upcall_pid: The Netlink port to use for packets received on this port that</span>
<span class="cm"> * miss the flow table.</span>
<span class="cm"> * @hash_node: Element in @dev_table hash table in vport.c.</span>
<span class="cm"> * @ops: Class structure.</span>
<span class="cm"> * @percpu_stats: Points to per-CPU statistics used and maintained by vport</span>
<span class="cm"> * @stats_lock: Protects @err_stats;</span>
<span class="cm"> * @err_stats: Points to error statistics used and maintained by vport</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vport</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">port_no</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">datapath</span>	<span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">upcall_pid</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hash_node</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">vport_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">vport_percpu_stats</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">percpu_stats</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">stats_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vport_err_stats</span> <span class="n">err_stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vport_parms - parameters for creating a new vport</span>
<span class="cm"> *</span>
<span class="cm"> * @name: New vport&#39;s name.</span>
<span class="cm"> * @type: New vport&#39;s type.</span>
<span class="cm"> * @options: %OVS_VPORT_ATTR_OPTIONS attribute from Netlink message, %NULL if</span>
<span class="cm"> * none was supplied.</span>
<span class="cm"> * @dp: New vport&#39;s datapath.</span>
<span class="cm"> * @port_no: New vport&#39;s port number.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vport_parms</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">ovs_vport_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">options</span><span class="p">;</span>

	<span class="cm">/* For ovs_vport_alloc(). */</span>
	<span class="k">struct</span> <span class="n">datapath</span> <span class="o">*</span><span class="n">dp</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">port_no</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">upcall_pid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct vport_ops - definition of a type of virtual port</span>
<span class="cm"> *</span>
<span class="cm"> * @type: %OVS_VPORT_TYPE_* value for this type of virtual port.</span>
<span class="cm"> * @create: Create a new vport configured as specified.  On success returns</span>
<span class="cm"> * a new vport allocated with ovs_vport_alloc(), otherwise an ERR_PTR() value.</span>
<span class="cm"> * @destroy: Destroys a vport.  Must call vport_free() on the vport but not</span>
<span class="cm"> * before an RCU grace period has elapsed.</span>
<span class="cm"> * @set_options: Modify the configuration of an existing vport.  May be %NULL</span>
<span class="cm"> * if modification is not supported.</span>
<span class="cm"> * @get_options: Appends vport-specific attributes for the configuration of an</span>
<span class="cm"> * existing vport to a &amp;struct sk_buff.  May be %NULL for a vport that does not</span>
<span class="cm"> * have any configuration.</span>
<span class="cm"> * @get_name: Get the device&#39;s name.</span>
<span class="cm"> * @get_config: Get the device&#39;s configuration.</span>
<span class="cm"> * @get_ifindex: Get the system interface index associated with the device.</span>
<span class="cm"> * May be null if the device does not have an ifindex.</span>
<span class="cm"> * @send: Send a packet on the device.  Returns the length of the packet sent.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vport_ops</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">ovs_vport_type</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/* Called with RTNL lock. */</span>
	<span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">vport_parms</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">set_options</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_options</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Called with rcu_read_lock or RTNL lock. */</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">get_name</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">get_config</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_ifindex</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">send</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">vport_err_type</span> <span class="p">{</span>
	<span class="n">VPORT_E_RX_DROPPED</span><span class="p">,</span>
	<span class="n">VPORT_E_RX_ERROR</span><span class="p">,</span>
	<span class="n">VPORT_E_TX_DROPPED</span><span class="p">,</span>
	<span class="n">VPORT_E_TX_ERROR</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="n">ovs_vport_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">priv_size</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vport_ops</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">vport_parms</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ovs_vport_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#define VPORT_ALIGN 8</span>

<span class="cm">/**</span>
<span class="cm"> *	vport_priv - access private data area of vport</span>
<span class="cm"> *</span>
<span class="cm"> * @vport: vport to access</span>
<span class="cm"> *</span>
<span class="cm"> * If a nonzero size was passed in priv_size of vport_alloc() a private data</span>
<span class="cm"> * area was allocated on creation.  This allows that area to be accessed and</span>
<span class="cm"> * used for any purpose needed by the vport implementer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">vport_priv</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">vport</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vport</span><span class="p">),</span> <span class="n">VPORT_ALIGN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	vport_from_priv - lookup vport from private data pointer</span>
<span class="cm"> *</span>
<span class="cm"> * @priv: Start of private data area.</span>
<span class="cm"> *</span>
<span class="cm"> * It is sometimes useful to translate from a pointer to the private data</span>
<span class="cm"> * area to the vport, such as in the case where the private data pointer is</span>
<span class="cm"> * the result of a hash table lookup.  @priv must point to the start of the</span>
<span class="cm"> * private data area.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="nf">vport_from_priv</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">)(</span><span class="n">priv</span> <span class="o">-</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">vport</span><span class="p">),</span> <span class="n">VPORT_ALIGN</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ovs_vport_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">ovs_vport_record_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">vport</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">vport_err_type</span> <span class="n">err_type</span><span class="p">);</span>

<span class="cm">/* List of statically compiled vport implementations.  Don&#39;t forget to also</span>
<span class="cm"> * add yours to the list at the top of vport.c. */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vport_ops</span> <span class="n">ovs_netdev_vport_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vport_ops</span> <span class="n">ovs_internal_vport_ops</span><span class="p">;</span>

<span class="cp">#endif </span><span class="cm">/* vport.h */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
