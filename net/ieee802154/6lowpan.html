<!DOCTYPE html>
<html><head><title>joekychen/linux » net › ieee802154 › 6lowpan.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>6lowpan.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2011, Siemens AG</span>
<span class="cm"> * written by Alexander Smirnov &lt;alex.bluesman.smirnov@gmail.com&gt;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Based on patches from Jon Smirl &lt;jonsmirl@gmail.com&gt;</span>
<span class="cm"> * Copyright (c) 2011 Jon Smirl &lt;jonsmirl@gmail.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2</span>
<span class="cm"> * as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> */</span>

<span class="cm">/* Jon&#39;s code is based on 6lowpan implementation for Contiki which is:</span>
<span class="cm"> * Copyright (c) 2008, Swedish Institute of Computer Science.</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions</span>
<span class="cm"> * are met:</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *    documentation and/or other materials provided with the distribution.</span>
<span class="cm"> * 3. Neither the name of the Institute nor the names of its contributors</span>
<span class="cm"> *    may be used to endorse or promote products derived from this software</span>
<span class="cm"> *    without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS&#39;&#39; AND</span>
<span class="cm"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="cm"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="cm"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE</span>
<span class="cm"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span class="cm"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span class="cm"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
<span class="cm"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
<span class="cm"> * SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;net/af_ieee802154.h&gt;</span>
<span class="cp">#include &lt;net/ieee802154.h&gt;</span>
<span class="cp">#include &lt;net/ieee802154_netdev.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>

<span class="cp">#include &quot;6lowpan.h&quot;</span>

<span class="cm">/* TTL uncompression values */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">lowpan_ttl_values</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">255</span><span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">lowpan_devices</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Uncompression of linklocal:</span>
<span class="cm"> *   0 -&gt; 16 bytes from packet</span>
<span class="cm"> *   1 -&gt; 2  bytes from prefix - bunch of zeroes and 8 from packet</span>
<span class="cm"> *   2 -&gt; 2  bytes from prefix - zeroes + 2 from packet</span>
<span class="cm"> *   3 -&gt; 2  bytes from prefix - infer 8 bytes from lladdr</span>
<span class="cm"> *</span>
<span class="cm"> *  NOTE: =&gt; the uncompress function does change 0xf to 0x10</span>
<span class="cm"> *  NOTE: 0x00 =&gt; no-autoconfig =&gt; unspecified</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">lowpan_unc_llconf</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x0f</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Uncompression of ctx-based:</span>
<span class="cm"> *   0 -&gt; 0 bits  from packet [unspecified / reserved]</span>
<span class="cm"> *   1 -&gt; 8 bytes from prefix - bunch of zeroes and 8 from packet</span>
<span class="cm"> *   2 -&gt; 8 bytes from prefix - zeroes + 2 from packet</span>
<span class="cm"> *   3 -&gt; 8 bytes from prefix - infer 8 bytes from lladdr</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">lowpan_unc_ctxconf</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x82</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Uncompression of ctx-base</span>
<span class="cm"> *   0 -&gt; 0 bits from packet</span>
<span class="cm"> *   1 -&gt; 2 bytes from prefix - bunch of zeroes 5 from packet</span>
<span class="cm"> *   2 -&gt; 2 bytes from prefix - zeroes + 3 from packet</span>
<span class="cm"> *   3 -&gt; 2 bytes from prefix - infer 1 bytes from lladdr</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">lowpan_unc_mxconf</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x0f</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">};</span>

<span class="cm">/* Link local prefix */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">lowpan_llprefix</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0xfe</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">};</span>

<span class="cm">/* private device info */</span>
<span class="k">struct</span> <span class="n">lowpan_dev_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span>	<span class="o">*</span><span class="n">real_dev</span><span class="p">;</span> <span class="cm">/* real WPAN device ptr */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">dev_list_mtx</span><span class="p">;</span> <span class="cm">/* mutex for list ops */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lowpan_dev_record</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ldev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lowpan_fragment</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span>		<span class="o">*</span><span class="n">skb</span><span class="p">;</span>		<span class="cm">/* skb to be assembled */</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>		<span class="cm">/* concurency lock */</span>
	<span class="n">u16</span>			<span class="n">length</span><span class="p">;</span>		<span class="cm">/* length to be assemled */</span>
	<span class="n">u32</span>			<span class="n">bytes_rcv</span><span class="p">;</span>	<span class="cm">/* bytes received */</span>
	<span class="n">u16</span>			<span class="n">tag</span><span class="p">;</span>		<span class="cm">/* current fragment tag */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">timer</span><span class="p">;</span>		<span class="cm">/* assembling timer */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>		<span class="cm">/* fragments list */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">fragment_tag</span><span class="p">;</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">lowpan_fragments</span><span class="p">);</span>
<span class="n">spinlock_t</span> <span class="n">flist_lock</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span>
<span class="n">lowpan_dev_info</span> <span class="o">*</span><span class="nf">lowpan_dev_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lowpan_address_flip</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IEEE802154_ADDR_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">(</span><span class="n">dest</span><span class="p">)[</span><span class="n">IEEE802154_ADDR_LEN</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">src</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* list of all 6lowpan devices, uses for package delivering */</span>
<span class="cm">/* print data in line */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lowpan_raw_dump_inline</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">caller</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s) %s: &quot;</span><span class="p">,</span> <span class="n">caller</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_NONE</span><span class="p">,</span>
		       <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * print data in a table format:</span>
<span class="cm"> *</span>
<span class="cm"> * addr: xx xx xx xx xx xx</span>
<span class="cm"> * addr: xx xx xx xx xx xx</span>
<span class="cm"> * ...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">lowpan_raw_dump_table</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">caller</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s) %s:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">caller</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">DUMP_PREFIX_OFFSET</span><span class="p">,</span>
		       <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* DEBUG */</span><span class="cp"></span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span>
<span class="nf">lowpan_compress_addr_64</span><span class="p">(</span><span class="n">u8</span> <span class="o">**</span><span class="n">hc06_ptr</span><span class="p">,</span> <span class="n">u8</span> <span class="n">shift</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">ipaddr</span><span class="p">,</span>
		 <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lladdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_addr_mac_addr_based</span><span class="p">(</span><span class="n">ipaddr</span><span class="p">,</span> <span class="n">lladdr</span><span class="p">))</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* 0-bits */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lowpan_is_iid_16_bit_compressable</span><span class="p">(</span><span class="n">ipaddr</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* compress IID to 16 bits xxxx::XXXX */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">hc06_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipaddr</span><span class="o">-&gt;</span><span class="n">s6_addr16</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
		<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* 16-bits */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* do not compress IID =&gt; xxxx::IID */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">hc06_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ipaddr</span><span class="o">-&gt;</span><span class="n">s6_addr16</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">);</span>
		<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* 64-bits */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rol8</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lowpan_uip_ds6_set_addr_iid</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">ipaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lladdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipaddr</span><span class="o">-&gt;</span><span class="n">s6_addr</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">lladdr</span><span class="p">,</span> <span class="n">IEEE802154_ADDR_LEN</span><span class="p">);</span>
	<span class="cm">/* second bit-flip (Universe/Local) is done according RFC2464 */</span>
	<span class="n">ipaddr</span><span class="o">-&gt;</span><span class="n">s6_addr</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">^=</span> <span class="mh">0x02</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Uncompress addresses based on a prefix and a postfix with zeroes in</span>
<span class="cm"> * between. If the postfix is zero in length it will use the link address</span>
<span class="cm"> * to configure the IP address (autoconf style).</span>
<span class="cm"> * pref_post_count takes a byte where the first nibble specify prefix count</span>
<span class="cm"> * and the second postfix count (NOTE: 15/0xf =&gt; 16 bytes copy).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lowpan_uncompress_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">in6_addr</span> <span class="o">*</span><span class="n">ipaddr</span><span class="p">,</span>
	<span class="n">u8</span> <span class="k">const</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="n">u8</span> <span class="n">pref_post_count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lladdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">prefcount</span> <span class="o">=</span> <span class="n">pref_post_count</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">postcount</span> <span class="o">=</span> <span class="n">pref_post_count</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>

	<span class="cm">/* full nibble 15 =&gt; 16 */</span>
	<span class="n">prefcount</span> <span class="o">=</span> <span class="p">(</span><span class="n">prefcount</span> <span class="o">==</span> <span class="mi">15</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="n">prefcount</span><span class="p">);</span>
	<span class="n">postcount</span> <span class="o">=</span> <span class="p">(</span><span class="n">postcount</span> <span class="o">==</span> <span class="mi">15</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="n">postcount</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lladdr</span><span class="p">)</span>
		<span class="n">lowpan_raw_dump_inline</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="s">&quot;linklocal address&quot;</span><span class="p">,</span>
						<span class="n">lladdr</span><span class="p">,</span>	<span class="n">IEEE802154_ADDR_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prefcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">ipaddr</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">prefcount</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prefcount</span> <span class="o">+</span> <span class="n">postcount</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipaddr</span><span class="o">-&gt;</span><span class="n">s6_addr</span><span class="p">[</span><span class="n">prefcount</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
					<span class="mi">16</span> <span class="o">-</span> <span class="p">(</span><span class="n">prefcount</span> <span class="o">+</span> <span class="n">postcount</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">postcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ipaddr</span><span class="o">-&gt;</span><span class="n">s6_addr</span><span class="p">[</span><span class="mi">16</span> <span class="o">-</span> <span class="n">postcount</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">postcount</span><span class="p">);</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">postcount</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prefcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lladdr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* no IID based configuration if no prefix and no data */</span>
		<span class="n">lowpan_uip_ds6_set_addr_iid</span><span class="p">(</span><span class="n">ipaddr</span><span class="p">,</span> <span class="n">lladdr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): uncompressing %d + %d =&gt; &quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">prefcount</span><span class="p">,</span>
								<span class="n">postcount</span><span class="p">);</span>
	<span class="n">lowpan_raw_dump_inline</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">ipaddr</span><span class="o">-&gt;</span><span class="n">s6_addr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lowpan_compress_udp_header</span><span class="p">(</span><span class="n">u8</span> <span class="o">**</span><span class="n">hc06_ptr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udphdr</span> <span class="o">*</span><span class="n">uh</span> <span class="o">=</span> <span class="n">udp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): UDP header compression</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">&amp;</span> <span class="n">LOWPAN_NHC_UDP_4BIT_MASK</span><span class="p">)</span> <span class="o">==</span>
				<span class="n">LOWPAN_NHC_UDP_4BIT_PORT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">&amp;</span> <span class="n">LOWPAN_NHC_UDP_4BIT_MASK</span><span class="p">)</span> <span class="o">==</span>
				<span class="n">LOWPAN_NHC_UDP_4BIT_PORT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): both ports compression to 4 bits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="o">**</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">LOWPAN_NHC_UDP_CS_P_11</span><span class="p">;</span>
		<span class="o">**</span><span class="p">(</span><span class="n">hc06_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="cm">/* subtraction is faster */</span>
		   <span class="p">(</span><span class="n">u8</span><span class="p">)((</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">-</span> <span class="n">LOWPAN_NHC_UDP_4BIT_PORT</span><span class="p">)</span> <span class="o">+</span>
		       <span class="p">((</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">&amp;</span> <span class="n">LOWPAN_NHC_UDP_4BIT_PORT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">));</span>
		<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">&amp;</span> <span class="n">LOWPAN_NHC_UDP_8BIT_MASK</span><span class="p">)</span> <span class="o">==</span>
			<span class="n">LOWPAN_NHC_UDP_8BIT_PORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): remove 8 bits of dest</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="o">**</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">LOWPAN_NHC_UDP_CS_P_01</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="o">**</span><span class="p">(</span><span class="n">hc06_ptr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">-</span> <span class="n">LOWPAN_NHC_UDP_8BIT_PORT</span><span class="p">);</span>
		<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">&amp;</span> <span class="n">LOWPAN_NHC_UDP_8BIT_MASK</span><span class="p">)</span> <span class="o">==</span>
			<span class="n">LOWPAN_NHC_UDP_8BIT_PORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): remove 8 bits of source</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="o">**</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">LOWPAN_NHC_UDP_CS_P_10</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="o">**</span><span class="p">(</span><span class="n">hc06_ptr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">-</span> <span class="n">LOWPAN_NHC_UDP_8BIT_PORT</span><span class="p">);</span>
		<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): can&#39;t compress header</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="o">**</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">LOWPAN_NHC_UDP_CS_P_00</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* checksum is always inline */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">hc06_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">lowpan_fetch_skb_u16</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lowpan_uncompress_udp_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udphdr</span> <span class="o">*</span><span class="n">uh</span> <span class="o">=</span> <span class="n">udp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">LOWPAN_NHC_UDP_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">LOWPAN_NHC_UDP_ID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): UDP header uncompression</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="n">LOWPAN_NHC_UDP_CS_P_11</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LOWPAN_NHC_UDP_CS_P_00</span>:
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LOWPAN_NHC_UDP_CS_P_01</span>:
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">=</span>
			   <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">LOWPAN_NHC_UDP_8BIT_PORT</span><span class="p">;</span>
			<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LOWPAN_NHC_UDP_CS_P_10</span>:
			<span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">LOWPAN_NHC_UDP_8BIT_PORT</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LOWPAN_NHC_UDP_CS_P_11</span>:
			<span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span> <span class="o">=</span>
			   <span class="n">LOWPAN_NHC_UDP_4BIT_PORT</span> <span class="o">+</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span> <span class="o">=</span>
			   <span class="n">LOWPAN_NHC_UDP_4BIT_PORT</span> <span class="o">+</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
			<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s) ERROR: unknown UDP format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): uncompressed UDP ports: src = %d, dst = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">uh</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="n">uh</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">);</span>

		<span class="cm">/* copy checksum */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uh</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): ERROR: unsupported NH format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lowpan_header_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_daddr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_saddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">iphc0</span><span class="p">,</span> <span class="n">iphc1</span><span class="p">,</span> <span class="o">*</span><span class="n">hc06_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">_saddr</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">_daddr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ieee802154_addr</span> <span class="n">sa</span><span class="p">,</span> <span class="n">da</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ETH_P_IPV6</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* TODO:</span>
<span class="cm">		 * if this package isn&#39;t ipv6 one, where should it be routed?</span>
<span class="cm">		 */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="n">ipv6_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">head</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): IPv6 header dump:</span><span class="se">\n\t</span><span class="s">version = %d</span><span class="se">\n\t</span><span class="s">length  = %d</span><span class="se">\n</span><span class="s">&quot;</span>
		 <span class="s">&quot;</span><span class="se">\t</span><span class="s">nexthdr = 0x%02x</span><span class="se">\n\t</span><span class="s">hop_lim = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">payload_len</span><span class="p">),</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">,</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">hop_limit</span><span class="p">);</span>

	<span class="n">lowpan_raw_dump_table</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="s">&quot;raw skb network header dump&quot;</span><span class="p">,</span>
		<span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">saddr</span><span class="p">)</span>
		<span class="n">saddr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">;</span>

	<span class="n">lowpan_raw_dump_inline</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="s">&quot;saddr&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">saddr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * As we copy some bit-length fields, in the IPHC encoding bytes,</span>
<span class="cm">	 * we sometimes use |=</span>
<span class="cm">	 * If the field is 0, and the current bit value in memory is 1,</span>
<span class="cm">	 * this does not work. We therefore reset the IPHC encoding here</span>
<span class="cm">	 */</span>
	<span class="n">iphc0</span> <span class="o">=</span> <span class="n">LOWPAN_DISPATCH_IPHC</span><span class="p">;</span>
	<span class="n">iphc1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* TODO: context lookup */</span>

	<span class="n">lowpan_raw_dump_inline</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="s">&quot;daddr&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">daddr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Traffic class, flow label</span>
<span class="cm">	 * If flow label is 0, compress it. If traffic class is 0, compress it</span>
<span class="cm">	 * We have to process both in the same time as the offset of traffic</span>
<span class="cm">	 * class depends on the presence of version and flow label</span>
<span class="cm">	 */</span>

	<span class="cm">/* hc06 format of TC is ECN | DSCP , original one is DSCP | ECN */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* flow label can be compressed */</span>
		<span class="n">iphc0</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_FL_C</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">((</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* compress (elide) all */</span>
			<span class="n">iphc0</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_TC_C</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* compress only the flow label */</span>
			<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Flow label cannot be compressed */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">((</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* compress only traffic class */</span>
			<span class="n">iphc0</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_TC_C</span><span class="p">;</span>
			<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">hc06_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* compress nothing */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">hc06_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
			<span class="cm">/* replace the top byte with new ECN | DSCP format */</span>
			<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
			<span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* NOTE: payload length is always compressed */</span>

	<span class="cm">/* Next Header is compress if UDP */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">UIP_PROTO_UDP</span><span class="p">)</span>
		<span class="n">iphc0</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_NH_C</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">iphc0</span> <span class="o">&amp;</span> <span class="n">LOWPAN_IPHC_NH_C</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nexthdr</span><span class="p">;</span>
		<span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Hop limit</span>
<span class="cm">	 * if 1:   compress, encoding is 01</span>
<span class="cm">	 * if 64:  compress, encoding is 10</span>
<span class="cm">	 * if 255: compress, encoding is 11</span>
<span class="cm">	 * else do not compress</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">hop_limit</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">iphc0</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_TTL_1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">64</span>:
		<span class="n">iphc0</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_TTL_64</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">255</span>:
		<span class="n">iphc0</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_TTL_255</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">hop_limit</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* source address compression */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_addr_unspecified</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): source address is unspecified, setting SAC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
		<span class="n">iphc1</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_SAC</span><span class="p">;</span>
	<span class="cm">/* TODO: context lookup */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_addr_link_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): source address is link-local</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">iphc1</span> <span class="o">|=</span> <span class="n">lowpan_compress_addr_64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hc06_ptr</span><span class="p">,</span>
				<span class="n">LOWPAN_IPHC_SAM_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">saddr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): send the full source address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">hc06_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">.</span><span class="n">s6_addr16</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* destination address compression */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_addr_mcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): destination address is multicast&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">iphc1</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_M</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lowpan_is_mcast_addr_compressable8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;compressed to 1 octet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">iphc1</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_DAM_11</span><span class="p">;</span>
			<span class="cm">/* use last byte */</span>
			<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">s6_addr</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>
			<span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lowpan_is_mcast_addr_compressable32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;compressed to 4 octets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">iphc1</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_DAM_10</span><span class="p">;</span>
			<span class="cm">/* second byte + the last three */</span>
			<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">s6_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">hc06_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">s6_addr</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="mi">3</span><span class="p">);</span>
			<span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lowpan_is_mcast_addr_compressable48</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;compressed to 6 octets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">iphc1</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_DAM_01</span><span class="p">;</span>
			<span class="cm">/* second byte + the last five */</span>
			<span class="o">*</span><span class="n">hc06_ptr</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">s6_addr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">hc06_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">s6_addr</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span> <span class="mi">5</span><span class="p">);</span>
			<span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;using full address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">iphc1</span> <span class="o">|=</span> <span class="n">LOWPAN_IPHC_DAM_00</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">hc06_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">s6_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): destination address is unicast: &quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="cm">/* TODO: context lookup */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_addr_link_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;destination address is link-local</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">iphc1</span> <span class="o">|=</span> <span class="n">lowpan_compress_addr_64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hc06_ptr</span><span class="p">,</span>
				<span class="n">LOWPAN_IPHC_DAM_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">daddr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;using full address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">hc06_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">.</span><span class="n">s6_addr16</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">hc06_ptr</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* UDP header compression */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">nexthdr</span> <span class="o">==</span> <span class="n">UIP_PROTO_UDP</span><span class="p">)</span>
		<span class="n">lowpan_compress_udp_header</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hc06_ptr</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">iphc0</span><span class="p">;</span>
	<span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iphc1</span><span class="p">;</span>

	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hc06_ptr</span> <span class="o">-</span> <span class="n">head</span><span class="p">),</span> <span class="n">head</span><span class="p">,</span> <span class="n">hc06_ptr</span> <span class="o">-</span> <span class="n">head</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>

	<span class="n">lowpan_raw_dump_table</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="s">&quot;raw skb data dump&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * NOTE1: I&#39;m still unsure about the fact that compression and WPAN</span>
<span class="cm">	 * header are created here and not later in the xmit. So wait for</span>
<span class="cm">	 * an opinion of net maintainers.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * NOTE2: to be absolutely correct, we must derive PANid information</span>
<span class="cm">	 * from MAC subif of the &#39;dev&#39; and &#39;real_dev&#39; network devices, but</span>
<span class="cm">	 * this isn&#39;t implemented in mainline yet, so currently we assign 0xff</span>
<span class="cm">	 */</span>
	<span class="p">{</span>
		<span class="cm">/* prepare wpan address data */</span>
		<span class="n">sa</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IEEE802154_ADDR_LONG</span><span class="p">;</span>
		<span class="n">sa</span><span class="p">.</span><span class="n">pan_id</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="n">da</span><span class="p">.</span><span class="n">addr_type</span> <span class="o">=</span> <span class="n">IEEE802154_ADDR_LONG</span><span class="p">;</span>
		<span class="n">da</span><span class="p">.</span><span class="n">pan_id</span> <span class="o">=</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">da</span><span class="p">.</span><span class="n">hwaddr</span><span class="p">),</span> <span class="n">daddr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sa</span><span class="p">.</span><span class="n">hwaddr</span><span class="p">),</span> <span class="n">saddr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

		<span class="n">mac_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IEEE802154_FC_TYPE_DATA</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">dev_hard_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">real_dev</span><span class="p">,</span>
				<span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">da</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lowpan_skb_deliver</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lowpan_dev_record</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">skb_copy_expand</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">),</span> <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
								<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">skb_push</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">));</span>
	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="n">skb_copy_to_linear_data</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">));</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_HOST</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lowpan_devices</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ldev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">real_dev</span> <span class="o">==</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_copy</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">stat</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ldev</span><span class="p">;</span>
			<span class="n">stat</span> <span class="o">=</span> <span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">stat</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lowpan_fragment_timer_expired</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">entry_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lowpan_fragment</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lowpan_fragment</span> <span class="o">*</span><span class="p">)</span><span class="n">entry_addr</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: timer expired for frame with tag %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
								<span class="n">entry</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flist_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flist_lock</span><span class="p">);</span>

	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lowpan_fragment</span> <span class="o">*</span>
<span class="nf">lowpan_alloc_new_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="n">iphc0</span><span class="p">,</span> <span class="n">u8</span> <span class="n">len</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lowpan_fragment</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>

	<span class="n">frame</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lowpan_fragment</span><span class="p">),</span>
			<span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">frame_err</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">iphc0</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>

	<span class="cm">/* allocate buffer for frame assembling */</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">+</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">skb_err</span><span class="p">;</span>

	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* reserve headroom for uncompressed ipv6 header */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ipv6hdr</span><span class="p">));</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="cm">/* time out is the same as for ipv6 - 60 sec */</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">LOWPAN_FRAG_TIMEOUT</span><span class="p">;</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">frame</span><span class="p">;</span>
	<span class="n">frame</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">lowpan_fragment_timer_expired</span><span class="p">;</span>

	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lowpan_fragments</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">frame</span><span class="p">;</span>

<span class="nl">skb_err:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
<span class="nl">frame_err:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lowpan_process_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ipv6hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">iphc0</span><span class="p">,</span> <span class="n">iphc1</span><span class="p">,</span> <span class="n">num_context</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">_saddr</span><span class="p">,</span> <span class="o">*</span><span class="n">_daddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">lowpan_raw_dump_table</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="s">&quot;raw skb data dump&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="cm">/* at least two bytes will be used for the encoding */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="n">iphc0</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* fragments assembling */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">iphc0</span> <span class="o">&amp;</span> <span class="n">LOWPAN_DISPATCH_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LOWPAN_DISPATCH_FRAG1</span>:
	<span class="k">case</span> <span class="n">LOWPAN_DISPATCH_FRAGN</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">lowpan_fragment</span> <span class="o">*</span><span class="n">frame</span><span class="p">;</span>
		<span class="n">u8</span> <span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">tag</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span> <span class="cm">/* frame length */</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u16</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * check if frame assembling with the same tag is</span>
<span class="cm">		 * already in progress</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flist_lock</span><span class="p">);</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lowpan_fragments</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="cm">/* alloc new frame structure */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">frame</span> <span class="o">=</span> <span class="n">lowpan_alloc_new_frame</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">iphc0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frame</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">unlock_and_drop</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">iphc0</span> <span class="o">&amp;</span> <span class="n">LOWPAN_DISPATCH_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">LOWPAN_DISPATCH_FRAG1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock_and_drop</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span> <span class="cm">/* fetch offset */</span>

		<span class="cm">/* if payload fits buffer, copy it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">offset</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))</span>
			<span class="n">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span>
							<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">unlock_and_drop</span><span class="p">;</span>

		<span class="n">frame</span><span class="o">-&gt;</span><span class="n">bytes_rcv</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="cm">/* frame assembling complete */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">bytes_rcv</span> <span class="o">==</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">frame</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">&gt;</span> <span class="n">jiffies</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* if timer haven&#39;t expired - first of all delete it */</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flist_lock</span><span class="p">);</span>

			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
			<span class="n">iphc0</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flist_lock</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iphc1</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">_saddr</span> <span class="o">=</span> <span class="n">mac_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">hwaddr</span><span class="p">;</span>
	<span class="n">_daddr</span> <span class="o">=</span> <span class="n">mac_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">da</span><span class="p">.</span><span class="n">hwaddr</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): iphc0 = %02x, iphc1 = %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">iphc0</span><span class="p">,</span> <span class="n">iphc1</span><span class="p">);</span>

	<span class="cm">/* another if the CID flag is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iphc1</span> <span class="o">&amp;</span> <span class="n">LOWPAN_IPHC_CID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): CID flag is set, increase header with one</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="n">num_context</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hdr</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

	<span class="cm">/* Traffic Class and Flow Label */</span>
	<span class="k">switch</span> <span class="p">((</span><span class="n">iphc0</span> <span class="o">&amp;</span> <span class="n">LOWPAN_IPHC_TF</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Traffic Class and FLow Label carried in-line</span>
<span class="cm">	 * ECN + DSCP + 4-bit Pad + Flow Label (4 bytes)</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* 00b */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="p">.</span><span class="n">flow_lbl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Traffic class carried in-line</span>
<span class="cm">	 * ECN + DSCP (1 byte), Flow Label is elided</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* 10b */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xC0</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">);</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Flow Label carried in-line</span>
<span class="cm">	 * ECN + 2-bit Pad + Flow Label (3 bytes), DSCP is elided</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* 01b */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x30</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="p">.</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/* Traffic Class and Flow Label are elided */</span>
	<span class="k">case</span> <span class="mi">3</span>: <span class="cm">/* 11b */</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">flow_lbl</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Next Header */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iphc0</span> <span class="o">&amp;</span> <span class="n">LOWPAN_IPHC_NH_C</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Next header is carried inline */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">nexthdr</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): NH flag is set, next header is carried &quot;</span>
			 <span class="s">&quot;inline: %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hdr</span><span class="p">.</span><span class="n">nexthdr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Hop Limit */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iphc0</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">!=</span> <span class="n">LOWPAN_IPHC_TTL_I</span><span class="p">)</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">hop_limit</span> <span class="o">=</span> <span class="n">lowpan_ttl_values</span><span class="p">[</span><span class="n">iphc0</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">];</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="n">hdr</span><span class="p">.</span><span class="n">hop_limit</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Extract SAM to the tmp variable */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">iphc1</span> <span class="o">&amp;</span> <span class="n">LOWPAN_IPHC_SAM</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">LOWPAN_IPHC_SAM_BIT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>

	<span class="cm">/* Source address uncompression */</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): source address stateless compression</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">lowpan_uncompress_addr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">.</span><span class="n">saddr</span><span class="p">,</span> <span class="n">lowpan_llprefix</span><span class="p">,</span>
				<span class="n">lowpan_unc_llconf</span><span class="p">[</span><span class="n">tmp</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="cm">/* Extract DAM to the tmp variable */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">iphc1</span> <span class="o">&amp;</span> <span class="n">LOWPAN_IPHC_DAM_11</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">LOWPAN_IPHC_DAM_BIT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">;</span>

	<span class="cm">/* check for Multicast Compression */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iphc1</span> <span class="o">&amp;</span> <span class="n">LOWPAN_IPHC_M</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iphc1</span> <span class="o">&amp;</span> <span class="n">LOWPAN_IPHC_DAC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): destination address context-based &quot;</span>
				 <span class="s">&quot;multicast compression</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="cm">/* TODO: implement this */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">prefix</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0xff</span><span class="p">,</span> <span class="mh">0x02</span><span class="p">};</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): destination address non-context-based&quot;</span>
				 <span class="s">&quot; multicast compression</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">prefix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lowpan_fetch_skb_u8</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">lowpan_uncompress_addr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">.</span><span class="n">daddr</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span>
					<span class="n">lowpan_unc_mxconf</span><span class="p">[</span><span class="n">tmp</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): destination address stateless compression</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">lowpan_uncompress_addr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">.</span><span class="n">daddr</span><span class="p">,</span> <span class="n">lowpan_llprefix</span><span class="p">,</span>
				<span class="n">lowpan_unc_llconf</span><span class="p">[</span><span class="n">tmp</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* UDP data uncompression */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iphc0</span> <span class="o">&amp;</span> <span class="n">LOWPAN_IPHC_NH_C</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lowpan_uncompress_udp_header</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="cm">/* Not fragmented package */</span>
	<span class="n">hdr</span><span class="p">.</span><span class="n">payload_len</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): skb headroom size = %d, data length = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
						<span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): IPv6 header dump:</span><span class="se">\n\t</span><span class="s">version = %d</span><span class="se">\n\t</span><span class="s">length  = %d</span><span class="se">\n\t</span><span class="s">&quot;</span>
		 <span class="s">&quot;nexthdr = 0x%02x</span><span class="se">\n\t</span><span class="s">hop_lim = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">hdr</span><span class="p">.</span><span class="n">version</span><span class="p">,</span>
		 <span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">payload_len</span><span class="p">),</span> <span class="n">hdr</span><span class="p">.</span><span class="n">nexthdr</span><span class="p">,</span> <span class="n">hdr</span><span class="p">.</span><span class="n">hop_limit</span><span class="p">);</span>

	<span class="n">lowpan_raw_dump_table</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="s">&quot;raw header dump&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span>
							<span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">lowpan_skb_deliver</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="p">);</span>

<span class="nl">unlock_and_drop:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flist_lock</span><span class="p">);</span>
<span class="nl">drop:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lowpan_get_mac_header_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Currently long addressing mode is supported only, so the overall</span>
<span class="cm">	 * header size is 21:</span>
<span class="cm">	 * FC SeqNum DPAN DA  SA  Sec</span>
<span class="cm">	 * 2  +  1  +  2 + 8 + 8 + 0  = 21</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">21</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lowpan_fragment_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">mlen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">plen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* if payload length is zero, therefore it&#39;s a first fragment */</span>
	<span class="n">hlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">plen</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">LOWPAN_FRAG1_HEAD_SIZE</span> <span class="o">:</span>  <span class="n">LOWPAN_FRAGN_HEAD_SIZE</span><span class="p">);</span>

	<span class="n">lowpan_raw_dump_inline</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="s">&quot;6lowpan fragment header&quot;</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>

	<span class="n">frag</span> <span class="o">=</span> <span class="n">dev_alloc_skb</span><span class="p">(</span><span class="n">hlen</span> <span class="o">+</span> <span class="n">mlen</span> <span class="o">+</span> <span class="n">plen</span> <span class="o">+</span> <span class="n">IEEE802154_MFR_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frag</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>
	<span class="n">frag</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* copy header, MFR and payload */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">mlen</span><span class="p">),</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">mlen</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">hlen</span><span class="p">),</span> <span class="n">head</span><span class="p">,</span> <span class="n">hlen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">plen</span><span class="p">)</span>
		<span class="n">skb_copy_from_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">mlen</span><span class="p">,</span>
					<span class="n">skb_put</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">plen</span><span class="p">),</span> <span class="n">plen</span><span class="p">);</span>

	<span class="n">lowpan_raw_dump_table</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="s">&quot; raw fragment dump&quot;</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
								<span class="n">frag</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lowpan_skb_fragmentation</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>  <span class="n">err</span><span class="p">,</span> <span class="n">header_length</span><span class="p">,</span> <span class="n">payload_length</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">head</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

	<span class="n">header_length</span> <span class="o">=</span> <span class="n">lowpan_get_mac_header_length</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">payload_length</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">header_length</span><span class="p">;</span>
	<span class="n">tag</span> <span class="o">=</span> <span class="n">fragment_tag</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* first fragment header */</span>
	<span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">LOWPAN_DISPATCH_FRAG1</span> <span class="o">|</span> <span class="p">(</span><span class="n">payload_length</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">);</span>
	<span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">payload_length</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">head</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tag</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
	<span class="n">head</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">tag</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">lowpan_fragment_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">header_length</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* next fragment header */</span>
	<span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOWPAN_DISPATCH_FRAG1</span><span class="p">;</span>
	<span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="n">LOWPAN_DISPATCH_FRAGN</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">payload_length</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">LOWPAN_FRAG_SIZE</span><span class="p">;</span>

		<span class="n">head</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">payload_length</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">payload_length</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">lowpan_fragment_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">header_length</span><span class="p">,</span>
							<span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">lowpan_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): package xmit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">real_dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s) ERROR: no real wpan device found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">IEEE802154_MTU</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): frame is too big, fragmentation is needed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">__func__</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">lowpan_skb_fragmentation</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s): ERROR: xmit failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">NETDEV_TX_BUSY</span> <span class="o">:</span> <span class="n">NETDEV_TX_OK</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lowpan_dev_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_put</span><span class="p">(</span><span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">real_dev</span><span class="p">);</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">wpan_phy</span> <span class="o">*</span><span class="nf">lowpan_get_phy</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">real_dev</span> <span class="o">=</span> <span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">real_dev</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ieee802154_mlme_ops</span><span class="p">(</span><span class="n">real_dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">get_phy</span><span class="p">(</span><span class="n">real_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">lowpan_get_pan_id</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">real_dev</span> <span class="o">=</span> <span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">real_dev</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ieee802154_mlme_ops</span><span class="p">(</span><span class="n">real_dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">get_pan_id</span><span class="p">(</span><span class="n">real_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">lowpan_get_short_addr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">real_dev</span> <span class="o">=</span> <span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">real_dev</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ieee802154_mlme_ops</span><span class="p">(</span><span class="n">real_dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">get_short_addr</span><span class="p">(</span><span class="n">real_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">header_ops</span> <span class="n">lowpan_header_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">create</span>	<span class="o">=</span> <span class="n">lowpan_header_create</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">lowpan_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">lowpan_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_set_mac_address</span>	<span class="o">=</span> <span class="n">eth_mac_addr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ieee802154_mlme_ops</span> <span class="n">lowpan_mlme</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">get_pan_id</span> <span class="o">=</span> <span class="n">lowpan_get_pan_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_phy</span> <span class="o">=</span> <span class="n">lowpan_get_phy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_short_addr</span> <span class="o">=</span> <span class="n">lowpan_get_short_addr</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lowpan_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span>		<span class="o">=</span> <span class="n">IEEE802154_ADDR_LEN</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">IEEE802154_ADDR_LEN</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span>		<span class="o">=</span> <span class="n">ARPHRD_IEEE802154</span><span class="p">;</span>
	<span class="cm">/* Frame Control + Sequence Number + Address fields + Security Header */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span>	<span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">20</span> <span class="o">+</span> <span class="mi">14</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">needed_tailroom</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="cm">/* FCS */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span>		<span class="o">=</span> <span class="mi">1281</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">IFF_BROADCAST</span> <span class="o">|</span> <span class="n">IFF_MULTICAST</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">watchdog_timeo</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">lowpan_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">header_ops</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">lowpan_header_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ml_priv</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">lowpan_mlme</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">destructor</span>		<span class="o">=</span> <span class="n">lowpan_dev_free</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lowpan_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IFLA_ADDRESS</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nla_len</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IFLA_ADDRESS</span><span class="p">])</span> <span class="o">!=</span> <span class="n">IEEE802154_ADDR_LEN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lowpan_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_IEEE802154</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

	<span class="cm">/* check that it&#39;s our buffer */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xe0</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LOWPAN_DISPATCH_IPHC</span>:	<span class="cm">/* ipv6 datagram */</span>
	<span class="k">case</span> <span class="n">LOWPAN_DISPATCH_FRAG1</span>:	<span class="cm">/* first fragment header */</span>
	<span class="k">case</span> <span class="n">LOWPAN_DISPATCH_FRAGN</span>:	<span class="cm">/* next fragments headers */</span>
		<span class="n">lowpan_process_data</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

<span class="nl">drop:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lowpan_newlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">src_net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[],</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">data</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">real_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lowpan_dev_record</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tb</span><span class="p">[</span><span class="n">IFLA_LINK</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/* find and hold real wpan device */</span>
	<span class="n">real_dev</span> <span class="o">=</span> <span class="n">dev_get_by_index</span><span class="p">(</span><span class="n">src_net</span><span class="p">,</span> <span class="n">nla_get_u32</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">IFLA_LINK</span><span class="p">]));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">real_dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">real_dev</span> <span class="o">=</span> <span class="n">real_dev</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev_list_mtx</span><span class="p">);</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lowpan_dev_record</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_put</span><span class="p">(</span><span class="n">real_dev</span><span class="p">);</span>
		<span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">real_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ldev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev_list_mtx</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lowpan_devices</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev_list_mtx</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flist_lock</span><span class="p">);</span>

	<span class="n">register_netdevice</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lowpan_dellink</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lowpan_dev_info</span> <span class="o">*</span><span class="n">lowpan_dev</span> <span class="o">=</span> <span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">real_dev</span> <span class="o">=</span> <span class="n">lowpan_dev</span><span class="o">-&gt;</span><span class="n">real_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lowpan_dev_record</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lowpan_fragment</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="o">*</span><span class="n">tframe</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flist_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">tframe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lowpan_fragments</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flist_lock</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev_list_mtx</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lowpan_devices</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">ldev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev_list_mtx</span><span class="p">);</span>

	<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lowpan_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev_list_mtx</span><span class="p">);</span>

	<span class="n">unregister_netdevice_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

	<span class="n">dev_put</span><span class="p">(</span><span class="n">real_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rtnl_link_ops</span> <span class="n">lowpan_link_ops</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">kind</span>		<span class="o">=</span> <span class="s">&quot;lowpan&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priv_size</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lowpan_dev_info</span><span class="p">),</span>
	<span class="p">.</span><span class="n">setup</span>		<span class="o">=</span> <span class="n">lowpan_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">newlink</span>	<span class="o">=</span> <span class="n">lowpan_newlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dellink</span>	<span class="o">=</span> <span class="n">lowpan_dellink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">validate</span>	<span class="o">=</span> <span class="n">lowpan_validate</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">lowpan_netlink_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rtnl_link_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lowpan_link_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">lowpan_netlink_fini</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rtnl_link_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lowpan_link_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">packet_type</span> <span class="n">lowpan_packet_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">__constant_htons</span><span class="p">(</span><span class="n">ETH_P_IEEE802154</span><span class="p">),</span>
	<span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">lowpan_rcv</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">lowpan_init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">lowpan_netlink_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">dev_add_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lowpan_packet_type</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">lowpan_cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">lowpan_netlink_fini</span><span class="p">();</span>

	<span class="n">dev_remove_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lowpan_packet_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">lowpan_init_module</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">lowpan_cleanup_module</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_RTNL_LINK</span><span class="p">(</span><span class="s">&quot;lowpan&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
