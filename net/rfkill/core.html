<!DOCTYPE html>
<html><head><title>joekychen/linux » net › rfkill › core.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>core.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2006 - 2007 Ivo van Doorn</span>
<span class="cm"> * Copyright (C) 2007 Dmitry Torokhov</span>
<span class="cm"> * Copyright 2009 Johannes Berg &lt;johannes@sipsolutions.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc.,</span>
<span class="cm"> * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/rfkill.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &quot;rfkill.h&quot;</span>

<span class="cp">#define POLL_INTERVAL		(5 * HZ)</span>

<span class="cp">#define RFKILL_BLOCK_HW		BIT(0)</span>
<span class="cp">#define RFKILL_BLOCK_SW		BIT(1)</span>
<span class="cp">#define RFKILL_BLOCK_SW_PREV	BIT(2)</span>
<span class="cp">#define RFKILL_BLOCK_ANY	(RFKILL_BLOCK_HW |\</span>
<span class="cp">				 RFKILL_BLOCK_SW |\</span>
<span class="cp">				 RFKILL_BLOCK_SW_PREV)</span>
<span class="cp">#define RFKILL_BLOCK_SW_SETCALL	BIT(31)</span>

<span class="k">struct</span> <span class="n">rfkill</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>

	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">rfkill_type</span>	<span class="n">type</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">state</span><span class="p">;</span>

	<span class="n">u32</span>			<span class="n">idx</span><span class="p">;</span>

	<span class="n">bool</span>			<span class="n">registered</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">persistent</span><span class="p">;</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">rfkill_ops</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_RFKILL_LEDS</span>
	<span class="k">struct</span> <span class="n">led_trigger</span>	<span class="n">led_trigger</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">ledtrigname</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">struct</span> <span class="n">device</span>		<span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">node</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">poll_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">uevent_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">sync_work</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#define to_rfkill(d)	container_of(d, struct rfkill, dev)</span>

<span class="k">struct</span> <span class="n">rfkill_int_event</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfkill_event</span>	<span class="n">ev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rfkill_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">events</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">mtx</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">read_wait</span><span class="p">;</span>
	<span class="n">bool</span>			<span class="n">input_handler</span><span class="p">;</span>
<span class="p">};</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Ivo van Doorn &lt;IvDoorn@gmail.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Johannes Berg &lt;johannes@sipsolutions.net&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;RF switch support&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * The locking here should be made much smarter, we currently have</span>
<span class="cm"> * a bit of a stupid situation because drivers might want to register</span>
<span class="cm"> * the rfkill struct under their own lock, and take this lock during</span>
<span class="cm"> * rfkill method calls -- which will cause an AB-BA deadlock situation.</span>
<span class="cm"> *</span>
<span class="cm"> * To fix that, we need to rework this code here to be mostly lock-free</span>
<span class="cm"> * and only use the mutex for list manipulations, not to protect the</span>
<span class="cm"> * various other global variables. Then we can avoid holding the mutex</span>
<span class="cm"> * around driver operations, and all is happy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">rfkill_list</span><span class="p">);</span>	<span class="cm">/* list of registered rf switches */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">rfkill_fds</span><span class="p">);</span>	<span class="cm">/* list of open fds of /dev/rfkill */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rfkill_default_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">default_state</span><span class="p">,</span> <span class="n">rfkill_default_state</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">default_state</span><span class="p">,</span>
		 <span class="s">&quot;Default initial state for all radio types, 0 = radio off&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">cur</span><span class="p">,</span> <span class="n">sav</span><span class="p">;</span>
<span class="p">}</span> <span class="n">rfkill_global_states</span><span class="p">[</span><span class="n">NUM_RFKILL_TYPES</span><span class="p">];</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">rfkill_epo_lock_active</span><span class="p">;</span>


<span class="cp">#ifdef CONFIG_RFKILL_LEDS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_led_trigger_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">led_trigger</span> <span class="o">*</span><span class="n">trigger</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">trigger</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">led_trigger</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_ANY</span><span class="p">)</span>
		<span class="n">led_trigger_event</span><span class="p">(</span><span class="n">trigger</span><span class="p">,</span> <span class="n">LED_OFF</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">led_trigger_event</span><span class="p">(</span><span class="n">trigger</span><span class="p">,</span> <span class="n">LED_FULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_led_trigger_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">led_classdev</span> <span class="o">*</span><span class="n">led</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>

	<span class="n">rfkill</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">led</span><span class="o">-&gt;</span><span class="n">trigger</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rfkill</span><span class="p">,</span> <span class="n">led_trigger</span><span class="p">);</span>

	<span class="n">rfkill_led_trigger_event</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rfkill_led_trigger_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">led_trigger</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">ledtrigname</span>
					<span class="o">?</span> <span class="o">:</span> <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">led_trigger</span><span class="p">.</span><span class="n">activate</span> <span class="o">=</span> <span class="n">rfkill_led_trigger_activate</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">led_trigger_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">led_trigger</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_led_trigger_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">led_trigger_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">led_trigger</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_led_trigger_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rfkill_led_trigger_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rfkill_led_trigger_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RFKILL_LEDS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_fill_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill_event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span>
			      <span class="k">enum</span> <span class="n">rfkill_operation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">hard</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_HW</span><span class="p">);</span>
	<span class="n">ev</span><span class="o">-&gt;</span><span class="n">soft</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RFKILL_BLOCK_SW</span> <span class="o">|</span>
					<span class="n">RFKILL_BLOCK_SW_PREV</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_send_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="k">enum</span> <span class="n">rfkill_operation</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfkill_int_event</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfkill_fds</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">rfkill_fill_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">,</span> <span class="n">rfkill</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_CHANGE</span><span class="p">);</span>

	<span class="cm">/* also send event to /dev/rfkill */</span>
	<span class="n">rfkill_send_events</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">RFKILL_OP_CHANGE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">__rfkill_set_hw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span>
				  <span class="n">bool</span> <span class="n">blocked</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">prev</span><span class="p">,</span> <span class="n">any</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_HW</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocked</span><span class="p">)</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">RFKILL_BLOCK_HW</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RFKILL_BLOCK_HW</span><span class="p">;</span>
	<span class="o">*</span><span class="n">change</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">!=</span> <span class="n">blocked</span><span class="p">;</span>
	<span class="n">any</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_ANY</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">rfkill_led_trigger_event</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">any</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_set_block - wrapper for set_block method</span>
<span class="cm"> *</span>
<span class="cm"> * @rfkill: the rfkill struct to use</span>
<span class="cm"> * @blocked: the new software state</span>
<span class="cm"> *</span>
<span class="cm"> * Calls the set_block method (when applicable) and handles notifications</span>
<span class="cm"> * etc. as well.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_set_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">power</span><span class="p">.</span><span class="n">power_state</span><span class="p">.</span><span class="n">event</span> <span class="o">&amp;</span> <span class="n">PM_EVENT_SLEEP</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some platforms (...!) generate input events which affect the</span>
<span class="cm">	 * _hard_ kill state -- whenever something tries to change the</span>
<span class="cm">	 * current software state query the hardware state too.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">query</span><span class="p">)</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">query</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_SW</span><span class="p">)</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">RFKILL_BLOCK_SW_PREV</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RFKILL_BLOCK_SW_PREV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blocked</span><span class="p">)</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">RFKILL_BLOCK_SW</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RFKILL_BLOCK_SW</span><span class="p">;</span>

	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">RFKILL_BLOCK_SW_SETCALL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_block</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">blocked</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Failed -- reset status to _prev, this may be different</span>
<span class="cm">		 * from what set set _PREV to earlier in this function</span>
<span class="cm">		 * if rfkill_set_sw_state was invoked.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_SW_PREV</span><span class="p">)</span>
			<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">RFKILL_BLOCK_SW</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RFKILL_BLOCK_SW</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RFKILL_BLOCK_SW_SETCALL</span><span class="p">;</span>
	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RFKILL_BLOCK_SW_PREV</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">rfkill_led_trigger_event</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>
	<span class="n">rfkill_event</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RFKILL_INPUT</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">rfkill_input_disabled</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __rfkill_switch_all - Toggle state of all switches of given type</span>
<span class="cm"> * @type: type of interfaces to be affected</span>
<span class="cm"> * @state: the new state</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets the state of all switches of given type,</span>
<span class="cm"> * unless a specific switch is claimed by userspace (in which case,</span>
<span class="cm"> * that switch is left alone) or suspended.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must have acquired rfkill_global_mutex.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__rfkill_switch_all</span><span class="p">(</span><span class="k">const</span> <span class="k">enum</span> <span class="n">rfkill_type</span> <span class="n">type</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>

	<span class="n">rfkill_global_states</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">blocked</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfkill_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">rfkill_set_block</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">blocked</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_switch_all - Toggle state of all switches of given type</span>
<span class="cm"> * @type: type of interfaces to be affected</span>
<span class="cm"> * @state: the new state</span>
<span class="cm"> *</span>
<span class="cm"> * Acquires rfkill_global_mutex and calls __rfkill_switch_all(@type, @state).</span>
<span class="cm"> * Please refer to __rfkill_switch_all() for details.</span>
<span class="cm"> *</span>
<span class="cm"> * Does nothing if the EPO lock is active.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rfkill_switch_all</span><span class="p">(</span><span class="k">enum</span> <span class="n">rfkill_type</span> <span class="n">type</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_input_disabled</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkill_epo_lock_active</span><span class="p">)</span>
		<span class="n">__rfkill_switch_all</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">blocked</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_epo - emergency power off all transmitters</span>
<span class="cm"> *</span>
<span class="cm"> * This kicks all non-suspended rfkill devices to RFKILL_STATE_SOFT_BLOCKED,</span>
<span class="cm"> * ignoring everything in its path but rfkill_global_mutex and rfkill-&gt;mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * The global state before the EPO is saved and can be restored later</span>
<span class="cm"> * using rfkill_restore_states().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rfkill_epo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_input_disabled</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>

	<span class="n">rfkill_epo_lock_active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfkill_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="n">rfkill_set_block</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RFKILL_TYPES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rfkill_global_states</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sav</span> <span class="o">=</span> <span class="n">rfkill_global_states</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
		<span class="n">rfkill_global_states</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_restore_states - restore global states</span>
<span class="cm"> *</span>
<span class="cm"> * Restore (and sync switches to) the global state from the</span>
<span class="cm"> * states in rfkill_default_states.  This can undo the effects of</span>
<span class="cm"> * a call to rfkill_epo().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rfkill_restore_states</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_input_disabled</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>

	<span class="n">rfkill_epo_lock_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RFKILL_TYPES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__rfkill_switch_all</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rfkill_global_states</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sav</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_remove_epo_lock - unlock state changes</span>
<span class="cm"> *</span>
<span class="cm"> * Used by rfkill-input manually unlock state changes, when</span>
<span class="cm"> * the EPO switch is deactivated.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">rfkill_remove_epo_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_input_disabled</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
	<span class="n">rfkill_epo_lock_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_is_epo_lock_active - returns true EPO is active</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 (false) if there is NOT an active EPO contidion,</span>
<span class="cm"> * and 1 (true) if there is an active EPO contition, which</span>
<span class="cm"> * locks all radios in one of the BLOCKED states.</span>
<span class="cm"> *</span>
<span class="cm"> * Can be called in atomic context.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">rfkill_is_epo_lock_active</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rfkill_epo_lock_active</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rfkill_get_global_sw_state - returns global state for a type</span>
<span class="cm"> * @type: the type to get the global state of</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the current global state for a given wireless</span>
<span class="cm"> * device type.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">rfkill_get_global_sw_state</span><span class="p">(</span><span class="k">const</span> <span class="k">enum</span> <span class="n">rfkill_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rfkill_global_states</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="n">bool</span> <span class="nf">rfkill_set_hw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">,</span> <span class="n">change</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__rfkill_set_hw_state</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">blocked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">change</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">change</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">uevent_work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rfkill_set_hw_state</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__rfkill_set_sw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">RFKILL_BLOCK_SW</span><span class="p">;</span>

	<span class="cm">/* if in a ops-&gt;set_block right now, use other bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_SW_SETCALL</span><span class="p">)</span>
		<span class="n">bit</span> <span class="o">=</span> <span class="n">RFKILL_BLOCK_SW_PREV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blocked</span><span class="p">)</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">bit</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">rfkill_set_sw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">prev</span><span class="p">,</span> <span class="n">hwblock</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_SW</span><span class="p">);</span>
	<span class="n">__rfkill_set_sw_state</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">blocked</span><span class="p">);</span>
	<span class="n">hwblock</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_HW</span><span class="p">);</span>
	<span class="n">blocked</span> <span class="o">=</span> <span class="n">blocked</span> <span class="o">||</span> <span class="n">hwblock</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">blocked</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">blocked</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hwblock</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">uevent_work</span><span class="p">);</span>

	<span class="n">rfkill_led_trigger_event</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">blocked</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rfkill_set_sw_state</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rfkill_init_sw_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">blocked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__rfkill_set_sw_state</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">blocked</span><span class="p">);</span>
	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">persistent</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rfkill_init_sw_state</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rfkill_set_states</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sw</span><span class="p">,</span> <span class="n">bool</span> <span class="n">hw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">swprev</span><span class="p">,</span> <span class="n">hwprev</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need to care about prev/setblock ... this is for uevent only</span>
<span class="cm">	 * and that will get triggered by rfkill_set_block anyway.</span>
<span class="cm">	 */</span>
	<span class="n">swprev</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_SW</span><span class="p">);</span>
	<span class="n">hwprev</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_HW</span><span class="p">);</span>
	<span class="n">__rfkill_set_sw_state</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">sw</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hw</span><span class="p">)</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">RFKILL_BLOCK_HW</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">RFKILL_BLOCK_HW</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">persistent</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swprev</span> <span class="o">!=</span> <span class="n">sw</span> <span class="o">||</span> <span class="n">hwprev</span> <span class="o">!=</span> <span class="n">hw</span><span class="p">)</span>
			<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">uevent_work</span><span class="p">);</span>

		<span class="n">rfkill_led_trigger_event</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rfkill_set_states</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_name_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">rfkill_get_type_str</span><span class="p">(</span><span class="k">enum</span> <span class="n">rfkill_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">NUM_RFKILL_TYPES</span> <span class="o">!=</span> <span class="n">RFKILL_TYPE_FM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RFKILL_TYPE_WLAN</span>:
		<span class="k">return</span> <span class="s">&quot;wlan&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RFKILL_TYPE_BLUETOOTH</span>:
		<span class="k">return</span> <span class="s">&quot;bluetooth&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RFKILL_TYPE_UWB</span>:
		<span class="k">return</span> <span class="s">&quot;ultrawideband&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RFKILL_TYPE_WIMAX</span>:
		<span class="k">return</span> <span class="s">&quot;wimax&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RFKILL_TYPE_WWAN</span>:
		<span class="k">return</span> <span class="s">&quot;wwan&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RFKILL_TYPE_GPS</span>:
		<span class="k">return</span> <span class="s">&quot;gps&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RFKILL_TYPE_FM</span>:
		<span class="k">return</span> <span class="s">&quot;fm&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_type_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rfkill_get_type_str</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_idx_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_persistent_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">persistent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_hard_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_HW</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_soft_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_SW</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_soft_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
	<span class="n">rfkill_set_block</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">?:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">user_state_from_blocked</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_HW</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RFKILL_USER_STATE_HARD_BLOCKED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_SW</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">RFKILL_USER_STATE_SOFT_BLOCKED</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">RFKILL_USER_STATE_UNBLOCKED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_state_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">user_state_from_blocked</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_state_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">RFKILL_USER_STATE_SOFT_BLOCKED</span> <span class="o">&amp;&amp;</span>
	    <span class="n">state</span> <span class="o">!=</span> <span class="n">RFKILL_USER_STATE_UNBLOCKED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
	<span class="n">rfkill_set_block</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">state</span> <span class="o">==</span> <span class="n">RFKILL_USER_STATE_SOFT_BLOCKED</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">?:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_claim_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_claim_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">rfkill_dev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">rfkill_name_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">rfkill_type_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">rfkill_idx_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">persistent</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">rfkill_persistent_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">rfkill_state_show</span><span class="p">,</span> <span class="n">rfkill_state_store</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">claim</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">rfkill_claim_show</span><span class="p">,</span> <span class="n">rfkill_claim_store</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">soft</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">rfkill_soft_show</span><span class="p">,</span> <span class="n">rfkill_soft_store</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">hard</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">rfkill_hard_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">),</span>
	<span class="n">__ATTR_NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rfkill_dev_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;RFKILL_NAME=%s&quot;</span><span class="p">,</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;RFKILL_TYPE=%s&quot;</span><span class="p">,</span>
			       <span class="n">rfkill_get_type_str</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;RFKILL_STATE=%d&quot;</span><span class="p">,</span>
			       <span class="n">user_state_from_blocked</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rfkill_pause_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">poll_work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rfkill_pause_polling</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rfkill_resume_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">poll_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rfkill_resume_polling</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rfkill_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">rfkill_pause_polling</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rfkill_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span> <span class="o">=</span> <span class="n">to_rfkill</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">cur</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">persistent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_SW</span><span class="p">);</span>
		<span class="n">rfkill_set_block</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rfkill_resume_polling</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="n">rfkill_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;rfkill&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_release</span>	<span class="o">=</span> <span class="n">rfkill_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_attrs</span>	<span class="o">=</span> <span class="n">rfkill_dev_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_uevent</span>	<span class="o">=</span> <span class="n">rfkill_dev_uevent</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">rfkill_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">rfkill_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">bool</span> <span class="nf">rfkill_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_ANY</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rfkill_blocked</span><span class="p">);</span>


<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span> <span class="n">__must_check</span> <span class="nf">rfkill_alloc</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">enum</span> <span class="n">rfkill_type</span> <span class="n">type</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">rfkill_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
					  <span class="kt">void</span> <span class="o">*</span><span class="n">ops_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_block</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">RFKILL_TYPE_ALL</span> <span class="o">||</span> <span class="n">type</span> <span class="o">&gt;=</span> <span class="n">NUM_RFKILL_TYPES</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rfkill</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rfkill</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">ops_data</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rfkill_class</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">device_initialize</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rfkill</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rfkill_alloc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>

	<span class="n">rfkill</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rfkill</span><span class="p">,</span> <span class="n">poll_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Poll hardware state -- driver will use one of the</span>
<span class="cm">	 * rfkill_set{,_hw,_sw}_state functions and use its</span>
<span class="cm">	 * return value to update the current status.</span>
<span class="cm">	 */</span>
	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

	<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">poll_work</span><span class="p">,</span>
		<span class="n">round_jiffies_relative</span><span class="p">(</span><span class="n">POLL_INTERVAL</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_uevent_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>

	<span class="n">rfkill</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rfkill</span><span class="p">,</span> <span class="n">uevent_work</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
	<span class="n">rfkill_event</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rfkill_sync_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">cur</span><span class="p">;</span>

	<span class="n">rfkill</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rfkill</span><span class="p">,</span> <span class="n">sync_work</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">rfkill_global_states</span><span class="p">[</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">].</span><span class="n">cur</span><span class="p">;</span>
	<span class="n">rfkill_set_block</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__must_check</span> <span class="nf">rfkill_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rfkill_no</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">registered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">rfkill_no</span><span class="p">;</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;rfkill%lu&quot;</span><span class="p">,</span> <span class="n">rfkill_no</span><span class="p">);</span>
	<span class="n">rfkill_no</span><span class="o">++</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfkill_list</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">device_add</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">remove</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">rfkill_led_trigger_register</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">devdel</span><span class="p">;</span>

	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">poll_work</span><span class="p">,</span> <span class="n">rfkill_poll</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">uevent_work</span><span class="p">,</span> <span class="n">rfkill_uevent_work</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">sync_work</span><span class="p">,</span> <span class="n">rfkill_sync_work</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">poll_work</span><span class="p">,</span>
			<span class="n">round_jiffies_relative</span><span class="p">(</span><span class="n">POLL_INTERVAL</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">persistent</span> <span class="o">||</span> <span class="n">rfkill_epo_lock_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">sync_work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_RFKILL_INPUT</span>
		<span class="n">bool</span> <span class="n">soft_blocked</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">RFKILL_BLOCK_SW</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_input_disabled</span><span class="p">))</span>
			<span class="n">__rfkill_switch_all</span><span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">soft_blocked</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">rfkill_send_events</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">RFKILL_OP_ADD</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">devdel:</span>
	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
 <span class="nl">remove:</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
 <span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rfkill_register</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rfkill_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rfkill</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)</span>
		<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">poll_work</span><span class="p">);</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">uevent_work</span><span class="p">);</span>
	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">sync_work</span><span class="p">);</span>

	<span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">registered</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">device_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
	<span class="n">rfkill_send_events</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">RFKILL_OP_DEL</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>

	<span class="n">rfkill_led_trigger_unregister</span><span class="p">(</span><span class="n">rfkill</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rfkill_unregister</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">rfkill_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="p">)</span>
		<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rfkill_destroy</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rfkill_fop_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfkill_int_event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * start getting events from elsewhere but hold mtx to get</span>
<span class="cm">	 * startup events added first</span>
<span class="cm">	 */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfkill_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ev</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>
		<span class="n">rfkill_fill_event</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">,</span> <span class="n">rfkill</span><span class="p">,</span> <span class="n">RFKILL_OP_ADD</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfkill_fds</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

 <span class="nl">free:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
	<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">rfkill_fop_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">))</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">rfkill_readable</span><span class="p">(</span><span class="k">struct</span> <span class="n">rfkill_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">r</span> <span class="o">=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_fop_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfkill_int_event</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span>
					       <span class="n">rfkill_readable</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ev</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rfkill_int_event</span><span class="p">,</span>
				<span class="n">list</span><span class="p">);</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">),</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">ev</span><span class="p">,</span> <span class="n">sz</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">rfkill_fop_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill</span> <span class="o">*</span><span class="n">rfkill</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfkill_event</span> <span class="n">ev</span><span class="p">;</span>

	<span class="cm">/* we don&#39;t need the &#39;hard&#39; variable but accept it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">RFKILL_EVENT_SIZE_V1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy as much data as we can accept into our &#39;ev&#39; buffer,</span>
<span class="cm">	 * but tell userspace how much we&#39;ve copied so it can determine</span>
<span class="cm">	 * our API version even in a write() call, if it cares.</span>
<span class="cm">	 */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="p">.</span><span class="n">op</span> <span class="o">!=</span> <span class="n">RFKILL_OP_CHANGE</span> <span class="o">&amp;&amp;</span> <span class="n">ev</span><span class="p">.</span><span class="n">op</span> <span class="o">!=</span> <span class="n">RFKILL_OP_CHANGE_ALL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">NUM_RFKILL_TYPES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="p">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">RFKILL_OP_CHANGE_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">RFKILL_TYPE_ALL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">enum</span> <span class="n">rfkill_type</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RFKILL_TYPES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">rfkill_global_states</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">ev</span><span class="p">.</span><span class="n">soft</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">rfkill_global_states</span><span class="p">[</span><span class="n">ev</span><span class="p">.</span><span class="n">type</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="n">ev</span><span class="p">.</span><span class="n">soft</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfkill_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">!=</span> <span class="n">ev</span><span class="p">.</span><span class="n">idx</span> <span class="o">&amp;&amp;</span> <span class="n">ev</span><span class="p">.</span><span class="n">op</span> <span class="o">!=</span> <span class="n">RFKILL_OP_CHANGE_ALL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rfkill</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ev</span><span class="p">.</span><span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="n">ev</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">RFKILL_TYPE_ALL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">rfkill_set_block</span><span class="p">(</span><span class="n">rfkill</span><span class="p">,</span> <span class="n">ev</span><span class="p">.</span><span class="n">soft</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">rfkill_fop_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rfkill_int_event</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_global_mutex</span><span class="p">);</span>

	<span class="n">mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_RFKILL_INPUT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">input_handler</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_input_disabled</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;rfkill: input handler enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RFKILL_INPUT</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">rfkill_fop_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rfkill_data</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RFKILL_IOC_MAGIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">_IOC_NR</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">RFKILL_IOC_NOINPUT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">input_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_input_disabled</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;rfkill: input handler disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">input_handler</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">mtx</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">rfkill_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">rfkill_fop_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">rfkill_fop_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">rfkill_fop_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">rfkill_fop_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">rfkill_fop_release</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_RFKILL_INPUT</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">rfkill_fop_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">rfkill_fop_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">miscdevice</span> <span class="n">rfkill_miscdev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>	<span class="o">=</span> <span class="s">&quot;rfkill&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">rfkill_fops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">minor</span>	<span class="o">=</span> <span class="n">MISC_DYNAMIC_MINOR</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">rfkill_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_RFKILL_TYPES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rfkill_global_states</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cur</span> <span class="o">=</span> <span class="o">!</span><span class="n">rfkill_default_state</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">misc_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_miscdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_class</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RFKILL_INPUT</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">rfkill_handler_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_miscdev</span><span class="p">);</span>
		<span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_class</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">rfkill_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">rfkill_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RFKILL_INPUT</span>
	<span class="n">rfkill_handler_exit</span><span class="p">();</span>
<span class="cp">#endif</span>
	<span class="n">misc_deregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_miscdev</span><span class="p">);</span>
	<span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfkill_class</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">rfkill_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
