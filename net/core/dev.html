<!DOCTYPE html>
<html><head><title>joekychen/linux » net › core › dev.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dev.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * 	NET3	Protocol independent device support routines.</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *	Derived from the non IP parts of dev.c 1.0.19</span>
<span class="cm"> * 		Authors:	Ross Biro</span>
<span class="cm"> *				Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *				Mark Evans, &lt;evansmp@uhura.aston.ac.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Additional Authors:</span>
<span class="cm"> *		Florian la Roche &lt;rzsfl@rz.uni-sb.de&gt;</span>
<span class="cm"> *		Alan Cox &lt;gw4pts@gw4pts.ampr.org&gt;</span>
<span class="cm"> *		David Hinds &lt;dahinds@users.sourceforge.net&gt;</span>
<span class="cm"> *		Alexey Kuznetsov &lt;kuznet@ms2.inr.ac.ru&gt;</span>
<span class="cm"> *		Adam Sulmicki &lt;adam@cfar.umd.edu&gt;</span>
<span class="cm"> *              Pekka Riikonen &lt;priikone@poesidon.pspt.fi&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Changes:</span>
<span class="cm"> *              D.J. Barrow     :       Fixed bug where dev-&gt;refcnt gets set</span>
<span class="cm"> *              			to 2 if register_netdev gets called</span>
<span class="cm"> *              			before net_dev_init &amp; also removed a</span>
<span class="cm"> *              			few lines of code in the process.</span>
<span class="cm"> *		Alan Cox	:	device private ioctl copies fields back.</span>
<span class="cm"> *		Alan Cox	:	Transmit queue code does relevant</span>
<span class="cm"> *					stunts to keep the queue safe.</span>
<span class="cm"> *		Alan Cox	:	Fixed double lock.</span>
<span class="cm"> *		Alan Cox	:	Fixed promisc NULL pointer trap</span>
<span class="cm"> *		????????	:	Support the full private ioctl range</span>
<span class="cm"> *		Alan Cox	:	Moved ioctl permission check into</span>
<span class="cm"> *					drivers</span>
<span class="cm"> *		Tim Kordas	:	SIOCADDMULTI/SIOCDELMULTI</span>
<span class="cm"> *		Alan Cox	:	100 backlog just doesn&#39;t cut it when</span>
<span class="cm"> *					you start doing multicast video 8)</span>
<span class="cm"> *		Alan Cox	:	Rewrote net_bh and list manager.</span>
<span class="cm"> *		Alan Cox	: 	Fix ETH_P_ALL echoback lengths.</span>
<span class="cm"> *		Alan Cox	:	Took out transmit every packet pass</span>
<span class="cm"> *					Saved a few bytes in the ioctl handler</span>
<span class="cm"> *		Alan Cox	:	Network driver sets packet type before</span>
<span class="cm"> *					calling netif_rx. Saves a function</span>
<span class="cm"> *					call a packet.</span>
<span class="cm"> *		Alan Cox	:	Hashed net_bh()</span>
<span class="cm"> *		Richard Kooijman:	Timestamp fixes.</span>
<span class="cm"> *		Alan Cox	:	Wrong field in SIOCGIFDSTADDR</span>
<span class="cm"> *		Alan Cox	:	Device lock protection.</span>
<span class="cm"> *		Alan Cox	: 	Fixed nasty side effect of device close</span>
<span class="cm"> *					changes.</span>
<span class="cm"> *		Rudi Cilibrasi	:	Pass the right thing to</span>
<span class="cm"> *					set_mac_address()</span>
<span class="cm"> *		Dave Miller	:	32bit quantity for the device lock to</span>
<span class="cm"> *					make it work out on a Sparc.</span>
<span class="cm"> *		Bjorn Ekwall	:	Added KERNELD hack.</span>
<span class="cm"> *		Alan Cox	:	Cleaned up the backlog initialise.</span>
<span class="cm"> *		Craig Metz	:	SIOCGIFCONF fix if space for under</span>
<span class="cm"> *					1 device.</span>
<span class="cm"> *	    Thomas Bogendoerfer :	Return ENODEV for dev_open, if there</span>
<span class="cm"> *					is no device open function.</span>
<span class="cm"> *		Andi Kleen	:	Fix error reporting for SIOCGIFCONF</span>
<span class="cm"> *	    Michael Chastain	:	Fix signed/unsigned for SIOCGIFCONF</span>
<span class="cm"> *		Cyrus Durgin	:	Cleaned for KMOD</span>
<span class="cm"> *		Adam Sulmicki   :	Bug Fix : Network Device Unload</span>
<span class="cm"> *					A network device unload needs to purge</span>
<span class="cm"> *					the backlog queue.</span>
<span class="cm"> *	Paul Rusty Russell	:	SIOCSIFNAME</span>
<span class="cm"> *              Pekka Riikonen  :	Netdev boot-time settings code</span>
<span class="cm"> *              Andrew Morton   :       Make unregister_netdevice wait</span>
<span class="cm"> *              			indefinitely on dev-&gt;refcnt</span>
<span class="cm"> * 		J Hadi Salim	:	- Backlog queue sampling</span>
<span class="cm"> *				        - netif_rx() feedback</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/sockios.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/if_ether.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/etherdevice.h&gt;</span>
<span class="cp">#include &lt;linux/ethtool.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;net/dst.h&gt;</span>
<span class="cp">#include &lt;net/pkt_sched.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;net/xfrm.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/netpoll.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;net/wext.h&gt;</span>
<span class="cp">#include &lt;net/iw_handler.h&gt;</span>
<span class="cp">#include &lt;asm/current.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/dmaengine.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/jhash.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;trace/events/napi.h&gt;</span>
<span class="cp">#include &lt;trace/events/net.h&gt;</span>
<span class="cp">#include &lt;trace/events/skb.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/inetdevice.h&gt;</span>
<span class="cp">#include &lt;linux/cpu_rmap.h&gt;</span>
<span class="cp">#include &lt;linux/net_tstamp.h&gt;</span>
<span class="cp">#include &lt;linux/static_key.h&gt;</span>
<span class="cp">#include &lt;net/flow_keys.h&gt;</span>

<span class="cp">#include &quot;net-sysfs.h&quot;</span>

<span class="cm">/* Instead of increasing this, you should create a hash table. */</span>
<span class="cp">#define MAX_GRO_SKBS 8</span>

<span class="cm">/* This should be increased if a protocol with a bigger head is added. */</span>
<span class="cp">#define GRO_MAX_HEAD (MAX_HEADER + 128)</span>

<span class="cm">/*</span>
<span class="cm"> *	The list of packet types we will receive (as opposed to discard)</span>
<span class="cm"> *	and the routines to invoke.</span>
<span class="cm"> *</span>
<span class="cm"> *	Why 16. Because with 16 the only overlap we get on a hash of the</span>
<span class="cm"> *	low nibble of the protocol value is RARP/SNAP/X.25.</span>
<span class="cm"> *</span>
<span class="cm"> *      NOTE:  That is no longer true with the addition of VLAN tags.  Not</span>
<span class="cm"> *             sure which should go first, but I bet it won&#39;t make much</span>
<span class="cm"> *             difference if we are running VLANs.  The good news is that</span>
<span class="cm"> *             this protocol won&#39;t be in the list unless compiled in, so</span>
<span class="cm"> *             the average user (w/out VLANs) will not be adversely affected.</span>
<span class="cm"> *             --BLG</span>
<span class="cm"> *</span>
<span class="cm"> *		0800	IP</span>
<span class="cm"> *		8100    802.1Q VLAN</span>
<span class="cm"> *		0001	802.3</span>
<span class="cm"> *		0002	AX.25</span>
<span class="cm"> *		0004	802.2</span>
<span class="cm"> *		8035	RARP</span>
<span class="cm"> *		0005	SNAP</span>
<span class="cm"> *		0805	X.25</span>
<span class="cm"> *		0806	ARP</span>
<span class="cm"> *		8137	IPX</span>
<span class="cm"> *		0009	Localtalk</span>
<span class="cm"> *		86DD	IPv6</span>
<span class="cm"> */</span>

<span class="cp">#define PTYPE_HASH_SIZE	(16)</span>
<span class="cp">#define PTYPE_HASH_MASK	(PTYPE_HASH_SIZE - 1)</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ptype_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">ptype_base</span><span class="p">[</span><span class="n">PTYPE_HASH_SIZE</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">ptype_all</span> <span class="n">__read_mostly</span><span class="p">;</span>	<span class="cm">/* Taps */</span>

<span class="cm">/*</span>
<span class="cm"> * The @dev_base_head list is protected by @dev_base_lock and the rtnl</span>
<span class="cm"> * semaphore.</span>
<span class="cm"> *</span>
<span class="cm"> * Pure readers hold dev_base_lock for reading, or rcu_read_lock()</span>
<span class="cm"> *</span>
<span class="cm"> * Writers must hold the rtnl semaphore while they loop through the</span>
<span class="cm"> * dev_base_head list, and hold dev_base_lock for writing when they do the</span>
<span class="cm"> * actual updates.  This allows pure readers to access the list even</span>
<span class="cm"> * while a writer is preparing to update it.</span>
<span class="cm"> *</span>
<span class="cm"> * To put it another way, dev_base_lock is held for writing only to</span>
<span class="cm"> * protect against pure readers; the rtnl semaphore provides the</span>
<span class="cm"> * protection against other writers.</span>
<span class="cm"> *</span>
<span class="cm"> * See, for example usages, register_netdevice() and</span>
<span class="cm"> * unregister_netdevice(), which must be called with the rtnl</span>
<span class="cm"> * semaphore held.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">dev_base_lock</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_base_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dev_base_seq_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_base_seq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="nf">dev_name_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">strnlen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">));</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_name_head</span><span class="p">[</span><span class="n">hash_32</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">NETDEV_HASHBITS</span><span class="p">)];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="nf">dev_index_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_index_head</span><span class="p">[</span><span class="n">ifindex</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NETDEV_HASHENTRIES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rps_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rps_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Device list insertion */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">list_netdevice</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_base_lock</span><span class="p">);</span>
	<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_base_head</span><span class="p">);</span>
	<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name_hlist</span><span class="p">,</span> <span class="n">dev_name_hash</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">index_hlist</span><span class="p">,</span>
			   <span class="n">dev_index_hash</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">));</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_base_lock</span><span class="p">);</span>

	<span class="n">dev_base_seq_inc</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Device list removal</span>
<span class="cm"> * caller must respect a RCU grace period before freeing/reusing dev</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlist_netdevice</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="cm">/* Unlink dev from the device chain */</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_base_lock</span><span class="p">);</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">);</span>
	<span class="n">hlist_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name_hlist</span><span class="p">);</span>
	<span class="n">hlist_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">index_hlist</span><span class="p">);</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_base_lock</span><span class="p">);</span>

	<span class="n">dev_base_seq_inc</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Our notifier list</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">RAW_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">netdev_chain</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Device drivers call our routines to queue packets here. We empty the</span>
<span class="cm"> *	queue in the local softnet handler.</span>
<span class="cm"> */</span>

<span class="n">DEFINE_PER_CPU_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">softnet_data</span><span class="p">,</span> <span class="n">softnet_data</span><span class="p">);</span>
<span class="n">EXPORT_PER_CPU_SYMBOL</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_LOCKDEP</span>
<span class="cm">/*</span>
<span class="cm"> * register_netdevice() inits txq-&gt;_xmit_lock and sets lockdep class</span>
<span class="cm"> * according to dev-&gt;type</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">netdev_lock_type</span><span class="p">[]</span> <span class="o">=</span>
	<span class="p">{</span><span class="n">ARPHRD_NETROM</span><span class="p">,</span> <span class="n">ARPHRD_ETHER</span><span class="p">,</span> <span class="n">ARPHRD_EETHER</span><span class="p">,</span> <span class="n">ARPHRD_AX25</span><span class="p">,</span>
	 <span class="n">ARPHRD_PRONET</span><span class="p">,</span> <span class="n">ARPHRD_CHAOS</span><span class="p">,</span> <span class="n">ARPHRD_IEEE802</span><span class="p">,</span> <span class="n">ARPHRD_ARCNET</span><span class="p">,</span>
	 <span class="n">ARPHRD_APPLETLK</span><span class="p">,</span> <span class="n">ARPHRD_DLCI</span><span class="p">,</span> <span class="n">ARPHRD_ATM</span><span class="p">,</span> <span class="n">ARPHRD_METRICOM</span><span class="p">,</span>
	 <span class="n">ARPHRD_IEEE1394</span><span class="p">,</span> <span class="n">ARPHRD_EUI64</span><span class="p">,</span> <span class="n">ARPHRD_INFINIBAND</span><span class="p">,</span> <span class="n">ARPHRD_SLIP</span><span class="p">,</span>
	 <span class="n">ARPHRD_CSLIP</span><span class="p">,</span> <span class="n">ARPHRD_SLIP6</span><span class="p">,</span> <span class="n">ARPHRD_CSLIP6</span><span class="p">,</span> <span class="n">ARPHRD_RSRVD</span><span class="p">,</span>
	 <span class="n">ARPHRD_ADAPT</span><span class="p">,</span> <span class="n">ARPHRD_ROSE</span><span class="p">,</span> <span class="n">ARPHRD_X25</span><span class="p">,</span> <span class="n">ARPHRD_HWX25</span><span class="p">,</span>
	 <span class="n">ARPHRD_PPP</span><span class="p">,</span> <span class="n">ARPHRD_CISCO</span><span class="p">,</span> <span class="n">ARPHRD_LAPB</span><span class="p">,</span> <span class="n">ARPHRD_DDCMP</span><span class="p">,</span>
	 <span class="n">ARPHRD_RAWHDLC</span><span class="p">,</span> <span class="n">ARPHRD_TUNNEL</span><span class="p">,</span> <span class="n">ARPHRD_TUNNEL6</span><span class="p">,</span> <span class="n">ARPHRD_FRAD</span><span class="p">,</span>
	 <span class="n">ARPHRD_SKIP</span><span class="p">,</span> <span class="n">ARPHRD_LOOPBACK</span><span class="p">,</span> <span class="n">ARPHRD_LOCALTLK</span><span class="p">,</span> <span class="n">ARPHRD_FDDI</span><span class="p">,</span>
	 <span class="n">ARPHRD_BIF</span><span class="p">,</span> <span class="n">ARPHRD_SIT</span><span class="p">,</span> <span class="n">ARPHRD_IPDDP</span><span class="p">,</span> <span class="n">ARPHRD_IPGRE</span><span class="p">,</span>
	 <span class="n">ARPHRD_PIMREG</span><span class="p">,</span> <span class="n">ARPHRD_HIPPI</span><span class="p">,</span> <span class="n">ARPHRD_ASH</span><span class="p">,</span> <span class="n">ARPHRD_ECONET</span><span class="p">,</span>
	 <span class="n">ARPHRD_IRDA</span><span class="p">,</span> <span class="n">ARPHRD_FCPP</span><span class="p">,</span> <span class="n">ARPHRD_FCAL</span><span class="p">,</span> <span class="n">ARPHRD_FCPL</span><span class="p">,</span>
	 <span class="n">ARPHRD_FCFABRIC</span><span class="p">,</span> <span class="n">ARPHRD_IEEE80211</span><span class="p">,</span> <span class="n">ARPHRD_IEEE80211_PRISM</span><span class="p">,</span>
	 <span class="n">ARPHRD_IEEE80211_RADIOTAP</span><span class="p">,</span> <span class="n">ARPHRD_PHONET</span><span class="p">,</span> <span class="n">ARPHRD_PHONET_PIPE</span><span class="p">,</span>
	 <span class="n">ARPHRD_IEEE802154</span><span class="p">,</span> <span class="n">ARPHRD_VOID</span><span class="p">,</span> <span class="n">ARPHRD_NONE</span><span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">netdev_lock_name</span><span class="p">[]</span> <span class="o">=</span>
	<span class="p">{</span><span class="s">&quot;_xmit_NETROM&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_ETHER&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_EETHER&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_AX25&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_PRONET&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_CHAOS&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_IEEE802&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_ARCNET&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_APPLETLK&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_DLCI&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_ATM&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_METRICOM&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_IEEE1394&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_EUI64&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_INFINIBAND&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_SLIP&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_CSLIP&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_SLIP6&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_CSLIP6&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_RSRVD&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_ADAPT&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_ROSE&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_X25&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_HWX25&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_PPP&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_CISCO&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_LAPB&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_DDCMP&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_RAWHDLC&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_TUNNEL&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_TUNNEL6&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_FRAD&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_SKIP&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_LOOPBACK&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_LOCALTLK&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_FDDI&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_BIF&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_SIT&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_IPDDP&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_IPGRE&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_PIMREG&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_HIPPI&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_ASH&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_ECONET&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_IRDA&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_FCPP&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_FCAL&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_FCPL&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_FCFABRIC&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_IEEE80211&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_IEEE80211_PRISM&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_IEEE80211_RADIOTAP&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_PHONET&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_PHONET_PIPE&quot;</span><span class="p">,</span>
	 <span class="s">&quot;_xmit_IEEE802154&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_VOID&quot;</span><span class="p">,</span> <span class="s">&quot;_xmit_NONE&quot;</span><span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">netdev_xmit_lock_key</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">netdev_lock_type</span><span class="p">)];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">netdev_addr_lock_key</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">netdev_lock_type</span><span class="p">)];</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">netdev_lock_pos</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">dev_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">netdev_lock_type</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netdev_lock_type</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">dev_type</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="cm">/* the last key is used by default */</span>
	<span class="k">return</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">netdev_lock_type</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_set_xmit_lockdep_class</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">dev_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">netdev_lock_pos</span><span class="p">(</span><span class="n">dev_type</span><span class="p">);</span>
	<span class="n">lockdep_set_class_and_name</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netdev_xmit_lock_key</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				   <span class="n">netdev_lock_name</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_set_addr_lockdep_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">netdev_lock_pos</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="n">lockdep_set_class_and_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_list_lock</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">netdev_addr_lock_key</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				   <span class="n">netdev_lock_name</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_set_xmit_lockdep_class</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">dev_type</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">netdev_set_addr_lockdep_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*******************************************************************************</span>

<span class="cm">		Protocol management and registration routines</span>

<span class="cm">*******************************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> *	Add a protocol ID to the list. Now that the input handler is</span>
<span class="cm"> *	smarter we can dispense with all the messy stuff that used to be</span>
<span class="cm"> *	here.</span>
<span class="cm"> *</span>
<span class="cm"> *	BEWARE!!! Protocol handlers, mangling input packets,</span>
<span class="cm"> *	MUST BE last in hash buckets and checking protocol handlers</span>
<span class="cm"> *	MUST start from promiscuous ptype_all chain in net_bh.</span>
<span class="cm"> *	It is true now, do not change it.</span>
<span class="cm"> *	Explanation follows: if protocol handler, mangling packet, will</span>
<span class="cm"> *	be the first on list, it is not able to sense, that packet</span>
<span class="cm"> *	is cloned and should be copied-on-write, so that it will</span>
<span class="cm"> *	change it and subsequent readers will get broken packet.</span>
<span class="cm"> *							--ANK (980803)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="nf">ptype_head</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_ALL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">ptype_base</span><span class="p">[</span><span class="n">ntohs</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PTYPE_HASH_MASK</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_add_pack - add packet handler</span>
<span class="cm"> *	@pt: packet type declaration</span>
<span class="cm"> *</span>
<span class="cm"> *	Add a protocol handler to the networking stack. The passed &amp;packet_type</span>
<span class="cm"> *	is linked into kernel lists and may not be freed until it has been</span>
<span class="cm"> *	removed from the kernel lists.</span>
<span class="cm"> *</span>
<span class="cm"> *	This call does not sleep therefore it can not</span>
<span class="cm"> *	guarantee all CPU&#39;s that are in middle of receiving packets</span>
<span class="cm"> *	will see the new packet type (until the next received packet).</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">dev_add_pack</span><span class="p">(</span><span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">ptype_head</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptype_lock</span><span class="p">);</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptype_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_add_pack</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	__dev_remove_pack	 - remove packet handler</span>
<span class="cm"> *	@pt: packet type declaration</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove a protocol handler that was previously added to the kernel</span>
<span class="cm"> *	protocol handlers by dev_add_pack(). The passed &amp;packet_type is removed</span>
<span class="cm"> *	from the kernel lists and can be freed or reused once this function</span>
<span class="cm"> *	returns.</span>
<span class="cm"> *</span>
<span class="cm"> *      The packet type might still be in use by receivers</span>
<span class="cm"> *	and must not be freed until after all the CPU&#39;s have gone</span>
<span class="cm"> *	through a quiescent state.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__dev_remove_pack</span><span class="p">(</span><span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">ptype_head</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptype_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pt</span> <span class="o">==</span> <span class="n">pt1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;dev_remove_pack: %p not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pt</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptype_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__dev_remove_pack</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_remove_pack	 - remove packet handler</span>
<span class="cm"> *	@pt: packet type declaration</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove a protocol handler that was previously added to the kernel</span>
<span class="cm"> *	protocol handlers by dev_add_pack(). The passed &amp;packet_type is removed</span>
<span class="cm"> *	from the kernel lists and can be freed or reused once this function</span>
<span class="cm"> *	returns.</span>
<span class="cm"> *</span>
<span class="cm"> *	This call sleeps to guarantee that no CPU is looking at the packet</span>
<span class="cm"> *	type after return.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dev_remove_pack</span><span class="p">(</span><span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__dev_remove_pack</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>

	<span class="n">synchronize_net</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_remove_pack</span><span class="p">);</span>

<span class="cm">/******************************************************************************</span>

<span class="cm">		      Device Boot-time Settings Routines</span>

<span class="cm">*******************************************************************************/</span>

<span class="cm">/* Boot time configuration table */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">netdev_boot_setup</span> <span class="n">dev_boot_setup</span><span class="p">[</span><span class="n">NETDEV_BOOT_SETUP_MAX</span><span class="p">];</span>

<span class="cm">/**</span>
<span class="cm"> *	netdev_boot_setup_add	- add new setup entry</span>
<span class="cm"> *	@name: name of the device</span>
<span class="cm"> *	@map: configured settings for the device</span>
<span class="cm"> *</span>
<span class="cm"> *	Adds new setup entry to the dev_boot_setup list.  The function</span>
<span class="cm"> *	returns 0 on error and 1 on success.  This is a generic routine to</span>
<span class="cm"> *	all netdevices.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netdev_boot_setup_add</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifmap</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_boot_setup</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">dev_boot_setup</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NETDEV_BOOT_SETUP_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">));</span>
			<span class="n">strlcpy</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">map</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">map</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">NETDEV_BOOT_SETUP_MAX</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netdev_boot_setup_check	- check boot time settings</span>
<span class="cm"> *	@dev: the netdevice</span>
<span class="cm"> *</span>
<span class="cm"> * 	Check boot time settings for the device.</span>
<span class="cm"> *	The found settings are set for the device to be used</span>
<span class="cm"> *	later in the device probing.</span>
<span class="cm"> *	Returns 0 if no settings found, 1 if they are.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netdev_boot_setup_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_boot_setup</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">dev_boot_setup</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NETDEV_BOOT_SETUP_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span> 	<span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">map</span><span class="p">.</span><span class="n">irq</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span> 	<span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">map</span><span class="p">.</span><span class="n">base_addr</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span> 	<span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">map</span><span class="p">.</span><span class="n">mem_start</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span> 	<span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">map</span><span class="p">.</span><span class="n">mem_end</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_boot_setup_check</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> *	netdev_boot_base	- get address from boot time settings</span>
<span class="cm"> *	@prefix: prefix for network device</span>
<span class="cm"> *	@unit: id for network device</span>
<span class="cm"> *</span>
<span class="cm"> * 	Check boot time settings for the base address of device.</span>
<span class="cm"> *	The found settings are set for the device to be used</span>
<span class="cm"> *	later in the device probing.</span>
<span class="cm"> *	Returns 0 if no settings found.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">netdev_boot_base</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">netdev_boot_setup</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">dev_boot_setup</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%s%d&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If device already registered then return base of 1</span>
<span class="cm">	 * to indicate not to probe for this interface</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__dev_get_by_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NETDEV_BOOT_SETUP_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">map</span><span class="p">.</span><span class="n">base_addr</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Saves at boot time configured settings for any netdevice.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">netdev_boot_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ints</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">ifmap</span> <span class="n">map</span><span class="p">;</span>

	<span class="n">str</span> <span class="o">=</span> <span class="n">get_options</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ints</span><span class="p">),</span> <span class="n">ints</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">str</span> <span class="o">||</span> <span class="o">!*</span><span class="n">str</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Save settings */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">map</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">map</span><span class="p">.</span><span class="n">irq</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">map</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">map</span><span class="p">.</span><span class="n">mem_start</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">map</span><span class="p">.</span><span class="n">mem_end</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/* Add new entry to the list */</span>
	<span class="k">return</span> <span class="n">netdev_boot_setup_add</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;netdev=&quot;</span><span class="p">,</span> <span class="n">netdev_boot_setup</span><span class="p">);</span>

<span class="cm">/*******************************************************************************</span>

<span class="cm">			    Device Interface Subroutines</span>

<span class="cm">*******************************************************************************/</span>

<span class="cm">/**</span>
<span class="cm"> *	__dev_get_by_name	- find a device by its name</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *	@name: name to find</span>
<span class="cm"> *</span>
<span class="cm"> *	Find an interface by name. Must be called under RTNL semaphore</span>
<span class="cm"> *	or @dev_base_lock. If the name is found a pointer to the device</span>
<span class="cm"> *	is returned. If the name is not found then %NULL is returned. The</span>
<span class="cm"> *	reference counters are not incremented so the caller must be</span>
<span class="cm"> *	careful with locks.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">__dev_get_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">dev_name_hash</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">name_hlist</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__dev_get_by_name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_get_by_name_rcu	- find a device by its name</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *	@name: name to find</span>
<span class="cm"> *</span>
<span class="cm"> *	Find an interface by name.</span>
<span class="cm"> *	If the name is found a pointer to the device is returned.</span>
<span class="cm"> * 	If the name is not found then %NULL is returned.</span>
<span class="cm"> *	The reference counters are not incremented so the caller must be</span>
<span class="cm"> *	careful with locks. The caller must hold RCU lock.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">dev_get_by_name_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">dev_name_hash</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">name_hlist</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_get_by_name_rcu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_get_by_name		- find a device by its name</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *	@name: name to find</span>
<span class="cm"> *</span>
<span class="cm"> *	Find an interface by name. This can be called from any</span>
<span class="cm"> *	context and does its own locking. The returned handle has</span>
<span class="cm"> *	the usage count incremented and the caller must use dev_put() to</span>
<span class="cm"> *	release it when it is no longer needed. %NULL is returned if no</span>
<span class="cm"> *	matching device is found.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">dev_get_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_name_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">dev_hold</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_get_by_name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	__dev_get_by_index - find a device by its ifindex</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *	@ifindex: index of device</span>
<span class="cm"> *</span>
<span class="cm"> *	Search for an interface by index. Returns %NULL if the device</span>
<span class="cm"> *	is not found or a pointer to the device. The device has not</span>
<span class="cm"> *	had its reference counter increased so the caller must be careful</span>
<span class="cm"> *	about locking. The caller must hold either the RTNL semaphore</span>
<span class="cm"> *	or @dev_base_lock.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">__dev_get_by_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">dev_index_hash</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">index_hlist</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">==</span> <span class="n">ifindex</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__dev_get_by_index</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_get_by_index_rcu - find a device by its ifindex</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *	@ifindex: index of device</span>
<span class="cm"> *</span>
<span class="cm"> *	Search for an interface by index. Returns %NULL if the device</span>
<span class="cm"> *	is not found or a pointer to the device. The device has not</span>
<span class="cm"> *	had its reference counter increased so the caller must be careful</span>
<span class="cm"> *	about locking. The caller must hold RCU lock.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">dev_get_by_index_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">dev_index_hash</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>

	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">index_hlist</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">==</span> <span class="n">ifindex</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_get_by_index_rcu</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> *	dev_get_by_index - find a device by its ifindex</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *	@ifindex: index of device</span>
<span class="cm"> *</span>
<span class="cm"> *	Search for an interface by index. Returns NULL if the device</span>
<span class="cm"> *	is not found or a pointer to the device. The device returned has</span>
<span class="cm"> *	had a reference added and the pointer is safe until the user calls</span>
<span class="cm"> *	dev_put to indicate they have finished with it.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">dev_get_by_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">dev_hold</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_get_by_index</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_getbyhwaddr_rcu - find a device by its hardware address</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *	@type: media type of device</span>
<span class="cm"> *	@ha: hardware address</span>
<span class="cm"> *</span>
<span class="cm"> *	Search for an interface by MAC address. Returns NULL if the device</span>
<span class="cm"> *	is not found or a pointer to the device.</span>
<span class="cm"> *	The caller must hold RCU or RTNL.</span>
<span class="cm"> *	The returned device has not had its ref count increased</span>
<span class="cm"> *	and the caller must therefore be careful about locking</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">dev_getbyhwaddr_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">type</span><span class="p">,</span>
				       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ha</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">for_each_netdev_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span> <span class="n">ha</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_getbyhwaddr_rcu</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">__dev_getfirstbyhwtype</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>
	<span class="n">for_each_netdev</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__dev_getfirstbyhwtype</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">dev_getfirstbyhwtype</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_netdev_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_hold</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_getfirstbyhwtype</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_get_by_flags_rcu - find any device with given flags</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *	@if_flags: IFF_* values</span>
<span class="cm"> *	@mask: bitmask of bits in if_flags to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Search for any interface with the given flags. Returns NULL if a device</span>
<span class="cm"> *	is not found or a pointer to the device. Must be called inside</span>
<span class="cm"> *	rcu_read_lock(), and result refcount is unchanged.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">dev_get_by_flags_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">if_flags</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">for_each_netdev_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">^</span> <span class="n">if_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_get_by_flags_rcu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_valid_name - check if name is okay for network device</span>
<span class="cm"> *	@name: name string</span>
<span class="cm"> *</span>
<span class="cm"> *	Network device names need to be valid file names to</span>
<span class="cm"> *	to allow sysfs to work.  We also disallow any kind of</span>
<span class="cm"> *	whitespace.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">dev_valid_name</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">name</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">IFNAMSIZ</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">name</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="o">||</span> <span class="n">isspace</span><span class="p">(</span><span class="o">*</span><span class="n">name</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">name</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_valid_name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	__dev_alloc_name - allocate a name for a device</span>
<span class="cm"> *	@net: network namespace to allocate the device name in</span>
<span class="cm"> *	@name: name format string</span>
<span class="cm"> *	@buf:  scratch buffer and result name string</span>
<span class="cm"> *</span>
<span class="cm"> *	Passed a format string - eg &quot;lt%d&quot; it will try and find a suitable</span>
<span class="cm"> *	id. It scans list of devices to build up a free map, then chooses</span>
<span class="cm"> *	the first empty slot. The caller must hold the dev_base or rtnl lock</span>
<span class="cm"> *	while allocating the name and adding the device in order to avoid</span>
<span class="cm"> *	duplicates.</span>
<span class="cm"> *	Limited to bits_per_byte * page size devices (ie 32K on most platforms).</span>
<span class="cm"> *	Returns the number of the unit assigned or a negative errno code.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dev_alloc_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">max_netdevices</span> <span class="o">=</span> <span class="mi">8</span><span class="o">*</span><span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">inuse</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">d</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">strnchr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="sc">&#39;%&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Verify the string as this thing may have come from</span>
<span class="cm">		 * the user.  There must be either one &quot;%d&quot; and no other &quot;%&quot;</span>
<span class="cm">		 * characters.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;d&#39;</span> <span class="o">||</span> <span class="n">strchr</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="sc">&#39;%&#39;</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* Use one page as a bit array of possible slots */</span>
		<span class="n">inuse</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span> <span class="n">get_zeroed_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inuse</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">for_each_netdev</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sscanf</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">max_netdevices</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/*  avoid cases where sscanf is not exact inverse of printf */</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">))</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">inuse</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">i</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">inuse</span><span class="p">,</span> <span class="n">max_netdevices</span><span class="p">);</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">inuse</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="n">name</span><span class="p">)</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__dev_get_by_name</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* It is possible to run out of possible slots</span>
<span class="cm">	 * when the name is long and there isn&#39;t enough space left</span>
<span class="cm">	 * for the digits, or if all bits are used.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_alloc_name - allocate a name for a device</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@name: name format string</span>
<span class="cm"> *</span>
<span class="cm"> *	Passed a format string - eg &quot;lt%d&quot; it will try and find a suitable</span>
<span class="cm"> *	id. It scans list of devices to build up a free map, then chooses</span>
<span class="cm"> *	the first empty slot. The caller must hold the dev_base or rtnl lock</span>
<span class="cm"> *	while allocating the name and adding the device in order to avoid</span>
<span class="cm"> *	duplicates.</span>
<span class="cm"> *	Limited to bits_per_byte * page size devices (ie 32K on most platforms).</span>
<span class="cm"> *	Returns the number of the unit assigned or a negative errno code.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">dev_alloc_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__dev_alloc_name</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_alloc_name</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_get_valid_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_valid_name</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39;%&#39;</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">dev_alloc_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">__dev_get_by_name</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">)</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_change_name - change name of a device</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@newname: name (or format string) must be at least IFNAMSIZ</span>
<span class="cm"> *</span>
<span class="cm"> *	Change name of a device, can pass format strings &quot;eth%d&quot;.</span>
<span class="cm"> *	for wildcarding.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_change_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">oldname</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">newname</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">oldname</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dev_get_valid_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">newname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">rollback:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">device_rename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_base_lock</span><span class="p">);</span>
	<span class="n">hlist_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name_hlist</span><span class="p">);</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_base_lock</span><span class="p">);</span>

	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_base_lock</span><span class="p">);</span>
	<span class="n">hlist_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name_hlist</span><span class="p">,</span> <span class="n">dev_name_hash</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_base_lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_CHANGENAME</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">notifier_to_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* err &gt;= 0 after dev_alloc_name() or stores the first errno */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">oldname</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">rollback</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: name change rollback failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_set_alias - change ifalias of a device</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@alias: name up to IFALIASZ</span>
<span class="cm"> *	@len: limit of bytes to copy from info</span>
<span class="cm"> *</span>
<span class="cm"> *	Set ifalias for a device,</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_set_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alias</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">IFALIASZ</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifalias</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifalias</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifalias</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifalias</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifalias</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifalias</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">strlcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifalias</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	netdev_features_change - device changes features</span>
<span class="cm"> *	@dev: device to cause notification</span>
<span class="cm"> *</span>
<span class="cm"> *	Called to indicate a device has changed features.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netdev_features_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_FEAT_CHANGE</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_features_change</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	netdev_state_change - device changes state</span>
<span class="cm"> *	@dev: device to cause notification</span>
<span class="cm"> *</span>
<span class="cm"> *	Called to indicate a device has changed state. This function calls</span>
<span class="cm"> *	the notifier chains for netdev_chain and sends a NEWLINK message</span>
<span class="cm"> *	to the routing socket.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netdev_state_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_CHANGE</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="n">rtmsg_ifinfo</span><span class="p">(</span><span class="n">RTM_NEWLINK</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_state_change</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">netdev_bonding_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_bonding_change</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_load 	- load a network module</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *	@name: name of interface</span>
<span class="cm"> *</span>
<span class="cm"> *	If a network interface is not present and the process has suitable</span>
<span class="cm"> *	privileges this function loads the module. If module loading is not</span>
<span class="cm"> *	available in this kernel then it becomes a nop.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">dev_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">no_module</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_name_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">no_module</span> <span class="o">=</span> <span class="o">!</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">no_module</span> <span class="o">&amp;&amp;</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
		<span class="n">no_module</span> <span class="o">=</span> <span class="n">request_module</span><span class="p">(</span><span class="s">&quot;netdev-%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">no_module</span> <span class="o">&amp;&amp;</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_MODULE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_module</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Loading kernel module for a network device with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s instead.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_load</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_PRE_UP</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">notifier_to_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">__LINK_STATE_START</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_validate_addr</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_validate_addr</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_open</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_open</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">__LINK_STATE_START</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IFF_UP</span><span class="p">;</span>
		<span class="n">net_dmaengine_get</span><span class="p">();</span>
		<span class="n">dev_set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev_activate</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_open	- prepare an interface for use.</span>
<span class="cm"> *	@dev:	device to open</span>
<span class="cm"> *</span>
<span class="cm"> *	Takes a device from down to up state. The device&#39;s private open</span>
<span class="cm"> *	function is invoked and then the multicast lists are loaded. Finally</span>
<span class="cm"> *	the device is moved into the up state and a %NETDEV_UP message is</span>
<span class="cm"> *	sent to the netdev notifier chain.</span>
<span class="cm"> *</span>
<span class="cm"> *	Calling this function on an active interface is a nop. On a failure</span>
<span class="cm"> *	a negative errno code is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__dev_open</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rtmsg_ifinfo</span><span class="p">(</span><span class="n">RTM_NEWLINK</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">IFF_UP</span><span class="o">|</span><span class="n">IFF_RUNNING</span><span class="p">);</span>
	<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_UP</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_open</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dev_close_many</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>
	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">unreg_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_GOING_DOWN</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

		<span class="n">clear_bit</span><span class="p">(</span><span class="n">__LINK_STATE_START</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

		<span class="cm">/* Synchronize to scheduled poll. We cannot touch poll list, it</span>
<span class="cm">		 * can be even on different cpu. So just clear netif_running().</span>
<span class="cm">		 *</span>
<span class="cm">		 * dev-&gt;stop() will invoke napi_disable() on all of it&#39;s</span>
<span class="cm">		 * napi_struct instances on this device.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span> <span class="cm">/* Commit netif_running(). */</span>
	<span class="p">}</span>

	<span class="n">dev_deactivate_many</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">unreg_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	Call the device specific close. This cannot fail.</span>
<span class="cm">		 *	Only if device is UP</span>
<span class="cm">		 *</span>
<span class="cm">		 *	We allow it to be called even after a DETACH hot-plug</span>
<span class="cm">		 *	event.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_stop</span><span class="p">)</span>
			<span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_stop</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IFF_UP</span><span class="p">;</span>
		<span class="n">net_dmaengine_put</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">single</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unreg_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">single</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">__dev_close_many</span><span class="p">(</span><span class="o">&amp;</span><span class="n">single</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">single</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_close_many</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">unreg_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">))</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unreg_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">);</span>

	<span class="n">__dev_close_many</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">unreg_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtmsg_ifinfo</span><span class="p">(</span><span class="n">RTM_NEWLINK</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">IFF_UP</span><span class="o">|</span><span class="n">IFF_RUNNING</span><span class="p">);</span>
		<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_DOWN</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* rollback_registered_many needs the complete original list */</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_close - shutdown an interface.</span>
<span class="cm"> *	@dev: device to shutdown</span>
<span class="cm"> *</span>
<span class="cm"> *	This function moves an active device into down state. A</span>
<span class="cm"> *	%NETDEV_GOING_DOWN is sent to the netdev notifier chain. The device</span>
<span class="cm"> *	is then deactivated and finally a %NETDEV_DOWN is sent to the notifier</span>
<span class="cm"> *	chain.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">single</span><span class="p">);</span>

		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unreg_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">single</span><span class="p">);</span>
		<span class="n">dev_close_many</span><span class="p">(</span><span class="o">&amp;</span><span class="n">single</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">single</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_close</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> *	dev_disable_lro - disable Large Receive Offload on a device</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *</span>
<span class="cm"> *	Disable Large Receive Offload (LRO) on a net device.  Must be</span>
<span class="cm"> *	called under RTNL.  This is needed if received packets may be</span>
<span class="cm"> *	forwarded to another interface.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dev_disable_lro</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re trying to disable lro on a vlan device</span>
<span class="cm">	 * use the underlying physical device instead</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_vlan_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">vlan_dev_real_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">wanted_features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_LRO</span><span class="p">;</span>
	<span class="n">netdev_update_features</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_LRO</span><span class="p">))</span>
		<span class="n">netdev_WARN</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to disable LRO!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_disable_lro</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">dev_boot_phase</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> *	register_netdevice_notifier - register a network notifier block</span>
<span class="cm"> *	@nb: notifier</span>
<span class="cm"> *</span>
<span class="cm"> *	Register a notifier to be called when network device events occur.</span>
<span class="cm"> *	The notifier passed is linked into the kernel structures and must</span>
<span class="cm"> *	not be reused until it has been unregistered. A negative errno code</span>
<span class="cm"> *	is returned on a failure.</span>
<span class="cm"> *</span>
<span class="cm"> * 	When registered all registration and up events are replayed</span>
<span class="cm"> *	to the new notifier to allow device to have a race free</span>
<span class="cm"> *	view of the network device list.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">register_netdevice_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">raw_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netdev_chain</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_boot_phase</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="n">for_each_net</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_netdev</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">NETDEV_REGISTER</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">notifier_to_errno</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">rollback</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">NETDEV_UP</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">unlock:</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">rollback:</span>
	<span class="n">last</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">for_each_net</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_netdev</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">outroll</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">NETDEV_GOING_DOWN</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
				<span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">NETDEV_DOWN</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">NETDEV_UNREGISTER</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">NETDEV_UNREGISTER_BATCH</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">outroll:</span>
	<span class="n">raw_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netdev_chain</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_netdevice_notifier</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	unregister_netdevice_notifier - unregister a network notifier block</span>
<span class="cm"> *	@nb: notifier</span>
<span class="cm"> *</span>
<span class="cm"> *	Unregister a notifier previously registered by</span>
<span class="cm"> *	register_netdevice_notifier(). The notifier is unlinked into the</span>
<span class="cm"> *	kernel structures and may then be reused. A negative errno code</span>
<span class="cm"> *	is returned on a failure.</span>
<span class="cm"> *</span>
<span class="cm"> * 	After unregistering unregister and down device events are synthesized</span>
<span class="cm"> *	for all devices on the device list to the removed notifier to remove</span>
<span class="cm"> *	the need for special case cleanup code.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">unregister_netdevice_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">raw_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netdev_chain</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">for_each_net</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_netdev</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">NETDEV_GOING_DOWN</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
				<span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">NETDEV_DOWN</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">NETDEV_UNREGISTER</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="n">nb</span><span class="o">-&gt;</span><span class="n">notifier_call</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">NETDEV_UNREGISTER_BATCH</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_netdevice_notifier</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	call_netdevice_notifiers - call all network notifier blocks</span>
<span class="cm"> *      @val: value passed unmodified to notifier function</span>
<span class="cm"> *      @dev: net_device pointer passed unmodified to notifier function</span>
<span class="cm"> *</span>
<span class="cm"> *	Call all network notifier blocks.  Parameters and return value</span>
<span class="cm"> *	are as for raw_notifier_call_chain().</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">call_netdevice_notifiers</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT_RTNL</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">raw_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netdev_chain</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">call_netdevice_notifiers</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">static_key</span> <span class="n">netstamp_needed</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="cp">#ifdef HAVE_JUMP_LABEL</span>
<span class="cm">/* We are not allowed to call static_key_slow_dec() from irq context</span>
<span class="cm"> * If net_disable_timestamp() is called from irq context, defer the</span>
<span class="cm"> * static_key_slow_dec() calls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">netstamp_needed_deferred</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">net_enable_timestamp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef HAVE_JUMP_LABEL</span>
	<span class="kt">int</span> <span class="n">deferred</span> <span class="o">=</span> <span class="n">atomic_xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netstamp_needed_deferred</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">deferred</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">deferred</span><span class="p">)</span>
			<span class="n">static_key_slow_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netstamp_needed</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">in_interrupt</span><span class="p">());</span>
	<span class="n">static_key_slow_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netstamp_needed</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">net_enable_timestamp</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">net_disable_timestamp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef HAVE_JUMP_LABEL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netstamp_needed_deferred</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">static_key_slow_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netstamp_needed</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">net_disable_timestamp</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">net_timestamp_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">static_key_false</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netstamp_needed</span><span class="p">))</span>
		<span class="n">__net_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define net_timestamp_check(COND, SKB)			\</span>
<span class="cp">	if (static_key_false(&amp;netstamp_needed)) {		\</span>
<span class="cp">		if ((COND) &amp;&amp; !(SKB)-&gt;tstamp.tv64)	\</span>
<span class="cp">			__net_timestamp(SKB);		\</span>
<span class="cp">	}						\</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">net_hwtstamp_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hwtstamp_config</span> <span class="n">cfg</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">hwtstamp_tx_types</span> <span class="n">tx_type</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">hwtstamp_rx_filters</span> <span class="n">rx_filter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tx_type_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rx_filter_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cfg</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">flags</span><span class="p">)</span> <span class="cm">/* reserved for future extensions */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">tx_type</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">.</span><span class="n">tx_type</span><span class="p">;</span>
	<span class="n">rx_filter</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">.</span><span class="n">rx_filter</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">tx_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_TX_OFF</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_TX_ON</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_TX_ONESTEP_SYNC</span>:
		<span class="n">tx_type_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">rx_filter</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_NONE</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_ALL</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_SOME</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V1_L4_EVENT</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V1_L4_SYNC</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L4_EVENT</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L4_SYNC</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L2_EVENT</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L2_SYNC</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_EVENT</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_SYNC</span>:
	<span class="k">case</span> <span class="n">HWTSTAMP_FILTER_PTP_V2_DELAY_REQ</span>:
		<span class="n">rx_filter_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx_type_valid</span> <span class="o">||</span> <span class="o">!</span><span class="n">rx_filter_valid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">is_skb_forwardable</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* if TSO is enabled, we don&#39;t care about the length as the packet</span>
<span class="cm">	 * could be forwarded without being segmented before</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dev_forward_skb - loopback an skb to another netif</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: destination network device</span>
<span class="cm"> * @skb: buffer to forward</span>
<span class="cm"> *</span>
<span class="cm"> * return values:</span>
<span class="cm"> *	NET_RX_SUCCESS	(no congestion)</span>
<span class="cm"> *	NET_RX_DROP     (packet was dropped, but freed)</span>
<span class="cm"> *</span>
<span class="cm"> * dev_forward_skb can be used for injecting an skb from the</span>
<span class="cm"> * start_xmit function of one device into the receive queue</span>
<span class="cm"> * of another device.</span>
<span class="cm"> *</span>
<span class="cm"> * The receiving device may be in another namespace, so</span>
<span class="cm"> * we have to clear all information in the skb that could</span>
<span class="cm"> * impact namespace isolation.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_forward_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_DEV_ZEROCOPY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_ubufs</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_dropped</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">skb_orphan</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">nf_reset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">is_skb_forwardable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_dropped</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">skb_dst_drop</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">.</span><span class="n">tv64</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_HOST</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">secpath_reset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">nf_reset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dev_forward_skb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">deliver_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt_prev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pt_prev</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Support routine. Sends outgoing frames to any network</span>
<span class="cm"> *	taps currently in use.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_queue_xmit_nit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">ptype</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Never send packets back to the socket</span>
<span class="cm">		 * they originated from - MvS (miquels@drinkel.ow.org)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">af_packet_priv</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
		     <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">af_packet_priv</span> <span class="o">!=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb2</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
				<span class="n">pt_prev</span> <span class="o">=</span> <span class="n">ptype</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">skb2</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb2</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">net_timestamp_set</span><span class="p">(</span><span class="n">skb2</span><span class="p">);</span>

			<span class="cm">/* skb-&gt;nh should be correctly</span>
<span class="cm">			   set by sender, so that the second statement is</span>
<span class="cm">			   just protection against buggy protocols.</span>
<span class="cm">			 */</span>
			<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb2</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">skb2</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">||</span>
			    <span class="n">skb2</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">&gt;</span> <span class="n">skb2</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">net_crit_ratelimited</span><span class="p">(</span><span class="s">&quot;protocol %04x is buggy, dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						     <span class="n">ntohs</span><span class="p">(</span><span class="n">skb2</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">),</span>
						     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb2</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">skb2</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">=</span> <span class="n">skb2</span><span class="o">-&gt;</span><span class="n">network_header</span><span class="p">;</span>
			<span class="n">skb2</span><span class="o">-&gt;</span><span class="n">pkt_type</span> <span class="o">=</span> <span class="n">PACKET_OUTGOING</span><span class="p">;</span>
			<span class="n">pt_prev</span> <span class="o">=</span> <span class="n">ptype</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span>
		<span class="n">pt_prev</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">skb2</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* netif_setup_tc - Handle tc mappings on real_num_tx_queues change</span>
<span class="cm"> * @dev: Network device</span>
<span class="cm"> * @txq: number of queues available</span>
<span class="cm"> *</span>
<span class="cm"> * If real_num_tx_queues is changed the tc mappings may no longer be</span>
<span class="cm"> * valid. To resolve this verify the tc mapping remains valid and if</span>
<span class="cm"> * not NULL the mapping. With no priorities mapping to this</span>
<span class="cm"> * offset/count pair it will no longer be used. In the worst case TC0</span>
<span class="cm"> * is invalid nothing can be done so disable priority mappings. If is</span>
<span class="cm"> * expected that drivers will fix this mapping if they can before</span>
<span class="cm"> * calling netif_set_real_num_tx_queues.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netif_setup_tc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_tc_txq</span> <span class="o">*</span><span class="n">tc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* If TC0 is invalidated disable TC mapping */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">txq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Number of in use tx queues changed invalidating tc mappings. Priority traffic classification disabled!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Invalidated prio to tc mappings set to TC0 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TC_BITMASK</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="n">netdev_get_prio_tc_map</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">tc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">[</span><span class="n">q</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">tc</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">txq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Number of in use tx queues changed. Priority %i to tc mapping %i is no longer valid. Setting map to 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
			<span class="n">netdev_set_prio_tc_map</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Routine to help set real_num_tx_queues. To avoid skbs mapped to queues</span>
<span class="cm"> * greater then real_num_tx_queues stale skbs on the qdisc must be flushed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netif_set_real_num_tx_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txq</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">txq</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">==</span> <span class="n">NETREG_REGISTERED</span> <span class="o">||</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">==</span> <span class="n">NETREG_UNREGISTERING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT_RTNL</span><span class="p">();</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">netdev_queue_update_kobjects</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">,</span>
						  <span class="n">txq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tc</span><span class="p">)</span>
			<span class="n">netif_setup_tc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">txq</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">)</span>
			<span class="n">qdisc_reset_all_tx_gt</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">=</span> <span class="n">txq</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netif_set_real_num_tx_queues</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_RPS</span>
<span class="cm">/**</span>
<span class="cm"> *	netif_set_real_num_rx_queues - set actual number of RX queues used</span>
<span class="cm"> *	@dev: Network device</span>
<span class="cm"> *	@rxq: Actual number of RX queues</span>
<span class="cm"> *</span>
<span class="cm"> *	This must be called either with the rtnl_lock held or before</span>
<span class="cm"> *	registration of the net device.  Returns 0 on success, or a</span>
<span class="cm"> *	negative error code.  If called before registration, it always</span>
<span class="cm"> *	succeeds.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netif_set_real_num_rx_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rxq</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">rxq</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">==</span> <span class="n">NETREG_REGISTERED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ASSERT_RTNL</span><span class="p">();</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">net_rx_queue_update_kobjects</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_rx_queues</span><span class="p">,</span>
						  <span class="n">rxq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_rx_queues</span> <span class="o">=</span> <span class="n">rxq</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netif_set_real_num_rx_queues</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__netif_reschedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">next_sched</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">next_sched</span><span class="p">;</span>
	<span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_TX_SOFTIRQ</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__netif_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">__netif_reschedule</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__netif_schedule</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">dev_kfree_skb_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_TX_SOFTIRQ</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_kfree_skb_irq</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">dev_kfree_skb_any</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_irq</span><span class="p">()</span> <span class="o">||</span> <span class="n">irqs_disabled</span><span class="p">())</span>
		<span class="n">dev_kfree_skb_irq</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_kfree_skb_any</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * netif_device_detach - mark device as removed</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Mark device as removed from system and therefore no longer available.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netif_device_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">__LINK_STATE_PRESENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_tx_stop_all_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netif_device_detach</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * netif_device_attach - mark device as attached</span>
<span class="cm"> * @dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> * Mark device as attached from system and restart if needed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netif_device_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">__LINK_STATE_PRESENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netif_tx_wake_all_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">__netdev_watchdog_up</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netif_device_attach</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_warn_bad_offload</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">netdev_features_t</span> <span class="n">null_features</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">driver</span> <span class="o">=</span> <span class="n">dev_driver_string</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">WARN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s: caps=(%pNF, %pNF) len=%d data_len=%d gso_size=%d &quot;</span>
	     <span class="s">&quot;gso_type=%d ip_summed=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="n">driver</span><span class="p">,</span> <span class="n">dev</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">null_features</span><span class="p">,</span>
	     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">null_features</span><span class="p">,</span>
	     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">,</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">,</span>
	     <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Invalidate hardware checksum when packet is to be mangled, and</span>
<span class="cm"> * complete checksum manually on outgoing path.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">skb_checksum_help</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__wsum</span> <span class="n">csum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_COMPLETE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_set_summed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_warn_bad_offload</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="n">csum</span> <span class="o">=</span> <span class="n">skb_checksum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__sum16</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">skb_clone_writable</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__sum16</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="p">(</span><span class="n">__sum16</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">=</span> <span class="n">csum_fold</span><span class="p">(</span><span class="n">csum</span><span class="p">);</span>
<span class="nl">out_set_summed:</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_checksum_help</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_gso_segment - Perform segmentation on skb.</span>
<span class="cm"> *	@skb: buffer to segment</span>
<span class="cm"> *	@features: features for the output path (see dev-&gt;features)</span>
<span class="cm"> *</span>
<span class="cm"> *	This function segments the given skb and returns a list of segments.</span>
<span class="cm"> *</span>
<span class="cm"> *	It may return NULL if the skb requires no segmentation.  This is</span>
<span class="cm"> *	only possible when GSO is used for verifying header integrity.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_gso_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">segs</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">ptype</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">type</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">vlan_depth</span> <span class="o">=</span> <span class="n">ETH_HLEN</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vlan_hdr</span> <span class="o">*</span><span class="n">vh</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pskb_may_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vlan_depth</span> <span class="o">+</span> <span class="n">VLAN_HLEN</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

		<span class="n">vh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vlan_hdr</span> <span class="o">*</span><span class="p">)(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">vlan_depth</span><span class="p">);</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">vh</span><span class="o">-&gt;</span><span class="n">h_vlan_encapsulated_proto</span><span class="p">;</span>
		<span class="n">vlan_depth</span> <span class="o">+=</span> <span class="n">VLAN_HLEN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span><span class="p">;</span>
	<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_warn_bad_offload</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb_header_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">err</span> <span class="o">=</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ptype_base</span><span class="p">[</span><span class="n">ntohs</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PTYPE_HASH_MASK</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">gso_segment</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">!=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">gso_send_check</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
				<span class="n">segs</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">skb_gso_ok</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">__skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span>
						 <span class="n">skb_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">)));</span>
			<span class="p">}</span>
			<span class="n">segs</span> <span class="o">=</span> <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">gso_segment</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">__skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">segs</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_gso_segment</span><span class="p">);</span>

<span class="cm">/* Take action when hardware reception checksum errors are detected. */</span>
<span class="cp">#ifdef CONFIG_BUG</span>
<span class="kt">void</span> <span class="nf">netdev_rx_csum_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_ratelimit</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: hw csum failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;&lt;unknown&gt;&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_rx_csum_fault</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* Actually, we should eliminate this check as soon as we know, that:</span>
<span class="cm"> * 1. IOMMU is present and allows to map all the memory.</span>
<span class="cm"> * 2. No high memory really exists on this machine.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">illegal_highdma</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">)))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PCI_DMA_BUS_IS_PHYS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">dma_addr_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span> <span class="o">||</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dma_mask</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dev_gso_cb</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define DEV_GSO_CB(skb) ((struct dev_gso_cb *)(skb)-&gt;cb)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_gso_skb_destructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dev_gso_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

	<span class="n">cb</span> <span class="o">=</span> <span class="n">DEV_GSO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cb</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">)</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_gso_segment - Perform emulated hardware segmentation on skb.</span>
<span class="cm"> *	@skb: buffer to segment</span>
<span class="cm"> *	@features: device features as applicable to this skb</span>
<span class="cm"> *</span>
<span class="cm"> *	This function segments the given skb and stores the list of segments</span>
<span class="cm"> *	in skb-&gt;next.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_gso_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">segs</span><span class="p">;</span>

	<span class="n">segs</span> <span class="o">=</span> <span class="n">skb_gso_segment</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>

	<span class="cm">/* Verifying header integrity only. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">segs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">segs</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">segs</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">segs</span><span class="p">;</span>
	<span class="n">DEV_GSO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">dev_gso_skb_destructor</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">can_checksum_protocol</span><span class="p">(</span><span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">,</span> <span class="n">__be16</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_GEN_CSUM</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">((</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_V4_CSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span> <span class="o">||</span>
		<span class="p">((</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_V6_CSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IPV6</span><span class="p">))</span> <span class="o">||</span>
		<span class="p">((</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_FCOE_CRC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_FCOE</span><span class="p">)));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_features_t</span> <span class="nf">harmonize_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	<span class="n">__be16</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_checksum_protocol</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_ALL_CSUM</span><span class="p">;</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_SG</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">illegal_highdma</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_SG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">features</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">netdev_features_t</span> <span class="nf">netif_skb_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be16</span> <span class="n">protocol</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vlan_ethhdr</span> <span class="o">*</span><span class="n">veh</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vlan_ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">protocol</span> <span class="o">=</span> <span class="n">veh</span><span class="o">-&gt;</span><span class="n">h_vlan_encapsulated_proto</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">harmonize_features</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">features</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|</span> <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">harmonize_features</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span> <span class="n">NETIF_F_HIGHDMA</span> <span class="o">|</span> <span class="n">NETIF_F_FRAGLIST</span> <span class="o">|</span>
				<span class="n">NETIF_F_GEN_CSUM</span> <span class="o">|</span> <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">harmonize_features</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netif_skb_features</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Returns true if either:</span>
<span class="cm"> *	1. skb has frag_list and the device doesn&#39;t support FRAGLIST, or</span>
<span class="cm"> *	2. skb is fragmented and the device does not support SG, or if</span>
<span class="cm"> *	   at least one of fragments is in highmem and device does not</span>
<span class="cm"> *	   support DMA from it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">skb_needs_linearize</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_is_nonlinear</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">((</span><span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_FRAGLIST</span><span class="p">))</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_SG</span><span class="p">)));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dev_hard_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">skb_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If device doesn&#39;t need skb-&gt;dst, release it right now while</span>
<span class="cm">		 * its hot in this cpu cache</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_XMIT_DST_RELEASE</span><span class="p">)</span>
			<span class="n">skb_dst_drop</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">))</span>
			<span class="n">dev_queue_xmit_nit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

		<span class="n">features</span> <span class="o">=</span> <span class="n">netif_skb_features</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_VLAN_TX</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">__vlan_put_tag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">vlan_tx_tag_get</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">vlan_tci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">netif_needs_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev_gso_segment</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">gso</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_needs_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">features</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">__skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>

			<span class="cm">/* If packet is not checksummed and device does not</span>
<span class="cm">			 * support checksumming for this protocol, complete</span>
<span class="cm">			 * checksumming here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb_set_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
					<span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_ALL_CSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				     <span class="n">skb_checksum_help</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">out_kfree_skb</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">skb_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="n">trace_net_dev_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">skb_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">NETDEV_TX_OK</span><span class="p">)</span>
			<span class="n">txq_trans_update</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">gso:</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If device doesn&#39;t need nskb-&gt;dst, release it right now while</span>
<span class="cm">		 * its hot in this cpu cache</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_XMIT_DST_RELEASE</span><span class="p">)</span>
			<span class="n">skb_dst_drop</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>

		<span class="n">skb_len</span> <span class="o">=</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_start_xmit</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="n">trace_net_dev_xmit</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">skb_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">NETDEV_TX_OK</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">NETDEV_TX_MASK</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_kfree_gso_skb</span><span class="p">;</span>
			<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">txq_trans_update</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">netif_xmit_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">NETDEV_TX_BUSY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

<span class="nl">out_kfree_gso_skb:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">DEV_GSO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">;</span>
<span class="nl">out_kfree_skb:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">hashrnd</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Returns a Tx hash based on the given packet descriptor a Tx queues&#39; number</span>
<span class="cm"> * to be used as a distribution range.</span>
<span class="cm"> */</span>
<span class="n">u16</span> <span class="nf">__skb_tx_hash</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_tx_queues</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">hash</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">qoffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">qcount</span> <span class="o">=</span> <span class="n">num_tx_queues</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_rx_queue_recorded</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">skb_get_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hash</span> <span class="o">&gt;=</span> <span class="n">num_tx_queues</span><span class="p">))</span>
			<span class="n">hash</span> <span class="o">-=</span> <span class="n">num_tx_queues</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">tc</span> <span class="o">=</span> <span class="n">netdev_get_prio_tc_map</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">);</span>
		<span class="n">qoffset</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">[</span><span class="n">tc</span><span class="p">].</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">qcount</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tc_to_txq</span><span class="p">[</span><span class="n">tc</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_hash</span><span class="p">)</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_hash</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u16</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">=</span> <span class="n">jhash_1word</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">hashrnd</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">u16</span><span class="p">)</span> <span class="p">(((</span><span class="n">u64</span><span class="p">)</span> <span class="n">hash</span> <span class="o">*</span> <span class="n">qcount</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">+</span> <span class="n">qoffset</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__skb_tx_hash</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u16</span> <span class="nf">dev_cap_txqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">queue_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">queue_index</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;%s selects TX queue %d, but real number of TX queues is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">,</span>
				     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">queue_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">get_xps_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_XPS</span>
	<span class="k">struct</span> <span class="n">xps_dev_maps</span> <span class="o">*</span><span class="n">dev_maps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">xps_map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">queue_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">dev_maps</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">xps_maps</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_maps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span>
		    <span class="n">dev_maps</span><span class="o">-&gt;</span><span class="n">cpu_map</span><span class="p">[</span><span class="n">raw_smp_processor_id</span><span class="p">()]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">queue_index</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">queues</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">hash</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_hash</span><span class="p">)</span>
					<span class="n">hash</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_hash</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u16</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">^</span>
					    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span><span class="p">;</span>
				<span class="n">hash</span> <span class="o">=</span> <span class="n">jhash_1word</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">hashrnd</span><span class="p">);</span>
				<span class="n">queue_index</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">queues</span><span class="p">[</span>
				    <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">hash</span> <span class="o">*</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">queue_index</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">))</span>
				<span class="n">queue_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">queue_index</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="nf">dev_pick_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">queue_index</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">queue_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_select_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue_index</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_select_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">queue_index</span> <span class="o">=</span> <span class="n">dev_cap_txqueue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
		<span class="n">queue_index</span> <span class="o">=</span> <span class="n">sk_tx_queue_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">queue_index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">ooo_okay</span> <span class="o">||</span>
		    <span class="n">queue_index</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">old_index</span> <span class="o">=</span> <span class="n">queue_index</span><span class="p">;</span>

			<span class="n">queue_index</span> <span class="o">=</span> <span class="n">get_xps_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">queue_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">queue_index</span> <span class="o">=</span> <span class="n">skb_tx_hash</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">queue_index</span> <span class="o">!=</span> <span class="n">old_index</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span>
				    <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_cache</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">&amp;&amp;</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">==</span> <span class="n">dst</span><span class="p">)</span>
					<span class="n">sk_tx_queue_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">skb_set_queue_mapping</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">netdev_get_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">queue_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__dev_xmit_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">root_lock</span> <span class="o">=</span> <span class="n">qdisc_lock</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">contended</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">qdisc_skb_cb</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pkt_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">qdisc_calculate_pkt_len</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Heuristic to force contended enqueues to serialize on a</span>
<span class="cm">	 * separate lock before trying to get qdisc main lock.</span>
<span class="cm">	 * This permits __QDISC_STATE_RUNNING owner to get the lock more often</span>
<span class="cm">	 * and dequeue packets faster.</span>
<span class="cm">	 */</span>
	<span class="n">contended</span> <span class="o">=</span> <span class="n">qdisc_is_running</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_DEACTIVATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">NET_XMIT_DROP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCQ_F_CAN_BYPASS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">qdisc_qlen</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="n">qdisc_run_begin</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is a work-conserving queue; there are no old skbs</span>
<span class="cm">		 * waiting to be sent out; and the qdisc is not running -</span>
<span class="cm">		 * xmit the skb directly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_XMIT_DST_RELEASE</span><span class="p">))</span>
			<span class="n">skb_dst_force</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">qdisc_bstats_update</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sch_direct_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">root_lock</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>
				<span class="n">contended</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">__qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">qdisc_run_end</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">NET_XMIT_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb_dst_force</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">NET_XMIT_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qdisc_run_begin</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>
				<span class="n">contended</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">__qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">contended</span><span class="p">))</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">busylock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if IS_ENABLED(CONFIG_NETPRIO_CGROUP)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_update_prio</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netprio_map</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priomap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">priomap</span><span class="p">[</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp_prioidx</span><span class="p">];</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define skb_update_prio(skb)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">xmit_recursion</span><span class="p">);</span>
<span class="cp">#define RECURSION_LIMIT 10</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_queue_xmit - transmit a buffer</span>
<span class="cm"> *	@skb: buffer to transmit</span>
<span class="cm"> *</span>
<span class="cm"> *	Queue a buffer for transmission to a network device. The caller must</span>
<span class="cm"> *	have set the device and priority and built the buffer before calling</span>
<span class="cm"> *	this function. The function can be called from an interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> *	A negative errno code is returned on a failure. A success does not</span>
<span class="cm"> *	guarantee the frame will be transmitted as it may be dropped due</span>
<span class="cm"> *	to congestion or traffic shaping.</span>
<span class="cm"> *</span>
<span class="cm"> * -----------------------------------------------------------------------------------</span>
<span class="cm"> *      I notice this method can also return errors from the queue disciplines,</span>
<span class="cm"> *      including NET_XMIT_DROP, which is a positive value.  So, errors can also</span>
<span class="cm"> *      be positive.</span>
<span class="cm"> *</span>
<span class="cm"> *      Regardless of the return value, the skb is consumed, so it is currently</span>
<span class="cm"> *      difficult to retry a send to this method.  (You can bump the ref count</span>
<span class="cm"> *      before sending to hold a reference for retry if you are careful.)</span>
<span class="cm"> *</span>
<span class="cm"> *      When calling this method, interrupts MUST be enabled.  This is because</span>
<span class="cm"> *      the BH enable code must have IRQs enabled so that it will not deadlock.</span>
<span class="cm"> *          --BLG</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Disable soft irqs for various locks below. Also</span>
<span class="cm">	 * stops preemption for RCU.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock_bh</span><span class="p">();</span>

	<span class="n">skb_update_prio</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">txq</span> <span class="o">=</span> <span class="n">dev_pick_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">qdisc</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_CLS_ACT</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span> <span class="o">=</span> <span class="n">SET_TC_AT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span><span class="p">,</span> <span class="n">AT_EGRESS</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">trace_net_dev_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">enqueue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">__dev_xmit_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The device has no queue. Common case for software devices:</span>
<span class="cm">	   loopback, all the sorts of tunnels...</span>

<span class="cm">	   Really, it is unlikely that netif_tx_lock protection is necessary</span>
<span class="cm">	   here.  (f.e. loopback and IP tunnels are clean ignoring statistics</span>
<span class="cm">	   counters.)</span>
<span class="cm">	   However, it is possible, that they rely on protection</span>
<span class="cm">	   made by us here.</span>

<span class="cm">	   Check this and shot the lock. It is not prone from deadlocks.</span>
<span class="cm">	   Either shot noqueue qdisc, it is even simpler 8)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span> <span class="cm">/* ok because BHs are off */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">txq</span><span class="o">-&gt;</span><span class="n">xmit_lock_owner</span> <span class="o">!=</span> <span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">xmit_recursion</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">RECURSION_LIMIT</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">recursion_alert</span><span class="p">;</span>

			<span class="n">HARD_TX_LOCK</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_xmit_stopped</span><span class="p">(</span><span class="n">txq</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">xmit_recursion</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">dev_hard_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
				<span class="n">__this_cpu_dec</span><span class="p">(</span><span class="n">xmit_recursion</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dev_xmit_complete</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">HARD_TX_UNLOCK</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">HARD_TX_UNLOCK</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
			<span class="n">net_crit_ratelimited</span><span class="p">(</span><span class="s">&quot;Virtual device %s asks to queue packet!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Recursion is detected! It is possible,</span>
<span class="cm">			 * unfortunately</span>
<span class="cm">			 */</span>
<span class="nl">recursion_alert:</span>
			<span class="n">net_crit_ratelimited</span><span class="p">(</span><span class="s">&quot;Dead loop on virtual device %s, fix it urgently!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENETDOWN</span><span class="p">;</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>

	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock_bh</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_queue_xmit</span><span class="p">);</span>


<span class="cm">/*=======================================================================</span>
<span class="cm">			Receiver routines</span>
<span class="cm">  =======================================================================*/</span>

<span class="kt">int</span> <span class="n">netdev_max_backlog</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">netdev_tstamp_prequeue</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">netdev_budget</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">weight_p</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>            <span class="cm">/* old backlog weight */</span>

<span class="cm">/* Called with irq disabled */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">____napi_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">);</span>
	<span class="n">__raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_RX_SOFTIRQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __skb_get_rxhash: calculate a flow hash based on src/dst addresses</span>
<span class="cm"> * and src/dst port numbers.  Sets rxhash in skb to non-zero hash value</span>
<span class="cm"> * on success, zero indicates no valid hash.  Also, sets l4_rxhash in skb</span>
<span class="cm"> * if hash is a canonical 4-tuple hash over transport ports.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__skb_get_rxhash</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">flow_keys</span> <span class="n">keys</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hash</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_flow_dissect</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">keys</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">ports</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">__force</span> <span class="n">u16</span><span class="p">)</span><span class="n">keys</span><span class="p">.</span><span class="n">port16</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u16</span><span class="p">)</span><span class="n">keys</span><span class="p">.</span><span class="n">port16</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">swap</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">port16</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">keys</span><span class="p">.</span><span class="n">port16</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">l4_rxhash</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* get a consistent hash (same value on both flow directions) */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">keys</span><span class="p">.</span><span class="n">dst</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">keys</span><span class="p">.</span><span class="n">src</span><span class="p">)</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">keys</span><span class="p">.</span><span class="n">src</span><span class="p">);</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">jhash_3words</span><span class="p">((</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">keys</span><span class="p">.</span><span class="n">dst</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">keys</span><span class="p">.</span><span class="n">src</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">__force</span> <span class="n">u32</span><span class="p">)</span><span class="n">keys</span><span class="p">.</span><span class="n">ports</span><span class="p">,</span> <span class="n">hashrnd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hash</span><span class="p">)</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__skb_get_rxhash</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_RPS</span>

<span class="cm">/* One global table that all flow-based protocols share. */</span>
<span class="k">struct</span> <span class="n">rps_sock_flow_table</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">rps_sock_flow_table</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rps_sock_flow_table</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">static_key</span> <span class="n">rps_needed</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rps_dev_flow</span> <span class="o">*</span>
<span class="nf">set_rps_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
	    <span class="k">struct</span> <span class="n">rps_dev_flow</span> <span class="o">*</span><span class="n">rflow</span><span class="p">,</span> <span class="n">u16</span> <span class="n">next_cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_cpu</span> <span class="o">!=</span> <span class="n">RPS_NO_CPU</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>
		<span class="k">struct</span> <span class="n">netdev_rx_queue</span> <span class="o">*</span><span class="n">rxqueue</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rps_dev_flow_table</span> <span class="o">*</span><span class="n">flow_table</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rps_dev_flow</span> <span class="o">*</span><span class="n">old_rflow</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">flow_id</span><span class="p">;</span>
		<span class="n">u16</span> <span class="n">rxq_index</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

		<span class="cm">/* Should we steer this flow to a different hardware queue? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_rx_queue_recorded</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_cpu_rmap</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_NTUPLE</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">rxq_index</span> <span class="o">=</span> <span class="n">cpu_rmap_lookup_index</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_cpu_rmap</span><span class="p">,</span> <span class="n">next_cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rxq_index</span> <span class="o">==</span> <span class="n">skb_get_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">rxqueue</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">_rx</span> <span class="o">+</span> <span class="n">rxq_index</span><span class="p">;</span>
		<span class="n">flow_table</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">rxqueue</span><span class="o">-&gt;</span><span class="n">rps_flow_table</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flow_table</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">flow_id</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span> <span class="o">&amp;</span> <span class="n">flow_table</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_rx_flow_steer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
							<span class="n">rxq_index</span><span class="p">,</span> <span class="n">flow_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">old_rflow</span> <span class="o">=</span> <span class="n">rflow</span><span class="p">;</span>
		<span class="n">rflow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">flow_table</span><span class="o">-&gt;</span><span class="n">flows</span><span class="p">[</span><span class="n">flow_id</span><span class="p">];</span>
		<span class="n">rflow</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_rflow</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">==</span> <span class="n">rflow</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">)</span>
			<span class="n">old_rflow</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="n">RPS_NO_FILTER</span><span class="p">;</span>
	<span class="nl">out:</span>
<span class="cp">#endif</span>
		<span class="n">rflow</span><span class="o">-&gt;</span><span class="n">last_qtail</span> <span class="o">=</span>
			<span class="n">per_cpu</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">,</span> <span class="n">next_cpu</span><span class="p">).</span><span class="n">input_queue_head</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rflow</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">next_cpu</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rflow</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get_rps_cpu is called from netif_receive_skb and returns the target</span>
<span class="cm"> * CPU from the RPS map of the receiving queue for a given skb.</span>
<span class="cm"> * rcu_read_lock must be held on entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_rps_cpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">rps_dev_flow</span> <span class="o">**</span><span class="n">rflowp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_rx_queue</span> <span class="o">*</span><span class="n">rxqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rps_map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rps_dev_flow_table</span> <span class="o">*</span><span class="n">flow_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rps_sock_flow_table</span> <span class="o">*</span><span class="n">sock_flow_table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">tcpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_rx_queue_recorded</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">index</span> <span class="o">=</span> <span class="n">skb_get_rx_queue</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_rx_queues</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WARN_ONCE</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_rx_queues</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>
				  <span class="s">&quot;%s received packet on queue %u, but number &quot;</span>
				  <span class="s">&quot;of RX queues is %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_rx_queues</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rxqueue</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">_rx</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rxqueue</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">_rx</span><span class="p">;</span>

	<span class="n">map</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">rxqueue</span><span class="o">-&gt;</span><span class="n">rps_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">rxqueue</span><span class="o">-&gt;</span><span class="n">rps_flow_table</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tcpu</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">tcpu</span><span class="p">))</span>
				<span class="n">cpu</span> <span class="o">=</span> <span class="n">tcpu</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">rxqueue</span><span class="o">-&gt;</span><span class="n">rps_flow_table</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_get_rxhash</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">flow_table</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">rxqueue</span><span class="o">-&gt;</span><span class="n">rps_flow_table</span><span class="p">);</span>
	<span class="n">sock_flow_table</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">rps_sock_flow_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flow_table</span> <span class="o">&amp;&amp;</span> <span class="n">sock_flow_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">next_cpu</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rps_dev_flow</span> <span class="o">*</span><span class="n">rflow</span><span class="p">;</span>

		<span class="n">rflow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">flow_table</span><span class="o">-&gt;</span><span class="n">flows</span><span class="p">[</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span> <span class="o">&amp;</span> <span class="n">flow_table</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">];</span>
		<span class="n">tcpu</span> <span class="o">=</span> <span class="n">rflow</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">;</span>

		<span class="n">next_cpu</span> <span class="o">=</span> <span class="n">sock_flow_table</span><span class="o">-&gt;</span><span class="n">ents</span><span class="p">[</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span> <span class="o">&amp;</span>
		    <span class="n">sock_flow_table</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the desired CPU (where last recvmsg was done) is</span>
<span class="cm">		 * different from current CPU (one in the rx-queue flow</span>
<span class="cm">		 * table entry), switch if one of the following holds:</span>
<span class="cm">		 *   - Current CPU is unset (equal to RPS_NO_CPU).</span>
<span class="cm">		 *   - Current CPU is offline.</span>
<span class="cm">		 *   - The current CPU&#39;s queue tail has advanced beyond the</span>
<span class="cm">		 *     last packet that was enqueued using this table entry.</span>
<span class="cm">		 *     This guarantees that all previous packets for the flow</span>
<span class="cm">		 *     have been dequeued, thus preserving in order delivery.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tcpu</span> <span class="o">!=</span> <span class="n">next_cpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">tcpu</span> <span class="o">==</span> <span class="n">RPS_NO_CPU</span> <span class="o">||</span> <span class="o">!</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">tcpu</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">,</span> <span class="n">tcpu</span><span class="p">).</span><span class="n">input_queue_head</span> <span class="o">-</span>
		      <span class="n">rflow</span><span class="o">-&gt;</span><span class="n">last_qtail</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">rflow</span> <span class="o">=</span> <span class="n">set_rps_cpu</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">rflow</span><span class="p">,</span> <span class="n">next_cpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcpu</span> <span class="o">!=</span> <span class="n">RPS_NO_CPU</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_online</span><span class="p">(</span><span class="n">tcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">rflowp</span> <span class="o">=</span> <span class="n">rflow</span><span class="p">;</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">tcpu</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tcpu</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">[((</span><span class="n">u64</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">rxhash</span> <span class="o">*</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">tcpu</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">tcpu</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RFS_ACCEL</span>

<span class="cm">/**</span>
<span class="cm"> * rps_may_expire_flow - check whether an RFS hardware filter may be removed</span>
<span class="cm"> * @dev: Device on which the filter was set</span>
<span class="cm"> * @rxq_index: RX queue index</span>
<span class="cm"> * @flow_id: Flow ID passed to ndo_rx_flow_steer()</span>
<span class="cm"> * @filter_id: Filter ID returned by ndo_rx_flow_steer()</span>
<span class="cm"> *</span>
<span class="cm"> * Drivers that implement ndo_rx_flow_steer() should periodically call</span>
<span class="cm"> * this function for each installed filter and remove the filters for</span>
<span class="cm"> * which it returns %true.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">rps_may_expire_flow</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="n">rxq_index</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">flow_id</span><span class="p">,</span> <span class="n">u16</span> <span class="n">filter_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_rx_queue</span> <span class="o">*</span><span class="n">rxqueue</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">_rx</span> <span class="o">+</span> <span class="n">rxq_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rps_dev_flow_table</span> <span class="o">*</span><span class="n">flow_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rps_dev_flow</span> <span class="o">*</span><span class="n">rflow</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">expire</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">flow_table</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">rxqueue</span><span class="o">-&gt;</span><span class="n">rps_flow_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flow_table</span> <span class="o">&amp;&amp;</span> <span class="n">flow_id</span> <span class="o">&lt;=</span> <span class="n">flow_table</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rflow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">flow_table</span><span class="o">-&gt;</span><span class="n">flows</span><span class="p">[</span><span class="n">flow_id</span><span class="p">];</span>
		<span class="n">cpu</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">rflow</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rflow</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">==</span> <span class="n">filter_id</span> <span class="o">&amp;&amp;</span> <span class="n">cpu</span> <span class="o">!=</span> <span class="n">RPS_NO_CPU</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">input_queue_head</span> <span class="o">-</span>
			   <span class="n">rflow</span><span class="o">-&gt;</span><span class="n">last_qtail</span><span class="p">)</span> <span class="o">&lt;</span>
		     <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">flow_table</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">)))</span>
			<span class="n">expire</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">expire</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">rps_may_expire_flow</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_RFS_ACCEL */</span><span class="cp"></span>

<span class="cm">/* Called from hardirq (IPI) context */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">rps_trigger_softirq</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="n">____napi_schedule</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">backlog</span><span class="p">);</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">received_rps</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_RPS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Check if this softnet_data structure is another cpu one</span>
<span class="cm"> * If yes, queue it to our IPI list and return 1</span>
<span class="cm"> * If no, return 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rps_ipi_queued</span><span class="p">(</span><span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">mysd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span> <span class="o">!=</span> <span class="n">mysd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">rps_ipi_next</span> <span class="o">=</span> <span class="n">mysd</span><span class="o">-&gt;</span><span class="n">rps_ipi_list</span><span class="p">;</span>
		<span class="n">mysd</span><span class="o">-&gt;</span><span class="n">rps_ipi_list</span> <span class="o">=</span> <span class="n">sd</span><span class="p">;</span>

		<span class="n">__raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_RX_SOFTIRQ</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_RPS */</span><span class="cp"></span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * enqueue_to_backlog is called to queue an skb to a per CPU backlog</span>
<span class="cm"> * queue (may be a remote CPU queue).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">enqueue_to_backlog</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">qtail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">rps_lock</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">netdev_max_backlog</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">enqueue:</span>
			<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">input_queue_tail_incr_save</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">qtail</span><span class="p">);</span>
			<span class="n">rps_unlock</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Schedule NAPI for backlog device</span>
<span class="cm">		 * We can use non atomic operation since we own the queue lock</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__test_and_set_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">backlog</span><span class="p">.</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rps_ipi_queued</span><span class="p">(</span><span class="n">sd</span><span class="p">))</span>
				<span class="n">____napi_schedule</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">backlog</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">enqueue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">dropped</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rps_unlock</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>

	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_dropped</span><span class="p">);</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_rx	-	post buffer to the network code</span>
<span class="cm"> *	@skb: buffer to post</span>
<span class="cm"> *</span>
<span class="cm"> *	This function receives a packet from a device driver and queues it for</span>
<span class="cm"> *	the upper (protocol) levels to process.  It always succeeds. The buffer</span>
<span class="cm"> *	may be dropped during processing for congestion control or by the</span>
<span class="cm"> *	protocol layers.</span>
<span class="cm"> *</span>
<span class="cm"> *	return values:</span>
<span class="cm"> *	NET_RX_SUCCESS	(no congestion)</span>
<span class="cm"> *	NET_RX_DROP     (packet was dropped)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">netif_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* if netpoll wants it, pretend we never saw it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netpoll_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="n">net_timestamp_check</span><span class="p">(</span><span class="n">netdev_tstamp_prequeue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">trace_netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">static_key_false</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rps_needed</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rps_dev_flow</span> <span class="n">voidflow</span><span class="p">,</span> <span class="o">*</span><span class="n">rflow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">voidflow</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>

		<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_rps_cpu</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rflow</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">enqueue_to_backlog</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rflow</span><span class="o">-&gt;</span><span class="n">last_qtail</span><span class="p">);</span>

		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qtail</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">enqueue_to_backlog</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">get_cpu</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">qtail</span><span class="p">);</span>
		<span class="n">put_cpu</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netif_rx</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">netif_rx_ni</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local_softirq_pending</span><span class="p">())</span>
		<span class="n">do_softirq</span><span class="p">();</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netif_rx_ni</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">net_tx_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">clist</span><span class="p">;</span>

		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">clist</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">clist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">clist</span><span class="p">;</span>
			<span class="n">clist</span> <span class="o">=</span> <span class="n">clist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">));</span>
			<span class="n">trace_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">net_tx_action</span><span class="p">);</span>
			<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">;</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
			<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">root_lock</span><span class="p">;</span>

			<span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next_sched</span><span class="p">;</span>

			<span class="n">root_lock</span> <span class="o">=</span> <span class="n">qdisc_lock</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spin_trylock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_SCHED</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
				<span class="n">qdisc_run</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_DEACTIVATED</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">__netif_reschedule</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
					<span class="n">clear_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_SCHED</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if (defined(CONFIG_BRIDGE) || defined(CONFIG_BRIDGE_MODULE)) &amp;&amp; \</span>
<span class="cp">    (defined(CONFIG_ATM_LANE) || defined(CONFIG_ATM_LANE_MODULE))</span>
<span class="cm">/* This hook is defined here for ATM LANE */</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">br_fdb_test_addr_hook</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">br_fdb_test_addr_hook</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NET_CLS_ACT</span>
<span class="cm">/* TODO: Maybe we should just force sch_ingress to be compiled in</span>
<span class="cm"> * when CONFIG_NET_CLS_ACT is? otherwise some useless instructions</span>
<span class="cm"> * a compare and 2 stores extra right now if we dont have it on</span>
<span class="cm"> * but have CONFIG_NET_CLS_ACT</span>
<span class="cm"> * NOTE: This doesn&#39;t stop any functionality; if you dont have</span>
<span class="cm"> * the ingress scheduler, you just can&#39;t add policies on ingress.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ing_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">rxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ttl</span> <span class="o">=</span> <span class="n">G_TC_RTTL</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">TC_ACT_OK</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">MAX_RED_LOOP</span> <span class="o">&lt;</span> <span class="n">ttl</span><span class="o">++</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;Redir loop detected Dropping packet (%d-&gt;%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">TC_ACT_SHOT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span> <span class="o">=</span> <span class="n">SET_TC_RTTL</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span><span class="p">,</span> <span class="n">ttl</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span> <span class="o">=</span> <span class="n">SET_TC_AT</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span><span class="p">,</span> <span class="n">AT_INGRESS</span><span class="p">);</span>

	<span class="n">q</span> <span class="o">=</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">qdisc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">noop_qdisc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">qdisc_lock</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__QDISC_STATE_DEACTIVATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">qdisc_enqueue_root</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">qdisc_lock</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">handle_ing</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">**</span><span class="n">pt_prev</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">rxq</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ingress_queue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rxq</span> <span class="o">||</span> <span class="n">rxq</span><span class="o">-&gt;</span><span class="n">qdisc</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">noop_qdisc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pt_prev</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
		<span class="o">*</span><span class="n">pt_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ing_filter</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">rxq</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TC_ACT_SHOT</span>:
	<span class="k">case</span> <span class="n">TC_ACT_STOLEN</span>:
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	netdev_rx_handler_register - register receive handler</span>
<span class="cm"> *	@dev: device to register a handler for</span>
<span class="cm"> *	@rx_handler: receive handler to register</span>
<span class="cm"> *	@rx_handler_data: data pointer that is used by rx handler</span>
<span class="cm"> *</span>
<span class="cm"> *	Register a receive hander for a device. This handler will then be</span>
<span class="cm"> *	called from __netif_receive_skb. A negative errno code is returned</span>
<span class="cm"> *	on a failure.</span>
<span class="cm"> *</span>
<span class="cm"> *	The caller must hold the rtnl_mutex.</span>
<span class="cm"> *</span>
<span class="cm"> *	For a general description of rx_handler, see enum rx_handler_result.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netdev_rx_handler_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="n">rx_handler_func_t</span> <span class="o">*</span><span class="n">rx_handler</span><span class="p">,</span>
			       <span class="kt">void</span> <span class="o">*</span><span class="n">rx_handler_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_handler</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_handler_data</span><span class="p">,</span> <span class="n">rx_handler_data</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_handler</span><span class="p">,</span> <span class="n">rx_handler</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">netdev_rx_handler_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	netdev_rx_handler_unregister - unregister receive handler</span>
<span class="cm"> *	@dev: device to unregister a handler from</span>
<span class="cm"> *</span>
<span class="cm"> *	Unregister a receive hander from a device.</span>
<span class="cm"> *</span>
<span class="cm"> *	The caller must hold the rtnl_mutex.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netdev_rx_handler_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>
	<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_handler</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_handler_data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">netdev_rx_handler_unregister</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__netif_receive_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">ptype</span><span class="p">,</span> <span class="o">*</span><span class="n">pt_prev</span><span class="p">;</span>
	<span class="n">rx_handler_func_t</span> <span class="o">*</span><span class="n">rx_handler</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">null_or_dev</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">deliver_exact</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">net_timestamp_check</span><span class="p">(</span><span class="o">!</span><span class="n">netdev_tstamp_prequeue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">trace_netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* if we&#39;ve gotten here through NAPI, check netpoll */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netpoll_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span>
	<span class="n">orig_dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_reset_mac_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">pt_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

<span class="nl">another_round:</span>

	<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">.</span><span class="n">processed</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_8021Q</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">vlan_untag</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_CLS_ACT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span> <span class="o">&amp;</span> <span class="n">TC_NCLS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span> <span class="o">=</span> <span class="n">CLR_TC_NCLS</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">ncls</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span> <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
			<span class="n">pt_prev</span> <span class="o">=</span> <span class="n">ptype</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NET_CLS_ACT</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">handle_ing</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt_prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">ncls:</span>
<span class="cp">#endif</span>

	<span class="n">rx_handler</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_handler</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vlan_tx_tag_present</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
			<span class="n">pt_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vlan_do_receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="p">,</span> <span class="o">!</span><span class="n">rx_handler</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">another_round</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rx_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
			<span class="n">pt_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">rx_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">RX_HANDLER_CONSUMED</span>:
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RX_HANDLER_ANOTHER</span>:
			<span class="k">goto</span> <span class="n">another_round</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RX_HANDLER_EXACT</span>:
			<span class="n">deliver_exact</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">RX_HANDLER_PASS</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* deliver only exact match when indicated */</span>
	<span class="n">null_or_dev</span> <span class="o">=</span> <span class="n">deliver_exact</span> <span class="o">?</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ptype_base</span><span class="p">[</span><span class="n">ntohs</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PTYPE_HASH_MASK</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">null_or_dev</span> <span class="o">||</span> <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span>
		     <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">orig_dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">deliver_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
			<span class="n">pt_prev</span> <span class="o">=</span> <span class="n">ptype</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pt_prev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">pt_prev</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pt_prev</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_dropped</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="cm">/* Jamal, now you will not able to escape explaining</span>
<span class="cm">		 * me how you were going to use this. :-)</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">NET_RX_DROP</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_receive_skb - process receive buffer from network</span>
<span class="cm"> *	@skb: buffer to process</span>
<span class="cm"> *</span>
<span class="cm"> *	netif_receive_skb() is the main receive data processing function.</span>
<span class="cm"> *	It always succeeds. The buffer may be dropped during processing</span>
<span class="cm"> *	for congestion control or by the protocol layers.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function may only be called from softirq context and interrupts</span>
<span class="cm"> *	should be enabled.</span>
<span class="cm"> *</span>
<span class="cm"> *	Return values (usually ignored):</span>
<span class="cm"> *	NET_RX_SUCCESS: no congestion</span>
<span class="cm"> *	NET_RX_DROP: packet was dropped</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netif_receive_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">net_timestamp_check</span><span class="p">(</span><span class="n">netdev_tstamp_prequeue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_defer_rx_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">static_key_false</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rps_needed</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rps_dev_flow</span> <span class="n">voidflow</span><span class="p">,</span> <span class="o">*</span><span class="n">rflow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">voidflow</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">rcu_read_lock</span><span class="p">();</span>

		<span class="n">cpu</span> <span class="o">=</span> <span class="n">get_rps_cpu</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rflow</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">enqueue_to_backlog</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rflow</span><span class="o">-&gt;</span><span class="n">last_qtail</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">__netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netif_receive_skb</span><span class="p">);</span>

<span class="cm">/* Network device is going away, flush any packets still pending</span>
<span class="cm"> * Called with irqs disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_backlog</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">rps_lock</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="n">skb_queue_walk_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">input_queue_head_incr</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rps_unlock</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>

	<span class="n">skb_queue_walk_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">process_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">process_queue</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">input_queue_head_incr</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">napi_gro_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">ptype</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">type</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ptype_base</span><span class="p">[</span><span class="n">ntohs</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PTYPE_HASH_MASK</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">type</span> <span class="o">||</span> <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">gro_complete</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">gro_complete</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">==</span> <span class="n">head</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">napi_gro_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_list</span><span class="p">;</span> <span class="n">skb</span><span class="p">;</span> <span class="n">skb</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">napi_gro_complete</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">napi_gro_flush</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">gro_result</span> <span class="nf">dev_gro_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">pp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">ptype</span><span class="p">;</span>
	<span class="n">__be16</span> <span class="n">type</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ptype_base</span><span class="p">[</span><span class="n">ntohs</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PTYPE_HASH_MASK</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">same_flow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mac_len</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">gro_result</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_GRO</span><span class="p">)</span> <span class="o">||</span> <span class="n">netpoll_rx_on</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">normal</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_is_gso</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">normal</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">type</span> <span class="o">||</span> <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">gro_receive</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">skb_set_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_gro_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="n">mac_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_len</span> <span class="o">=</span> <span class="n">mac_len</span><span class="p">;</span>
		<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">same_flow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">pp</span> <span class="o">=</span> <span class="n">ptype</span><span class="o">-&gt;</span><span class="n">gro_receive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_list</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ptype</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">normal</span><span class="p">;</span>

	<span class="n">same_flow</span> <span class="o">=</span> <span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">same_flow</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">?</span> <span class="n">GRO_MERGED_FREE</span> <span class="o">:</span> <span class="n">GRO_MERGED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span> <span class="o">=</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>

		<span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">napi_gro_complete</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
		<span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">same_flow</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">ok</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flush</span> <span class="o">||</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_count</span> <span class="o">&gt;=</span> <span class="n">MAX_GRO_SKBS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">normal</span><span class="p">;</span>

	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="n">skb_gro_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_list</span><span class="p">;</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_list</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">GRO_HELD</span><span class="p">;</span>

<span class="nl">pull:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">skb_gro_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">grow</span> <span class="o">=</span> <span class="n">skb_gro_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">&lt;</span> <span class="n">grow</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag0</span><span class="p">,</span> <span class="n">grow</span><span class="p">);</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+=</span> <span class="n">grow</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">-=</span> <span class="n">grow</span><span class="p">;</span>

		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">grow</span><span class="p">;</span>
		<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grow</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="p">{</span>
			<span class="n">skb_frag_unref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">memmove</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">,</span>
				<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				<span class="o">--</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">skb_frag_t</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">ok:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">normal:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">GRO_NORMAL</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">pull</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_gro_receive</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">gro_result_t</span>
<span class="nf">__napi_gro_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maclen</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_list</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">diffs</span><span class="p">;</span>

		<span class="n">diffs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">^</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">diffs</span> <span class="o">|=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vlan_tci</span> <span class="o">^</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">vlan_tci</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">maclen</span> <span class="o">==</span> <span class="n">ETH_HLEN</span><span class="p">)</span>
			<span class="n">diffs</span> <span class="o">|=</span> <span class="n">compare_ether_header</span><span class="p">(</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
						      <span class="n">skb_gro_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">diffs</span><span class="p">)</span>
			<span class="n">diffs</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
				       <span class="n">skb_gro_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
				       <span class="n">maclen</span><span class="p">);</span>
		<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">same_flow</span> <span class="o">=</span> <span class="o">!</span><span class="n">diffs</span><span class="p">;</span>
		<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dev_gro_receive</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">gro_result_t</span> <span class="nf">napi_skb_finish</span><span class="p">(</span><span class="n">gro_result_t</span> <span class="n">ret</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GRO_NORMAL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">GRO_DROP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GRO_DROP</span>:
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GRO_MERGED_FREE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">NAPI_GRO_FREE_STOLEN_HEAD</span><span class="p">)</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">skbuff_head_cache</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GRO_HELD</span>:
	<span class="k">case</span> <span class="n">GRO_MERGED</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">napi_skb_finish</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">skb_gro_reset_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag0</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag0_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="p">{</span>
		<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag0</span> <span class="o">=</span>
			<span class="n">skb_frag_address</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag0_len</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_gro_reset_offset</span><span class="p">);</span>

<span class="n">gro_result_t</span> <span class="nf">napi_gro_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_gro_reset_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">napi_skb_finish</span><span class="p">(</span><span class="n">__napi_gro_receive</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">),</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">napi_gro_receive</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">napi_reuse_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="cm">/* restore the reserve we had after netdev_alloc_skb_ip_align() */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">NET_SKB_PAD</span> <span class="o">+</span> <span class="n">NET_IP_ALIGN</span> <span class="o">-</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">vlan_tci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">skb_iif</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">napi_get_frags</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">netdev_alloc_skb_ip_align</span><span class="p">(</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">GRO_MAX_HEAD</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">napi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">napi_get_frags</span><span class="p">);</span>

<span class="n">gro_result_t</span> <span class="nf">napi_frags_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			       <span class="n">gro_result_t</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">GRO_NORMAL</span>:
	<span class="k">case</span> <span class="n">GRO_HELD</span>:
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth_type_trans</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">GRO_HELD</span><span class="p">)</span>
			<span class="n">skb_gro_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">-</span><span class="n">ETH_HLEN</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">GRO_DROP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GRO_DROP</span>:
	<span class="k">case</span> <span class="n">GRO_MERGED_FREE</span>:
		<span class="n">napi_reuse_skb</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GRO_MERGED</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">napi_frags_finish</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">napi_frags_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">eth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hlen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">off</span><span class="p">;</span>

	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_gro_reset_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">off</span> <span class="o">=</span> <span class="n">skb_gro_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">hlen</span> <span class="o">=</span> <span class="n">off</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">eth</span><span class="p">);</span>
	<span class="n">eth</span> <span class="o">=</span> <span class="n">skb_gro_header_fast</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_gro_header_hard</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">eth</span> <span class="o">=</span> <span class="n">skb_gro_header_slow</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">hlen</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">eth</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">napi_reuse_skb</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">skb_gro_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">eth</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * This works because the only protocols we care about don&#39;t require</span>
<span class="cm">	 * special handling.  We&#39;ll fix it up properly at the end.</span>
<span class="cm">	 */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">eth</span><span class="o">-&gt;</span><span class="n">h_proto</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">gro_result_t</span> <span class="nf">napi_gro_frags</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">napi_frags_skb</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">GRO_DROP</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">napi_frags_finish</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">__napi_gro_receive</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="n">skb</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">napi_gro_frags</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * net_rps_action sends any pending IPI&#39;s for rps.</span>
<span class="cm"> * Note: called with local irq disabled, but exits with local irq enabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">net_rps_action_and_irq_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">remsd</span> <span class="o">=</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">rps_ipi_list</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">remsd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">rps_ipi_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">local_irq_enable</span><span class="p">();</span>

		<span class="cm">/* Send pending IPI&#39;s to kick RPS processing on remote cpus. */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">remsd</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">remsd</span><span class="o">-&gt;</span><span class="n">rps_ipi_next</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="n">remsd</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">))</span>
				<span class="n">__smp_call_function_single</span><span class="p">(</span><span class="n">remsd</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span>
							   <span class="o">&amp;</span><span class="n">remsd</span><span class="o">-&gt;</span><span class="n">csd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">remsd</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">process_backlog</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quota</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">work</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">softnet_data</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="cm">/* Check if we have pending ipi, its better to send them now,</span>
<span class="cm">	 * not waiting net_rx_action() end.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">rps_ipi_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>
		<span class="n">net_rps_action_and_irq_enable</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight_p</span><span class="p">;</span>
	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">work</span> <span class="o">&lt;</span> <span class="n">quota</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qlen</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">process_queue</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">local_irq_enable</span><span class="p">();</span>
			<span class="n">__netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">local_irq_disable</span><span class="p">();</span>
			<span class="n">input_queue_head_incr</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">work</span> <span class="o">&gt;=</span> <span class="n">quota</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">local_irq_enable</span><span class="p">();</span>
				<span class="k">return</span> <span class="n">work</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">rps_lock</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
		<span class="n">qlen</span> <span class="o">=</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qlen</span><span class="p">)</span>
			<span class="n">skb_queue_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">process_queue</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qlen</span> <span class="o">&lt;</span> <span class="n">quota</span> <span class="o">-</span> <span class="n">work</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Inline a custom version of __napi_complete().</span>
<span class="cm">			 * only current cpu owns and manipulates this napi,</span>
<span class="cm">			 * and NAPI_STATE_SCHED is the only possible flag set on backlog.</span>
<span class="cm">			 * we can use a plain write instead of clear_bit(),</span>
<span class="cm">			 * and we dont need an smp_mb() memory barrier.</span>
<span class="cm">			 */</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">);</span>
			<span class="n">napi</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">quota</span> <span class="o">=</span> <span class="n">work</span> <span class="o">+</span> <span class="n">qlen</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rps_unlock</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">work</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __napi_schedule - schedule for receive</span>
<span class="cm"> * @n: entry to schedule</span>
<span class="cm"> *</span>
<span class="cm"> * The entry&#39;s receive function will be scheduled to run</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__napi_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">____napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">),</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__napi_schedule</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__napi_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">gro_list</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">);</span>
	<span class="n">smp_mb__before_clear_bit</span><span class="p">();</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__napi_complete</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">napi_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * don&#39;t let napi dequeue from the cpu poll list</span>
<span class="cm">	 * just in case its running on a different cpu</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NAPI_STATE_NPSVC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">napi_gro_flush</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">__napi_complete</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">napi_complete</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">netif_napi_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="kt">int</span> <span class="n">weight</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">);</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">poll</span> <span class="o">=</span> <span class="n">poll</span><span class="p">;</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">napi_list</span><span class="p">);</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NETPOLL</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">poll_lock</span><span class="p">);</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">poll_owner</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netif_napi_add</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">netif_napi_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">napi</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">);</span>
	<span class="n">napi_free_frags</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_list</span><span class="p">;</span> <span class="n">skb</span><span class="p">;</span> <span class="n">skb</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">napi</span><span class="o">-&gt;</span><span class="n">gro_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netif_napi_del</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">net_rx_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_limit</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">budget</span> <span class="o">=</span> <span class="n">netdev_budget</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">have</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">work</span><span class="p">,</span> <span class="n">weight</span><span class="p">;</span>

		<span class="cm">/* If softirq window is exhuasted then punt.</span>
<span class="cm">		 * Allow this to run for 2 jiffies since which will allow</span>
<span class="cm">		 * an average latency of 1.5/HZ.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">budget</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">time_limit</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">softnet_break</span><span class="p">;</span>

		<span class="n">local_irq_enable</span><span class="p">();</span>

		<span class="cm">/* Even though interrupts have been re-enabled, this</span>
<span class="cm">		 * access is safe because interrupts can only add new</span>
<span class="cm">		 * entries to the tail of this list, and only -&gt;poll()</span>
<span class="cm">		 * calls can remove this head entry from the list.</span>
<span class="cm">		 */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">napi_struct</span><span class="p">,</span> <span class="n">poll_list</span><span class="p">);</span>

		<span class="n">have</span> <span class="o">=</span> <span class="n">netpoll_poll_lock</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

		<span class="n">weight</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>

		<span class="cm">/* This NAPI_STATE_SCHED test is for avoiding a race</span>
<span class="cm">		 * with netpoll&#39;s poll_napi().  Only the entity which</span>
<span class="cm">		 * obtains the lock and sees NAPI_STATE_SCHED set will</span>
<span class="cm">		 * actually make the -&gt;poll() call.  Therefore we avoid</span>
<span class="cm">		 * accidentally calling -&gt;poll() when NAPI is not scheduled.</span>
<span class="cm">		 */</span>
		<span class="n">work</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NAPI_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">work</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">weight</span><span class="p">);</span>
			<span class="n">trace_napi_poll</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">work</span> <span class="o">&gt;</span> <span class="n">weight</span><span class="p">);</span>

		<span class="n">budget</span> <span class="o">-=</span> <span class="n">work</span><span class="p">;</span>

		<span class="n">local_irq_disable</span><span class="p">();</span>

		<span class="cm">/* Drivers must not modify the NAPI state if they</span>
<span class="cm">		 * consume the entire weight.  In such cases this code</span>
<span class="cm">		 * still &quot;owns&quot; the NAPI instance and therefore can</span>
<span class="cm">		 * move the instance around on the list at-will.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">work</span> <span class="o">==</span> <span class="n">weight</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">napi_disable_pending</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">local_irq_enable</span><span class="p">();</span>
				<span class="n">napi_complete</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
				<span class="n">local_irq_disable</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">netpoll_poll_unlock</span><span class="p">(</span><span class="n">have</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">net_rps_action_and_irq_enable</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_DMA</span>
	<span class="cm">/*</span>
<span class="cm">	 * There may not be any more sk_buffs coming right now, so push</span>
<span class="cm">	 * any pending DMA copies to hardware</span>
<span class="cm">	 */</span>
	<span class="n">dma_issue_pending_all</span><span class="p">();</span>
<span class="cp">#endif</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">softnet_break:</span>
	<span class="n">sd</span><span class="o">-&gt;</span><span class="n">time_squeeze</span><span class="o">++</span><span class="p">;</span>
	<span class="n">__raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_RX_SOFTIRQ</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">gifconf_func_t</span> <span class="o">*</span><span class="n">gifconf_list</span><span class="p">[</span><span class="n">NPROTO</span><span class="p">];</span>

<span class="cm">/**</span>
<span class="cm"> *	register_gifconf	-	register a SIOCGIF handler</span>
<span class="cm"> *	@family: Address family</span>
<span class="cm"> *	@gifconf: Function handler</span>
<span class="cm"> *</span>
<span class="cm"> *	Register protocol dependent address dumping routines. The handler</span>
<span class="cm"> *	that is passed must not be freed or reused until it has been replaced</span>
<span class="cm"> *	by another handler.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">register_gifconf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="n">gifconf_func_t</span> <span class="o">*</span><span class="n">gifconf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">&gt;=</span> <span class="n">NPROTO</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">gifconf_list</span><span class="p">[</span><span class="n">family</span><span class="p">]</span> <span class="o">=</span> <span class="n">gifconf</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_gifconf</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> *	Map an interface index to its name (SIOCGIFNAME)</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	We need this ioctl for efficient implementation of the</span>
<span class="cm"> *	if_indextoname() function required by the IPv6 API.  Without</span>
<span class="cm"> *	it, we would have to search all the interfaces to find a</span>
<span class="cm"> *	match.  --pb</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_ifname</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Fetch the caller&#39;s info block.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_index_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_ifindex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Perform a SIOCGIFCONF call. This structure will change</span>
<span class="cm"> *	size eventually, and there is nothing I can do about it.</span>
<span class="cm"> *	Thus we will need a &#39;compatibility mode&#39;.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_ifconf</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ifconf</span> <span class="n">ifc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Fetch the caller&#39;s info block.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifc</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifconf</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">ifc</span><span class="p">.</span><span class="n">ifc_buf</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ifc</span><span class="p">.</span><span class="n">ifc_len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Loop over the interfaces, and write an info block for each.</span>
<span class="cm">	 */</span>

	<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_netdev</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NPROTO</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gifconf_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pos</span><span class="p">)</span>
					<span class="n">done</span> <span class="o">=</span> <span class="n">gifconf_list</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">done</span> <span class="o">=</span> <span class="n">gifconf_list</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">dev</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">total</span><span class="p">,</span>
							       <span class="n">len</span> <span class="o">-</span> <span class="n">total</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">done</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="n">total</span> <span class="o">+=</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	All done.  Write the updated control block back to the caller.</span>
<span class="cm">	 */</span>
	<span class="n">ifc</span><span class="p">.</span><span class="n">ifc_len</span> <span class="o">=</span> <span class="n">total</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 	Both BSD and Solaris return 0 here, so we do too.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifconf</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>

<span class="cp">#define BUCKET_SPACE (32 - NETDEV_HASHBITS - 1)</span>

<span class="cp">#define get_bucket(x) ((x) &gt;&gt; BUCKET_SPACE)</span>
<span class="cp">#define get_offset(x) ((x) &amp; ((1 &lt;&lt; BUCKET_SPACE) - 1))</span>
<span class="cp">#define set_bucket_offset(b, o) ((b) &lt;&lt; BUCKET_SPACE | (o))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">dev_from_same_bucket</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">seq_file_net</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">get_offset</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">);</span>

	<span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_name_head</span><span class="p">[</span><span class="n">get_bucket</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)];</span>
	<span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">name_hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">==</span> <span class="n">offset</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">dev_from_bucket</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bucket</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_from_same_bucket</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>

		<span class="n">bucket</span> <span class="o">=</span> <span class="n">get_bucket</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">set_bucket_offset</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bucket</span> <span class="o">&lt;</span> <span class="n">NETDEV_HASHENTRIES</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	This is invoked by the /proc filesystem handler to display a device</span>
<span class="cm"> *	in detail.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">dev_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">pos</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SEQ_START_TOKEN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_bucket</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">NETDEV_HASHENTRIES</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dev_from_bucket</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">dev_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev_from_bucket</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dev_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_seq_printf_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">stats</span> <span class="o">=</span> <span class="n">dev_get_stats</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%6s: %7llu %7llu %4llu %4llu %4llu %5llu %10llu %9llu &quot;</span>
		   <span class="s">&quot;%8llu %7llu %4llu %4llu %4llu %5llu %7llu %10llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_bytes</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_packets</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_errors</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_dropped</span> <span class="o">+</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_missed_errors</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_fifo_errors</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_length_errors</span> <span class="o">+</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_over_errors</span> <span class="o">+</span>
		    <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_crc_errors</span> <span class="o">+</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_frame_errors</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">rx_compressed</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">multicast</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_bytes</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_packets</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_errors</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_dropped</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_fifo_errors</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">collisions</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_carrier_errors</span> <span class="o">+</span>
		    <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_aborted_errors</span> <span class="o">+</span>
		    <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_window_errors</span> <span class="o">+</span>
		    <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_heartbeat_errors</span><span class="p">,</span>
		   <span class="n">stats</span><span class="o">-&gt;</span><span class="n">tx_compressed</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Called from the PROCfs module. This now uses the new arbitrary sized</span>
<span class="cm"> *	/proc/net interface to create /proc/net/dev</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Inter-|   Receive                            &quot;</span>
			      <span class="s">&quot;                    |  Transmit</span><span class="se">\n</span><span class="s">&quot;</span>
			      <span class="s">&quot; face |bytes    packets errs drop fifo frame &quot;</span>
			      <span class="s">&quot;compressed multicast|bytes    packets errs &quot;</span>
			      <span class="s">&quot;drop fifo colls carrier compressed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev_seq_printf_stats</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="nf">softnet_get_online</span><span class="p">(</span><span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpu_online</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">softnet_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">softnet_get_online</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">softnet_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">softnet_get_online</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">softnet_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">softnet_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%08x %08x %08x %08x %08x %08x %08x %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">sd</span><span class="o">-&gt;</span><span class="n">processed</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">dropped</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">time_squeeze</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		   <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* was fastroute */</span>
		   <span class="n">sd</span><span class="o">-&gt;</span><span class="n">cpu_collision</span><span class="p">,</span> <span class="n">sd</span><span class="o">-&gt;</span><span class="n">received_rps</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">dev_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">dev_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">dev_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">dev_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">dev_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open_net</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_seq_ops</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_net_private</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">dev_seq_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>	 <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">dev_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release_net</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">softnet_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">softnet_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">softnet_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">softnet_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">softnet_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">softnet_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">softnet_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">softnet_seq_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>	 <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">softnet_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ptype_get_idx</span><span class="p">(</span><span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">t</span><span class="p">;</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">pos</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">pt</span><span class="p">;</span>
		<span class="o">++</span><span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">PTYPE_HASH_SIZE</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptype_base</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">pos</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">pt</span><span class="p">;</span>
			<span class="o">++</span><span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ptype_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">pos</span> <span class="o">?</span> <span class="n">ptype_get_idx</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">SEQ_START_TOKEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ptype_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">nxt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>

	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ptype_get_idx</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="n">pt</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">nxt</span> <span class="o">=</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_ALL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nxt</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nxt</span> <span class="o">=</span> <span class="n">ptype_base</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PTYPE_HASH_MASK</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nxt</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ptype_base</span><span class="p">[</span><span class="n">hash</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">hash</span> <span class="o">&gt;=</span> <span class="n">PTYPE_HASH_SIZE</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">nxt</span> <span class="o">=</span> <span class="n">ptype_base</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">found:</span>
	<span class="k">return</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">nxt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">packet_type</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ptype_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">RCU</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptype_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Type Device      Function</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">seq_file_net</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_ALL</span><span class="p">))</span>
			<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;ALL &quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%04x&quot;</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">pt</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">));</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot; %-8s %pF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">pt</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">pt</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">ptype_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">ptype_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">ptype_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">ptype_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">ptype_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ptype_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open_net</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptype_seq_ops</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_net_private</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ptype_seq_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>	 <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">ptype_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>  <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release_net</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__net_init</span> <span class="nf">dev_proc_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_net_fops_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;dev&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_seq_fops</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_net_fops_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;softnet_stat&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">softnet_seq_fops</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_net_fops_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;ptype&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptype_seq_fops</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_softnet</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wext_proc_init</span><span class="p">(</span><span class="n">net</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_ptype</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">out_ptype:</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;ptype&quot;</span><span class="p">);</span>
<span class="nl">out_softnet:</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;softnet_stat&quot;</span><span class="p">);</span>
<span class="nl">out_dev:</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;dev&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__net_exit</span> <span class="nf">dev_proc_net_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wext_proc_exit</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>

	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;ptype&quot;</span><span class="p">);</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;softnet_stat&quot;</span><span class="p">);</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;dev&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">__net_initdata</span> <span class="n">dev_proc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">dev_proc_net_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">dev_proc_net_exit</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">dev_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">register_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_proc_ops</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define dev_proc_init() 0</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>


<span class="cm">/**</span>
<span class="cm"> *	netdev_set_master	-	set up master pointer</span>
<span class="cm"> *	@slave: slave device</span>
<span class="cm"> *	@master: new master device</span>
<span class="cm"> *</span>
<span class="cm"> *	Changes the master device of the slave. Pass %NULL to break the</span>
<span class="cm"> *	bonding. The caller must hold the RTNL semaphore. On a failure</span>
<span class="cm"> *	a negative errno code is returned. On success the reference counts</span>
<span class="cm"> *	are adjusted and the function returns zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netdev_set_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">slave</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="n">dev_hold</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">slave</span><span class="o">-&gt;</span><span class="n">master</span> <span class="o">=</span> <span class="n">master</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span>
		<span class="n">dev_put</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_set_master</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	netdev_set_bond_master	-	set up bonding master/slave pair</span>
<span class="cm"> *	@slave: slave device</span>
<span class="cm"> *	@master: new master device</span>
<span class="cm"> *</span>
<span class="cm"> *	Changes the master device of the slave. Pass %NULL to break the</span>
<span class="cm"> *	bonding. The caller must hold the RTNL semaphore. On a failure</span>
<span class="cm"> *	a negative errno code is returned. On success %RTM_NEWLINK is sent</span>
<span class="cm"> *	to the routing socket and the function returns zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">netdev_set_bond_master</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">slave</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">master</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">netdev_set_master</span><span class="p">(</span><span class="n">slave</span><span class="p">,</span> <span class="n">master</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">master</span><span class="p">)</span>
		<span class="n">slave</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IFF_SLAVE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">slave</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IFF_SLAVE</span><span class="p">;</span>

	<span class="n">rtmsg_ifinfo</span><span class="p">(</span><span class="n">RTM_NEWLINK</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">IFF_SLAVE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_set_bond_master</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_change_rx_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_change_rx_flags</span><span class="p">)</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_change_rx_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dev_set_promiscuity</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_flags</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IFF_PROMISC</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">promiscuity</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">promiscuity</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Avoid overflow.</span>
<span class="cm">		 * If inc causes overflow, untouch promisc and return error.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IFF_PROMISC</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">promiscuity</span> <span class="o">-=</span> <span class="n">inc</span><span class="p">;</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: promiscuity touches roof, set promiscuity failed. promiscuity feature of device might be broken.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">!=</span> <span class="n">old_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;device %s %s promiscuous mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span> <span class="o">?</span> <span class="s">&quot;entered&quot;</span> <span class="o">:</span> <span class="s">&quot;left&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">current_uid_gid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gid</span><span class="p">);</span>
			<span class="n">audit_log</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">audit_context</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">,</span>
				<span class="n">AUDIT_ANOM_PROMISCUOUS</span><span class="p">,</span>
				<span class="s">&quot;dev=%s prom=%d old_prom=%d auid=%u uid=%u gid=%u ses=%u&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">),</span>
				<span class="p">(</span><span class="n">old_flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">),</span>
				<span class="n">audit_get_loginuid</span><span class="p">(</span><span class="n">current</span><span class="p">),</span>
				<span class="n">uid</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span>
				<span class="n">audit_get_sessionid</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">dev_change_rx_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">IFF_PROMISC</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_set_promiscuity	- update promiscuity count on a device</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@inc: modifier</span>
<span class="cm"> *</span>
<span class="cm"> *	Add or remove promiscuity from a device. While the count in the device</span>
<span class="cm"> *	remains above zero the interface remains promiscuous. Once it hits zero</span>
<span class="cm"> *	the device reverts back to normal filtering operation. A negative inc</span>
<span class="cm"> *	value is used to drop promiscuity on the device.</span>
<span class="cm"> *	Return 0 if successful or a negative errno code on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_set_promiscuity</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_flags</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__dev_set_promiscuity</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">inc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">!=</span> <span class="n">old_flags</span><span class="p">)</span>
		<span class="n">dev_set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_set_promiscuity</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_set_allmulti	- update allmulti count on a device</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@inc: modifier</span>
<span class="cm"> *</span>
<span class="cm"> *	Add or remove reception of all multicast frames to a device. While the</span>
<span class="cm"> *	count in the device remains above zero the interface remains listening</span>
<span class="cm"> *	to all interfaces. Once it hits zero the device reverts back to normal</span>
<span class="cm"> *	filtering operation. A negative @inc value is used to drop the counter</span>
<span class="cm"> *	when releasing a resource needing all multicasts.</span>
<span class="cm"> *	Return 0 if successful or a negative errno code on error.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">dev_set_allmulti</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_flags</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IFF_ALLMULTI</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">allmulti</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">allmulti</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Avoid overflow.</span>
<span class="cm">		 * If inc causes overflow, untouch allmulti and return error.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IFF_ALLMULTI</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">allmulti</span> <span class="o">-=</span> <span class="n">inc</span><span class="p">;</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: allmulti touches roof, set allmulti failed. allmulti feature of device might be broken.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">^</span> <span class="n">old_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_change_rx_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">IFF_ALLMULTI</span><span class="p">);</span>
		<span class="n">dev_set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_set_allmulti</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Upload unicast and multicast address lists to device and</span>
<span class="cm"> *	configure RX filtering. When the device doesn&#39;t support unicast</span>
<span class="cm"> *	filtering it is put in promiscuous mode while unicast addresses</span>
<span class="cm"> *	are present.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__dev_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>

	<span class="cm">/* dev_open will call this function so the list will stay sane. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">&amp;</span><span class="n">IFF_UP</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;</span> <span class="n">IFF_UNICAST_FLT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Unicast addresses changes may only happen under the rtnl,</span>
<span class="cm">		 * therefore calling __dev_set_promiscuity here is safe.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netdev_uc_empty</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">uc_promisc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__dev_set_promiscuity</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">uc_promisc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">netdev_uc_empty</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">uc_promisc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__dev_set_promiscuity</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">uc_promisc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_set_rx_mode</span><span class="p">)</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dev_set_rx_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netif_addr_lock_bh</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">__dev_set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netif_addr_unlock_bh</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_get_flags - get flags reported to userspace</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *</span>
<span class="cm"> *	Get the combination of flag bits exported through APIs to userspace.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">dev_get_flags</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">IFF_PROMISC</span> <span class="o">|</span>
				<span class="n">IFF_ALLMULTI</span> <span class="o">|</span>
				<span class="n">IFF_RUNNING</span> <span class="o">|</span>
				<span class="n">IFF_LOWER_UP</span> <span class="o">|</span>
				<span class="n">IFF_DORMANT</span><span class="p">))</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IFF_PROMISC</span> <span class="o">|</span>
				<span class="n">IFF_ALLMULTI</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_running</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_oper_up</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">IFF_RUNNING</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">IFF_LOWER_UP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_dormant</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">IFF_DORMANT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_get_flags</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__dev_change_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_flags</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Set the flags on our device.</span>
<span class="cm">	 */</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IFF_DEBUG</span> <span class="o">|</span> <span class="n">IFF_NOTRAILERS</span> <span class="o">|</span> <span class="n">IFF_NOARP</span> <span class="o">|</span>
			       <span class="n">IFF_DYNAMIC</span> <span class="o">|</span> <span class="n">IFF_MULTICAST</span> <span class="o">|</span> <span class="n">IFF_PORTSEL</span> <span class="o">|</span>
			       <span class="n">IFF_AUTOMEDIA</span><span class="p">))</span> <span class="o">|</span>
		     <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IFF_UP</span> <span class="o">|</span> <span class="n">IFF_VOLATILE</span> <span class="o">|</span> <span class="n">IFF_PROMISC</span> <span class="o">|</span>
				    <span class="n">IFF_ALLMULTI</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Load in the correct multicast list now the flags have changed.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">old_flags</span> <span class="o">^</span> <span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IFF_MULTICAST</span><span class="p">)</span>
		<span class="n">dev_change_rx_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">IFF_MULTICAST</span><span class="p">);</span>

	<span class="n">dev_set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Have we downed the interface. We handle IFF_UP ourselves</span>
<span class="cm">	 *	according to user attempts to set it, rather than blindly</span>
<span class="cm">	 *	setting it.</span>
<span class="cm">	 */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">old_flags</span> <span class="o">^</span> <span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Bit is different  ? */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">((</span><span class="n">old_flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="o">?</span> <span class="n">__dev_close</span> <span class="o">:</span> <span class="n">__dev_open</span><span class="p">)(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">dev_set_rx_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">^</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gflags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_PROMISC</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gflags</span> <span class="o">^=</span> <span class="n">IFF_PROMISC</span><span class="p">;</span>
		<span class="n">dev_set_promiscuity</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">inc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* NOTE: order of synchronization of IFF_PROMISC and IFF_ALLMULTI</span>
<span class="cm">	   is important. Some (broken) drivers set IFF_PROMISC, when</span>
<span class="cm">	   IFF_ALLMULTI is requested not asking us and not reporting.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">^</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gflags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_ALLMULTI</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gflags</span> <span class="o">^=</span> <span class="n">IFF_ALLMULTI</span><span class="p">;</span>
		<span class="n">dev_set_allmulti</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">inc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__dev_notify_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">changes</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">^</span> <span class="n">old_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">changes</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span>
			<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_UP</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_DOWN</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">changes</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">IFF_UP</span> <span class="o">|</span> <span class="n">IFF_PROMISC</span> <span class="o">|</span> <span class="n">IFF_ALLMULTI</span> <span class="o">|</span> <span class="n">IFF_VOLATILE</span><span class="p">)))</span>
		<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_CHANGE</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_change_flags - change device settings</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@flags: device state flags</span>
<span class="cm"> *</span>
<span class="cm"> *	Change settings on device based state flags. The flags are</span>
<span class="cm"> *	in the userspace exported format.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_change_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">changes</span><span class="p">,</span> <span class="n">old_flags</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__dev_change_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">changes</span> <span class="o">=</span> <span class="n">old_flags</span> <span class="o">^</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">changes</span><span class="p">)</span>
		<span class="n">rtmsg_ifinfo</span><span class="p">(</span><span class="n">RTM_NEWLINK</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">changes</span><span class="p">);</span>

	<span class="n">__dev_notify_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">old_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_change_flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_set_mtu - Change maximum transfer unit</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@new_mtu: new transfer unit</span>
<span class="cm"> *</span>
<span class="cm"> *	Change the maximum transfer size of the network device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_set_mtu</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_mtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*	MTU must be positive.	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_mtu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_change_mtu</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_change_mtu</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">new_mtu</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">new_mtu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span>
		<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_CHANGEMTU</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_set_mtu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_set_group - Change group this device belongs to</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@new_group: group this device should belong to</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dev_set_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">group</span> <span class="o">=</span> <span class="n">new_group</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_set_group</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_set_mac_address - Change Media Access Control Address</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@sa: new address</span>
<span class="cm"> *</span>
<span class="cm"> *	Change the hardware (MAC) address of the device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dev_set_mac_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_set_mac_address</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_set_mac_address</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sa</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_CHANGEADDR</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_set_mac_address</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Perform the SIOCxIFxxx calls, inside rcu_read_lock()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_ifsioc_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_name_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCGIFFLAGS</span>:	<span class="cm">/* Get interface flags */</span>
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_flags</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="n">dev_get_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCGIFMETRIC</span>:	<span class="cm">/* Get the metric on the interface</span>
<span class="cm">				   (currently unused) */</span>
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_metric</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCGIFMTU</span>:	<span class="cm">/* Get the MTU of a device */</span>
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_mtu</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCGIFHWADDR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">)</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_addr</span><span class="p">,</span>
			       <span class="n">min</span><span class="p">(</span><span class="k">sizeof</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">));</span>
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCGIFSLAVE</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCGIFMAP</span>:
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">mem_start</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">;</span>
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">mem_end</span>   <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">mem_end</span><span class="p">;</span>
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">irq</span>       <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">dma</span>       <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">;</span>
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">port</span>      <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">if_port</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCGIFINDEX</span>:
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_ifindex</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCGIFTXQLEN</span>:
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_qlen</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="cm">/* dev_ioctl() should ensure this case</span>
<span class="cm">		 * is never reached</span>
<span class="cm">		 */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Perform the SIOCxIFxxx calls, inside rtnl_lock()</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_ifsioc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">__dev_get_by_name</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_name</span><span class="p">);</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCSIFFLAGS</span>:	<span class="cm">/* Set interface flags */</span>
		<span class="k">return</span> <span class="n">dev_change_flags</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_flags</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SIOCSIFMETRIC</span>:	<span class="cm">/* Set the metric on the interface</span>
<span class="cm">				   (currently unused) */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCSIFMTU</span>:	<span class="cm">/* Set the MTU of a device */</span>
		<span class="k">return</span> <span class="n">dev_set_mtu</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_mtu</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SIOCSIFHWADDR</span>:
		<span class="k">return</span> <span class="n">dev_set_mac_address</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SIOCSIFHWBROADCAST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">broadcast</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span>
		       <span class="n">min</span><span class="p">(</span><span class="k">sizeof</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_len</span><span class="p">));</span>
		<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_CHANGEADDR</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCSIFMAP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_set_config</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_set_config</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_map</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCADDMULTI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_set_rx_mode</span> <span class="o">||</span>
		    <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">AF_UNSPEC</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">dev_mc_add_global</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SIOCDELMULTI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_set_rx_mode</span> <span class="o">||</span>
		    <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">AF_UNSPEC</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">dev_mc_del_global</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_hwaddr</span><span class="p">.</span><span class="n">sa_data</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SIOCSIFTXQLEN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_qlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span> <span class="o">=</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_qlen</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCSIFNAME</span>:
		<span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_newname</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">dev_change_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_newname</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SIOCSHWTSTAMP</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">net_hwtstamp_validate</span><span class="p">(</span><span class="n">ifr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Unknown or private ioctl</span>
<span class="cm">	 */</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&gt;=</span> <span class="n">SIOCDEVPRIVATE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cmd</span> <span class="o">&lt;=</span> <span class="n">SIOCDEVPRIVATE</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCBONDENSLAVE</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCBONDRELEASE</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCBONDSETHWADDR</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCBONDSLAVEINFOQUERY</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCBONDINFOQUERY</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCBONDCHANGEACTIVE</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCGMIIPHY</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCGMIIREG</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCSMIIREG</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCBRADDIF</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCBRDELIF</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCSHWTSTAMP</span> <span class="o">||</span>
		    <span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCWANDEV</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_do_ioctl</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">netif_device_present</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_do_ioctl</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	This function handles all &quot;interface&quot;-type I/O control requests. The actual</span>
<span class="cm"> *	&#39;doing&#39; part of this is dev_ifsioc above.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_ioctl	-	network device ioctl</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *	@cmd: command to issue</span>
<span class="cm"> *	@arg: pointer to a struct ifreq in user space</span>
<span class="cm"> *</span>
<span class="cm"> *	Issue ioctl functions to devices. This is normally called by the</span>
<span class="cm"> *	user space syscall interfaces but can sometimes be useful for</span>
<span class="cm"> *	other purposes. The return value is the return from the syscall if</span>
<span class="cm"> *	positive or a negative errno code on error.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">dev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">colon</span><span class="p">;</span>

	<span class="cm">/* One special case: SIOCGIFCONF takes ifconf argument</span>
<span class="cm">	   and requires shared lock, because it sleeps writing</span>
<span class="cm">	   to user space.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCGIFCONF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dev_ifconf</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCGIFNAME</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">dev_ifname</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">colon</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">colon</span><span class="p">)</span>
		<span class="o">*</span><span class="n">colon</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	See which interface the caller is talking about.</span>
<span class="cm">	 */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *	These ioctl calls:</span>
<span class="cm">	 *	- can be done by all.</span>
<span class="cm">	 *	- atomic and do not require locking.</span>
<span class="cm">	 *	- return a value</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIOCGIFFLAGS</span>:
	<span class="k">case</span> <span class="n">SIOCGIFMETRIC</span>:
	<span class="k">case</span> <span class="n">SIOCGIFMTU</span>:
	<span class="k">case</span> <span class="n">SIOCGIFHWADDR</span>:
	<span class="k">case</span> <span class="n">SIOCGIFSLAVE</span>:
	<span class="k">case</span> <span class="n">SIOCGIFMAP</span>:
	<span class="k">case</span> <span class="n">SIOCGIFINDEX</span>:
	<span class="k">case</span> <span class="n">SIOCGIFTXQLEN</span>:
		<span class="n">dev_load</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">);</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dev_ifsioc_locked</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">colon</span><span class="p">)</span>
				<span class="o">*</span><span class="n">colon</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">)))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCETHTOOL</span>:
		<span class="n">dev_load</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">);</span>
		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dev_ethtool</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">colon</span><span class="p">)</span>
				<span class="o">*</span><span class="n">colon</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">)))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	These ioctl calls:</span>
<span class="cm">	 *	- require superuser power.</span>
<span class="cm">	 *	- require strict serialization.</span>
<span class="cm">	 *	- return a value</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:
	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:
	<span class="k">case</span> <span class="n">SIOCSIFNAME</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="n">dev_load</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">);</span>
		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dev_ifsioc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">colon</span><span class="p">)</span>
				<span class="o">*</span><span class="n">colon</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">)))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	These ioctl calls:</span>
<span class="cm">	 *	- require superuser power.</span>
<span class="cm">	 *	- require strict serialization.</span>
<span class="cm">	 *	- do not return a value</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIOCSIFFLAGS</span>:
	<span class="k">case</span> <span class="n">SIOCSIFMETRIC</span>:
	<span class="k">case</span> <span class="n">SIOCSIFMTU</span>:
	<span class="k">case</span> <span class="n">SIOCSIFMAP</span>:
	<span class="k">case</span> <span class="n">SIOCSIFHWADDR</span>:
	<span class="k">case</span> <span class="n">SIOCSIFSLAVE</span>:
	<span class="k">case</span> <span class="n">SIOCADDMULTI</span>:
	<span class="k">case</span> <span class="n">SIOCDELMULTI</span>:
	<span class="k">case</span> <span class="n">SIOCSIFHWBROADCAST</span>:
	<span class="k">case</span> <span class="n">SIOCSIFTXQLEN</span>:
	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:
	<span class="k">case</span> <span class="n">SIOCBONDENSLAVE</span>:
	<span class="k">case</span> <span class="n">SIOCBONDRELEASE</span>:
	<span class="k">case</span> <span class="n">SIOCBONDSETHWADDR</span>:
	<span class="k">case</span> <span class="n">SIOCBONDCHANGEACTIVE</span>:
	<span class="k">case</span> <span class="n">SIOCBRADDIF</span>:
	<span class="k">case</span> <span class="n">SIOCBRDELIF</span>:
	<span class="k">case</span> <span class="n">SIOCSHWTSTAMP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">SIOCBONDSLAVEINFOQUERY</span>:
	<span class="k">case</span> <span class="n">SIOCBONDINFOQUERY</span>:
		<span class="n">dev_load</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">);</span>
		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dev_ifsioc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SIOCGIFMEM</span>:
		<span class="cm">/* Get the per device memory space. We can add this but</span>
<span class="cm">		 * currently do not support it */</span>
	<span class="k">case</span> <span class="n">SIOCSIFMEM</span>:
		<span class="cm">/* Set the per device memory buffer space.</span>
<span class="cm">		 * Not applicable in our case */</span>
	<span class="k">case</span> <span class="n">SIOCSIFLINK</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Unknown or private ioctl.</span>
<span class="cm">	 */</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCWANDEV</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">cmd</span> <span class="o">&gt;=</span> <span class="n">SIOCDEVPRIVATE</span> <span class="o">&amp;&amp;</span>
		     <span class="n">cmd</span> <span class="o">&lt;=</span> <span class="n">SIOCDEVPRIVATE</span> <span class="o">+</span> <span class="mi">15</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev_load</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">);</span>
			<span class="n">rtnl_lock</span><span class="p">();</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">dev_ifsioc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="n">rtnl_unlock</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span>
						 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">)))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Take care of Wireless Extensions */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&gt;=</span> <span class="n">SIOCIWFIRST</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span> <span class="o">&lt;=</span> <span class="n">SIOCIWLAST</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">wext_handle_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	dev_new_index	-	allocate an ifindex</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a suitable unique value for a new device interface</span>
<span class="cm"> *	number.  The caller must hold the rtnl semaphore or the</span>
<span class="cm"> *	dev_base_lock to be sure it remains unique.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_new_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">ifindex</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">ifindex</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ifindex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__dev_get_by_index</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">ifindex</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ifindex</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Delayed registration/unregisteration */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">net_todo_list</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">net_set_todo</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">todo_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_todo_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rollback_registered_many</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev_boot_phase</span><span class="p">);</span>
	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">unreg_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Some devices call without registering</span>
<span class="cm">		 * for initialization unwind. Remove those</span>
<span class="cm">		 * devices and proceed with the remaining.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">==</span> <span class="n">NETREG_UNINITIALIZED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;unregister_netdevice: device %s/%p never was registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unreg_list</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">dismantle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">!=</span> <span class="n">NETREG_REGISTERED</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If device is running, close it first. */</span>
	<span class="n">dev_close_many</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">unreg_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* And unlink it from device chain. */</span>
		<span class="n">unlist_netdevice</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">=</span> <span class="n">NETREG_UNREGISTERING</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">synchronize_net</span><span class="p">();</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">unreg_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Shutdown queueing discipline. */</span>
		<span class="n">dev_shutdown</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>


		<span class="cm">/* Notify protocols, that we are about to destroy</span>
<span class="cm">		   this device. They should clean all the things.</span>
<span class="cm">		*/</span>
		<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_UNREGISTER</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rtnl_link_ops</span> <span class="o">||</span>
		    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rtnl_link_state</span> <span class="o">==</span> <span class="n">RTNL_LINK_INITIALIZED</span><span class="p">)</span>
			<span class="n">rtmsg_ifinfo</span><span class="p">(</span><span class="n">RTM_DELLINK</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="o">~</span><span class="mi">0U</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *	Flush the unicast and multicast chains</span>
<span class="cm">		 */</span>
		<span class="n">dev_uc_flush</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev_mc_flush</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_uninit</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_uninit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* Notifier chain MUST detach us from master device. */</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">master</span><span class="p">);</span>

		<span class="cm">/* Remove entries from kobject tree */</span>
		<span class="n">netdev_unregister_kobject</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Process any work delayed until the end of the batch */</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span><span class="p">,</span> <span class="n">unreg_list</span><span class="p">);</span>
	<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_UNREGISTER_BATCH</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">synchronize_net</span><span class="p">();</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">unreg_list</span><span class="p">)</span>
		<span class="n">dev_put</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rollback_registered</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">single</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unreg_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">single</span><span class="p">);</span>
	<span class="n">rollback_registered_many</span><span class="p">(</span><span class="o">&amp;</span><span class="n">single</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">single</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_features_t</span> <span class="nf">netdev_fix_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Fix illegal checksum combinations */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_HW_CSUM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NETIF_F_IP_CSUM</span><span class="o">|</span><span class="n">NETIF_F_IPV6_CSUM</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">netdev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;mixed HW and IP checksum settings.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">NETIF_F_IP_CSUM</span><span class="o">|</span><span class="n">NETIF_F_IPV6_CSUM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Fix illegal SG+CSUM combinations. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_SG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_ALL_CSUM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Dropping NETIF_F_SG since no checksum feature.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_SG</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* TSO requires that SG is present as well. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_ALL_TSO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_SG</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Dropping TSO features since no SG feature.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_ALL_TSO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* TSO ECN requires that TSO is present as well. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_ALL_TSO</span><span class="p">)</span> <span class="o">==</span> <span class="n">NETIF_F_TSO_ECN</span><span class="p">)</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_TSO_ECN</span><span class="p">;</span>

	<span class="cm">/* Software GSO depends on SG. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_GSO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_SG</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Dropping NETIF_F_GSO since no SG feature.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_GSO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* UFO needs SG and checksumming */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_UFO</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* maybe split UFO into V4 and V6? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_GEN_CSUM</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NETIF_F_IP_CSUM</span><span class="o">|</span><span class="n">NETIF_F_IPV6_CSUM</span><span class="p">))</span>
			    <span class="o">==</span> <span class="p">(</span><span class="n">NETIF_F_IP_CSUM</span><span class="o">|</span><span class="n">NETIF_F_IPV6_CSUM</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Dropping NETIF_F_UFO since no checksum offload features.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_UFO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_SG</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Dropping NETIF_F_UFO since no NETIF_F_SG feature.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_UFO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">features</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__netdev_update_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="n">features</span> <span class="o">=</span> <span class="n">netdev_get_wanted_features</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_fix_features</span><span class="p">)</span>
		<span class="n">features</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_fix_features</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>

	<span class="cm">/* driver might be less strict about feature dependencies */</span>
	<span class="n">features</span> <span class="o">=</span> <span class="n">netdev_fix_features</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">==</span> <span class="n">features</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">netdev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Features changed: %pNF -&gt; %pNF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">features</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_set_features</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_set_features</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">netdev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;set_features() failed (%d); wanted %pNF, left %pNF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">features</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">=</span> <span class="n">features</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netdev_update_features - recalculate device features</span>
<span class="cm"> *	@dev: the device to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Recalculate dev-&gt;features set and send notifications if it</span>
<span class="cm"> *	has changed. Should be called after driver or hardware dependent</span>
<span class="cm"> *	conditions might have changed that influence the features.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netdev_update_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__netdev_update_features</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">netdev_features_change</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_update_features</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	netdev_change_features - recalculate device features</span>
<span class="cm"> *	@dev: the device to check</span>
<span class="cm"> *</span>
<span class="cm"> *	Recalculate dev-&gt;features set and send notifications even</span>
<span class="cm"> *	if they have not changed. Should be called instead of</span>
<span class="cm"> *	netdev_update_features() if also dev-&gt;vlan_features might</span>
<span class="cm"> *	have changed to allow the changes to be propagated to stacked</span>
<span class="cm"> *	VLAN devices.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netdev_change_features</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__netdev_update_features</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">netdev_features_change</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_change_features</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	netif_stacked_transfer_operstate -	transfer operstate</span>
<span class="cm"> *	@rootdev: the root or lower level device to transfer state from</span>
<span class="cm"> *	@dev: the device to transfer operstate to</span>
<span class="cm"> *</span>
<span class="cm"> *	Transfer operational state from root to device. This is normally</span>
<span class="cm"> *	called when a stacking relationship exists between the root</span>
<span class="cm"> *	device and the device(a leaf device).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netif_stacked_transfer_operstate</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">rootdev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rootdev</span><span class="o">-&gt;</span><span class="n">operstate</span> <span class="o">==</span> <span class="n">IF_OPER_DORMANT</span><span class="p">)</span>
		<span class="n">netif_dormant_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">netif_dormant_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">rootdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">netif_carrier_on</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="n">netif_carrier_off</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netif_stacked_transfer_operstate</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_RPS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">netif_alloc_rx_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_rx_queue</span> <span class="o">*</span><span class="n">rx</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">rx</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_rx_queue</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;netdev: Unable to allocate %u rx queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">_rx</span> <span class="o">=</span> <span class="n">rx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">rx</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_init_one_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Initialize queue lock */</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">_xmit_lock</span><span class="p">);</span>
	<span class="n">netdev_set_xmit_lockdep_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">_xmit_lock</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">xmit_lock_owner</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">netdev_queue_numa_node_write</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">);</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BQL</span>
	<span class="n">dql_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">dql</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netif_alloc_netdev_queues</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">tx</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">tx</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_queue</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;netdev: Unable to allocate %u tx queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">_tx</span> <span class="o">=</span> <span class="n">tx</span><span class="p">;</span>

	<span class="n">netdev_for_each_tx_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">netdev_init_one_queue</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_global_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	register_netdevice	- register a network device</span>
<span class="cm"> *	@dev: device to register</span>
<span class="cm"> *</span>
<span class="cm"> *	Take a completed network device structure and add it to the kernel</span>
<span class="cm"> *	interfaces. A %NETDEV_REGISTER message is sent to the netdev notifier</span>
<span class="cm"> *	chain. 0 is returned on success. A negative errno code is returned</span>
<span class="cm"> *	on a failure to set up the device, or if the name is a duplicate.</span>
<span class="cm"> *</span>
<span class="cm"> *	Callers must hold the rtnl semaphore. You may want</span>
<span class="cm"> *	register_netdev() instead of this.</span>
<span class="cm"> *</span>
<span class="cm"> *	BUGS:</span>
<span class="cm"> *	The locking appears insufficient to guarantee two parallel registers</span>
<span class="cm"> *	will not get the same name.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">register_netdevice</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev_boot_phase</span><span class="p">);</span>
	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="cm">/* When net_device&#39;s are persistent, this will be fatal. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">!=</span> <span class="n">NETREG_UNINITIALIZED</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">addr_list_lock</span><span class="p">);</span>
	<span class="n">netdev_set_addr_lockdep_class</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">iflink</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dev_get_valid_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Init, if this function is available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_init</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">=</span> <span class="n">dev_new_index</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iflink</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">iflink</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span>

	<span class="cm">/* Transfer changeable features to wanted_features and enable</span>
<span class="cm">	 * software offloads (GSO and GRO).</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_SOFT_FEATURES</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_SOFT_FEATURES</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">wanted_features</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_features</span><span class="p">;</span>

	<span class="cm">/* Turn on no cache copy if HW is doing checksum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_LOOPBACK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hw_features</span> <span class="o">|=</span> <span class="n">NETIF_F_NOCACHE_COPY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_ALL_CSUM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">wanted_features</span> <span class="o">|=</span> <span class="n">NETIF_F_NOCACHE_COPY</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">NETIF_F_NOCACHE_COPY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Make NETIF_F_HIGHDMA inheritable to VLAN devices.</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">vlan_features</span> <span class="o">|=</span> <span class="n">NETIF_F_HIGHDMA</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_POST_INIT</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">notifier_to_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_uninit</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">netdev_register_kobject</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_uninit</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">=</span> <span class="n">NETREG_REGISTERED</span><span class="p">;</span>

	<span class="n">__netdev_update_features</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Default initial state at registry is that the</span>
<span class="cm">	 *	device is present.</span>
<span class="cm">	 */</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">__LINK_STATE_PRESENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="n">dev_init_scheduler</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_hold</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">list_netdevice</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Notify protocols, that a new device appeared. */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_REGISTER</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">notifier_to_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rollback_registered</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">=</span> <span class="n">NETREG_UNREGISTERED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Prevent userspace races by waiting until the network</span>
<span class="cm">	 *	device is fully setup before sending notifications.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rtnl_link_ops</span> <span class="o">||</span>
	    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">rtnl_link_state</span> <span class="o">==</span> <span class="n">RTNL_LINK_INITIALIZED</span><span class="p">)</span>
		<span class="n">rtmsg_ifinfo</span><span class="p">(</span><span class="n">RTM_NEWLINK</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="o">~</span><span class="mi">0U</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">err_uninit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_uninit</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="o">-&gt;</span><span class="n">ndo_uninit</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_netdevice</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	init_dummy_netdev	- init a dummy network device for NAPI</span>
<span class="cm"> *	@dev: device to init</span>
<span class="cm"> *</span>
<span class="cm"> *	This takes a network device structure and initialize the minimum</span>
<span class="cm"> *	amount of fields so it can be used to schedule NAPI polls without</span>
<span class="cm"> *	registering a full blown interface. This is to be used by drivers</span>
<span class="cm"> *	that need to tie several hardware interfaces to a single NAPI</span>
<span class="cm"> *	poll scheduler due to HW limitations.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">init_dummy_netdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clear everything. Note we don&#39;t initialize spinlocks</span>
<span class="cm">	 * are they aren&#39;t supposed to be taken by any of the</span>
<span class="cm">	 * NAPI code and this dummy netdev is supposed to be</span>
<span class="cm">	 * only ever used for NAPI polls</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="p">));</span>

	<span class="cm">/* make sure we BUG if trying to hit standard</span>
<span class="cm">	 * register/unregister code path</span>
<span class="cm">	 */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">=</span> <span class="n">NETREG_DUMMY</span><span class="p">;</span>

	<span class="cm">/* NAPI wants this */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">napi_list</span><span class="p">);</span>

	<span class="cm">/* a dummy interface is started by default */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">__LINK_STATE_PRESENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">__LINK_STATE_START</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="cm">/* Note : We dont allocate pcpu_refcnt for dummy devices,</span>
<span class="cm">	 * because users of this &#39;device&#39; dont need to change</span>
<span class="cm">	 * its refcount.</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">init_dummy_netdev</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> *	register_netdev	- register a network device</span>
<span class="cm"> *	@dev: device to register</span>
<span class="cm"> *</span>
<span class="cm"> *	Take a completed network device structure and add it to the kernel</span>
<span class="cm"> *	interfaces. A %NETDEV_REGISTER message is sent to the netdev notifier</span>
<span class="cm"> *	chain. 0 is returned on success. A negative errno code is returned</span>
<span class="cm"> *	on a failure to set up the device, or if the name is a duplicate.</span>
<span class="cm"> *</span>
<span class="cm"> *	This is a wrapper around register_netdevice that takes the rtnl semaphore</span>
<span class="cm"> *	and expands the device name if you passed a format string to</span>
<span class="cm"> *	alloc_netdev.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">register_netdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_netdevice</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">register_netdev</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">netdev_refcnt_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">refcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">refcnt</span> <span class="o">+=</span> <span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcpu_refcnt</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">refcnt</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_refcnt_read</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * netdev_wait_allrefs - wait until all references are gone.</span>
<span class="cm"> *</span>
<span class="cm"> * This is called when unregistering network devices.</span>
<span class="cm"> *</span>
<span class="cm"> * Any protocol or device that holds a reference should register</span>
<span class="cm"> * for netdevice notification, and cleanup and put back the</span>
<span class="cm"> * reference if they receive an UNREGISTER event.</span>
<span class="cm"> * We can get stuck here if buggy protocols don&#39;t correctly</span>
<span class="cm"> * call dev_put.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">netdev_wait_allrefs</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rebroadcast_time</span><span class="p">,</span> <span class="n">warning_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">refcnt</span><span class="p">;</span>

	<span class="n">linkwatch_forget_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">rebroadcast_time</span> <span class="o">=</span> <span class="n">warning_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">refcnt</span> <span class="o">=</span> <span class="n">netdev_refcnt_read</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">refcnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">rebroadcast_time</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rtnl_lock</span><span class="p">();</span>

			<span class="cm">/* Rebroadcast unregister notification */</span>
			<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_UNREGISTER</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
			<span class="cm">/* don&#39;t resend NETDEV_UNREGISTER_BATCH, _BATCH users</span>
<span class="cm">			 * should have already handle it the first time */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">__LINK_STATE_LINKWATCH_PENDING</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* We must not have linkwatch events</span>
<span class="cm">				 * pending on unregister. If this</span>
<span class="cm">				 * happens, we simply run the queue</span>
<span class="cm">				 * unscheduled, resulting in a noop</span>
<span class="cm">				 * for this device.</span>
<span class="cm">				 */</span>
				<span class="n">linkwatch_run_queue</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="n">__rtnl_unlock</span><span class="p">();</span>

			<span class="n">rebroadcast_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">msleep</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>

		<span class="n">refcnt</span> <span class="o">=</span> <span class="n">netdev_refcnt_read</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">warning_time</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;unregister_netdevice: waiting for %s to become free. Usage count = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">refcnt</span><span class="p">);</span>
			<span class="n">warning_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* The sequence is:</span>
<span class="cm"> *</span>
<span class="cm"> *	rtnl_lock();</span>
<span class="cm"> *	...</span>
<span class="cm"> *	register_netdevice(x1);</span>
<span class="cm"> *	register_netdevice(x2);</span>
<span class="cm"> *	...</span>
<span class="cm"> *	unregister_netdevice(y1);</span>
<span class="cm"> *	unregister_netdevice(y2);</span>
<span class="cm"> *      ...</span>
<span class="cm"> *	rtnl_unlock();</span>
<span class="cm"> *	free_netdev(y1);</span>
<span class="cm"> *	free_netdev(y2);</span>
<span class="cm"> *</span>
<span class="cm"> * We are invoked by rtnl_unlock().</span>
<span class="cm"> * This allows us to deal with problems:</span>
<span class="cm"> * 1) We can delete sysfs objects which invoke hotplug</span>
<span class="cm"> *    without deadlocking with linkwatch via keventd.</span>
<span class="cm"> * 2) Since we run with the RTNL semaphore not held, we can sleep</span>
<span class="cm"> *    safely in order to wait for the netdev refcnt to drop to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * We must not return until all unregister events added during</span>
<span class="cm"> * the interval the lock was held have been completed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netdev_run_todo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/* Snapshot list, allow later requests */</span>
	<span class="n">list_replace_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_todo_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">__rtnl_unlock</span><span class="p">();</span>

	<span class="cm">/* Wait for rcu callbacks to finish before attempting to drain</span>
<span class="cm">	 * the device list.  This usually avoids a 250ms wait.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span>
		<span class="n">rcu_barrier</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span>
			<span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span><span class="p">,</span> <span class="n">todo_list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">todo_list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">!=</span> <span class="n">NETREG_UNREGISTERING</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;network todo &#39;%s&#39; but state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span><span class="p">);</span>
			<span class="n">dump_stack</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">=</span> <span class="n">NETREG_UNREGISTERED</span><span class="p">;</span>

		<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">flush_backlog</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">netdev_wait_allrefs</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* paranoia */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">netdev_refcnt_read</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ip_ptr</span><span class="p">));</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ip6_ptr</span><span class="p">));</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dn_ptr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

		<span class="cm">/* Free network device */</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Convert net_device_stats to rtnl_link_stats64.  They have the same</span>
<span class="cm"> * fields in the same order, with only the type differing.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">netdev_stats_to_stats64</span><span class="p">(</span><span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">stats64</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_stats</span> <span class="o">*</span><span class="n">netdev_stats</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if BITS_PER_LONG == 64</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats64</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">netdev_stats</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">stats64</span><span class="p">,</span> <span class="n">netdev_stats</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats64</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats64</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">netdev_stats</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">stats64</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">netdev_stats</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">!=</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">stats64</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_stats_to_stats64</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_get_stats	- get network device statistics</span>
<span class="cm"> *	@dev: device to get statistics from</span>
<span class="cm"> *	@storage: place to store stats</span>
<span class="cm"> *</span>
<span class="cm"> *	Get network statistics from device. Return @storage.</span>
<span class="cm"> *	The device driver may provide its own method by setting</span>
<span class="cm"> *	dev-&gt;netdev_ops-&gt;get_stats64 or dev-&gt;netdev_ops-&gt;get_stats;</span>
<span class="cm"> *	otherwise the internal statistics structure is used.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="nf">dev_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">rtnl_link_stats64</span> <span class="o">*</span><span class="n">storage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_get_stats64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">storage</span><span class="p">));</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_get_stats64</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">storage</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_get_stats</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">netdev_stats_to_stats64</span><span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">ndo_get_stats</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">netdev_stats_to_stats64</span><span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">storage</span><span class="o">-&gt;</span><span class="n">rx_dropped</span> <span class="o">+=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rx_dropped</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">storage</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dev_get_stats</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="nf">dev_ingress_queue_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="n">dev_ingress_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_CLS_ACT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">queue</span><span class="p">;</span>
	<span class="n">queue</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">queue</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">netdev_init_one_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">qdisc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">noop_qdisc</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">qdisc_sleeping</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">noop_qdisc</span><span class="p">;</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ingress_queue</span><span class="p">,</span> <span class="n">queue</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">queue</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	alloc_netdev_mqs - allocate network device</span>
<span class="cm"> *	@sizeof_priv:	size of private data to allocate space for</span>
<span class="cm"> *	@name:		device name format string</span>
<span class="cm"> *	@setup:		callback to initialize device</span>
<span class="cm"> *	@txqs:		the number of TX subqueues to allocate</span>
<span class="cm"> *	@rxqs:		the number of RX subqueues to allocate</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocates a struct net_device with private data area for driver use</span>
<span class="cm"> *	and performs basic initialization.  Also allocates subquue structs</span>
<span class="cm"> *	for each queue on the device.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="nf">alloc_netdev_mqs</span><span class="p">(</span><span class="kt">int</span> <span class="n">sizeof_priv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">setup</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">),</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">txqs</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rxqs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">alloc_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">txqs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;alloc_netdev: Unable to allocate device with zero queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rxqs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;alloc_netdev: Unable to allocate device with zero RX queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">alloc_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sizeof_priv</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ensure 32-byte alignment of private area */</span>
		<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">NETDEV_ALIGN</span><span class="p">);</span>
		<span class="n">alloc_size</span> <span class="o">+=</span> <span class="n">sizeof_priv</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* ensure 32-byte alignment of whole construct */</span>
	<span class="n">alloc_size</span> <span class="o">+=</span> <span class="n">NETDEV_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;alloc_netdev: Unable to allocate device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">PTR_ALIGN</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">NETDEV_ALIGN</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">padded</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcpu_refcnt</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcpu_refcnt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_addr_init</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free_pcpu</span><span class="p">;</span>

	<span class="n">dev_mc_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_uc_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev_net_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gso_max_size</span> <span class="o">=</span> <span class="n">GSO_MAX_SIZE</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">napi_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unreg_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link_watch_list</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">=</span> <span class="n">IFF_XMIT_DST_RELEASE</span><span class="p">;</span>
	<span class="n">setup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_tx_queues</span> <span class="o">=</span> <span class="n">txqs</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_tx_queues</span> <span class="o">=</span> <span class="n">txqs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_alloc_netdev_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free_all</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">num_rx_queues</span> <span class="o">=</span> <span class="n">rxqs</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">real_num_rx_queues</span> <span class="o">=</span> <span class="n">rxqs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netif_alloc_rx_queues</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free_all</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">group</span> <span class="o">=</span> <span class="n">INIT_NETDEV_GROUP</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>

<span class="nl">free_all:</span>
	<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">free_pcpu:</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcpu_refcnt</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_tx</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_rx</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="nl">free_p:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">alloc_netdev_mqs</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	free_netdev - free network device</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *</span>
<span class="cm"> *	This function does the last stage of destroying an allocated device</span>
<span class="cm"> * 	interface. The reference to the device object is released.</span>
<span class="cm"> *	If this is the last reference then it will be freed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">free_netdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">release_net</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_tx</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_RPS</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">_rx</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ingress_queue</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

	<span class="cm">/* Flush device addresses */</span>
	<span class="n">dev_addr_flush</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">napi_list</span><span class="p">,</span> <span class="n">dev_list</span><span class="p">)</span>
		<span class="n">netif_napi_del</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">free_percpu</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcpu_refcnt</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">pcpu_refcnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*  Compatibility with error handling in drivers */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">==</span> <span class="n">NETREG_UNINITIALIZED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span> <span class="o">-</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">padded</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">!=</span> <span class="n">NETREG_UNREGISTERED</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">=</span> <span class="n">NETREG_RELEASED</span><span class="p">;</span>

	<span class="cm">/* will free via device release */</span>
	<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">free_netdev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	synchronize_net -  Synchronize with packet receive processing</span>
<span class="cm"> *</span>
<span class="cm"> *	Wait for packets currently being received to be done.</span>
<span class="cm"> *	Does not block later packets from starting.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">synchronize_net</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtnl_is_locked</span><span class="p">())</span>
		<span class="n">synchronize_rcu_expedited</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">synchronize_rcu</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">synchronize_net</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	unregister_netdevice_queue - remove device from the kernel</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@head: list</span>
<span class="cm"> *</span>
<span class="cm"> *	This function shuts down a device interface and removes it</span>
<span class="cm"> *	from the kernel tables.</span>
<span class="cm"> *	If head not NULL, device is queued to be unregistered later.</span>
<span class="cm"> *</span>
<span class="cm"> *	Callers must hold the rtnl semaphore.  You may want</span>
<span class="cm"> *	unregister_netdev() instead of this.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">unregister_netdevice_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unreg_list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rollback_registered</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="cm">/* Finish processing unregister after unlock */</span>
		<span class="n">net_set_todo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_netdevice_queue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	unregister_netdevice_many - unregister many devices</span>
<span class="cm"> *	@head: list of devices</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unregister_netdevice_many</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rollback_registered_many</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">unreg_list</span><span class="p">)</span>
			<span class="n">net_set_todo</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_netdevice_many</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	unregister_netdev - remove device from the kernel</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *</span>
<span class="cm"> *	This function shuts down a device interface and removes it</span>
<span class="cm"> *	from the kernel tables.</span>
<span class="cm"> *</span>
<span class="cm"> *	This is just a wrapper for unregister_netdevice that takes</span>
<span class="cm"> *	the rtnl semaphore.  In general you want to use this and not</span>
<span class="cm"> *	unregister_netdevice.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unregister_netdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">unregister_netdevice</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unregister_netdev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	dev_change_net_namespace - move device to different nethost namespace</span>
<span class="cm"> *	@dev: device</span>
<span class="cm"> *	@net: network namespace</span>
<span class="cm"> *	@pat: If not NULL name pattern to try if the current device name</span>
<span class="cm"> *	      is already taken in the destination network namespace.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function shuts down a device interface and moves it</span>
<span class="cm"> *	to a new network namespace. On success 0 is returned, on</span>
<span class="cm"> *	a failure a netagive errno code is returned.</span>
<span class="cm"> *</span>
<span class="cm"> *	Callers must hold the rtnl semaphore.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">dev_change_net_namespace</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ASSERT_RTNL</span><span class="p">();</span>

	<span class="cm">/* Don&#39;t allow namespace local devices to be moved. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_NETNS_LOCAL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Ensure the device has been registrered */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">reg_state</span> <span class="o">!=</span> <span class="n">NETREG_REGISTERED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Get out if there is nothing todo */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_eq</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">net</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Pick the destination device name, and ensure</span>
<span class="cm">	 * we can use it in the destination network namespace.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__dev_get_by_name</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We get here if we can&#39;t use the current device name */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pat</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_get_valid_name</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * And now a mini version of register_netdevice unregister_netdevice.</span>
<span class="cm">	 */</span>

	<span class="cm">/* If device is running close it first. */</span>
	<span class="n">dev_close</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* And unlink it from device chain */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">unlist_netdevice</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">synchronize_net</span><span class="p">();</span>

	<span class="cm">/* Shutdown queueing discipline. */</span>
	<span class="n">dev_shutdown</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Notify protocols, that we are about to destroy</span>
<span class="cm">	   this device. They should clean all the things.</span>

<span class="cm">	   Note that dev-&gt;reg_state stays at NETREG_REGISTERED.</span>
<span class="cm">	   This is wanted because this way 8021q and macvlan know</span>
<span class="cm">	   the device is just moving and can keep their slaves up.</span>
<span class="cm">	*/</span>
	<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_UNREGISTER</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_UNREGISTER_BATCH</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">rtmsg_ifinfo</span><span class="p">(</span><span class="n">RTM_DELLINK</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="o">~</span><span class="mi">0U</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Flush the unicast and multicast chains</span>
<span class="cm">	 */</span>
	<span class="n">dev_uc_flush</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_mc_flush</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Actually switch the network namespace */</span>
	<span class="n">dev_net_set</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>

	<span class="cm">/* If there is an ifindex conflict assign a new one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__dev_get_by_index</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">iflink</span> <span class="o">=</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">iflink</span> <span class="o">==</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span> <span class="o">=</span> <span class="n">dev_new_index</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iflink</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">iflink</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fixup kobjects */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_rename</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>

	<span class="cm">/* Add the device back in the hashes */</span>
	<span class="n">list_netdevice</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* Notify protocols, that a new device appeared. */</span>
	<span class="n">call_netdevice_notifiers</span><span class="p">(</span><span class="n">NETDEV_REGISTER</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Prevent userspace races by waiting until the network</span>
<span class="cm">	 *	device is fully setup before sending notifications.</span>
<span class="cm">	 */</span>
	<span class="n">rtmsg_ifinfo</span><span class="p">(</span><span class="n">RTM_NEWLINK</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="o">~</span><span class="mi">0U</span><span class="p">);</span>

	<span class="n">synchronize_net</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dev_change_net_namespace</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_cpu_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="o">*</span><span class="n">ocpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">list_skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">oldcpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ocpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="o">*</span><span class="n">oldsd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">!=</span> <span class="n">CPU_DEAD</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">!=</span> <span class="n">CPU_DEAD_FROZEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="n">local_irq_disable</span><span class="p">();</span>
	<span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">oldsd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">,</span> <span class="n">oldcpu</span><span class="p">);</span>

	<span class="cm">/* Find end of our completion_queue. */</span>
	<span class="n">list_skb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">list_skb</span><span class="p">)</span>
		<span class="n">list_skb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">list_skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="cm">/* Append completion queue from offline CPU. */</span>
	<span class="o">*</span><span class="n">list_skb</span> <span class="o">=</span> <span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">completion_queue</span><span class="p">;</span>
	<span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">completion_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Append output queue from offline CPU. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span><span class="p">;</span>
		<span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">output_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Append NAPI poll list from offline CPU. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">);</span>
		<span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_RX_SOFTIRQ</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">NET_TX_SOFTIRQ</span><span class="p">);</span>
	<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="cm">/* Process offline CPU&#39;s input_pkt_queue */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">process_queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">input_queue_head_incr</span><span class="p">(</span><span class="n">oldsd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldsd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">input_queue_head_incr</span><span class="p">(</span><span class="n">oldsd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	netdev_increment_features - increment feature set by one</span>
<span class="cm"> *	@all: current feature set</span>
<span class="cm"> *	@one: new feature set</span>
<span class="cm"> *	@mask: mask feature set</span>
<span class="cm"> *</span>
<span class="cm"> *	Computes a new feature set after adding a device with feature set</span>
<span class="cm"> *	@one to the master device with current feature set @all.  Will not</span>
<span class="cm"> *	enable anything that is off in @mask. Returns the new feature set.</span>
<span class="cm"> */</span>
<span class="n">netdev_features_t</span> <span class="nf">netdev_increment_features</span><span class="p">(</span><span class="n">netdev_features_t</span> <span class="n">all</span><span class="p">,</span>
	<span class="n">netdev_features_t</span> <span class="n">one</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">NETIF_F_GEN_CSUM</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">NETIF_F_ALL_CSUM</span><span class="p">;</span>
	<span class="n">mask</span> <span class="o">|=</span> <span class="n">NETIF_F_VLAN_CHALLENGED</span><span class="p">;</span>

	<span class="n">all</span> <span class="o">|=</span> <span class="n">one</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NETIF_F_ONE_FOR_ALL</span><span class="o">|</span><span class="n">NETIF_F_ALL_CSUM</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">all</span> <span class="o">&amp;=</span> <span class="n">one</span> <span class="o">|</span> <span class="o">~</span><span class="n">NETIF_F_ALL_FOR_ALL</span><span class="p">;</span>

	<span class="cm">/* If one device supports hw checksumming, set for all. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">all</span> <span class="o">&amp;</span> <span class="n">NETIF_F_GEN_CSUM</span><span class="p">)</span>
		<span class="n">all</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">NETIF_F_ALL_CSUM</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">NETIF_F_GEN_CSUM</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">all</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_increment_features</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="nf">netdev_create_hash</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">hash</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hash</span><span class="p">)</span> <span class="o">*</span> <span class="n">NETDEV_HASHENTRIES</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NETDEV_HASHENTRIES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">hash</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initialize per network namespace state */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__net_init</span> <span class="nf">netdev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_base_head</span><span class="p">);</span>

	<span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_name_head</span> <span class="o">=</span> <span class="n">netdev_create_hash</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_name_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_name</span><span class="p">;</span>

	<span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_index_head</span> <span class="o">=</span> <span class="n">netdev_create_hash</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_index_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_idx</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_idx:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_name_head</span><span class="p">);</span>
<span class="nl">err_name:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	netdev_drivername - network driver for the device</span>
<span class="cm"> *	@dev: network device</span>
<span class="cm"> *</span>
<span class="cm"> *	Determine network driver for device.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">netdev_drivername</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">empty</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">empty</span><span class="p">;</span>

	<span class="n">driver</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">empty</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__netdev_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">va_format</span> <span class="o">*</span><span class="n">vaf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">dev_printk</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&quot;%s: %pV&quot;</span><span class="p">,</span>
			       <span class="n">netdev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">vaf</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s%s: %pV&quot;</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">netdev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">vaf</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s(NULL net_device): %pV&quot;</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">vaf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__netdev_printk</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">netdev_printk</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>

	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">format</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>

	<span class="n">r</span> <span class="o">=</span> <span class="n">__netdev_printk</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_printk</span><span class="p">);</span>

<span class="cp">#define define_netdev_printk_level(func, level)			\</span>
<span class="cp">int func(const struct net_device *dev, const char *fmt, ...)	\</span>
<span class="cp">{								\</span>
<span class="cp">	int r;							\</span>
<span class="cp">	struct va_format vaf;					\</span>
<span class="cp">	va_list args;						\</span>
<span class="cp">								\</span>
<span class="cp">	va_start(args, fmt);					\</span>
<span class="cp">								\</span>
<span class="cp">	vaf.fmt = fmt;						\</span>
<span class="cp">	vaf.va = &amp;args;						\</span>
<span class="cp">								\</span>
<span class="cp">	r = __netdev_printk(level, dev, &amp;vaf);			\</span>
<span class="cp">	va_end(args);						\</span>
<span class="cp">								\</span>
<span class="cp">	return r;						\</span>
<span class="cp">}								\</span>
<span class="cp">EXPORT_SYMBOL(func);</span>

<span class="n">define_netdev_printk_level</span><span class="p">(</span><span class="n">netdev_emerg</span><span class="p">,</span> <span class="n">KERN_EMERG</span><span class="p">);</span>
<span class="n">define_netdev_printk_level</span><span class="p">(</span><span class="n">netdev_alert</span><span class="p">,</span> <span class="n">KERN_ALERT</span><span class="p">);</span>
<span class="n">define_netdev_printk_level</span><span class="p">(</span><span class="n">netdev_crit</span><span class="p">,</span> <span class="n">KERN_CRIT</span><span class="p">);</span>
<span class="n">define_netdev_printk_level</span><span class="p">(</span><span class="n">netdev_err</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">);</span>
<span class="n">define_netdev_printk_level</span><span class="p">(</span><span class="n">netdev_warn</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">);</span>
<span class="n">define_netdev_printk_level</span><span class="p">(</span><span class="n">netdev_notice</span><span class="p">,</span> <span class="n">KERN_NOTICE</span><span class="p">);</span>
<span class="n">define_netdev_printk_level</span><span class="p">(</span><span class="n">netdev_info</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__net_exit</span> <span class="nf">netdev_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_name_head</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_index_head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">__net_initdata</span> <span class="n">netdev_net_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">netdev_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">netdev_exit</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__net_exit</span> <span class="nf">default_device_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">aux</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Push all migratable network devices back to the</span>
<span class="cm">	 * initial network namespace</span>
<span class="cm">	 */</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">for_each_netdev_safe</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">aux</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
		<span class="kt">char</span> <span class="n">fb_name</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>

		<span class="cm">/* Ignore unmoveable devices (i.e. loopback) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_NETNS_LOCAL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Leave virtual devices for the generic cleanup */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rtnl_link_ops</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Push remaining network devices to init_net */</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">fb_name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">,</span> <span class="s">&quot;dev%d&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dev_change_net_namespace</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">fb_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;%s: failed to move %s to init_net: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">__func__</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__net_exit</span> <span class="nf">default_device_exit_batch</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">net_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* At exit all network devices most be removed from a network</span>
<span class="cm">	 * namespace.  Do this in the reverse order of registration.</span>
<span class="cm">	 * Do this across as many network namespaces as possible to</span>
<span class="cm">	 * improve batching efficiency.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">dev_kill_list</span><span class="p">);</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">net_list</span><span class="p">,</span> <span class="n">exit_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_netdev_reverse</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">rtnl_link_ops</span><span class="p">)</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">rtnl_link_ops</span><span class="o">-&gt;</span><span class="n">dellink</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_kill_list</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">unregister_netdevice_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_kill_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">unregister_netdevice_many</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_kill_list</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_kill_list</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">__net_initdata</span> <span class="n">default_device_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">default_device_exit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit_batch</span> <span class="o">=</span> <span class="n">default_device_exit_batch</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Initialize the DEV module. At boot time this walks the device list and</span>
<span class="cm"> *	unhooks any devices that fail to initialise (normally hardware not</span>
<span class="cm"> *	present) and leaves us with a valid list of present and active devices.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *       This is called single threaded during boot, so no need</span>
<span class="cm"> *       to take the rtnl semaphore.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">net_dev_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev_boot_phase</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev_proc_init</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">netdev_kobject_init</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptype_all</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PTYPE_HASH_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptype_base</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">register_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netdev_net_ops</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Initialise the packet receive queues.</span>
<span class="cm">	 */</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">softnet_data</span> <span class="o">*</span><span class="n">sd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">softnet_data</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sd</span><span class="p">));</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">input_pkt_queue</span><span class="p">);</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">process_queue</span><span class="p">);</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">completion_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">poll_list</span><span class="p">);</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue_tailp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">output_queue</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_RPS</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">csd</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">rps_trigger_softirq</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">csd</span><span class="p">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">sd</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">csd</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">backlog</span><span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">process_backlog</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">backlog</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight_p</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">backlog</span><span class="p">.</span><span class="n">gro_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">sd</span><span class="o">-&gt;</span><span class="n">backlog</span><span class="p">.</span><span class="n">gro_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_boot_phase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* The loopback device is special if any other network devices</span>
<span class="cm">	 * is present in a network namespace the loopback device must</span>
<span class="cm">	 * be present. Since we now dynamically allocate and free the</span>
<span class="cm">	 * loopback device ensure this invariant is maintained by</span>
<span class="cm">	 * keeping the loopback device as the first device on the</span>
<span class="cm">	 * list of network devices.  Ensuring the loopback devices</span>
<span class="cm">	 * is the first device that appears and the last network device</span>
<span class="cm">	 * that disappears.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_pernet_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loopback_net_ops</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">register_pernet_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">default_device_ops</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">open_softirq</span><span class="p">(</span><span class="n">NET_TX_SOFTIRQ</span><span class="p">,</span> <span class="n">net_tx_action</span><span class="p">);</span>
	<span class="n">open_softirq</span><span class="p">(</span><span class="n">NET_RX_SOFTIRQ</span><span class="p">,</span> <span class="n">net_rx_action</span><span class="p">);</span>

	<span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">dev_cpu_callback</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">dst_init</span><span class="p">();</span>
	<span class="n">dev_mcast_init</span><span class="p">();</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">net_dev_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">initialize_hashrnd</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hashrnd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hashrnd</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">late_initcall_sync</span><span class="p">(</span><span class="n">initialize_hashrnd</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
