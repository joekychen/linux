<!DOCTYPE html>
<html><head><title>joekychen/linux » net › core › sock.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sock.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * INET		An implementation of the TCP/IP protocol suite for the LINUX</span>
<span class="cm"> *		operating system.  INET is implemented using the  BSD Socket</span>
<span class="cm"> *		interface as the means of communication with the user level.</span>
<span class="cm"> *</span>
<span class="cm"> *		Generic socket support routines. Memory allocators, socket lock/release</span>
<span class="cm"> *		handler for protocols to use and generic option handler.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Ross Biro</span>
<span class="cm"> *		Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *		Florian La Roche, &lt;flla@stud.uni-sb.de&gt;</span>
<span class="cm"> *		Alan Cox, &lt;A.Cox@swansea.ac.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Fixes:</span>
<span class="cm"> *		Alan Cox	: 	Numerous verify_area() problems</span>
<span class="cm"> *		Alan Cox	:	Connecting on a connecting socket</span>
<span class="cm"> *					now returns an error for tcp.</span>
<span class="cm"> *		Alan Cox	:	sock-&gt;protocol is set correctly.</span>
<span class="cm"> *					and is not sometimes left as 0.</span>
<span class="cm"> *		Alan Cox	:	connect handles icmp errors on a</span>
<span class="cm"> *					connect properly. Unfortunately there</span>
<span class="cm"> *					is a restart syscall nasty there. I</span>
<span class="cm"> *					can&#39;t match BSD without hacking the C</span>
<span class="cm"> *					library. Ideas urgently sought!</span>
<span class="cm"> *		Alan Cox	:	Disallow bind() to addresses that are</span>
<span class="cm"> *					not ours - especially broadcast ones!!</span>
<span class="cm"> *		Alan Cox	:	Socket 1024 _IS_ ok for users. (fencepost)</span>
<span class="cm"> *		Alan Cox	:	sock_wfree/sock_rfree don&#39;t destroy sockets,</span>
<span class="cm"> *					instead they leave that for the DESTROY timer.</span>
<span class="cm"> *		Alan Cox	:	Clean up error flag in accept</span>
<span class="cm"> *		Alan Cox	:	TCP ack handling is buggy, the DESTROY timer</span>
<span class="cm"> *					was buggy. Put a remove_sock() in the handler</span>
<span class="cm"> *					for memory when we hit 0. Also altered the timer</span>
<span class="cm"> *					code. The ACK stuff can wait and needs major</span>
<span class="cm"> *					TCP layer surgery.</span>
<span class="cm"> *		Alan Cox	:	Fixed TCP ack bug, removed remove sock</span>
<span class="cm"> *					and fixed timer/inet_bh race.</span>
<span class="cm"> *		Alan Cox	:	Added zapped flag for TCP</span>
<span class="cm"> *		Alan Cox	:	Move kfree_skb into skbuff.c and tidied up surplus code</span>
<span class="cm"> *		Alan Cox	:	for new sk_buff allocations wmalloc/rmalloc now call alloc_skb</span>
<span class="cm"> *		Alan Cox	:	kfree_s calls now are kfree_skbmem so we can track skb resources</span>
<span class="cm"> *		Alan Cox	:	Supports socket option broadcast now as does udp. Packet and raw need fixing.</span>
<span class="cm"> *		Alan Cox	:	Added RCVBUF,SNDBUF size setting. It suddenly occurred to me how easy it was so...</span>
<span class="cm"> *		Rick Sladkey	:	Relaxed UDP rules for matching packets.</span>
<span class="cm"> *		C.E.Hawkins	:	IFF_PROMISC/SIOCGHWADDR support</span>
<span class="cm"> *	Pauline Middelink	:	identd support</span>
<span class="cm"> *		Alan Cox	:	Fixed connect() taking signals I think.</span>
<span class="cm"> *		Alan Cox	:	SO_LINGER supported</span>
<span class="cm"> *		Alan Cox	:	Error reporting fixes</span>
<span class="cm"> *		Anonymous	:	inet_create tidied up (sk-&gt;reuse setting)</span>
<span class="cm"> *		Alan Cox	:	inet sockets don&#39;t set sk-&gt;type!</span>
<span class="cm"> *		Alan Cox	:	Split socket option code</span>
<span class="cm"> *		Alan Cox	:	Callbacks</span>
<span class="cm"> *		Alan Cox	:	Nagle flag for Charles &amp; Johannes stuff</span>
<span class="cm"> *		Alex		:	Removed restriction on inet fioctl</span>
<span class="cm"> *		Alan Cox	:	Splitting INET from NET core</span>
<span class="cm"> *		Alan Cox	:	Fixed bogus SO_TYPE handling in getsockopt()</span>
<span class="cm"> *		Adam Caldwell	:	Missing return in SO_DONTROUTE/SO_DEBUG code</span>
<span class="cm"> *		Alan Cox	:	Split IP from generic code</span>
<span class="cm"> *		Alan Cox	:	New kfree_skbmem()</span>
<span class="cm"> *		Alan Cox	:	Make SO_DEBUG superuser only.</span>
<span class="cm"> *		Alan Cox	:	Allow anyone to clear SO_DEBUG</span>
<span class="cm"> *					(compatibility fix)</span>
<span class="cm"> *		Alan Cox	:	Added optimistic memory grabbing for AF_UNIX throughput.</span>
<span class="cm"> *		Alan Cox	:	Allocator for a socket is settable.</span>
<span class="cm"> *		Alan Cox	:	SO_ERROR includes soft errors.</span>
<span class="cm"> *		Alan Cox	:	Allow NULL arguments on some SO_ opts</span>
<span class="cm"> *		Alan Cox	: 	Generic socket allocation to make hooks</span>
<span class="cm"> *					easier (suggested by Craig Metz).</span>
<span class="cm"> *		Michael Pall	:	SO_ERROR returns positive errno again</span>
<span class="cm"> *              Steve Whitehouse:       Added default destructor to free</span>
<span class="cm"> *                                      protocol private data.</span>
<span class="cm"> *              Steve Whitehouse:       Added various other default routines</span>
<span class="cm"> *                                      common to several socket families.</span>
<span class="cm"> *              Chris Evans     :       Call suser() check last on F_SETOWN</span>
<span class="cm"> *		Jay Schulist	:	Added SO_ATTACH_FILTER and SO_DETACH_FILTER.</span>
<span class="cm"> *		Andi Kleen	:	Add sock_kmalloc()/sock_kfree_s()</span>
<span class="cm"> *		Andi Kleen	:	Fix write_space callback</span>
<span class="cm"> *		Chris Evans	:	Security fixes - signedness again</span>
<span class="cm"> *		Arnaldo C. Melo :       cleanups, use skb_queue_purge</span>
<span class="cm"> *</span>
<span class="cm"> * To Fix:</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/sockios.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/tcp.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/user_namespace.h&gt;</span>
<span class="cp">#include &lt;linux/static_key.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;net/protocol.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/request_sock.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;linux/net_tstamp.h&gt;</span>
<span class="cp">#include &lt;net/xfrm.h&gt;</span>
<span class="cp">#include &lt;linux/ipsec.h&gt;</span>
<span class="cp">#include &lt;net/cls_cgroup.h&gt;</span>
<span class="cp">#include &lt;net/netprio_cgroup.h&gt;</span>

<span class="cp">#include &lt;linux/filter.h&gt;</span>

<span class="cp">#include &lt;trace/events/sock.h&gt;</span>

<span class="cp">#ifdef CONFIG_INET</span>
<span class="cp">#include &lt;net/tcp.h&gt;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">proto_list_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">proto_list</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR_KMEM</span>
<span class="kt">int</span> <span class="nf">mem_cgroup_sockets_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">proto</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proto_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">init_cgroup</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">proto</span><span class="o">-&gt;</span><span class="n">init_cgroup</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">ss</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">list_for_each_entry_continue_reverse</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proto_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">destroy_cgroup</span><span class="p">)</span>
			<span class="n">proto</span><span class="o">-&gt;</span><span class="n">destroy_cgroup</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mem_cgroup_sockets_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">proto</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">proto</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proto_list</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">destroy_cgroup</span><span class="p">)</span>
			<span class="n">proto</span><span class="o">-&gt;</span><span class="n">destroy_cgroup</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Each address family might have different locking rules, so we have</span>
<span class="cm"> * one slock key per address family:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">af_family_keys</span><span class="p">[</span><span class="n">AF_MAX</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">af_family_slock_keys</span><span class="p">[</span><span class="n">AF_MAX</span><span class="p">];</span>

<span class="k">struct</span> <span class="n">static_key</span> <span class="n">memcg_socket_limit_enabled</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">memcg_socket_limit_enabled</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Make lock validator output more readable. (we pre-construct these</span>
<span class="cm"> * strings build-time, so that runtime initialization of socket</span>
<span class="cm"> * locks is fast):</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">af_family_key_strings</span><span class="p">[</span><span class="n">AF_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">&quot;sk_lock-AF_UNSPEC&quot;</span><span class="p">,</span> <span class="s">&quot;sk_lock-AF_UNIX&quot;</span>     <span class="p">,</span> <span class="s">&quot;sk_lock-AF_INET&quot;</span>     <span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_AX25&quot;</span>  <span class="p">,</span> <span class="s">&quot;sk_lock-AF_IPX&quot;</span>      <span class="p">,</span> <span class="s">&quot;sk_lock-AF_APPLETALK&quot;</span><span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_NETROM&quot;</span><span class="p">,</span> <span class="s">&quot;sk_lock-AF_BRIDGE&quot;</span>   <span class="p">,</span> <span class="s">&quot;sk_lock-AF_ATMPVC&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_X25&quot;</span>   <span class="p">,</span> <span class="s">&quot;sk_lock-AF_INET6&quot;</span>    <span class="p">,</span> <span class="s">&quot;sk_lock-AF_ROSE&quot;</span>     <span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_DECnet&quot;</span><span class="p">,</span> <span class="s">&quot;sk_lock-AF_NETBEUI&quot;</span>  <span class="p">,</span> <span class="s">&quot;sk_lock-AF_SECURITY&quot;</span> <span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_KEY&quot;</span>   <span class="p">,</span> <span class="s">&quot;sk_lock-AF_NETLINK&quot;</span>  <span class="p">,</span> <span class="s">&quot;sk_lock-AF_PACKET&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_ASH&quot;</span>   <span class="p">,</span> <span class="s">&quot;sk_lock-AF_ECONET&quot;</span>   <span class="p">,</span> <span class="s">&quot;sk_lock-AF_ATMSVC&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_RDS&quot;</span>   <span class="p">,</span> <span class="s">&quot;sk_lock-AF_SNA&quot;</span>      <span class="p">,</span> <span class="s">&quot;sk_lock-AF_IRDA&quot;</span>     <span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_PPPOX&quot;</span> <span class="p">,</span> <span class="s">&quot;sk_lock-AF_WANPIPE&quot;</span>  <span class="p">,</span> <span class="s">&quot;sk_lock-AF_LLC&quot;</span>      <span class="p">,</span>
  <span class="s">&quot;sk_lock-27&quot;</span>       <span class="p">,</span> <span class="s">&quot;sk_lock-28&quot;</span>          <span class="p">,</span> <span class="s">&quot;sk_lock-AF_CAN&quot;</span>      <span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_TIPC&quot;</span>  <span class="p">,</span> <span class="s">&quot;sk_lock-AF_BLUETOOTH&quot;</span><span class="p">,</span> <span class="s">&quot;sk_lock-IUCV&quot;</span>        <span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_RXRPC&quot;</span> <span class="p">,</span> <span class="s">&quot;sk_lock-AF_ISDN&quot;</span>     <span class="p">,</span> <span class="s">&quot;sk_lock-AF_PHONET&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_IEEE802154&quot;</span><span class="p">,</span> <span class="s">&quot;sk_lock-AF_CAIF&quot;</span> <span class="p">,</span> <span class="s">&quot;sk_lock-AF_ALG&quot;</span>      <span class="p">,</span>
  <span class="s">&quot;sk_lock-AF_NFC&quot;</span>   <span class="p">,</span> <span class="s">&quot;sk_lock-AF_MAX&quot;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">af_family_slock_key_strings</span><span class="p">[</span><span class="n">AF_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">&quot;slock-AF_UNSPEC&quot;</span><span class="p">,</span> <span class="s">&quot;slock-AF_UNIX&quot;</span>     <span class="p">,</span> <span class="s">&quot;slock-AF_INET&quot;</span>     <span class="p">,</span>
  <span class="s">&quot;slock-AF_AX25&quot;</span>  <span class="p">,</span> <span class="s">&quot;slock-AF_IPX&quot;</span>      <span class="p">,</span> <span class="s">&quot;slock-AF_APPLETALK&quot;</span><span class="p">,</span>
  <span class="s">&quot;slock-AF_NETROM&quot;</span><span class="p">,</span> <span class="s">&quot;slock-AF_BRIDGE&quot;</span>   <span class="p">,</span> <span class="s">&quot;slock-AF_ATMPVC&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;slock-AF_X25&quot;</span>   <span class="p">,</span> <span class="s">&quot;slock-AF_INET6&quot;</span>    <span class="p">,</span> <span class="s">&quot;slock-AF_ROSE&quot;</span>     <span class="p">,</span>
  <span class="s">&quot;slock-AF_DECnet&quot;</span><span class="p">,</span> <span class="s">&quot;slock-AF_NETBEUI&quot;</span>  <span class="p">,</span> <span class="s">&quot;slock-AF_SECURITY&quot;</span> <span class="p">,</span>
  <span class="s">&quot;slock-AF_KEY&quot;</span>   <span class="p">,</span> <span class="s">&quot;slock-AF_NETLINK&quot;</span>  <span class="p">,</span> <span class="s">&quot;slock-AF_PACKET&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;slock-AF_ASH&quot;</span>   <span class="p">,</span> <span class="s">&quot;slock-AF_ECONET&quot;</span>   <span class="p">,</span> <span class="s">&quot;slock-AF_ATMSVC&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;slock-AF_RDS&quot;</span>   <span class="p">,</span> <span class="s">&quot;slock-AF_SNA&quot;</span>      <span class="p">,</span> <span class="s">&quot;slock-AF_IRDA&quot;</span>     <span class="p">,</span>
  <span class="s">&quot;slock-AF_PPPOX&quot;</span> <span class="p">,</span> <span class="s">&quot;slock-AF_WANPIPE&quot;</span>  <span class="p">,</span> <span class="s">&quot;slock-AF_LLC&quot;</span>      <span class="p">,</span>
  <span class="s">&quot;slock-27&quot;</span>       <span class="p">,</span> <span class="s">&quot;slock-28&quot;</span>          <span class="p">,</span> <span class="s">&quot;slock-AF_CAN&quot;</span>      <span class="p">,</span>
  <span class="s">&quot;slock-AF_TIPC&quot;</span>  <span class="p">,</span> <span class="s">&quot;slock-AF_BLUETOOTH&quot;</span><span class="p">,</span> <span class="s">&quot;slock-AF_IUCV&quot;</span>     <span class="p">,</span>
  <span class="s">&quot;slock-AF_RXRPC&quot;</span> <span class="p">,</span> <span class="s">&quot;slock-AF_ISDN&quot;</span>     <span class="p">,</span> <span class="s">&quot;slock-AF_PHONET&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;slock-AF_IEEE802154&quot;</span><span class="p">,</span> <span class="s">&quot;slock-AF_CAIF&quot;</span> <span class="p">,</span> <span class="s">&quot;slock-AF_ALG&quot;</span>      <span class="p">,</span>
  <span class="s">&quot;slock-AF_NFC&quot;</span>   <span class="p">,</span> <span class="s">&quot;slock-AF_MAX&quot;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">af_family_clock_key_strings</span><span class="p">[</span><span class="n">AF_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">&quot;clock-AF_UNSPEC&quot;</span><span class="p">,</span> <span class="s">&quot;clock-AF_UNIX&quot;</span>     <span class="p">,</span> <span class="s">&quot;clock-AF_INET&quot;</span>     <span class="p">,</span>
  <span class="s">&quot;clock-AF_AX25&quot;</span>  <span class="p">,</span> <span class="s">&quot;clock-AF_IPX&quot;</span>      <span class="p">,</span> <span class="s">&quot;clock-AF_APPLETALK&quot;</span><span class="p">,</span>
  <span class="s">&quot;clock-AF_NETROM&quot;</span><span class="p">,</span> <span class="s">&quot;clock-AF_BRIDGE&quot;</span>   <span class="p">,</span> <span class="s">&quot;clock-AF_ATMPVC&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;clock-AF_X25&quot;</span>   <span class="p">,</span> <span class="s">&quot;clock-AF_INET6&quot;</span>    <span class="p">,</span> <span class="s">&quot;clock-AF_ROSE&quot;</span>     <span class="p">,</span>
  <span class="s">&quot;clock-AF_DECnet&quot;</span><span class="p">,</span> <span class="s">&quot;clock-AF_NETBEUI&quot;</span>  <span class="p">,</span> <span class="s">&quot;clock-AF_SECURITY&quot;</span> <span class="p">,</span>
  <span class="s">&quot;clock-AF_KEY&quot;</span>   <span class="p">,</span> <span class="s">&quot;clock-AF_NETLINK&quot;</span>  <span class="p">,</span> <span class="s">&quot;clock-AF_PACKET&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;clock-AF_ASH&quot;</span>   <span class="p">,</span> <span class="s">&quot;clock-AF_ECONET&quot;</span>   <span class="p">,</span> <span class="s">&quot;clock-AF_ATMSVC&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;clock-AF_RDS&quot;</span>   <span class="p">,</span> <span class="s">&quot;clock-AF_SNA&quot;</span>      <span class="p">,</span> <span class="s">&quot;clock-AF_IRDA&quot;</span>     <span class="p">,</span>
  <span class="s">&quot;clock-AF_PPPOX&quot;</span> <span class="p">,</span> <span class="s">&quot;clock-AF_WANPIPE&quot;</span>  <span class="p">,</span> <span class="s">&quot;clock-AF_LLC&quot;</span>      <span class="p">,</span>
  <span class="s">&quot;clock-27&quot;</span>       <span class="p">,</span> <span class="s">&quot;clock-28&quot;</span>          <span class="p">,</span> <span class="s">&quot;clock-AF_CAN&quot;</span>      <span class="p">,</span>
  <span class="s">&quot;clock-AF_TIPC&quot;</span>  <span class="p">,</span> <span class="s">&quot;clock-AF_BLUETOOTH&quot;</span><span class="p">,</span> <span class="s">&quot;clock-AF_IUCV&quot;</span>     <span class="p">,</span>
  <span class="s">&quot;clock-AF_RXRPC&quot;</span> <span class="p">,</span> <span class="s">&quot;clock-AF_ISDN&quot;</span>     <span class="p">,</span> <span class="s">&quot;clock-AF_PHONET&quot;</span>   <span class="p">,</span>
  <span class="s">&quot;clock-AF_IEEE802154&quot;</span><span class="p">,</span> <span class="s">&quot;clock-AF_CAIF&quot;</span> <span class="p">,</span> <span class="s">&quot;clock-AF_ALG&quot;</span>      <span class="p">,</span>
  <span class="s">&quot;clock-AF_NFC&quot;</span>   <span class="p">,</span> <span class="s">&quot;clock-AF_MAX&quot;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * sk_callback_lock locking rules are per-address-family,</span>
<span class="cm"> * so split the lock classes by using a per-AF key:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">af_callback_keys</span><span class="p">[</span><span class="n">AF_MAX</span><span class="p">];</span>

<span class="cm">/* Take into consideration the size of the struct sk_buff overhead in the</span>
<span class="cm"> * determination of these values, since that is non-constant across</span>
<span class="cm"> * platforms.  This makes socket queueing behavior and performance</span>
<span class="cm"> * not depend upon such differences.</span>
<span class="cm"> */</span>
<span class="cp">#define _SK_MEM_PACKETS		256</span>
<span class="cp">#define _SK_MEM_OVERHEAD	SKB_TRUESIZE(256)</span>
<span class="cp">#define SK_WMEM_MAX		(_SK_MEM_OVERHEAD * _SK_MEM_PACKETS)</span>
<span class="cp">#define SK_RMEM_MAX		(_SK_MEM_OVERHEAD * _SK_MEM_PACKETS)</span>

<span class="cm">/* Run time adjustable parameters. */</span>
<span class="n">__u32</span> <span class="n">sysctl_wmem_max</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">SK_WMEM_MAX</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sysctl_wmem_max</span><span class="p">);</span>
<span class="n">__u32</span> <span class="n">sysctl_rmem_max</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">SK_RMEM_MAX</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sysctl_rmem_max</span><span class="p">);</span>
<span class="n">__u32</span> <span class="n">sysctl_wmem_default</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">SK_WMEM_MAX</span><span class="p">;</span>
<span class="n">__u32</span> <span class="n">sysctl_rmem_default</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">SK_RMEM_MAX</span><span class="p">;</span>

<span class="cm">/* Maximal space eaten by iovec or ancillary data plus some space */</span>
<span class="kt">int</span> <span class="n">sysctl_optmem_max</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">UIO_MAXIOV</span><span class="o">+</span><span class="mi">512</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sysctl_optmem_max</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_CGROUPS)</span>
<span class="cp">#if !defined(CONFIG_NET_CLS_CGROUP)</span>
<span class="kt">int</span> <span class="n">net_cls_subsys_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">net_cls_subsys_id</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if !defined(CONFIG_NETPRIO_CGROUP)</span>
<span class="kt">int</span> <span class="n">net_prio_subsys_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">net_prio_subsys_id</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sock_set_timeout</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="n">timeo_p</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tv</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tv</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">&gt;=</span> <span class="n">USEC_PER_SEC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">int</span> <span class="n">warned</span> <span class="n">__read_mostly</span><span class="p">;</span>

		<span class="o">*</span><span class="n">timeo_p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">warned</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">net_ratelimit</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">warned</span><span class="o">++</span><span class="p">;</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s: `%s&#39; (pid %d) tries to set negative timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">timeo_p</span> <span class="o">=</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="o">/</span><span class="n">HZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="o">*</span><span class="n">timeo_p</span> <span class="o">=</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="o">*</span><span class="n">HZ</span> <span class="o">+</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="o">+</span><span class="p">(</span><span class="mi">1000000</span><span class="o">/</span><span class="n">HZ</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1000000</span><span class="o">/</span><span class="n">HZ</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_warn_obsolete_bsdism</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">warned</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">warncomm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">warncomm</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">warned</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strcpy</span><span class="p">(</span><span class="n">warncomm</span><span class="p">,</span>  <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;process `%s&#39; is using obsolete %s SO_BSDCOMPAT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">warncomm</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="n">warned</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define SK_FLAGS_TIMESTAMP ((1UL &lt;&lt; SOCK_TIMESTAMP) | (1UL &lt;&lt; SOCK_TIMESTAMPING_RX_SOFTWARE))</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_disable_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_flags</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">flags</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_flags</span> <span class="o">&amp;</span> <span class="n">SK_FLAGS_TIMESTAMP</span><span class="p">))</span>
			<span class="n">net_disable_timestamp</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">sock_queue_rcv_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skb_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_drops</span><span class="p">);</span>
		<span class="n">trace_sock_rcvqueue_full</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sk_filter</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_rmem_schedule</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_drops</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Cache the SKB length before we tack it onto the receive</span>
<span class="cm">	 * queue.  Once it is added it no longer belongs to us and</span>
<span class="cm">	 * may be freed by other threads of control pulling packets</span>
<span class="cm">	 * from the queue.</span>
<span class="cm">	 */</span>
	<span class="n">skb_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/* we escape from rcu protected region, make sure we dont leak</span>
<span class="cm">	 * a norefcounted dst</span>
<span class="cm">	 */</span>
	<span class="n">skb_dst_force</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dropcount</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_drops</span><span class="p">);</span>
	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb_len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_queue_rcv_skb</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sk_receive_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">nested</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk_filter</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard_and_relse</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk_rcvqueues_full</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_drops</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">discard_and_relse</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nested</span><span class="p">)</span>
		<span class="n">bh_lock_sock_nested</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * trylock + unlock semantics:</span>
<span class="cm">		 */</span>
		<span class="n">mutex_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">sk_backlog_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">mutex_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sk_add_backlog</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_drops</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">discard_and_relse</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">discard_and_relse:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_receive_skb</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sk_reset_txq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk_tx_queue_clear</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_reset_txq</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="nf">__sk_dst_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">obsolete</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">cookie</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk_tx_queue_clear</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_cache</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">dst_release</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__sk_dst_check</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="nf">sk_dst_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">obsolete</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">check</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">cookie</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk_dst_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">dst_release</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_dst_check</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sock_bindtodevice</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NETDEVICES</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">devname</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="cm">/* Sorry... */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_RAW</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Bind this socket to a particular device like &quot;eth0&quot;,</span>
<span class="cm">	 * as specified in the passed interface name. If the</span>
<span class="cm">	 * name is &quot;&quot; or the option length is zero the socket</span>
<span class="cm">	 * is not bound.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&gt;</span> <span class="n">IFNAMSIZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">optlen</span> <span class="o">=</span> <span class="n">IFNAMSIZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">devname</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">devname</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">devname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devname</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">dev_get_by_name_rcu</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">devname</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">sk_dst_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_valbool_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">valbool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">valbool</span><span class="p">)</span>
		<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	This is meant for all protocols to use and covers goings on</span>
<span class="cm"> *	at the socket level. Everything here is generic.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">sock_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">valbool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">linger</span> <span class="n">ling</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Options without arguments</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optname</span> <span class="o">==</span> <span class="n">SO_BINDTODEVICE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sock_bindtodevice</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">optval</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">valbool</span> <span class="o">=</span> <span class="n">val</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">optname</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SO_DEBUG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DBG</span><span class="p">,</span> <span class="n">valbool</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SO_REUSEADDR</span>:
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span> <span class="o">=</span> <span class="p">(</span><span class="n">valbool</span> <span class="o">?</span> <span class="n">SK_CAN_REUSE</span> <span class="o">:</span> <span class="n">SK_NO_REUSE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SO_TYPE</span>:
	<span class="k">case</span> <span class="n">SO_PROTOCOL</span>:
	<span class="k">case</span> <span class="n">SO_DOMAIN</span>:
	<span class="k">case</span> <span class="n">SO_ERROR</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SO_DONTROUTE</span>:
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_LOCALROUTE</span><span class="p">,</span> <span class="n">valbool</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SO_BROADCAST</span>:
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_BROADCAST</span><span class="p">,</span> <span class="n">valbool</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SO_SNDBUF</span>:
		<span class="cm">/* Don&#39;t error on this BSD doesn&#39;t and if you think</span>
<span class="cm">		 * about it this is right. Otherwise apps have to</span>
<span class="cm">		 * play &#39;guess the biggest size&#39; games. RCVBUF/SNDBUF</span>
<span class="cm">		 * are treated in BSD as hints</span>
<span class="cm">		 */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">sysctl_wmem_max</span><span class="p">);</span>
<span class="nl">set_sndbuf:</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">|=</span> <span class="n">SOCK_SNDBUF_LOCK</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">val</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">SOCK_MIN_SNDBUF</span><span class="p">);</span>
		<span class="cm">/* Wake up sending tasks if we upped the value. */</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_SNDBUFFORCE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">set_sndbuf</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_RCVBUF</span>:
		<span class="cm">/* Don&#39;t error on this BSD doesn&#39;t and if you think</span>
<span class="cm">		 * about it this is right. Otherwise apps have to</span>
<span class="cm">		 * play &#39;guess the biggest size&#39; games. RCVBUF/SNDBUF</span>
<span class="cm">		 * are treated in BSD as hints</span>
<span class="cm">		 */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">sysctl_rmem_max</span><span class="p">);</span>
<span class="nl">set_rcvbuf:</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">|=</span> <span class="n">SOCK_RCVBUF_LOCK</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We double it on the way in to account for</span>
<span class="cm">		 * &quot;struct sk_buff&quot; etc. overhead.   Applications</span>
<span class="cm">		 * assume that the SO_RCVBUF setting they make will</span>
<span class="cm">		 * allow that much actual data to be received on that</span>
<span class="cm">		 * socket.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Applications are unaware that &quot;struct sk_buff&quot; and</span>
<span class="cm">		 * other overheads allocate from the receive buffer</span>
<span class="cm">		 * during socket buffer allocation.</span>
<span class="cm">		 *</span>
<span class="cm">		 * And after considering the possible alternatives,</span>
<span class="cm">		 * returning the value we actually used in getsockopt</span>
<span class="cm">		 * is the most desirable behavior.</span>
<span class="cm">		 */</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">val</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">SOCK_MIN_RCVBUF</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_RCVBUFFORCE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">set_rcvbuf</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_KEEPALIVE</span>:
<span class="cp">#ifdef CONFIG_INET</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
			<span class="n">tcp_set_keepalive</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">valbool</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_KEEPOPEN</span><span class="p">,</span> <span class="n">valbool</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_OOBINLINE</span>:
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_URGINLINE</span><span class="p">,</span> <span class="n">valbool</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_NO_CHECK</span>:
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_no_check</span> <span class="o">=</span> <span class="n">valbool</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_PRIORITY</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">)</span> <span class="o">||</span> <span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_priority</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_LINGER</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ling</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>	<span class="cm">/* 1003.1g */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ling</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ling</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ling</span><span class="p">.</span><span class="n">l_onoff</span><span class="p">)</span>
			<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_LINGER</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
<span class="cp">#if (BITS_PER_LONG == 32)</span>
			<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ling</span><span class="p">.</span><span class="n">l_linger</span> <span class="o">&gt;=</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="o">/</span><span class="n">HZ</span><span class="p">)</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lingertime</span> <span class="o">=</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">;</span>
			<span class="k">else</span>
<span class="cp">#endif</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lingertime</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">ling</span><span class="p">.</span><span class="n">l_linger</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_LINGER</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_BSDCOMPAT</span>:
		<span class="n">sock_warn_obsolete_bsdism</span><span class="p">(</span><span class="s">&quot;setsockopt&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_PASSCRED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">valbool</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_PASSCRED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_PASSCRED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_TIMESTAMP</span>:
	<span class="k">case</span> <span class="n">SO_TIMESTAMPNS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">valbool</span><span class="p">)</span>  <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">optname</span> <span class="o">==</span> <span class="n">SO_TIMESTAMP</span><span class="p">)</span>
				<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMPNS</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMPNS</span><span class="p">);</span>
			<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMP</span><span class="p">);</span>
			<span class="n">sock_enable_timestamp</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMP</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMP</span><span class="p">);</span>
			<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMPNS</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_TIMESTAMPING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOF_TIMESTAMPING_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_TX_HARDWARE</span><span class="p">,</span>
				  <span class="n">val</span> <span class="o">&amp;</span> <span class="n">SOF_TIMESTAMPING_TX_HARDWARE</span><span class="p">);</span>
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_TX_SOFTWARE</span><span class="p">,</span>
				  <span class="n">val</span> <span class="o">&amp;</span> <span class="n">SOF_TIMESTAMPING_TX_SOFTWARE</span><span class="p">);</span>
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_RX_HARDWARE</span><span class="p">,</span>
				  <span class="n">val</span> <span class="o">&amp;</span> <span class="n">SOF_TIMESTAMPING_RX_HARDWARE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">SOF_TIMESTAMPING_RX_SOFTWARE</span><span class="p">)</span>
			<span class="n">sock_enable_timestamp</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
					      <span class="n">SOCK_TIMESTAMPING_RX_SOFTWARE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">sock_disable_timestamp</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
					       <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">SOCK_TIMESTAMPING_RX_SOFTWARE</span><span class="p">));</span>
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_SOFTWARE</span><span class="p">,</span>
				  <span class="n">val</span> <span class="o">&amp;</span> <span class="n">SOF_TIMESTAMPING_SOFTWARE</span><span class="p">);</span>
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_SYS_HARDWARE</span><span class="p">,</span>
				  <span class="n">val</span> <span class="o">&amp;</span> <span class="n">SOF_TIMESTAMPING_SYS_HARDWARE</span><span class="p">);</span>
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_RAW_HARDWARE</span><span class="p">,</span>
				  <span class="n">val</span> <span class="o">&amp;</span> <span class="n">SOF_TIMESTAMPING_RAW_HARDWARE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_RCVLOWAT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvlowat</span> <span class="o">=</span> <span class="n">val</span> <span class="o">?</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_RCVTIMEO</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sock_set_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvtimeo</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_SNDTIMEO</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sock_set_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_ATTACH_FILTER</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_fprog</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sock_fprog</span> <span class="n">fprog</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fprog</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fprog</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">sk_attach_filter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fprog</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_DETACH_FILTER</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sk_detach_filter</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_PASSSEC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">valbool</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_PASSSEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_PASSSEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SO_MARK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_mark</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* We implement the SO_SNDLOWAT etc to</span>
<span class="cm">		   not be settable (1003.1g 5.3) */</span>
	<span class="k">case</span> <span class="n">SO_RXQ_OVFL</span>:
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RXQ_OVFL</span><span class="p">,</span> <span class="n">valbool</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_WIFI_STATUS</span>:
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WIFI_STATUS</span><span class="p">,</span> <span class="n">valbool</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_PEEK_OFF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_peek_off</span><span class="p">)</span>
			<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_peek_off</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_NOFCS</span>:
		<span class="n">sock_valbool_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_NOFCS</span><span class="p">,</span> <span class="n">valbool</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_setsockopt</span><span class="p">);</span>


<span class="kt">void</span> <span class="nf">cred_to_ucred</span><span class="p">(</span><span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">ucred</span> <span class="o">*</span><span class="n">ucred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ucred</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid_vnr</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">ucred</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">ucred</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cred</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">current_ns</span> <span class="o">=</span> <span class="n">current_user_ns</span><span class="p">();</span>

		<span class="n">ucred</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">from_kuid</span><span class="p">(</span><span class="n">current_ns</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">);</span>
		<span class="n">ucred</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">from_kgid</span><span class="p">(</span><span class="n">current_ns</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">cred_to_ucred</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">linger</span> <span class="n">ling</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tm</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">v</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">lv</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">optname</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SO_DEBUG</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DBG</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_DONTROUTE</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_LOCALROUTE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_BROADCAST</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_BROADCAST</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_SNDBUF</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_RCVBUF</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_REUSEADDR</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_KEEPALIVE</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_KEEPOPEN</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_TYPE</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_PROTOCOL</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_DOMAIN</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_ERROR</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err_soft</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_OOBINLINE</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_URGINLINE</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_NO_CHECK</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_no_check</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_PRIORITY</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_priority</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_LINGER</span>:
		<span class="n">lv</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">ling</span><span class="p">);</span>
		<span class="n">v</span><span class="p">.</span><span class="n">ling</span><span class="p">.</span><span class="n">l_onoff</span>	<span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_LINGER</span><span class="p">);</span>
		<span class="n">v</span><span class="p">.</span><span class="n">ling</span><span class="p">.</span><span class="n">l_linger</span>	<span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lingertime</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_BSDCOMPAT</span>:
		<span class="n">sock_warn_obsolete_bsdism</span><span class="p">(</span><span class="s">&quot;getsockopt&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_TIMESTAMP</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMPNS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_TIMESTAMPNS</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMPNS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_TIMESTAMPING</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_TX_HARDWARE</span><span class="p">))</span>
			<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="n">SOF_TIMESTAMPING_TX_HARDWARE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_TX_SOFTWARE</span><span class="p">))</span>
			<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="n">SOF_TIMESTAMPING_TX_SOFTWARE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_RX_HARDWARE</span><span class="p">))</span>
			<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="n">SOF_TIMESTAMPING_RX_HARDWARE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_RX_SOFTWARE</span><span class="p">))</span>
			<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="n">SOF_TIMESTAMPING_RX_SOFTWARE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_SOFTWARE</span><span class="p">))</span>
			<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="n">SOF_TIMESTAMPING_SOFTWARE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_SYS_HARDWARE</span><span class="p">))</span>
			<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="n">SOF_TIMESTAMPING_SYS_HARDWARE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_RAW_HARDWARE</span><span class="p">))</span>
			<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">|=</span> <span class="n">SOF_TIMESTAMPING_RAW_HARDWARE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_RCVTIMEO</span>:
		<span class="n">lv</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvtimeo</span> <span class="o">==</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v</span><span class="p">.</span><span class="n">tm</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">v</span><span class="p">.</span><span class="n">tm</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">v</span><span class="p">.</span><span class="n">tm</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvtimeo</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="n">v</span><span class="p">.</span><span class="n">tm</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvtimeo</span> <span class="o">%</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_SNDTIMEO</span>:
		<span class="n">lv</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span> <span class="o">==</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v</span><span class="p">.</span><span class="n">tm</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">v</span><span class="p">.</span><span class="n">tm</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">v</span><span class="p">.</span><span class="n">tm</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="n">v</span><span class="p">.</span><span class="n">tm</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span> <span class="o">%</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_RCVLOWAT</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvlowat</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_SNDLOWAT</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_PASSCRED</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="o">!!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_PASSCRED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_PEERCRED</span>:
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">ucred</span> <span class="n">peercred</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">peercred</span><span class="p">))</span>
			<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">peercred</span><span class="p">);</span>
		<span class="n">cred_to_ucred</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_pid</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_cred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peercred</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peercred</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lenout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">case</span> <span class="n">SO_PEERNAME</span>:
	<span class="p">{</span>
		<span class="kt">char</span> <span class="n">address</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">getname</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lv</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lv</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lenout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Dubious BSD thing... Probably nobody even uses it, but</span>
<span class="cm">	 * the UNIX standard wants it for whatever reason... -DaveM</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SO_ACCEPTCONN</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_PASSSEC</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="o">!!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_PASSSEC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_PEERSEC</span>:
		<span class="k">return</span> <span class="n">security_socket_getpeersec_stream</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SO_MARK</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_mark</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_RXQ_OVFL</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RXQ_OVFL</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_WIFI_STATUS</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WIFI_STATUS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SO_PEEK_OFF</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_peek_off</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peek_off</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SO_NOFCS</span>:
		<span class="n">v</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_NOFCS</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">lv</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">lv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="nl">lenout:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize an sk_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * (We also register the sk_lock with the lock validator.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_lock_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sock_lock_init_class_and_name</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
			<span class="n">af_family_slock_key_strings</span><span class="p">[</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">],</span>
			<span class="n">af_family_slock_keys</span> <span class="o">+</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">,</span>
			<span class="n">af_family_key_strings</span><span class="p">[</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">],</span>
			<span class="n">af_family_keys</span> <span class="o">+</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copy all fields from osk to nsk but nsk-&gt;sk_refcnt must not change yet,</span>
<span class="cm"> * even temporarly, because of RCU lookups. sk_node should also be left as is.</span>
<span class="cm"> * We must not copy fields between sk_dontcopy_begin and sk_dontcopy_end</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">nsk</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">osk</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SECURITY_NETWORK</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">sptr</span> <span class="o">=</span> <span class="n">nsk</span><span class="o">-&gt;</span><span class="n">sk_security</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">nsk</span><span class="p">,</span> <span class="n">osk</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">sk_dontcopy_begin</span><span class="p">));</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nsk</span><span class="o">-&gt;</span><span class="n">sk_dontcopy_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">osk</span><span class="o">-&gt;</span><span class="n">sk_dontcopy_end</span><span class="p">,</span>
	       <span class="n">osk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">obj_size</span> <span class="o">-</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">sk_dontcopy_end</span><span class="p">));</span>

<span class="cp">#ifdef CONFIG_SECURITY_NETWORK</span>
	<span class="n">nsk</span><span class="o">-&gt;</span><span class="n">sk_security</span> <span class="o">=</span> <span class="n">sptr</span><span class="p">;</span>
	<span class="n">security_sk_clone</span><span class="p">(</span><span class="n">osk</span><span class="p">,</span> <span class="n">nsk</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * caches using SLAB_DESTROY_BY_RCU should let .next pointer from nulls nodes</span>
<span class="cm"> * un-modified. Special care is taken when initializing object to zero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sk_prot_clear_nulls</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">sk_node</span><span class="p">.</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">sk_node</span><span class="p">.</span><span class="n">next</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_node</span><span class="p">.</span><span class="n">pprev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="n">size</span> <span class="o">-</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">sk_node</span><span class="p">.</span><span class="n">pprev</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sk_prot_clear_portaddr_nulls</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nulls1</span><span class="p">,</span> <span class="n">nulls2</span><span class="p">;</span>

	<span class="n">nulls1</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">__sk_common</span><span class="p">.</span><span class="n">skc_node</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
	<span class="n">nulls2</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span><span class="p">,</span> <span class="n">__sk_common</span><span class="p">.</span><span class="n">skc_portaddr_node</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nulls1</span> <span class="o">&gt;</span> <span class="n">nulls2</span><span class="p">)</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">nulls1</span><span class="p">,</span> <span class="n">nulls2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nulls1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nulls1</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sk</span> <span class="o">+</span> <span class="n">nulls1</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="n">nulls2</span> <span class="o">-</span> <span class="n">nulls1</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sk</span> <span class="o">+</span> <span class="n">nulls2</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="n">size</span> <span class="o">-</span> <span class="n">nulls2</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_prot_clear_portaddr_nulls</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sk_prot_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">slab</span><span class="p">;</span>

	<span class="n">slab</span> <span class="o">=</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slab</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span> <span class="n">priority</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_ZERO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">priority</span> <span class="o">&amp;</span> <span class="n">__GFP_ZERO</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">clear_sk</span><span class="p">)</span>
				<span class="n">prot</span><span class="o">-&gt;</span><span class="n">clear_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">obj_size</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">sk_prot_clear_nulls</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">obj_size</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sk</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">obj_size</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmemcheck_annotate_bitfield</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">security_sk_alloc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">priority</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_free_sec</span><span class="p">;</span>
		<span class="n">sk_tx_queue_clear</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>

<span class="nl">out_free_sec:</span>
	<span class="n">security_sk_free</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slab</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sk_prot_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">slab</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>

	<span class="n">owner</span> <span class="o">=</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>
	<span class="n">slab</span> <span class="o">=</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">;</span>

	<span class="n">security_sk_free</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slab</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CGROUPS</span>
<span class="kt">void</span> <span class="nf">sock_update_classid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">classid</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>  <span class="cm">/* doing current task, which cannot vanish. */</span>
	<span class="n">classid</span> <span class="o">=</span> <span class="n">task_cls_classid</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">classid</span> <span class="o">&amp;&amp;</span> <span class="n">classid</span> <span class="o">!=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_classid</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_classid</span> <span class="o">=</span> <span class="n">classid</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_update_classid</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sock_update_netprioidx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_interrupt</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp_prioidx</span> <span class="o">=</span> <span class="n">task_netprioidx</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sock_update_netprioidx</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	sk_alloc - All socket objects are allocated here</span>
<span class="cm"> *	@net: the applicable net namespace</span>
<span class="cm"> *	@family: protocol family</span>
<span class="cm"> *	@priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc)</span>
<span class="cm"> *	@prot: struct proto associated with this new sock instance</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sk_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">sk_prot_alloc</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span> <span class="n">priority</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span> <span class="n">family</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">=</span> <span class="n">family</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * See comment in struct sock definition to understand</span>
<span class="cm">		 * why we need sk_prot_creator -acme</span>
<span class="cm">		 */</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot_creator</span> <span class="o">=</span> <span class="n">prot</span><span class="p">;</span>
		<span class="n">sock_lock_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sock_net_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">get_net</span><span class="p">(</span><span class="n">net</span><span class="p">));</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">sock_update_classid</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">sock_update_netprioidx</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_alloc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__sk_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">filter</span> <span class="o">=</span> <span class="n">rcu_dereference_check</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_filter</span><span class="p">,</span>
				       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk_filter_uncharge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>
		<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_filter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sock_disable_timestamp</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SK_FLAGS_TIMESTAMP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: optmem leakage (%d bytes) detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_cred</span><span class="p">)</span>
		<span class="n">put_cred</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_cred</span><span class="p">);</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_pid</span><span class="p">);</span>
	<span class="n">put_net</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="n">sk_prot_free</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot_creator</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sk_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We subtract one from sk_wmem_alloc and can know if</span>
<span class="cm">	 * some packets are still in some tx queue.</span>
<span class="cm">	 * If not null, sock_wfree() will call __sk_free(sk) later</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">))</span>
		<span class="n">__sk_free</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_free</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Last sock_put should drop reference to sk-&gt;sk_net. It has already</span>
<span class="cm"> * been dropped in sk_change_net. Taking reference to stopping namespace</span>
<span class="cm"> * is not an option.</span>
<span class="cm"> * Take reference to a socket to remove it from hash _alive_ and after that</span>
<span class="cm"> * destroy it in the context of init_net.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sk_release_kernel</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sock_release</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">);</span>
	<span class="n">release_net</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="n">sock_net_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">get_net</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">));</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_release_kernel</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sk_update_clone</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span>
		<span class="n">sock_update_memcg</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sk_clone_lock - clone a socket, and lock its clone</span>
<span class="cm"> *	@sk: the socket to clone</span>
<span class="cm"> *	@priority: for allocation (%GFP_KERNEL, %GFP_ATOMIC, etc)</span>
<span class="cm"> *</span>
<span class="cm"> *	Caller must unlock socket even in error path (bh_unlock_sock(newsk))</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">sk_clone_lock</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span><span class="p">;</span>

	<span class="n">newsk</span> <span class="o">=</span> <span class="n">sk_prot_alloc</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">,</span> <span class="n">priority</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsk</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_filter</span> <span class="o">*</span><span class="n">filter</span><span class="p">;</span>

		<span class="n">sock_copy</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

		<span class="cm">/* SANITY */</span>
		<span class="n">get_net</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">newsk</span><span class="p">));</span>
		<span class="n">sk_node_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_node</span><span class="p">);</span>
		<span class="n">sock_lock_init</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
		<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
		<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">head</span>	<span class="o">=</span> <span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * sk_wmem_alloc set to one (see sk_free() and sock_wfree())</span>
<span class="cm">		 */</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NET_DMA</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_async_wait_queue</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_dst_lock</span><span class="p">);</span>
		<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
		<span class="n">lockdep_set_class_and_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">,</span>
				<span class="n">af_callback_keys</span> <span class="o">+</span> <span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">,</span>
				<span class="n">af_family_clock_key_strings</span><span class="p">[</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">]);</span>

		<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_dst_cache</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span>	<span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_userlocks</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOCK_BINDPORT_LOCK</span><span class="p">;</span>

		<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">SOCK_DONE</span><span class="p">);</span>
		<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_error_queue</span><span class="p">);</span>

		<span class="n">filter</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_filter</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">sk_filter_charge</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">filter</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">xfrm_sk_clone_policy</span><span class="p">(</span><span class="n">newsk</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* It is still raw copy of parent, so invalidate</span>
<span class="cm">			 * destructor and make plain sk_free() */</span>
			<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
			<span class="n">sk_free</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
			<span class="n">newsk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_err</span>	   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Before updating sk_refcnt, we must commit prior changes to memory</span>
<span class="cm">		 * (Documentation/RCU/rculist_nulls.txt for details)</span>
<span class="cm">		 */</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Increment the counter in the same struct proto as the master</span>
<span class="cm">		 * sock (sk_refcnt_debug_inc uses newsk-&gt;sk_prot-&gt;socks, that</span>
<span class="cm">		 * is the same as sk-&gt;sk_prot-&gt;socks, as this field was copied</span>
<span class="cm">		 * with memcpy).</span>
<span class="cm">		 *</span>
<span class="cm">		 * This _changes_ the previous behaviour, where</span>
<span class="cm">		 * tcp_create_openreq_child always was incrementing the</span>
<span class="cm">		 * equivalent to tcp_prot-&gt;socks (inet_sock_nr), so this have</span>
<span class="cm">		 * to be taken into account in all callers. -acme</span>
<span class="cm">		 */</span>
		<span class="n">sk_refcnt_debug_inc</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
		<span class="n">sk_set_socket</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_wq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">sk_update_clone</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">sockets_allocated</span><span class="p">)</span>
			<span class="n">sk_sockets_allocated_inc</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_flags</span> <span class="o">&amp;</span> <span class="n">SK_FLAGS_TIMESTAMP</span><span class="p">)</span>
			<span class="n">net_enable_timestamp</span><span class="p">();</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">newsk</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sk_clone_lock</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sk_setup_caps</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__sk_dst_set</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">=</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">features</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">&amp;</span> <span class="n">NETIF_F_GSO</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">|=</span> <span class="n">NETIF_F_GSO_SOFTWARE</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_nocaps</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk_can_gso</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">header_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NETIF_F_GSO_MASK</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_route_caps</span> <span class="o">|=</span> <span class="n">NETIF_F_SG</span> <span class="o">|</span> <span class="n">NETIF_F_HW_CSUM</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_gso_max_size</span> <span class="o">=</span> <span class="n">dst</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gso_max_size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sk_setup_caps</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">sk_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">totalram_pages</span> <span class="o">&lt;=</span> <span class="mi">4096</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sysctl_wmem_max</span> <span class="o">=</span> <span class="mi">32767</span><span class="p">;</span>
		<span class="n">sysctl_rmem_max</span> <span class="o">=</span> <span class="mi">32767</span><span class="p">;</span>
		<span class="n">sysctl_wmem_default</span> <span class="o">=</span> <span class="mi">32767</span><span class="p">;</span>
		<span class="n">sysctl_rmem_default</span> <span class="o">=</span> <span class="mi">32767</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">totalram_pages</span> <span class="o">&gt;=</span> <span class="mi">131072</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sysctl_wmem_max</span> <span class="o">=</span> <span class="mi">131071</span><span class="p">;</span>
		<span class="n">sysctl_rmem_max</span> <span class="o">=</span> <span class="mi">131071</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Simple resource managers for sockets.</span>
<span class="cm"> */</span>


<span class="cm">/*</span>
<span class="cm"> * Write buffer destructor automatically called from kfree_skb.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sock_wfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_USE_WRITE_QUEUE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Keep a reference on sk_wmem_alloc, this will be released</span>
<span class="cm">		 * after sk_write_space() call</span>
<span class="cm">		 */</span>
		<span class="n">atomic_sub</span><span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">);</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * if sk_wmem_alloc reaches 0, we must finish what sk_free()</span>
<span class="cm">	 * could not do because of in-flight packets</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_sub_and_test</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">))</span>
		<span class="n">__sk_free</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_wfree</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Read buffer destructor automatically called from kfree_skb.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sock_rfree</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>

	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>
	<span class="n">sk_mem_uncharge</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_rfree</span><span class="p">);</span>


<span class="kt">int</span> <span class="nf">sock_i_uid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">uid</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">uid</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span> <span class="o">?</span> <span class="n">SOCK_INODE</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">uid</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_i_uid</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">sock_i_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">ino</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span> <span class="o">?</span> <span class="n">SOCK_INODE</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ino</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_i_ino</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a skb from the socket&#39;s send buffer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">sock_wmalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">,</span>
			     <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">||</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_set_owner_w</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_wmalloc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a skb from the socket&#39;s receive buffer.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">sock_rmalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">,</span>
			     <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">||</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate a memory block from the socket&#39;s option memory buffer.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">sock_kmalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">priority</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">sysctl_optmem_max</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">sysctl_optmem_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>
		<span class="cm">/* First do the add, to avoid the race if kmalloc</span>
<span class="cm">		 * might sleep.</span>
<span class="cm">		 */</span>
		<span class="n">atomic_add</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">);</span>
		<span class="n">mem</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
		<span class="n">atomic_sub</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_kmalloc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Free an option memory block.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sock_kfree_s</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_omem_alloc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_kfree_s</span><span class="p">);</span>

<span class="cm">/* It is almost wait_for_tcp_memory minus release_sock/lock_sock.</span>
<span class="cm">   I think, these locks should be removed for datagram sockets.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">sock_wait_for_wmem</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">timeo</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">timeo</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *	Generic send/receive buffer handlers</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">sock_alloc_send_pskb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">header_len</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">noblock</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="o">*</span><span class="n">errcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">npages</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">+</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">npages</span> <span class="o">&gt;</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

	<span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span>
		<span class="n">gfp_mask</span> <span class="o">|=</span> <span class="n">__GFP_REPEAT</span><span class="p">;</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">noblock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">header_len</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

				<span class="cm">/* No pages, we&#39;re done... */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_len</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">data_len</span><span class="p">;</span>
				<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">npages</span><span class="p">;</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

					<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
						<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
						<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
						<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="n">__skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
							<span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							<span class="p">(</span><span class="n">data_len</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span> <span class="o">?</span>
							 <span class="n">PAGE_SIZE</span> <span class="o">:</span>
							 <span class="n">data_len</span><span class="p">));</span>
					<span class="n">data_len</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* Full success... */</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">interrupted</span><span class="p">;</span>
		<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_wait_for_wmem</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">timeo</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">skb_set_owner_w</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>

<span class="nl">interrupted:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
<span class="nl">failure:</span>
	<span class="o">*</span><span class="n">errcode</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_alloc_send_pskb</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">sock_alloc_send_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">noblock</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">errcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock_alloc_send_pskb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">noblock</span><span class="p">,</span> <span class="n">errcode</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_alloc_send_skb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__lock_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">prepare_to_wait_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
					<span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__release_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

			<span class="n">prefetch</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">skb_dst_is_noref</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">sk_backlog_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * We are in process context here with softirqs</span>
<span class="cm">			 * disabled, use cond_resched_softirq() to preempt.</span>
<span class="cm">			 * This is safe to do because we&#39;ve taken the backlog</span>
<span class="cm">			 * queue private:</span>
<span class="cm">			 */</span>
			<span class="n">cond_resched_softirq</span><span class="p">();</span>

			<span class="n">skb</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">head</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doing the zeroing here guarantee we can not loop forever</span>
<span class="cm">	 * while a wild producer attempts to flood us.</span>
<span class="cm">	 */</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sk_wait_data - wait for data to arrive at sk_receive_queue</span>
<span class="cm"> * @sk:    sock to wait on</span>
<span class="cm"> * @timeo: for how long</span>
<span class="cm"> *</span>
<span class="cm"> * Now socket state including sk-&gt;sk_err is changed only under lock,</span>
<span class="cm"> * hence we may omit checks after joining wait queue.</span>
<span class="cm"> * We check receive queue before schedule() only as optimization;</span>
<span class="cm"> * it is very likely that release_sock() added new data.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sk_wait_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timeo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_WAITDATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">sk_wait_event</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">timeo</span><span class="p">,</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">));</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_WAITDATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_wait_data</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	__sk_mem_schedule - increase sk_forward_alloc and memory_allocated</span>
<span class="cm"> *	@sk: socket</span>
<span class="cm"> *	@size: memory size to allocate</span>
<span class="cm"> *	@kind: allocation type</span>
<span class="cm"> *</span>
<span class="cm"> *	If kind is SK_MEM_SEND, it means wmem allocation. Otherwise it means</span>
<span class="cm"> *	rmem allocation. This function assumes that protocols which have</span>
<span class="cm"> *	memory_pressure use sk_wmem_queued as write buffer accounting.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__sk_mem_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kind</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">amt</span> <span class="o">=</span> <span class="n">sk_mem_pages</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">allocated</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">parent_status</span> <span class="o">=</span> <span class="n">UNDER_LIMIT</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span> <span class="o">+=</span> <span class="n">amt</span> <span class="o">*</span> <span class="n">SK_MEM_QUANTUM</span><span class="p">;</span>

	<span class="n">allocated</span> <span class="o">=</span> <span class="n">sk_memory_allocated_add</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">amt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent_status</span><span class="p">);</span>

	<span class="cm">/* Under limit. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent_status</span> <span class="o">==</span> <span class="n">UNDER_LIMIT</span> <span class="o">&amp;&amp;</span>
			<span class="n">allocated</span> <span class="o">&lt;=</span> <span class="n">sk_prot_mem_limits</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sk_leave_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Under pressure. (we or our parents) */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">parent_status</span> <span class="o">&gt;</span> <span class="n">SOFT_LIMIT</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">allocated</span> <span class="o">&gt;</span> <span class="n">sk_prot_mem_limits</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">sk_enter_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Over hard limit (we or our parents) */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">parent_status</span> <span class="o">==</span> <span class="n">OVER_LIMIT</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">allocated</span> <span class="o">&gt;</span> <span class="n">sk_prot_mem_limits</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">suppress_allocation</span><span class="p">;</span>

	<span class="cm">/* guarantee minimum buffer size under pressure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kind</span> <span class="o">==</span> <span class="n">SK_MEM_RECV</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">sysctl_rmem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* SK_MEM_SEND */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">&lt;</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">sysctl_wmem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">)</span> <span class="o">&lt;</span>
			   <span class="n">prot</span><span class="o">-&gt;</span><span class="n">sysctl_wmem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk_has_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">alloc</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk_under_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">alloc</span> <span class="o">=</span> <span class="n">sk_sockets_allocated_read_positive</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk_prot_mem_limits</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">alloc</span> <span class="o">*</span>
		    <span class="n">sk_mem_pages</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+</span>
				 <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">+</span>
				 <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">suppress_allocation:</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kind</span> <span class="o">==</span> <span class="n">SK_MEM_SEND</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk_stream_moderate_sndbuf</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="cm">/* Fail only if socket is _under_ its sndbuf.</span>
<span class="cm">		 * In this case we cannot block, so that we have to fail.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trace_sock_exceed_buf_limit</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">allocated</span><span class="p">);</span>

	<span class="cm">/* Alas. Undo changes. */</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span> <span class="o">-=</span> <span class="n">amt</span> <span class="o">*</span> <span class="n">SK_MEM_QUANTUM</span><span class="p">;</span>

	<span class="n">sk_memory_allocated_sub</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">amt</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__sk_mem_schedule</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	__sk_reclaim - reclaim memory_allocated</span>
<span class="cm"> *	@sk: socket</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__sk_mem_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk_memory_allocated_sub</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span> <span class="o">&gt;&gt;</span> <span class="n">SK_MEM_QUANTUM_SHIFT</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span> <span class="o">&amp;=</span> <span class="n">SK_MEM_QUANTUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk_under_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">sk_memory_allocated</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sk_prot_mem_limits</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="n">sk_leave_memory_pressure</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__sk_mem_reclaim</span><span class="p">);</span>


<span class="cm">/*</span>
<span class="cm"> * Set of default routines for initialising struct proto_ops when</span>
<span class="cm"> * the protocol does not support a particular function. In certain</span>
<span class="cm"> * cases where it makes no sense for a protocol to have a &quot;do nothing&quot;</span>
<span class="cm"> * function, some default processing is provided.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">sock_no_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_bind</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_connect</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_socketpair</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_socketpair</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_accept</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_getname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">saddr</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">peer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_getname</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sock_no_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">pt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_poll</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_ioctl</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_listen</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_shutdown</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_setsockopt</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_getsockopt</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
		    <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_sendmsg</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
		    <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_recvmsg</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_no_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Mirror missing mmap method error code */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_mmap</span><span class="p">);</span>

<span class="kt">ssize_t</span> <span class="nf">sock_no_sendpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">{.</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">};</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="n">iov</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">iov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">kernel_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_no_sendpage</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Default Socket Callbacks</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_def_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq_has_sleeper</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span>
		<span class="n">wake_up_interruptible_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_def_error_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq_has_sleeper</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span>
		<span class="n">wake_up_interruptible_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">POLLERR</span><span class="p">);</span>
	<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_IO</span><span class="p">,</span> <span class="n">POLL_ERR</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_def_readable</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq_has_sleeper</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span>
		<span class="n">wake_up_interruptible_sync_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLPRI</span> <span class="o">|</span>
						<span class="n">POLLRDNORM</span> <span class="o">|</span> <span class="n">POLLRDBAND</span><span class="p">);</span>
	<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_WAITD</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_def_write_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="cm">/* Do not wake up a writer until he can make &quot;significant&quot;</span>
<span class="cm">	 * progress.  --DaveM</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wq</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wq_has_sleeper</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span>
			<span class="n">wake_up_interruptible_sync_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">POLLOUT</span> <span class="o">|</span>
						<span class="n">POLLWRNORM</span> <span class="o">|</span> <span class="n">POLLWRBAND</span><span class="p">);</span>

		<span class="cm">/* Should agree with poll, otherwise some programs break */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_writeable</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
			<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_SPACE</span><span class="p">,</span> <span class="n">POLL_OUT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_def_destruct</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protinfo</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sk_send_sigurg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">send_sigurg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_owner</span><span class="p">))</span>
			<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_URG</span><span class="p">,</span> <span class="n">POLL_PRI</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_send_sigurg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sk_reset_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timer_list</span><span class="o">*</span> <span class="n">timer</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mod_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">expires</span><span class="p">))</span>
		<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_reset_timer</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sk_stop_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timer_list</span><span class="o">*</span> <span class="n">timer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">del_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">))</span>
		<span class="n">__sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_stop_timer</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sock_init_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_queue</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NET_DMA</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_async_wait_queue</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span>	<span class="o">=</span>	<span class="nb">NULL</span><span class="p">;</span>

	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_timer</span><span class="p">);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span>	<span class="o">=</span>	<span class="n">GFP_KERNEL</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span>		<span class="o">=</span>	<span class="n">sysctl_rmem_default</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span>		<span class="o">=</span>	<span class="n">sysctl_wmem_default</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>		<span class="o">=</span>	<span class="n">TCP_CLOSE</span><span class="p">;</span>
	<span class="n">sk_set_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sock</span><span class="p">);</span>

	<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span>	<span class="o">=</span>	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span>	<span class="o">=</span>	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">;</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span>	<span class="o">=</span>	<span class="n">sk</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span>	<span class="o">=</span>	<span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_dst_lock</span><span class="p">);</span>
	<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
	<span class="n">lockdep_set_class_and_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">,</span>
			<span class="n">af_callback_keys</span> <span class="o">+</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">,</span>
			<span class="n">af_family_clock_key_strings</span><span class="p">[</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">]);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span>	<span class="o">=</span>	<span class="n">sock_def_wakeup</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span>	<span class="o">=</span>	<span class="n">sock_def_readable</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span>	<span class="o">=</span>	<span class="n">sock_def_write_space</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_report</span>	<span class="o">=</span>	<span class="n">sock_def_error_report</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span>		<span class="o">=</span>	<span class="n">sock_def_destruct</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_page</span>	<span class="o">=</span>	<span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_off</span>	<span class="o">=</span>	<span class="mi">0</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peek_off</span>		<span class="o">=</span>	<span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_pid</span> 	<span class="o">=</span>	<span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_cred</span>	<span class="o">=</span>	<span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_pending</span>	<span class="o">=</span>	<span class="mi">0</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvlowat</span>		<span class="o">=</span>	<span class="mi">1</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvtimeo</span>		<span class="o">=</span>	<span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span>		<span class="o">=</span>	<span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_stamp</span> <span class="o">=</span> <span class="n">ktime_set</span><span class="p">(</span><span class="o">-</span><span class="mi">1L</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Before updating sk_refcnt, we must commit prior changes to memory</span>
<span class="cm">	 * (Documentation/RCU/rculist_nulls.txt for details)</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_drops</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_init_data</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">lock_sock_nested</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">subclass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">owned</span><span class="p">)</span>
		<span class="n">__lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">owned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The sk_lock has mutex_lock() semantics here:</span>
<span class="cm">	 */</span>
	<span class="n">mutex_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="n">subclass</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lock_sock_nested</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">release_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The sk_lock has mutex_unlock() semantics:</span>
<span class="cm">	 */</span>
	<span class="n">mutex_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog</span><span class="p">.</span><span class="n">tail</span><span class="p">)</span>
		<span class="n">__release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">owned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">wq</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">release_sock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * lock_sock_fast - fast version of lock_sock</span>
<span class="cm"> * @sk: socket</span>
<span class="cm"> *</span>
<span class="cm"> * This version should be used for very small section, where process wont block</span>
<span class="cm"> * return false if fast path is taken</span>
<span class="cm"> *   sk_lock.slock locked, owned = 0, BH disabled</span>
<span class="cm"> * return true if slow path is taken</span>
<span class="cm"> *   sk_lock.slock unlocked, owned = 1, BH enabled</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">lock_sock_fast</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">owned</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note : We must disable BH</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">__lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">owned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">slock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The sk_lock has mutex_lock() semantics here:</span>
<span class="cm">	 */</span>
	<span class="n">mutex_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lock_sock_fast</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_get_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="n">__user</span> <span class="o">*</span><span class="n">userstamp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMP</span><span class="p">))</span>
		<span class="n">sock_enable_timestamp</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMP</span><span class="p">);</span>
	<span class="n">tv</span> <span class="o">=</span> <span class="n">ktime_to_timeval</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_stamp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_stamp</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
		<span class="n">tv</span> <span class="o">=</span> <span class="n">ktime_to_timeval</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_stamp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">userstamp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tv</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_get_timestamp</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_get_timestampns</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">userstamp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMP</span><span class="p">))</span>
		<span class="n">sock_enable_timestamp</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMP</span><span class="p">);</span>
	<span class="n">ts</span> <span class="o">=</span> <span class="n">ktime_to_timespec</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_stamp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_stamp</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
		<span class="n">ts</span> <span class="o">=</span> <span class="n">ktime_to_timespec</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_stamp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">userstamp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_get_timestampns</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sock_enable_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">previous_flags</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_flags</span><span class="p">;</span>

		<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * we just set one of the two flags which require net</span>
<span class="cm">		 * time stamping, but time stamping might have been on</span>
<span class="cm">		 * already because of the other one</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">previous_flags</span> <span class="o">&amp;</span> <span class="n">SK_FLAGS_TIMESTAMP</span><span class="p">))</span>
			<span class="n">net_enable_timestamp</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Get a socket option on an socket.</span>
<span class="cm"> *</span>
<span class="cm"> *	FIX: POSIX 1003.1g is very ambiguous here. It states that</span>
<span class="cm"> *	asynchronous errors should be reported by getsockopt. We assume</span>
<span class="cm"> *	this means if you specify SO_ERROR (otherwise whats the point of it).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sock_common_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_common_getsockopt</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="kt">int</span> <span class="nf">compat_sock_common_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">compat_getsockopt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">compat_getsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span>
						      <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">compat_sock_common_getsockopt</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">sock_common_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">recvmsg</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">,</span>
				   <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSG_DONTWAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="n">addr_len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_common_recvmsg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Set socket options on an inet socket.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sock_common_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_common_setsockopt</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="kt">int</span> <span class="nf">compat_sock_common_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">compat_setsockopt</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">compat_setsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span>
						      <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">compat_sock_common_setsockopt</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">sk_common_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Observation: when sock_common_release is called, processes have</span>
<span class="cm">	 * no access to socket. But net still has.</span>
<span class="cm">	 * Step one, detach it from networking:</span>
<span class="cm">	 *</span>
<span class="cm">	 * A. Remove from hash tables.</span>
<span class="cm">	 */</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">unhash</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In this point socket cannot receive new packets, but it is possible</span>
<span class="cm">	 * that some packets are in flight because some CPU runs receiver and</span>
<span class="cm">	 * did hash table lookup before we unhashed socket. They will achieve</span>
<span class="cm">	 * receive queue and will be purged by socket destructor.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also we still have packets pending on receive queue and probably,</span>
<span class="cm">	 * our own packets waiting in device queues. sock_destroy will drain</span>
<span class="cm">	 * receive queue, but transmitted packets will delay socket destruction</span>
<span class="cm">	 * until the last reference will be released.</span>
<span class="cm">	 */</span>

	<span class="n">sock_orphan</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">xfrm_sk_free_policy</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sk_refcnt_debug_release</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sk_common_release</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cp">#define PROTO_INUSE_NR	64	</span><span class="cm">/* should be enough for the first time */</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">prot_inuse</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">[</span><span class="n">PROTO_INUSE_NR</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">proto_inuse_idx</span><span class="p">,</span> <span class="n">PROTO_INUSE_NR</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_NS</span>
<span class="kt">void</span> <span class="nf">sock_prot_inuse_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__this_cpu_add</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">core</span><span class="p">.</span><span class="n">inuse</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">inuse_idx</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sock_prot_inuse_add</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_prot_inuse_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">inuse_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">+=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">core</span><span class="p">.</span><span class="n">inuse</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">res</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sock_prot_inuse_get</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__net_init</span> <span class="nf">sock_inuse_init_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">core</span><span class="p">.</span><span class="n">inuse</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">prot_inuse</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">core</span><span class="p">.</span><span class="n">inuse</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__net_exit</span> <span class="nf">sock_inuse_exit_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">core</span><span class="p">.</span><span class="n">inuse</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">net_inuse_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">sock_inuse_init_net</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">sock_inuse_exit_net</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">net_inuse_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">register_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_inuse_ops</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Cannot initialize net inuse counters&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">core_initcall</span><span class="p">(</span><span class="n">net_inuse_init</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">prot_inuse</span><span class="p">,</span> <span class="n">prot_inuse</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sock_prot_inuse_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__this_cpu_add</span><span class="p">(</span><span class="n">prot_inuse</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">inuse_idx</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sock_prot_inuse_add</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_prot_inuse_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">inuse_idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">+=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">prot_inuse</span><span class="p">,</span> <span class="n">cpu</span><span class="p">).</span><span class="n">val</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">res</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sock_prot_inuse_get</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">assign_proto_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prot</span><span class="o">-&gt;</span><span class="n">inuse_idx</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="n">proto_inuse_idx</span><span class="p">,</span> <span class="n">PROTO_INUSE_NR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">inuse_idx</span> <span class="o">==</span> <span class="n">PROTO_INUSE_NR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;PROTO_INUSE_NR exhausted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">inuse_idx</span><span class="p">,</span> <span class="n">proto_inuse_idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_proto_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">inuse_idx</span> <span class="o">!=</span> <span class="n">PROTO_INUSE_NR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">inuse_idx</span><span class="p">,</span> <span class="n">proto_inuse_idx</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">assign_proto_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">release_proto_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">proto_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc_slab</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_slab</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">obj_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab_flags</span><span class="p">,</span>
					<span class="nb">NULL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;%s: Can&#39;t create sock SLAB cache!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">prot</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab_name</span> <span class="o">=</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;request_sock_%s&quot;</span><span class="p">,</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free_sock_slab</span><span class="p">;</span>

			<span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab_name</span><span class="p">,</span>
								 <span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">obj_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
								 <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;%s: Can&#39;t create request sock SLAB cache!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">prot</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_free_request_sock_slab_name</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span><span class="o">-&gt;</span><span class="n">twsk_slab_name</span> <span class="o">=</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="s">&quot;tw_sock_%s&quot;</span><span class="p">,</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span><span class="o">-&gt;</span><span class="n">twsk_slab_name</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free_request_sock_slab</span><span class="p">;</span>

			<span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span><span class="o">-&gt;</span><span class="n">twsk_slab</span> <span class="o">=</span>
				<span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span><span class="o">-&gt;</span><span class="n">twsk_slab_name</span><span class="p">,</span>
						  <span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span><span class="o">-&gt;</span><span class="n">twsk_obj_size</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">,</span>
						  <span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span>
							<span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab_flags</span><span class="p">,</span>
						  <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span><span class="o">-&gt;</span><span class="n">twsk_slab</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free_timewait_sock_slab_name</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list_mutex</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proto_list</span><span class="p">);</span>
	<span class="n">assign_proto_idx</span><span class="p">(</span><span class="n">prot</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_timewait_sock_slab_name:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span><span class="o">-&gt;</span><span class="n">twsk_slab_name</span><span class="p">);</span>
<span class="nl">out_free_request_sock_slab:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span> <span class="o">&amp;&amp;</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">);</span>
		<span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_free_request_sock_slab_name:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab_name</span><span class="p">);</span>
<span class="nl">out_free_sock_slab:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">);</span>
	<span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">proto_register</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">proto_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list_mutex</span><span class="p">);</span>
	<span class="n">release_proto_idx</span><span class="p">(</span><span class="n">prot</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">);</span>
		<span class="n">prot</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab_name</span><span class="p">);</span>
		<span class="n">prot</span><span class="o">-&gt;</span><span class="n">rsk_prot</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span><span class="o">-&gt;</span><span class="n">twsk_slab</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span><span class="o">-&gt;</span><span class="n">twsk_slab</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span><span class="o">-&gt;</span><span class="n">twsk_slab_name</span><span class="p">);</span>
		<span class="n">prot</span><span class="o">-&gt;</span><span class="n">twsk_prot</span><span class="o">-&gt;</span><span class="n">twsk_slab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">proto_unregister</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">proto_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">proto_list_mutex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">seq_list_start_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">proto_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_list_next</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proto_list</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">proto_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">proto_list_mutex</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_list_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="nf">proto_method_implemented</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">method</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">method</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="sc">&#39;n&#39;</span> <span class="o">:</span> <span class="sc">&#39;y&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">sock_prot_memory_allocated</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proto</span><span class="o">-&gt;</span><span class="n">memory_allocated</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="n">proto_memory_allocated</span><span class="p">(</span><span class="n">proto</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1L</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sock_prot_memory_pressure</span><span class="p">(</span><span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">proto</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">proto</span><span class="o">-&gt;</span><span class="n">memory_pressure</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span>
	<span class="n">proto_memory_pressure</span><span class="p">(</span><span class="n">proto</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span> <span class="o">:</span> <span class="s">&quot;NI&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">proto_seq_printf</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proto</span> <span class="o">*</span><span class="n">proto</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-9s %4u %6d  %6ld   %-3s %6u   %-3s  %-10s &quot;</span>
			<span class="s">&quot;%2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">proto</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		   <span class="n">proto</span><span class="o">-&gt;</span><span class="n">obj_size</span><span class="p">,</span>
		   <span class="n">sock_prot_inuse_get</span><span class="p">(</span><span class="n">seq_file_net</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span> <span class="n">proto</span><span class="p">),</span>
		   <span class="n">sock_prot_memory_allocated</span><span class="p">(</span><span class="n">proto</span><span class="p">),</span>
		   <span class="n">sock_prot_memory_pressure</span><span class="p">(</span><span class="n">proto</span><span class="p">),</span>
		   <span class="n">proto</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">,</span>
		   <span class="n">proto</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="s">&quot;no&quot;</span> <span class="o">:</span> <span class="s">&quot;yes&quot;</span><span class="p">,</span>
		   <span class="n">module_name</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">connect</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">disconnect</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">setsockopt</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">getsockopt</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">sendmsg</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">recvmsg</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">sendpage</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">backlog_rcv</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">unhash</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">get_port</span><span class="p">),</span>
		   <span class="n">proto_method_implemented</span><span class="p">(</span><span class="n">proto</span><span class="o">-&gt;</span><span class="n">enter_memory_pressure</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proto_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">proto_list</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-9s %-4s %-8s %-6s %-5s %-7s %-4s %-10s %s&quot;</span><span class="p">,</span>
			   <span class="s">&quot;protocol&quot;</span><span class="p">,</span>
			   <span class="s">&quot;size&quot;</span><span class="p">,</span>
			   <span class="s">&quot;sockets&quot;</span><span class="p">,</span>
			   <span class="s">&quot;memory&quot;</span><span class="p">,</span>
			   <span class="s">&quot;press&quot;</span><span class="p">,</span>
			   <span class="s">&quot;maxhdr&quot;</span><span class="p">,</span>
			   <span class="s">&quot;slab&quot;</span><span class="p">,</span>
			   <span class="s">&quot;module&quot;</span><span class="p">,</span>
			   <span class="s">&quot;cl co di ac io in de sh ss gs se re sp bi br ha uh gp em</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">proto_seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proto</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">proto_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>  <span class="o">=</span> <span class="n">proto_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>   <span class="o">=</span> <span class="n">proto_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>   <span class="o">=</span> <span class="n">proto_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>   <span class="o">=</span> <span class="n">proto_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">proto_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open_net</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proto_seq_ops</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_net_private</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proto_seq_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">proto_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release_net</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__net_init</span> <span class="kt">int</span> <span class="nf">proto_init_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_net_fops_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;protocols&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proto_seq_fops</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__net_exit</span> <span class="kt">void</span> <span class="nf">proto_exit_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;protocols&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">__net_initdata</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">proto_net_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">proto_init_net</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">proto_exit_net</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">proto_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">register_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proto_net_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">proto_init</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* PROC_FS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
