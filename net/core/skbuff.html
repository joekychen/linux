<!DOCTYPE html>
<html><head><title>joekychen/linux » net › core › skbuff.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>skbuff.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *	Routines having to do with the &#39;struct sk_buff&#39; memory handlers.</span>
<span class="cm"> *</span>
<span class="cm"> *	Authors:	Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</span>
<span class="cm"> *			Florian La Roche &lt;rzsfl@rz.uni-sb.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	Fixes:</span>
<span class="cm"> *		Alan Cox	:	Fixed the worst of the load</span>
<span class="cm"> *					balancer bugs.</span>
<span class="cm"> *		Dave Platt	:	Interrupt stacking fix.</span>
<span class="cm"> *	Richard Kooijman	:	Timestamp fixes.</span>
<span class="cm"> *		Alan Cox	:	Changed buffer format.</span>
<span class="cm"> *		Alan Cox	:	destructor hook for AF_UNIX etc.</span>
<span class="cm"> *		Linus Torvalds	:	Better skb_clone.</span>
<span class="cm"> *		Alan Cox	:	Added skb_copy.</span>
<span class="cm"> *		Alan Cox	:	Added all the changed routines Linus</span>
<span class="cm"> *					only put in the headers</span>
<span class="cm"> *		Ray VanTassle	:	Fixed --skb-&gt;lock in free</span>
<span class="cm"> *		Alan Cox	:	skb_copy copy arp field</span>
<span class="cm"> *		Andi Kleen	:	slabified it.</span>
<span class="cm"> *		Robert Olsson	:	Removed skb_head_pool</span>
<span class="cm"> *</span>
<span class="cm"> *	NOTE:</span>
<span class="cm"> *		The __skb_ routines should be called with interrupts</span>
<span class="cm"> *	disabled, or you better be *real* sure that the operation is atomic</span>
<span class="cm"> *	with respect to whatever list is being frobbed (e.g. via lock_sock()</span>
<span class="cm"> *	or via disabling bottom half handlers, etc).</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	as published by the Free Software Foundation; either version</span>
<span class="cm"> *	2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	The functions in this file will not compile correctly with gcc 2.4.x</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/kmemcheck.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/inet.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#ifdef CONFIG_NET_CLS_ACT</span>
<span class="cp">#include &lt;net/pkt_sched.h&gt;</span>
<span class="cp">#endif</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/splice.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>
<span class="cp">#include &lt;linux/errqueue.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cp">#include &lt;net/protocol.h&gt;</span>
<span class="cp">#include &lt;net/dst.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;net/xfrm.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;trace/events/skb.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">skbuff_head_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">skbuff_fclone_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_pipe_buf_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_pipe_buf_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sock_pipe_buf_steal</span><span class="p">(</span><span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">pipe_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Pipe buffer operations for a socket. */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pipe_buf_operations</span> <span class="n">sock_pipe_buf_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">can_merge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">generic_pipe_buf_map</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unmap</span> <span class="o">=</span> <span class="n">generic_pipe_buf_unmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">confirm</span> <span class="o">=</span> <span class="n">generic_pipe_buf_confirm</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">sock_pipe_buf_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">steal</span> <span class="o">=</span> <span class="n">sock_pipe_buf_steal</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">sock_pipe_buf_get</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Keep out-of-line to prevent kernel bloat.</span>
<span class="cm"> *	__builtin_return_address is not used because it is not always</span>
<span class="cm"> *	reliable.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_over_panic	- 	private function</span>
<span class="cm"> *	@skb: buffer</span>
<span class="cm"> *	@sz: size</span>
<span class="cm"> *	@here: address</span>
<span class="cm"> *</span>
<span class="cm"> *	Out of line support code for skb_put(). Not user callable.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_over_panic</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">here</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;%s: text:%p len:%d put:%d head:%p data:%p tail:%#lx end:%#lx dev:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">here</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">,</span>
		 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;&lt;NULL&gt;&quot;</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_under_panic	- 	private function</span>
<span class="cm"> *	@skb: buffer</span>
<span class="cm"> *	@sz: size</span>
<span class="cm"> *	@here: address</span>
<span class="cm"> *</span>
<span class="cm"> *	Out of line support code for skb_push(). Not user callable.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_under_panic</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">here</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;%s: text:%p len:%d put:%d head:%p data:%p tail:%#lx end:%#lx dev:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">here</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">,</span>
		 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">?</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;&lt;NULL&gt;&quot;</span><span class="p">);</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* 	Allocate a new skbuff. We do this ourselves so we can fill in a few</span>
<span class="cm"> *	&#39;private&#39; fields and also do memory statistics to find all the</span>
<span class="cm"> *	[BEEP] leaks.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	__alloc_skb	-	allocate a network buffer</span>
<span class="cm"> *	@size: size to allocate</span>
<span class="cm"> *	@gfp_mask: allocation mask</span>
<span class="cm"> *	@fclone: allocate from fclone cache instead of head cache</span>
<span class="cm"> *		and allocate a cloned (child) skb</span>
<span class="cm"> *	@node: numa node to allocate memory on</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate a new &amp;sk_buff. The returned buffer has no headroom and a</span>
<span class="cm"> *	tail room of size bytes. The object has a reference count of one.</span>
<span class="cm"> *	The return is the buffer. On a failure the return is %NULL.</span>
<span class="cm"> *</span>
<span class="cm"> *	Buffers may only be allocated from interrupts using a @gfp_mask of</span>
<span class="cm"> *	%GFP_ATOMIC.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">__alloc_skb</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">fclone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">shinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">fclone</span> <span class="o">?</span> <span class="n">skbuff_fclone_cache</span> <span class="o">:</span> <span class="n">skbuff_head_cache</span><span class="p">;</span>

	<span class="cm">/* Get the HEAD */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">kmem_cache_alloc_node</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_DMA</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">prefetchw</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* We do our best to align skb_shared_info on a separate cache</span>
<span class="cm">	 * line. It usually works because kmalloc(X &gt; SMP_CACHE_BYTES) gives</span>
<span class="cm">	 * aligned memory blocks, unless SLUB/SLAB debug is enabled.</span>
<span class="cm">	 * Both skb-&gt;head and skb_shared_info are cache line aligned.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span><span class="p">));</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc_node_track_caller</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>
	<span class="cm">/* kmalloc(size) might give us more room than requested.</span>
<span class="cm">	 * Put skb_shared_info exactly at the end of allocated zone,</span>
<span class="cm">	 * to allow max possible filling before reallocation.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">SKB_WITH_OVERHEAD</span><span class="p">(</span><span class="n">ksize</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
	<span class="n">prefetchw</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only clear those fields we need to clear, not those that we will</span>
<span class="cm">	 * actually initialise below. Hence, don&#39;t put any more fields after</span>
<span class="cm">	 * the tail pointer in struct sk_buff!</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">tail</span><span class="p">));</span>
	<span class="cm">/* Account for allocated memory : skb + skb-&gt;head */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">=</span> <span class="n">SKB_TRUESIZE</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">skb_reset_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
<span class="cp">#ifdef NET_SKBUFF_DATA_USES_OFFSET</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* make sure we initialize shinfo sequentially */</span>
	<span class="n">shinfo</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">shinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span><span class="p">,</span> <span class="n">dataref</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">dataref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">kmemcheck_annotate_variable</span><span class="p">(</span><span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">destructor_arg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fclone</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">skb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">atomic_t</span> <span class="o">*</span><span class="n">fclone_ref</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">child</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">kmemcheck_annotate_bitfield</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>
		<span class="n">kmemcheck_annotate_bitfield</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">fclone</span> <span class="o">=</span> <span class="n">SKB_FCLONE_ORIG</span><span class="p">;</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="n">fclone_ref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">child</span><span class="o">-&gt;</span><span class="n">fclone</span> <span class="o">=</span> <span class="n">SKB_FCLONE_UNAVAILABLE</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="nl">nodata:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__alloc_skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * build_skb - build a network buffer</span>
<span class="cm"> * @data: data buffer provided by caller</span>
<span class="cm"> * @frag_size: size of fragment, or 0 if head was kmalloced</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a new &amp;sk_buff. Caller provides space holding head and</span>
<span class="cm"> * skb_shared_info. @data must have been allocated by kmalloc()</span>
<span class="cm"> * The return is the new skb buffer.</span>
<span class="cm"> * On a failure the return is %NULL, and @data is not freed.</span>
<span class="cm"> * Notes :</span>
<span class="cm"> *  Before IO, driver allocates only data buffer where NIC put incoming frame</span>
<span class="cm"> *  Driver should add room at head (NET_SKB_PAD) and</span>
<span class="cm"> *  MUST add room at tail (SKB_DATA_ALIGN(skb_shared_info))</span>
<span class="cm"> *  After IO, driver calls build_skb(), to allocate sk_buff and populate it</span>
<span class="cm"> *  before giving packet to stack.</span>
<span class="cm"> *  RX rings only contains data buffers, not full skbs.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">build_skb</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">frag_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">shinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">frag_size</span> <span class="o">?</span> <span class="o">:</span> <span class="n">ksize</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">skbuff_head_cache</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">-=</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span><span class="p">));</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">tail</span><span class="p">));</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">=</span> <span class="n">SKB_TRUESIZE</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">head_frag</span> <span class="o">=</span> <span class="n">frag_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">skb_reset_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
<span class="cp">#ifdef NET_SKBUFF_DATA_USES_OFFSET</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* make sure we initialize shinfo sequentially */</span>
	<span class="n">shinfo</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">shinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span><span class="p">,</span> <span class="n">dataref</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">dataref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">kmemcheck_annotate_variable</span><span class="p">(</span><span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">destructor_arg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">build_skb</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">netdev_alloc_cache</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">netdev_alloc_cache</span><span class="p">,</span> <span class="n">netdev_alloc_cache</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * netdev_alloc_frag - allocate a page fragment</span>
<span class="cm"> * @fragsz: fragment size</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates a frag from a page for receive buffer.</span>
<span class="cm"> * Uses GFP_ATOMIC allocations.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">netdev_alloc_frag</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fragsz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">netdev_alloc_cache</span> <span class="o">*</span><span class="n">nc</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">nc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">netdev_alloc_cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">refill:</span>
		<span class="n">nc</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_COLD</span><span class="p">);</span>
		<span class="n">nc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">fragsz</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">refill</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">nc</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">nc</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">fragsz</span><span class="p">;</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">nc</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">netdev_alloc_frag</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	__netdev_alloc_skb - allocate an skbuff for rx on a specific device</span>
<span class="cm"> *	@dev: network device to receive on</span>
<span class="cm"> *	@length: length to allocate</span>
<span class="cm"> *	@gfp_mask: get_free_pages mask, passed to alloc_skb</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate a new &amp;sk_buff and assign it a usage count of one. The</span>
<span class="cm"> *	buffer has unspecified headroom built in. Users should allocate</span>
<span class="cm"> *	the headroom they think they need without accounting for the</span>
<span class="cm"> *	built in space. The built in space is used for optimisations.</span>
<span class="cm"> *</span>
<span class="cm"> *	%NULL is returned if there is no free memory.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">__netdev_alloc_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fragsz</span> <span class="o">=</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">NET_SKB_PAD</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fragsz</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">netdev_alloc_frag</span><span class="p">(</span><span class="n">fragsz</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">build_skb</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fragsz</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
				<span class="n">put_page</span><span class="p">(</span><span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">__alloc_skb</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">NET_SKB_PAD</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">NET_SKB_PAD</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__netdev_alloc_skb</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">skb_add_rx_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">truesize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">truesize</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_add_rx_frag</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_drop_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">listp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="o">*</span><span class="n">listp</span><span class="p">;</span>

	<span class="o">*</span><span class="n">listp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
		<span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_drop_fraglist</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_drop_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_clone_fraglist</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>

	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">skb_get</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_free_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head_frag</span><span class="p">)</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_release_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">cloned</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">atomic_sub_return</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nohdr</span> <span class="o">?</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">SKB_DATAREF_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dataref</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">skb_frag_unref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If skb buf is from userspace, we need to notify the caller</span>
<span class="cm">		 * the lower device DMA has done;</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_DEV_ZEROCOPY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ubuf_info</span> <span class="o">*</span><span class="n">uarg</span><span class="p">;</span>

			<span class="n">uarg</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">destructor_arg</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">uarg</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)</span>
				<span class="n">uarg</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">uarg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="n">skb_drop_fraglist</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">skb_free_head</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Free an skbuff by memory without cleaning the state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">kfree_skbmem</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">other</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="o">*</span><span class="n">fclone_ref</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">fclone</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SKB_FCLONE_UNAVAILABLE</span>:
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">skbuff_head_cache</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SKB_FCLONE_ORIG</span>:
		<span class="n">fclone_ref</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">skb</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="n">fclone_ref</span><span class="p">))</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">skbuff_fclone_cache</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SKB_FCLONE_CLONE</span>:
		<span class="n">fclone_ref</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">skb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">other</span> <span class="o">=</span> <span class="n">skb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* The clone portion is available for</span>
<span class="cm">		 * fast-cloning again.</span>
<span class="cm">		 */</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">fclone</span> <span class="o">=</span> <span class="n">SKB_FCLONE_UNAVAILABLE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="n">fclone_ref</span><span class="p">))</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">skbuff_fclone_cache</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_release_head_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_dst_drop</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_XFRM</span>
	<span class="n">secpath_put</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">in_irq</span><span class="p">());</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#if IS_ENABLED(CONFIG_NF_CONNTRACK)</span>
	<span class="n">nf_conntrack_put</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED</span>
	<span class="n">nf_conntrack_put_reasm</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nfct_reasm</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_BRIDGE_NETFILTER</span>
	<span class="n">nf_bridge_put</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">nf_bridge</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cm">/* XXX: IS this still necessary? - JHS */</span>
<span class="cp">#ifdef CONFIG_NET_SCHED</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NET_CLS_ACT</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tc_verd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Free everything but the sk_buff shell. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_release_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_release_head_state</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_release_data</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__kfree_skb - private function</span>
<span class="cm"> *	@skb: buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Free an sk_buff. Release anything attached to the buffer.</span>
<span class="cm"> *	Clean the state. This is an internal helper function. Users should</span>
<span class="cm"> *	always call kfree_skb</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">__kfree_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_release_all</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">kfree_skbmem</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__kfree_skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	kfree_skb - free an sk_buff</span>
<span class="cm"> *	@skb: buffer to free</span>
<span class="cm"> *</span>
<span class="cm"> *	Drop a reference to the buffer and free it if the usage count has</span>
<span class="cm"> *	hit zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kfree_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">trace_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kfree_skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	consume_skb - free an skbuff</span>
<span class="cm"> *	@skb: buffer to free</span>
<span class="cm"> *</span>
<span class="cm"> *	Drop a ref to the buffer and free it if the usage count has hit zero</span>
<span class="cm"> *	Functions identically to kfree_skb, but kfree_skb assumes that the frame</span>
<span class="cm"> *	is being dropped after a failure and notes that</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">consume_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">smp_rmb</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">trace_consume_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">consume_skb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * 	skb_recycle - clean up an skb for reuse</span>
<span class="cm"> * 	@skb: buffer</span>
<span class="cm"> *</span>
<span class="cm"> * 	Recycles the skb to be reused as a receive buffer. This</span>
<span class="cm"> * 	function does any necessary reference count dropping, and</span>
<span class="cm"> * 	cleans up the skbuff as if it just came from __alloc_skb().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">skb_recycle</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">shinfo</span><span class="p">;</span>

	<span class="n">skb_release_head_state</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">shinfo</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">shinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span><span class="p">,</span> <span class="n">dataref</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shinfo</span><span class="o">-&gt;</span><span class="n">dataref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">,</span> <span class="n">tail</span><span class="p">));</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">NET_SKB_PAD</span><span class="p">;</span>
	<span class="n">skb_reset_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_recycle</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_recycle_check - check if skb can be reused for receive</span>
<span class="cm"> *	@skb: buffer</span>
<span class="cm"> *	@skb_size: minimum receive buffer size</span>
<span class="cm"> *</span>
<span class="cm"> *	Checks that the skb passed in is not shared or cloned, and</span>
<span class="cm"> *	that it is linear and its head portion at least as large as</span>
<span class="cm"> *	skb_size so that it can be recycled as a receive buffer.</span>
<span class="cm"> *	If these conditions are met, this function does any necessary</span>
<span class="cm"> *	reference count dropping and cleans up the skbuff as if it</span>
<span class="cm"> *	just came from __alloc_skb().</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">skb_recycle_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">skb_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_is_recycleable</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">skb_recycle</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_recycle_check</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__copy_skb_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">tstamp</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">dev</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">transport_header</span>	<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">transport_header</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">network_header</span>	<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">network_header</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">mac_header</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">mac_header</span><span class="p">;</span>
	<span class="n">skb_dst_copy</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">rxhash</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">rxhash</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">ooo_okay</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">ooo_okay</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">l4_rxhash</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">l4_rxhash</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">no_fcs</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">no_fcs</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_XFRM</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">sp</span>			<span class="o">=</span> <span class="n">secpath_get</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">));</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">csum</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">local_df</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">local_df</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">pkt_type</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">pkt_type</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">ip_summed</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">ip_summed</span><span class="p">;</span>
	<span class="n">skb_copy_queue_mapping</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">priority</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>
<span class="cp">#if IS_ENABLED(CONFIG_IP_VS)</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">ipvs_property</span>	<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">ipvs_property</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">protocol</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">mark</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">mark</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">skb_iif</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">skb_iif</span><span class="p">;</span>
	<span class="n">__nf_copy</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
<span class="cp">#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">nf_trace</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">nf_trace</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NET_SCHED</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">tc_index</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">tc_index</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NET_CLS_ACT</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">tc_verd</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">tc_verd</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">vlan_tci</span>		<span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">vlan_tci</span><span class="p">;</span>

	<span class="n">skb_copy_secmark</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * You should not add any new code to this function.  Add it to</span>
<span class="cm"> * __copy_skb_header above instead.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">__skb_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define C(x) n-&gt;x = skb-&gt;x</span>

	<span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">__copy_skb_header</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">C</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">C</span><span class="p">(</span><span class="n">data_len</span><span class="p">);</span>
	<span class="n">C</span><span class="p">(</span><span class="n">mac_len</span><span class="p">);</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">hdr_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">nohdr</span> <span class="o">?</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">:</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">hdr_len</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">cloned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">nohdr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">C</span><span class="p">(</span><span class="n">tail</span><span class="p">);</span>
	<span class="n">C</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
	<span class="n">C</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
	<span class="n">C</span><span class="p">(</span><span class="n">head_frag</span><span class="p">);</span>
	<span class="n">C</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">C</span><span class="p">(</span><span class="n">truesize</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">users</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dataref</span><span class="p">));</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">cloned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="cp">#undef C</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_morph	-	morph one skb into another</span>
<span class="cm"> *	@dst: the skb to receive the contents</span>
<span class="cm"> *	@src: the skb to supply the contents</span>
<span class="cm"> *</span>
<span class="cm"> *	This is identical to skb_clone except that the target skb is</span>
<span class="cm"> *	supplied by the user.</span>
<span class="cm"> *</span>
<span class="cm"> *	The target skb is returned upon exit.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_morph</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_release_all</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__skb_clone</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">skb_morph</span><span class="p">);</span>

<span class="cm">/*	skb_copy_ubufs	-	copy userspace skb frags buffers to kernel</span>
<span class="cm"> *	@skb: the skb to modify</span>
<span class="cm"> *	@gfp_mask: allocation priority</span>
<span class="cm"> *</span>
<span class="cm"> *	This must be called on SKBTX_DEV_ZEROCOPY skb.</span>
<span class="cm"> *	It will copy all frags into kernel and drop the reference</span>
<span class="cm"> *	to userspace pages.</span>
<span class="cm"> *</span>
<span class="cm"> *	If this function is called from an interrupt gfp_mask() must be</span>
<span class="cm"> *	%GFP_ATOMIC.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success or a negative error code on failure</span>
<span class="cm"> *	to allocate kernel memory to copy to.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">skb_copy_ubufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_frags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ubuf_info</span> <span class="o">*</span><span class="n">uarg</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">destructor_arg</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
				<span class="n">put_page</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
				<span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
		       <span class="n">vaddr</span> <span class="o">+</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">head</span><span class="p">;</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* skb frags release userspace buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">skb_frag_unref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">uarg</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">uarg</span><span class="p">);</span>

	<span class="cm">/* skb frags point to kernel buffers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
		<span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SKBTX_DEV_ZEROCOPY</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	skb_clone	-	duplicate an sk_buff</span>
<span class="cm"> *	@skb: buffer to clone</span>
<span class="cm"> *	@gfp_mask: allocation priority</span>
<span class="cm"> *</span>
<span class="cm"> *	Duplicate an &amp;sk_buff. The new one is not owned by a socket. Both</span>
<span class="cm"> *	copies share the same packet data but not structure. The new</span>
<span class="cm"> *	buffer has a reference count of 1. If the allocation fails the</span>
<span class="cm"> *	function returns %NULL otherwise the new buffer is returned.</span>
<span class="cm"> *</span>
<span class="cm"> *	If this function is called from an interrupt gfp_mask() must be</span>
<span class="cm"> *	%GFP_ATOMIC.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_DEV_ZEROCOPY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_ubufs</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">skb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">fclone</span> <span class="o">==</span> <span class="n">SKB_FCLONE_ORIG</span> <span class="o">&amp;&amp;</span>
	    <span class="n">n</span><span class="o">-&gt;</span><span class="n">fclone</span> <span class="o">==</span> <span class="n">SKB_FCLONE_UNAVAILABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_t</span> <span class="o">*</span><span class="n">fclone_ref</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">fclone</span> <span class="o">=</span> <span class="n">SKB_FCLONE_CLONE</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="n">fclone_ref</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">skbuff_head_cache</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">kmemcheck_annotate_bitfield</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">flags1</span><span class="p">);</span>
		<span class="n">kmemcheck_annotate_bitfield</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">flags2</span><span class="p">);</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">fclone</span> <span class="o">=</span> <span class="n">SKB_FCLONE_UNAVAILABLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">__skb_clone</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_clone</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_skb_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef NET_SKBUFF_DATA_USES_OFFSET</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Shift between the two data areas in bytes</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">__copy_skb_header</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>

<span class="cp">#ifndef NET_SKBUFF_DATA_USES_OFFSET</span>
	<span class="cm">/* {transport,network,mac}_header are relative to skb-&gt;head */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">network_header</span>   <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_mac_header_was_set</span><span class="p">(</span><span class="n">new</span><span class="p">))</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">mac_header</span>	      <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">old</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">old</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_segs</span><span class="p">;</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">old</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_copy	-	create private copy of an sk_buff</span>
<span class="cm"> *	@skb: buffer to copy</span>
<span class="cm"> *	@gfp_mask: allocation priority</span>
<span class="cm"> *</span>
<span class="cm"> *	Make a copy of both an &amp;sk_buff and its data. This is used when the</span>
<span class="cm"> *	caller wishes to modify the data and needs a private copy of the</span>
<span class="cm"> *	data to alter. Returns %NULL on failure or the pointer to the buffer</span>
<span class="cm"> *	on success. The returned buffer has a reference count of 1.</span>
<span class="cm"> *</span>
<span class="cm"> *	As by-product this function converts non-linear &amp;sk_buff to linear</span>
<span class="cm"> *	one, so that &amp;sk_buff becomes completely private and caller is allowed</span>
<span class="cm"> *	to modify all the data of returned buffer. This means that this</span>
<span class="cm"> *	function is not recommended for use in circumstances when only</span>
<span class="cm"> *	header is going to be modified. Use pskb_copy() instead.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_copy</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">headerlen</span> <span class="o">=</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">skb_end_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Set the data pointer */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">headerlen</span><span class="p">);</span>
	<span class="cm">/* Set the tail pointer and length */</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">-</span><span class="n">headerlen</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">headerlen</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">copy_skb_header</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_copy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	__pskb_copy	-	create copy of an sk_buff with private head.</span>
<span class="cm"> *	@skb: buffer to copy</span>
<span class="cm"> *	@headroom: headroom of new skb</span>
<span class="cm"> *	@gfp_mask: allocation priority</span>
<span class="cm"> *</span>
<span class="cm"> *	Make a copy of both an &amp;sk_buff and part of its data, located</span>
<span class="cm"> *	in header. Fragmented data remain shared. This is used when</span>
<span class="cm"> *	the caller wishes to modify only header of &amp;sk_buff and needs</span>
<span class="cm"> *	private copy of the header to alter. Returns %NULL on failure</span>
<span class="cm"> *	or the pointer to the buffer on success.</span>
<span class="cm"> *	The returned buffer has a reference count of 1.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">__pskb_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">headroom</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">headroom</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Set the data pointer */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">headroom</span><span class="p">);</span>
	<span class="cm">/* Set the tail pointer and length */</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="cm">/* Copy the bytes */</span>
	<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">n</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">data_len</span>  <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">len</span>	     <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_DEV_ZEROCOPY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_ubufs</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
				<span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">skb_frag_ref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">;</span>
		<span class="n">skb_clone_fraglist</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">copy_skb_header</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__pskb_copy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	pskb_expand_head - reallocate header of &amp;sk_buff</span>
<span class="cm"> *	@skb: buffer to reallocate</span>
<span class="cm"> *	@nhead: room to add at head</span>
<span class="cm"> *	@ntail: room to add at tail</span>
<span class="cm"> *	@gfp_mask: allocation priority</span>
<span class="cm"> *</span>
<span class="cm"> *	Expands (or creates identical copy, if &amp;nhead and &amp;ntail are zero)</span>
<span class="cm"> *	header of skb. &amp;sk_buff itself is not changed. &amp;sk_buff MUST have</span>
<span class="cm"> *	reference count of 1. Returns zero in the case of success or error,</span>
<span class="cm"> *	if expansion failed. In the last case, &amp;sk_buff is not changed.</span>
<span class="cm"> *</span>
<span class="cm"> *	All the pointers pointing into skb header may change and must be</span>
<span class="cm"> *	reloaded after call to this function.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">pskb_expand_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nhead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ntail</span><span class="p">,</span>
		     <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nhead</span> <span class="o">+</span> <span class="n">skb_end_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">ntail</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">off</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nhead</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_shared</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span><span class="p">)),</span>
		       <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nodata</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">SKB_WITH_OVERHEAD</span><span class="p">(</span><span class="n">ksize</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>

	<span class="cm">/* Copy only real data... and, alas, header. This should be</span>
<span class="cm">	 * optimized for the cases when header is void.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">nhead</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">((</span><span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">data</span> <span class="o">+</span> <span class="n">size</span><span class="p">),</span>
	       <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
	       <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_shared_info</span><span class="p">,</span> <span class="n">frags</span><span class="p">[</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">]));</span>

	<span class="cm">/*</span>
<span class="cm">	 * if shinfo is shared we must drop the old head gracefully, but if it</span>
<span class="cm">	 * is not we can just drop the old head and let the existing refcount</span>
<span class="cm">	 * be since all we did is relocate the values</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* copy this zero copy skb frags */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_flags</span> <span class="o">&amp;</span> <span class="n">SKBTX_DEV_ZEROCOPY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_ubufs</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">nofrags</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">skb_frag_ref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="n">skb_clone_fraglist</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="n">skb_release_data</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb_free_head</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">off</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">nhead</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span>     <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">head_frag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span>    <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
<span class="cp">#ifdef NET_SKBUFF_DATA_USES_OFFSET</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span>      <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">off</span>           <span class="o">=</span> <span class="n">nhead</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span>      <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/* {transport,network,mac}_header and tail are relative to skb-&gt;head */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span>	      <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">network_header</span>   <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_mac_header_was_set</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
	<span class="cm">/* Only adjust this if it actually is csum_start rather than csum */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_start</span> <span class="o">+=</span> <span class="n">nhead</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">cloned</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">hdr_len</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">nohdr</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dataref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nofrags:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="nl">nodata:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">pskb_expand_head</span><span class="p">);</span>

<span class="cm">/* Make private copy of skb with writable head and some headroom */</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_realloc_headroom</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">headroom</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">headroom</span> <span class="o">-</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">skb2</span> <span class="o">=</span> <span class="n">pskb_copy</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">skb2</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb2</span> <span class="o">&amp;&amp;</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb2</span><span class="p">,</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="n">delta</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
					     <span class="n">GFP_ATOMIC</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb2</span><span class="p">);</span>
			<span class="n">skb2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">skb2</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_realloc_headroom</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_copy_expand	-	copy and expand sk_buff</span>
<span class="cm"> *	@skb: buffer to copy</span>
<span class="cm"> *	@newheadroom: new free bytes at head</span>
<span class="cm"> *	@newtailroom: new free bytes at tail</span>
<span class="cm"> *	@gfp_mask: allocation priority</span>
<span class="cm"> *</span>
<span class="cm"> *	Make a copy of both an &amp;sk_buff and its data and while doing so</span>
<span class="cm"> *	allocate additional space.</span>
<span class="cm"> *</span>
<span class="cm"> *	This is used when the caller wishes to modify the data and needs a</span>
<span class="cm"> *	private copy of the data to alter as well as more space for new fields.</span>
<span class="cm"> *	Returns %NULL on failure or the pointer to the buffer</span>
<span class="cm"> *	on success. The returned buffer has a reference count of 1.</span>
<span class="cm"> *</span>
<span class="cm"> *	You must pass %GFP_ATOMIC as the allocation priority if this function</span>
<span class="cm"> *	is called from an interrupt.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_copy_expand</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">newheadroom</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newtailroom</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *	Allocate the copy buffer</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">newheadroom</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">newtailroom</span><span class="p">,</span>
				      <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">oldheadroom</span> <span class="o">=</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">head_copy_len</span><span class="p">,</span> <span class="n">head_copy_off</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">newheadroom</span><span class="p">);</span>

	<span class="cm">/* Set the tail pointer and length */</span>
	<span class="n">skb_put</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">head_copy_len</span> <span class="o">=</span> <span class="n">oldheadroom</span><span class="p">;</span>
	<span class="n">head_copy_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newheadroom</span> <span class="o">&lt;=</span> <span class="n">head_copy_len</span><span class="p">)</span>
		<span class="n">head_copy_len</span> <span class="o">=</span> <span class="n">newheadroom</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">head_copy_off</span> <span class="o">=</span> <span class="n">newheadroom</span> <span class="o">-</span> <span class="n">head_copy_len</span><span class="p">;</span>

	<span class="cm">/* Copy the linear header and data. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">-</span><span class="n">head_copy_len</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">+</span> <span class="n">head_copy_off</span><span class="p">,</span>
			  <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">head_copy_len</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">copy_skb_header</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">off</span>                  <span class="o">=</span> <span class="n">newheadroom</span> <span class="o">-</span> <span class="n">oldheadroom</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">csum_start</span> <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
<span class="cp">#ifdef NET_SKBUFF_DATA_USES_OFFSET</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">network_header</span>   <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_mac_header_was_set</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="n">n</span><span class="o">-&gt;</span><span class="n">mac_header</span> <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_copy_expand</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_pad			-	zero pad the tail of an skb</span>
<span class="cm"> *	@skb: buffer to pad</span>
<span class="cm"> *	@pad: space to pad</span>
<span class="cm"> *</span>
<span class="cm"> *	Ensure that a buffer is followed by a padding area that is zero</span>
<span class="cm"> *	filled. Used by network drivers which may DMA or transfer data</span>
<span class="cm"> *	beyond the buffer end onto the wire.</span>
<span class="cm"> *</span>
<span class="cm"> *	May return error in out of memory cases. The skb is freed on error.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">skb_pad</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ntail</span><span class="p">;</span>

	<span class="cm">/* If the skbuff is non linear tailroom is always zero.. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">pad</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">+</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ntail</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+</span> <span class="n">pad</span> <span class="o">-</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">ntail</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ntail</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_skb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME: The use of this function with non-linear skb&#39;s really needs</span>
<span class="cm">	 * to be audited.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">skb_linearize</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free_skb</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_skb:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_pad</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_put - add data to a buffer</span>
<span class="cm"> *	@skb: buffer to use</span>
<span class="cm"> *	@len: amount of data to add</span>
<span class="cm"> *</span>
<span class="cm"> *	This function extends the used data area of the buffer. If this would</span>
<span class="cm"> *	exceed the total buffer size the kernel will panic. A pointer to the</span>
<span class="cm"> *	first byte of the extra data is returned.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">SKB_LINEAR_ASSERT</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">))</span>
		<span class="n">skb_over_panic</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_put</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_push - add data to the start of a buffer</span>
<span class="cm"> *	@skb: buffer to use</span>
<span class="cm"> *	@len: amount of data to add</span>
<span class="cm"> *</span>
<span class="cm"> *	This function extends the used data area of the buffer at the buffer</span>
<span class="cm"> *	start. If this would exceed the total buffer headroom the kernel will</span>
<span class="cm"> *	panic. A pointer to the first byte of the extra data is returned.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>  <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">))</span>
		<span class="n">skb_under_panic</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_push</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_pull - remove data from the start of a buffer</span>
<span class="cm"> *	@skb: buffer to use</span>
<span class="cm"> *	@len: amount of data to remove</span>
<span class="cm"> *</span>
<span class="cm"> *	This function removes data from the start of a buffer, returning</span>
<span class="cm"> *	the memory to the headroom. A pointer to the next data in the buffer</span>
<span class="cm"> *	is returned. Once the data has been pulled future pushes will overwrite</span>
<span class="cm"> *	the old data.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_pull</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_pull_inline</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_pull</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_trim - remove end from a buffer</span>
<span class="cm"> *	@skb: buffer to alter</span>
<span class="cm"> *	@len: new length</span>
<span class="cm"> *</span>
<span class="cm"> *	Cut the length of a buffer down by removing data from the tail. If</span>
<span class="cm"> *	the buffer is already under the length specified it is not modified.</span>
<span class="cm"> *	The skb must be linear.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">skb_trim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
		<span class="n">__skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_trim</span><span class="p">);</span>

<span class="cm">/* Trims skb to length len. It can change skb pointers.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">___pskb_trim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">fragp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nfrags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">unlikely</span><span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">drop_pages</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfrags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">skb_frag_size_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>

<span class="nl">drop_pages:</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfrags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">skb_frag_unref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
			<span class="n">skb_drop_fraglist</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">fragp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">;</span> <span class="p">(</span><span class="n">frag</span> <span class="o">=</span> <span class="o">*</span><span class="n">fragp</span><span class="p">);</span>
	     <span class="n">fragp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb_shared</span><span class="p">(</span><span class="n">frag</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nfrag</span><span class="p">;</span>

			<span class="n">nfrag</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nfrag</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="n">nfrag</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">consume_skb</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
			<span class="n">frag</span> <span class="o">=</span> <span class="n">nfrag</span><span class="p">;</span>
			<span class="o">*</span><span class="n">fragp</span> <span class="o">=</span> <span class="n">frag</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span>
		    <span class="n">unlikely</span><span class="p">((</span><span class="n">err</span> <span class="o">=</span> <span class="n">pskb_trim</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">))))</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="n">skb_drop_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">-=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>       <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>       <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">skb_set_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">___pskb_trim</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	__pskb_pull_tail - advance tail of skb header</span>
<span class="cm"> *	@skb: buffer to reallocate</span>
<span class="cm"> *	@delta: number of bytes to advance tail</span>
<span class="cm"> *</span>
<span class="cm"> *	The function makes a sense only on a fragmented &amp;sk_buff,</span>
<span class="cm"> *	it expands header moving its tail forward and copying necessary</span>
<span class="cm"> *	data from fragmented part.</span>
<span class="cm"> *</span>
<span class="cm"> *	&amp;sk_buff MUST have reference count of 1.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns %NULL (and &amp;sk_buff does not change) if pull failed</span>
<span class="cm"> *	or value of new tail of skb in the case of success.</span>
<span class="cm"> *</span>
<span class="cm"> *	All the pointers pointing into skb header may change and must be</span>
<span class="cm"> *	reloaded after call to this function.</span>
<span class="cm"> */</span>

<span class="cm">/* Moves tail of skb head forward, copying data from fragmented part,</span>
<span class="cm"> * when it is necessary.</span>
<span class="cm"> * 1. It may fail due to malloc failure.</span>
<span class="cm"> * 2. It may change skb pointers.</span>
<span class="cm"> *</span>
<span class="cm"> * It is pretty complicated. Luckily, it is called only in exceptional cases.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__pskb_pull_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If skb has not enough free space at tail, get new one</span>
<span class="cm">	 * plus 128 bytes for future expansions. If we have enough</span>
<span class="cm">	 * room at tail, reallocate without expansion only if skb is cloned.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">eat</span> <span class="o">=</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span> <span class="o">-</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eat</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eat</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">eat</span> <span class="o">+</span> <span class="mi">128</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">GFP_ATOMIC</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">delta</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="cm">/* Optimization: no fragments, no reasons to preestimate</span>
<span class="cm">	 * size of pulled pages. Superb.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">pull_pages</span><span class="p">;</span>

	<span class="cm">/* Estimate size of pulled pages. */</span>
	<span class="n">eat</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">eat</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">pull_pages</span><span class="p">;</span>
		<span class="n">eat</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we need update frag list, we are in troubles.</span>
<span class="cm">	 * Certainly, it possible to add an offset to skb data,</span>
<span class="cm">	 * but taking into account that pulling is expected to</span>
<span class="cm">	 * be very rare operation, it is worth to fight against</span>
<span class="cm">	 * further bloating skb head and crucify ourselves here instead.</span>
<span class="cm">	 * Pure masohism, indeed. 8)8)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eat</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">clone</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">insp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">eat</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Eaten as whole. */</span>
				<span class="n">eat</span> <span class="o">-=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
				<span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
				<span class="n">insp</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Eaten partially. */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">skb_shared</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/* Sucks! We need to fork list. :-( */</span>
					<span class="n">clone</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clone</span><span class="p">)</span>
						<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="n">insp</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
					<span class="n">list</span> <span class="o">=</span> <span class="n">clone</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* This may be pulled without</span>
<span class="cm">					 * problems. */</span>
					<span class="n">insp</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pskb_pull</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">eat</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">kfree_skb</span><span class="p">(</span><span class="n">clone</span><span class="p">);</span>
					<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">eat</span><span class="p">);</span>

		<span class="cm">/* Free pulled out fragments. */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">list</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">)</span> <span class="o">!=</span> <span class="n">insp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* And insert new clone at head. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clone</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clone</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span> <span class="o">=</span> <span class="n">clone</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Success! Now we may commit changes to skb data. */</span>

<span class="nl">pull_pages:</span>
	<span class="n">eat</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">eat</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_frag_unref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">eat</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eat</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">eat</span><span class="p">;</span>
				<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">eat</span><span class="p">);</span>
				<span class="n">eat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">k</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tail</span>     <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__pskb_pull_tail</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_copy_bits - copy bits from skb to kernel buffer</span>
<span class="cm"> *	@skb: source skb</span>
<span class="cm"> *	@offset: offset in source</span>
<span class="cm"> *	@to: destination buffer</span>
<span class="cm"> *	@len: number of bytes to copy</span>
<span class="cm"> *</span>
<span class="cm"> *	Copy the specified number of bytes from the source skb to the</span>
<span class="cm"> *	destination buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *	CAUTION ! :</span>
<span class="cm"> *		If its prototype is ever changed,</span>
<span class="cm"> *		check arch/{*}/net/{*}.S files,</span>
<span class="cm"> *		since it is called from BPF assembly code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">skb_copy_bits</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag_iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">copy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fault</span><span class="p">;</span>

	<span class="cm">/* Copy header. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">skb_copy_from_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">to</span>     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

			<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">to</span><span class="p">,</span>
			       <span class="n">vaddr</span> <span class="o">+</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
			       <span class="n">copy</span><span class="p">);</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">to</span>     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag_iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">frag_iter</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">frag_iter</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">copy</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">fault</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">to</span>     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fault:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_copy_bits</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Callback from splice_to_pipe(), if we need to release some pages</span>
<span class="cm"> * at the end of the spd in case we error&#39;ed out in filling the pipe.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_spd_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">splice_pipe_desc</span> <span class="o">*</span><span class="n">spd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">linear_to_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">new_page:</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">off</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* hold one ref to this page until it&#39;s full */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mlen</span><span class="p">;</span>

		<span class="cm">/* If we are the only user of the page, we can reset offset */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_off</span><span class="p">;</span>
		<span class="n">mlen</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mlen</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">&amp;&amp;</span> <span class="n">mlen</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">new_page</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="n">mlen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="o">*</span><span class="n">len</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndmsg_off</span> <span class="o">+=</span> <span class="o">*</span><span class="n">len</span><span class="p">;</span>
	<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">spd_can_coalesce</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">splice_pipe_desc</span> <span class="o">*</span><span class="n">spd</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>	<span class="n">spd</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">&amp;&amp;</span>
		<span class="n">spd</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">page</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">[</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">offset</span> <span class="o">+</span>
		 <span class="n">spd</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">[</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">==</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fill page/offset/length into spd, if it can hold more pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">spd_fill_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">splice_pipe_desc</span> <span class="o">*</span><span class="n">spd</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">linear</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">linear</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">linear_to_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spd_can_coalesce</span><span class="p">(</span><span class="n">spd</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spd</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">[</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">len</span> <span class="o">+=</span> <span class="o">*</span><span class="n">len</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spd</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">spd</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">[</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">].</span><span class="n">len</span> <span class="o">=</span> <span class="o">*</span><span class="n">len</span><span class="p">;</span>
	<span class="n">spd</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">[</span><span class="n">spd</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">spd</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__segment_seek</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">poff</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">plen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>

	<span class="o">*</span><span class="n">poff</span> <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">poff</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">nth_page</span><span class="p">(</span><span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

	<span class="o">*</span><span class="n">poff</span> <span class="o">=</span> <span class="o">*</span><span class="n">poff</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="o">*</span><span class="n">plen</span> <span class="o">-=</span> <span class="n">off</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">__splice_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">poff</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">off</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">splice_pipe_desc</span> <span class="o">*</span><span class="n">spd</span><span class="p">,</span> <span class="n">bool</span> <span class="n">linear</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* skip this segment if already processed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="n">plen</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">off</span> <span class="o">-=</span> <span class="n">plen</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ignore any bits we already processed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">off</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__segment_seek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">poff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">plen</span><span class="p">,</span> <span class="o">*</span><span class="n">off</span><span class="p">);</span>
		<span class="o">*</span><span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flen</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>

		<span class="cm">/* the linear region may spread across several pages  */</span>
		<span class="n">flen</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flen</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">poff</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">spd_fill_page</span><span class="p">(</span><span class="n">spd</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flen</span><span class="p">,</span> <span class="n">poff</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">sk</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

		<span class="n">__segment_seek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">poff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">plen</span><span class="p">,</span> <span class="n">flen</span><span class="p">);</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">-=</span> <span class="n">flen</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">plen</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map linear and fragment data from the skb to spd. It reports true if the</span>
<span class="cm"> * pipe is full or if we already spliced the requested length.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">__skb_splice_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">splice_pipe_desc</span> <span class="o">*</span><span class="n">spd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">seg</span><span class="p">;</span>

	<span class="cm">/* map the linear part :</span>
<span class="cm">	 * If skb-&gt;head_frag is set, this &#39;linear&#39; part is backed by a</span>
<span class="cm">	 * fragment, and if the head is not shared with any clones then</span>
<span class="cm">	 * we can avoid a copy since we own the head portion of this page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__splice_segment</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
			     <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
			     <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">spd</span><span class="p">,</span>
			     <span class="n">skb_head_is_locked</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span>
			     <span class="n">sk</span><span class="p">,</span> <span class="n">pipe</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * then map the fragments</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">seg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">seg</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">__splice_segment</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
				     <span class="n">f</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
				     <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">spd</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">pipe</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map data from the skb to a pipe. Should handle both the linear part,</span>
<span class="cm"> * the fragments, and the frag list. It does NOT handle frag lists within</span>
<span class="cm"> * the frag list, if such a thing exists. We&#39;d probably need to recurse to</span>
<span class="cm"> * handle that cleanly.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">skb_splice_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tlen</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">partial_page</span> <span class="n">partial</span><span class="p">[</span><span class="n">MAX_SKB_FRAGS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">MAX_SKB_FRAGS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">splice_pipe_desc</span> <span class="n">spd</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">,</span>
		<span class="p">.</span><span class="n">partial</span> <span class="o">=</span> <span class="n">partial</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_pages_max</span> <span class="o">=</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sock_pipe_buf_ops</span><span class="p">,</span>
		<span class="p">.</span><span class="n">spd_release</span> <span class="o">=</span> <span class="n">sock_spd_release</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag_iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * __skb_splice_bits() only fails if the output has no room left,</span>
<span class="cm">	 * so no point in going over the frag_list for the error case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__skb_splice_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spd</span><span class="p">,</span> <span class="n">sk</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tlen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * now see if we have a frag_list to map</span>
<span class="cm">	 */</span>
	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag_iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tlen</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__skb_splice_bits</span><span class="p">(</span><span class="n">frag_iter</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spd</span><span class="p">,</span> <span class="n">sk</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spd</span><span class="p">.</span><span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Drop the socket lock, otherwise we have reverse</span>
<span class="cm">		 * locking dependencies between sk_lock and i_mutex</span>
<span class="cm">		 * here as compared to sendfile(). We enter here</span>
<span class="cm">		 * with the socket lock held, and splice_to_pipe() will</span>
<span class="cm">		 * grab the pipe inode lock. For sendfile() emulation,</span>
<span class="cm">		 * we call into -&gt;sendpage() with the i_mutex lock held</span>
<span class="cm">		 * and networking will grab the socket lock.</span>
<span class="cm">		 */</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">splice_to_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spd</span><span class="p">);</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_store_bits - store bits from kernel buffer to skb</span>
<span class="cm"> *	@skb: destination buffer</span>
<span class="cm"> *	@offset: offset in destination</span>
<span class="cm"> *	@from: source buffer</span>
<span class="cm"> *	@len: number of bytes to copy</span>
<span class="cm"> *</span>
<span class="cm"> *	Copy the specified number of bytes from the source buffer to the</span>
<span class="cm"> *	destination skb.  This function handles all the messy bits of</span>
<span class="cm"> *	traversing fragment lists and such.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">skb_store_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag_iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">copy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fault</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">skb_copy_to_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">from</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

			<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
			       <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">from</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag_iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">frag_iter</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_store_bits</span><span class="p">(</span><span class="n">frag_iter</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
					   <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">fault</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">from</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fault:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_store_bits</span><span class="p">);</span>

<span class="cm">/* Checksum skb data. */</span>

<span class="n">__wsum</span> <span class="nf">skb_checksum</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">__wsum</span> <span class="n">csum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag_iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Checksum header. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">csum</span> <span class="o">=</span> <span class="n">csum_partial</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">csum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">csum</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">pos</span>	<span class="o">=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__wsum</span> <span class="n">csum2</span><span class="p">;</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
			<span class="n">csum2</span> <span class="o">=</span> <span class="n">csum_partial</span><span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span>
					     <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
			<span class="n">csum</span> <span class="o">=</span> <span class="n">csum_block_add</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span> <span class="n">csum2</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">csum</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">pos</span>    <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag_iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">frag_iter</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__wsum</span> <span class="n">csum2</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">csum2</span> <span class="o">=</span> <span class="n">skb_checksum</span><span class="p">(</span><span class="n">frag_iter</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
					     <span class="n">copy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">csum</span> <span class="o">=</span> <span class="n">csum_block_add</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span> <span class="n">csum2</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">csum</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">pos</span>    <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">csum</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_checksum</span><span class="p">);</span>

<span class="cm">/* Both of above in one bottle. */</span>

<span class="n">__wsum</span> <span class="nf">skb_copy_and_csum_bits</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
				    <span class="n">u8</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">__wsum</span> <span class="n">csum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag_iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Copy header. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">csum</span> <span class="o">=</span> <span class="n">csum_partial_copy_nocheck</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span>
						 <span class="n">copy</span><span class="p">,</span> <span class="n">csum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">csum</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">to</span>     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">pos</span>	<span class="o">=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__wsum</span> <span class="n">csum2</span><span class="p">;</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">;</span>
			<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">vaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>
			<span class="n">csum2</span> <span class="o">=</span> <span class="n">csum_partial_copy_nocheck</span><span class="p">(</span><span class="n">vaddr</span> <span class="o">+</span>
							  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span>
							  <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span>
							  <span class="n">copy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
			<span class="n">csum</span> <span class="o">=</span> <span class="n">csum_block_add</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span> <span class="n">csum2</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">csum</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">to</span>     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">pos</span>    <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag_iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__wsum</span> <span class="n">csum2</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">frag_iter</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">csum2</span> <span class="o">=</span> <span class="n">skb_copy_and_csum_bits</span><span class="p">(</span><span class="n">frag_iter</span><span class="p">,</span>
						       <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
						       <span class="n">to</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">csum</span> <span class="o">=</span> <span class="n">csum_block_add</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span> <span class="n">csum2</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">csum</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">to</span>     <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">pos</span>    <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">csum</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_copy_and_csum_bits</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">skb_copy_and_csum_dev</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__wsum</span> <span class="n">csum</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">csstart</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
		<span class="n">csstart</span> <span class="o">=</span> <span class="n">skb_checksum_start_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">csstart</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">csstart</span> <span class="o">&gt;</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

	<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">csstart</span><span class="p">);</span>

	<span class="n">csum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csstart</span> <span class="o">!=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
		<span class="n">csum</span> <span class="o">=</span> <span class="n">skb_copy_and_csum_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">csstart</span><span class="p">,</span> <span class="n">to</span> <span class="o">+</span> <span class="n">csstart</span><span class="p">,</span>
					      <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">csstart</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">csstuff</span> <span class="o">=</span> <span class="n">csstart</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span><span class="p">;</span>

		<span class="o">*</span><span class="p">((</span><span class="n">__sum16</span> <span class="o">*</span><span class="p">)(</span><span class="n">to</span> <span class="o">+</span> <span class="n">csstuff</span><span class="p">))</span> <span class="o">=</span> <span class="n">csum_fold</span><span class="p">(</span><span class="n">csum</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_copy_and_csum_dev</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_dequeue - remove from the head of the queue</span>
<span class="cm"> *	@list: list to dequeue from</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove the head of the list. The list lock is taken so the function</span>
<span class="cm"> *	may be used safely with other locking list functions. The head item is</span>
<span class="cm"> *	returned or %NULL if the list is empty.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_dequeue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_dequeue_tail - remove from the tail of the queue</span>
<span class="cm"> *	@list: list to dequeue from</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove the tail of the list. The list lock is taken so the function</span>
<span class="cm"> *	may be used safely with other locking list functions. The tail item is</span>
<span class="cm"> *	returned or %NULL if the list is empty.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_dequeue_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">__skb_dequeue_tail</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_dequeue_tail</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_purge - empty a list</span>
<span class="cm"> *	@list: list to empty</span>
<span class="cm"> *</span>
<span class="cm"> *	Delete all buffers on an &amp;sk_buff list. Each buffer is removed from</span>
<span class="cm"> *	the list and one reference dropped. This function takes the list</span>
<span class="cm"> *	lock and is atomic with respect to other list locking functions.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">skb_queue_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_queue_purge</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_head - queue a buffer at the list head</span>
<span class="cm"> *	@list: list to use</span>
<span class="cm"> *	@newsk: buffer to queue</span>
<span class="cm"> *</span>
<span class="cm"> *	Queue a buffer at the start of the list. This function takes the</span>
<span class="cm"> *	list lock and can be used safely with other locking &amp;sk_buff functions</span>
<span class="cm"> *	safely.</span>
<span class="cm"> *</span>
<span class="cm"> *	A buffer cannot be placed on two lists at the same time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">skb_queue_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__skb_queue_head</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_queue_head</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_queue_tail - queue a buffer at the list tail</span>
<span class="cm"> *	@list: list to use</span>
<span class="cm"> *	@newsk: buffer to queue</span>
<span class="cm"> *</span>
<span class="cm"> *	Queue a buffer at the tail of the list. This function takes the</span>
<span class="cm"> *	list lock and can be used safely with other locking &amp;sk_buff functions</span>
<span class="cm"> *	safely.</span>
<span class="cm"> *</span>
<span class="cm"> *	A buffer cannot be placed on two lists at the same time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">skb_queue_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_queue_tail</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_unlink	-	remove a buffer from a list</span>
<span class="cm"> *	@skb: buffer to remove</span>
<span class="cm"> *	@list: list to use</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove a packet from a list. The list locks are taken and this</span>
<span class="cm"> *	function is atomic with respect to other list locked calls</span>
<span class="cm"> *</span>
<span class="cm"> *	You must know what list the SKB is on.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">skb_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_unlink</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_append	-	append a buffer</span>
<span class="cm"> *	@old: buffer to insert after</span>
<span class="cm"> *	@newsk: buffer to insert</span>
<span class="cm"> *	@list: list to use</span>
<span class="cm"> *</span>
<span class="cm"> *	Place a packet after a given packet in a list. The list locks are taken</span>
<span class="cm"> *	and this function is atomic with respect to other list locked calls.</span>
<span class="cm"> *	A buffer cannot be placed on two lists at the same time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">skb_append</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__skb_queue_after</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_append</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_insert	-	insert a buffer</span>
<span class="cm"> *	@old: buffer to insert before</span>
<span class="cm"> *	@newsk: buffer to insert</span>
<span class="cm"> *	@list: list to use</span>
<span class="cm"> *</span>
<span class="cm"> *	Place a packet before a given packet in a list. The list locks are</span>
<span class="cm"> * 	taken and this function is atomic with respect to other list locked</span>
<span class="cm"> *	calls.</span>
<span class="cm"> *</span>
<span class="cm"> *	A buffer cannot be placed on two lists at the same time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">skb_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">newsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">__skb_insert</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_insert</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_split_inside_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">skb1</span><span class="p">,</span>
					   <span class="k">const</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">skb_copy_from_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">skb1</span><span class="p">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">len</span><span class="p">),</span>
					 <span class="n">pos</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>
	<span class="cm">/* And move data appendix as is. */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb1</span><span class="o">-&gt;</span><span class="n">data_len</span>		   <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="n">skb1</span><span class="o">-&gt;</span><span class="n">len</span>		   <span class="o">+=</span> <span class="n">skb1</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span>		   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>		   <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb_set_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">skb_split_no_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sk_buff</span><span class="o">*</span> <span class="n">skb1</span><span class="p">,</span>
				       <span class="k">const</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">nfrags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>

	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb1</span><span class="o">-&gt;</span><span class="n">len</span>		  <span class="o">=</span> <span class="n">skb1</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span>		  <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span>		  <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">pos</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfrags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Split frag.</span>
<span class="cm">				 * We have two variants in this case:</span>
<span class="cm">				 * 1. Move all the frag to the second</span>
<span class="cm">				 *    part, if it is possible. F.e.</span>
<span class="cm">				 *    this approach is mandatory for TUX,</span>
<span class="cm">				 *    where splitting is expensive.</span>
<span class="cm">				 * 2. Split is accurately. We make this.</span>
<span class="cm">				 */</span>
				<span class="n">skb_frag_ref</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">pos</span><span class="p">;</span>
				<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">len</span> <span class="o">-</span> <span class="n">pos</span><span class="p">);</span>
				<span class="n">skb_frag_size_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">len</span> <span class="o">-</span> <span class="n">pos</span><span class="p">);</span>
				<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">k</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_split - Split fragmented skb to two parts at length len.</span>
<span class="cm"> * @skb: the buffer to split</span>
<span class="cm"> * @skb1: the buffer to receive the second part</span>
<span class="cm"> * @len: new length for skb</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">skb_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb1</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="p">)</span>	<span class="cm">/* Split line is inside header. */</span>
		<span class="n">skb_split_inside_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb1</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">else</span>		<span class="cm">/* Second chunk has no header, nothing to copy. */</span>
		<span class="n">skb_split_no_header</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb1</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_split</span><span class="p">);</span>

<span class="cm">/* Shifting from/to a cloned skb is a no-go.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller cannot keep skb_shinfo related pointers past calling here!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">skb_prepare_for_shift</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_shift - Shifts paged data partially from skb to another</span>
<span class="cm"> * @tgt: buffer into which tail data gets added</span>
<span class="cm"> * @skb: buffer from which the paged data comes from</span>
<span class="cm"> * @shiftlen: shift up to this many bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Attempts to shift up to shiftlen worth of bytes, which may be less than</span>
<span class="cm"> * the length of the skb, from skb to tgt. Returns number bytes shifted.</span>
<span class="cm"> * It&#39;s up to caller to free skb if everything was shifted.</span>
<span class="cm"> *</span>
<span class="cm"> * If @tgt runs out of frags, the whole operation is aborted.</span>
<span class="cm"> *</span>
<span class="cm"> * Skb cannot include anything else but paged data while tgt is allowed</span>
<span class="cm"> * to have non-paged data as well.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: full sized shift could be optimized but that would need</span>
<span class="cm"> * specialized skb free&#39;er to handle frags without up-to-date nr_frags.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">skb_shift</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tgt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shiftlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">merge</span><span class="p">,</span> <span class="n">todo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_frag_struct</span> <span class="o">*</span><span class="n">fragfrom</span><span class="p">,</span> <span class="o">*</span><span class="n">fragto</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">shiftlen</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>	<span class="cm">/* Would corrupt stream */</span>

	<span class="n">todo</span> <span class="o">=</span> <span class="n">shiftlen</span><span class="p">;</span>
	<span class="n">from</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="n">fragfrom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">from</span><span class="p">];</span>

	<span class="cm">/* Actual merge is delayed until the point when we know we can</span>
<span class="cm">	 * commit all, so that we don&#39;t have to undo partial changes</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">skb_can_coalesce</span><span class="p">(</span><span class="n">tgt</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">skb_frag_page</span><span class="p">(</span><span class="n">fragfrom</span><span class="p">),</span>
			      <span class="n">fragfrom</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">merge</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">merge</span> <span class="o">=</span> <span class="n">to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">todo</span> <span class="o">-=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">fragfrom</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">todo</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_prepare_for_shift</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">skb_prepare_for_shift</span><span class="p">(</span><span class="n">tgt</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/* All previous frag pointers might be stale! */</span>
			<span class="n">fragfrom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">from</span><span class="p">];</span>
			<span class="n">fragto</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">merge</span><span class="p">];</span>

			<span class="n">skb_frag_size_add</span><span class="p">(</span><span class="n">fragto</span><span class="p">,</span> <span class="n">shiftlen</span><span class="p">);</span>
			<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="n">fragfrom</span><span class="p">,</span> <span class="n">shiftlen</span><span class="p">);</span>
			<span class="n">fragfrom</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">shiftlen</span><span class="p">;</span>

			<span class="k">goto</span> <span class="n">onlymerged</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">from</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Skip full, not-fitting skb to avoid expensive operations */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">shiftlen</span> <span class="o">==</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">-</span> <span class="n">from</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">MAX_SKB_FRAGS</span> <span class="o">-</span> <span class="n">to</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_prepare_for_shift</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">skb_prepare_for_shift</span><span class="p">(</span><span class="n">tgt</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">todo</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">from</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">to</span> <span class="o">==</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">fragfrom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">from</span><span class="p">];</span>
		<span class="n">fragto</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">to</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">todo</span> <span class="o">&gt;=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">fragfrom</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">fragto</span> <span class="o">=</span> <span class="o">*</span><span class="n">fragfrom</span><span class="p">;</span>
			<span class="n">todo</span> <span class="o">-=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">fragfrom</span><span class="p">);</span>
			<span class="n">from</span><span class="o">++</span><span class="p">;</span>
			<span class="n">to</span><span class="o">++</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">__skb_frag_ref</span><span class="p">(</span><span class="n">fragfrom</span><span class="p">);</span>
			<span class="n">fragto</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">fragfrom</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
			<span class="n">fragto</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="n">fragfrom</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">;</span>
			<span class="n">skb_frag_size_set</span><span class="p">(</span><span class="n">fragto</span><span class="p">,</span> <span class="n">todo</span><span class="p">);</span>

			<span class="n">fragfrom</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">todo</span><span class="p">;</span>
			<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="n">fragfrom</span><span class="p">,</span> <span class="n">todo</span><span class="p">);</span>
			<span class="n">todo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">to</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Ready to &quot;commit&quot; this state change to tgt */</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">merge</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fragfrom</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">fragto</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">merge</span><span class="p">];</span>

		<span class="n">skb_frag_size_add</span><span class="p">(</span><span class="n">fragto</span><span class="p">,</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">fragfrom</span><span class="p">));</span>
		<span class="n">__skb_frag_unref</span><span class="p">(</span><span class="n">fragfrom</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Reposition in the original skb */</span>
	<span class="n">to</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">from</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">)</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">to</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">from</span><span class="o">++</span><span class="p">];</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">todo</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">);</span>

<span class="nl">onlymerged:</span>
	<span class="cm">/* Most likely the tgt won&#39;t ever need its checksum anymore, skb on</span>
<span class="cm">	 * the other hand might need it if it needs to be resent</span>
<span class="cm">	 */</span>
	<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>

	<span class="cm">/* Yak, is it really working this way? Some helper please? */</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-=</span> <span class="n">shiftlen</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">-=</span> <span class="n">shiftlen</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">-=</span> <span class="n">shiftlen</span><span class="p">;</span>
	<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">shiftlen</span><span class="p">;</span>
	<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">shiftlen</span><span class="p">;</span>
	<span class="n">tgt</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">shiftlen</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">shiftlen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_prepare_seq_read - Prepare a sequential read of skb data</span>
<span class="cm"> * @skb: the buffer to read</span>
<span class="cm"> * @from: lower offset of data to be read</span>
<span class="cm"> * @to: upper offset of data to be read</span>
<span class="cm"> * @st: state variable</span>
<span class="cm"> *</span>
<span class="cm"> * Initializes the specified state variable. Must be called before</span>
<span class="cm"> * invoking skb_seq_read() for the first time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">skb_prepare_seq_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">skb_seq_state</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">lower_offset</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">upper_offset</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">root_skb</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">cur_skb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_idx</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">stepped_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_prepare_seq_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * skb_seq_read - Sequentially read skb data</span>
<span class="cm"> * @consumed: number of bytes consumed by the caller so far</span>
<span class="cm"> * @data: destination pointer for data to be returned</span>
<span class="cm"> * @st: state variable</span>
<span class="cm"> *</span>
<span class="cm"> * Reads a block of skb data at &amp;consumed relative to the</span>
<span class="cm"> * lower offset specified to skb_prepare_seq_read(). Assigns</span>
<span class="cm"> * the head of the data block to &amp;data and returns the length</span>
<span class="cm"> * of the block or 0 if the end of the skb data or the upper</span>
<span class="cm"> * offset has been reached.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller is not required to consume all of the data</span>
<span class="cm"> * returned, i.e. &amp;consumed is typically set to the number</span>
<span class="cm"> * of bytes already consumed and the next call to</span>
<span class="cm"> * skb_seq_read() will return the remaining part of the block.</span>
<span class="cm"> *</span>
<span class="cm"> * Note 1: The size of each block of data returned can be arbitrary,</span>
<span class="cm"> *       this limitation is the cost for zerocopy seqeuental</span>
<span class="cm"> *       reads of potentially non linear data.</span>
<span class="cm"> *</span>
<span class="cm"> * Note 2: Fragment lists within fragments are not implemented</span>
<span class="cm"> *       at the moment, state-&gt;root_skb could be replaced with</span>
<span class="cm"> *       a stack for this purpose.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">skb_seq_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">consumed</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">**</span><span class="n">data</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">skb_seq_state</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">block_limit</span><span class="p">,</span> <span class="n">abs_offset</span> <span class="o">=</span> <span class="n">consumed</span> <span class="o">+</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">lower_offset</span><span class="p">;</span>
	<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">abs_offset</span> <span class="o">&gt;=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">upper_offset</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">next_skb:</span>
	<span class="n">block_limit</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">cur_skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">stepped_offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">abs_offset</span> <span class="o">&lt;</span> <span class="n">block_limit</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">cur_skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="p">(</span><span class="n">abs_offset</span> <span class="o">-</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">stepped_offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">block_limit</span> <span class="o">-</span> <span class="n">abs_offset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span><span class="p">)</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">stepped_offset</span> <span class="o">+=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">cur_skb</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_idx</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">cur_skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">cur_skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_idx</span><span class="p">];</span>
		<span class="n">block_limit</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span> <span class="o">+</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">stepped_offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">abs_offset</span> <span class="o">&lt;</span> <span class="n">block_limit</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span><span class="p">)</span>
				<span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">));</span>

			<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">abs_offset</span> <span class="o">-</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">stepped_offset</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">block_limit</span> <span class="o">-</span> <span class="n">abs_offset</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span><span class="p">);</span>
			<span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_idx</span><span class="o">++</span><span class="p">;</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">stepped_offset</span> <span class="o">+=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span><span class="p">);</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">root_skb</span> <span class="o">==</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">cur_skb</span> <span class="o">&amp;&amp;</span> <span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">root_skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">cur_skb</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">root_skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">;</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">next_skb</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">cur_skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">cur_skb</span> <span class="o">=</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">cur_skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">next_skb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_seq_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * skb_abort_seq_read - Abort a sequential read of skb data</span>
<span class="cm"> * @st: state variable</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called if skb_seq_read() was not called until it</span>
<span class="cm"> * returned 0.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">skb_abort_seq_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">skb_seq_state</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span><span class="p">)</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">frag_data</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_abort_seq_read</span><span class="p">);</span>

<span class="cp">#define TS_SKB_CB(state)	((struct skb_seq_state *) &amp;((state)-&gt;cb))</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">skb_ts_get_next_block</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">u8</span> <span class="o">**</span><span class="n">text</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">ts_config</span> <span class="o">*</span><span class="n">conf</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">ts_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_seq_read</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">TS_SKB_CB</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">skb_ts_finish</span><span class="p">(</span><span class="k">struct</span> <span class="n">ts_config</span> <span class="o">*</span><span class="n">conf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ts_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_abort_seq_read</span><span class="p">(</span><span class="n">TS_SKB_CB</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * skb_find_text - Find a text pattern in skb data</span>
<span class="cm"> * @skb: the buffer to look in</span>
<span class="cm"> * @from: search offset</span>
<span class="cm"> * @to: search limit</span>
<span class="cm"> * @config: textsearch configuration</span>
<span class="cm"> * @state: uninitialized textsearch state variable</span>
<span class="cm"> *</span>
<span class="cm"> * Finds a pattern in the skb data according to the specified</span>
<span class="cm"> * textsearch configuration. Use textsearch_next() to retrieve</span>
<span class="cm"> * subsequent occurrences of the pattern. Returns the offset</span>
<span class="cm"> * to the first occurrence or UINT_MAX if no match was found.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">skb_find_text</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ts_config</span> <span class="o">*</span><span class="n">config</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">ts_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">config</span><span class="o">-&gt;</span><span class="n">get_next_block</span> <span class="o">=</span> <span class="n">skb_ts_get_next_block</span><span class="p">;</span>
	<span class="n">config</span><span class="o">-&gt;</span><span class="n">finish</span> <span class="o">=</span> <span class="n">skb_ts_finish</span><span class="p">;</span>

	<span class="n">skb_prepare_seq_read</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">TS_SKB_CB</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">textsearch_find</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="n">to</span> <span class="o">-</span> <span class="n">from</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="n">UINT_MAX</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_find_text</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * skb_append_datato_frags: - append the user data to a skb</span>
<span class="cm"> * @sk: sock  structure</span>
<span class="cm"> * @skb: skb structure to be appened with user data.</span>
<span class="cm"> * @getfrag: call back function to be used for getting the user data</span>
<span class="cm"> * @from: pointer to user message iov</span>
<span class="cm"> * @length: length of the iov message</span>
<span class="cm"> *</span>
<span class="cm"> * Description: This procedure append the user data in the fragment part</span>
<span class="cm"> * of the skb if any page alloc fails user this procedure returns  -ENOMEM</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">skb_append_datato_frags</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getfrag</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">odd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">),</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">frg_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copy</span><span class="p">,</span> <span class="n">left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Return error if we don&#39;t have space for new frag */</span>
		<span class="n">frg_cnt</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frg_cnt</span> <span class="o">&gt;=</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="cm">/* allocate a new page for next frag */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* If alloc_page fails just return failure and caller will</span>
<span class="cm">		 * free previous allocated pages by doing kfree_skb()</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="cm">/* initialize the next frag */</span>
		<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frg_cnt</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">atomic_add</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">);</span>

		<span class="cm">/* get the new initialized frag */</span>
		<span class="n">frg_cnt</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">frg_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

		<span class="cm">/* copy the user data to page */</span>
		<span class="n">left</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="p">;</span>
		<span class="n">copy</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span><span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">length</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">getfrag</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">skb_frag_address</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span> <span class="o">+</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">),</span>
			    <span class="n">offset</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="cm">/* copy was successful so update the size parameters */</span>
		<span class="n">skb_frag_size_add</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="n">length</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_append_datato_frags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_pull_rcsum - pull skb and update receive checksum</span>
<span class="cm"> *	@skb: buffer to update</span>
<span class="cm"> *	@len: length of data pulled</span>
<span class="cm"> *</span>
<span class="cm"> *	This function performs an skb_pull on the packet and updates</span>
<span class="cm"> *	the CHECKSUM_COMPLETE checksum.  It should be used on</span>
<span class="cm"> *	receive path processing instead of skb_pull unless you know</span>
<span class="cm"> *	that the checksum difference is zero (e.g., a valid IP header)</span>
<span class="cm"> *	or you are setting ip_summed to CHECKSUM_NONE.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">skb_pull_rcsum</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
	<span class="n">skb_postpull_rcsum</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">skb_pull_rcsum</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_segment - Perform protocol segmentation on skb.</span>
<span class="cm"> *	@skb: buffer to segment</span>
<span class="cm"> *	@features: features for the output path (see dev-&gt;features)</span>
<span class="cm"> *</span>
<span class="cm"> *	This function performs segmentation on the given skb.  It returns</span>
<span class="cm"> *	a pointer to the first in a list of new skbs for the segments.</span>
<span class="cm"> *	In case of error it returns ERR_PTR(err).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">skb_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">netdev_features_t</span> <span class="n">features</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">segs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">fskb</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mss</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">doffset</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">doffset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">headroom</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">NETIF_F_SG</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nfrags</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>

	<span class="n">__skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">doffset</span><span class="p">);</span>
	<span class="n">headroom</span> <span class="o">=</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">pos</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span><span class="p">;</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">hsize</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">mss</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">mss</span><span class="p">;</span>

		<span class="n">hsize</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">hsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hsize</span> <span class="o">&gt;</span> <span class="n">len</span> <span class="o">||</span> <span class="o">!</span><span class="n">sg</span><span class="p">)</span>
			<span class="n">hsize</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hsize</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">nfrags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">fskb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">len</span><span class="p">);</span>

			<span class="n">pos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">nskb</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">fskb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="n">fskb</span> <span class="o">=</span> <span class="n">fskb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nskb</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

			<span class="n">hsize</span> <span class="o">=</span> <span class="n">skb_end_offset</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_cow_head</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">doffset</span> <span class="o">+</span> <span class="n">headroom</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">skb_end_offset</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span> <span class="o">-</span> <span class="n">hsize</span><span class="p">;</span>
			<span class="n">skb_release_head_state</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
			<span class="n">__skb_push</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">doffset</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">nskb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">hsize</span> <span class="o">+</span> <span class="n">doffset</span> <span class="o">+</span> <span class="n">headroom</span><span class="p">,</span>
					 <span class="n">GFP_ATOMIC</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nskb</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

			<span class="n">skb_reserve</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">headroom</span><span class="p">);</span>
			<span class="n">__skb_put</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">doffset</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">segs</span><span class="p">)</span>
			<span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">segs</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>
		<span class="n">tail</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>

		<span class="n">__copy_skb_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">mac_len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_len</span><span class="p">;</span>

		<span class="cm">/* nskb and skb might have different headroom */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nskb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">==</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">)</span>
			<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">csum_start</span> <span class="o">+=</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span> <span class="o">-</span> <span class="n">headroom</span><span class="p">;</span>

		<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
		<span class="n">skb_set_network_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_len</span><span class="p">);</span>
		<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">transport_header</span> <span class="o">=</span> <span class="p">(</span><span class="n">nskb</span><span class="o">-&gt;</span><span class="n">network_header</span> <span class="o">+</span>
					  <span class="n">skb_network_header_len</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="n">skb_copy_from_linear_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">doffset</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fskb</span> <span class="o">!=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_NONE</span><span class="p">;</span>
			<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">csum</span> <span class="o">=</span> <span class="n">skb_copy_and_csum_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
							    <span class="n">skb_put</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span>
							    <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">frag</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">;</span>

		<span class="n">skb_copy_from_linear_data_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
						 <span class="n">skb_put</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">hsize</span><span class="p">),</span> <span class="n">hsize</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfrags</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">__skb_frag_ref</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">pos</span><span class="p">;</span>
				<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">pos</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
				<span class="n">pos</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">));</span>
				<span class="k">goto</span> <span class="n">skip_fraglist</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">frag</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">fskb2</span> <span class="o">=</span> <span class="n">fskb</span><span class="p">;</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">fskb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

			<span class="n">pos</span> <span class="o">+=</span> <span class="n">fskb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="n">fskb</span> <span class="o">=</span> <span class="n">fskb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">fskb2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fskb2</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">fskb2</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fskb2</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">skb_get</span><span class="p">(</span><span class="n">fskb2</span><span class="p">);</span>

			<span class="n">SKB_FRAG_ASSERT</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
			<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span> <span class="o">=</span> <span class="n">fskb2</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">skip_fraglist:</span>
		<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">hsize</span><span class="p">;</span>
		<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
		<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">segs</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">segs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">segs</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">skb_segment</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">skb_gro_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">skbinfo</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">skb_shared_info</span> <span class="o">*</span><span class="n">pinfo</span> <span class="o">=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">headroom</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb_gro_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">skb_gro_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">headlen</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">delta_truesize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">65536</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">merge</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">headlen</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag2</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">skbinfo</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nr_frags</span> <span class="o">=</span> <span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">offset</span> <span class="o">-=</span> <span class="n">headlen</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nr_frags</span> <span class="o">&gt;</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>

		<span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">nr_frags</span><span class="p">;</span>
		<span class="n">skbinfo</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">frag</span> <span class="o">=</span> <span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">+</span> <span class="n">nr_frags</span><span class="p">;</span>
		<span class="n">frag2</span> <span class="o">=</span> <span class="n">skbinfo</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="o">*--</span><span class="n">frag</span> <span class="o">=</span> <span class="o">*--</span><span class="n">frag2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span><span class="p">);</span>

		<span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

		<span class="cm">/* all fragments truesize : remove (head size + sk_buff) */</span>
		<span class="n">delta_truesize</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">-</span>
				 <span class="n">SKB_TRUESIZE</span><span class="p">(</span><span class="n">skb_end_offset</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>

		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">-=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">NAPI_GRO_FREE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head_frag</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nr_frags</span> <span class="o">=</span> <span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>
		<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">+</span> <span class="n">nr_frags</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_size</span> <span class="o">=</span> <span class="n">headlen</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">first_offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">skbinfo</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">&gt;</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>

		<span class="n">first_offset</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span>
			       <span class="n">offset</span><span class="p">;</span>

		<span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="n">nr_frags</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">skbinfo</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>

		<span class="n">frag</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">.</span><span class="n">p</span>	  <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span> <span class="o">=</span> <span class="n">first_offset</span><span class="p">;</span>
		<span class="n">skb_frag_size_set</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">first_size</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">frag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">skbinfo</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">frag</span><span class="p">)</span> <span class="o">*</span> <span class="n">skbinfo</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">);</span>
		<span class="cm">/* We dont need to clear skbinfo-&gt;nr_frags here */</span>

		<span class="n">delta_truesize</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">-</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">));</span>
		<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">NAPI_GRO_FREE_STOLEN_HEAD</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skb_gro_len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span>

	<span class="n">headroom</span> <span class="o">=</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">nskb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">headroom</span> <span class="o">+</span> <span class="n">skb_gro_offset</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nskb</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">__copy_skb_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">mac_len</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mac_len</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">headroom</span><span class="p">);</span>
	<span class="n">__skb_put</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">skb_gro_offset</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

	<span class="n">skb_set_mac_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">skb_mac_header</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">skb_set_network_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">skb_network_offset</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="n">skb_set_transport_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="n">skb_transport_offset</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

	<span class="n">__skb_pull</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">skb_gro_offset</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">),</span> <span class="n">skb_mac_header</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
	       <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="n">skb_mac_header</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>

	<span class="o">*</span><span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">nskb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">gso_size</span><span class="p">;</span>
	<span class="n">pinfo</span><span class="o">-&gt;</span><span class="n">gso_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">skb_header_release</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>
	<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>

<span class="nl">merge:</span>
	<span class="n">delta_truesize</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">headlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">eat</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">headlen</span><span class="p">;</span>

		<span class="n">skbinfo</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page_offset</span> <span class="o">+=</span> <span class="n">eat</span><span class="p">;</span>
		<span class="n">skb_frag_size_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skbinfo</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">eat</span><span class="p">);</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">-=</span> <span class="n">eat</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-=</span> <span class="n">eat</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">headlen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">skb_header_release</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">delta_truesize</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">NAPI_GRO_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">same_flow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">skb_gro_receive</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">skb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skbuff_head_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;skbuff_head_cache&quot;</span><span class="p">,</span>
					      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">),</span>
					      <span class="mi">0</span><span class="p">,</span>
					      <span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span>
					      <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">skbuff_fclone_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;skbuff_fclone_cache&quot;</span><span class="p">,</span>
						<span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">))</span> <span class="o">+</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">atomic_t</span><span class="p">),</span>
						<span class="mi">0</span><span class="p">,</span>
						<span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_to_sgvec - Fill a scatter-gather list from a socket buffer</span>
<span class="cm"> *	@skb: Socket buffer containing the buffers to be mapped</span>
<span class="cm"> *	@sg: The scatter-gather list to map into</span>
<span class="cm"> *	@offset: The offset into the buffer&#39;s contents to start mapping</span>
<span class="cm"> *	@len: Length of buffer space to be mapped</span>
<span class="cm"> *</span>
<span class="cm"> *	Fill the specified scatter-gather list with mappings/pointers into a</span>
<span class="cm"> *	region of the buffer space attached to a socket buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__skb_to_sgvec</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">frag_iter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">elt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">sg_set_buf</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
		<span class="n">elt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">elt</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">skb_frag_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_frag_t</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">sg_set_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="n">elt</span><span class="p">],</span> <span class="n">skb_frag_page</span><span class="p">(</span><span class="n">frag</span><span class="p">),</span> <span class="n">copy</span><span class="p">,</span>
					<span class="n">frag</span><span class="o">-&gt;</span><span class="n">page_offset</span><span class="o">+</span><span class="n">offset</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>
			<span class="n">elt</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">elt</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skb_walk_frags</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">frag_iter</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">frag_iter</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">copy</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">elt</span> <span class="o">+=</span> <span class="n">__skb_to_sgvec</span><span class="p">(</span><span class="n">frag_iter</span><span class="p">,</span> <span class="n">sg</span><span class="o">+</span><span class="n">elt</span><span class="p">,</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
					      <span class="n">copy</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">elt</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">elt</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">skb_to_sgvec</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nsg</span> <span class="o">=</span> <span class="n">__skb_to_sgvec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">sg_mark_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="p">[</span><span class="n">nsg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">nsg</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">skb_to_sgvec</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	skb_cow_data - Check that a socket buffer&#39;s data buffers are writable</span>
<span class="cm"> *	@skb: The socket buffer to check.</span>
<span class="cm"> *	@tailbits: Amount of trailing space to be added</span>
<span class="cm"> *	@trailer: Returned pointer to the skb where the @tailbits space begins</span>
<span class="cm"> *</span>
<span class="cm"> *	Make sure that the data buffers attached to a socket buffer are</span>
<span class="cm"> *	writable. If they are not, private copies are made of the data buffers</span>
<span class="cm"> *	and the socket buffer is set to use these instead.</span>
<span class="cm"> *</span>
<span class="cm"> *	If @tailbits is given, make sure that there is space to write @tailbits</span>
<span class="cm"> *	bytes of data beyond current end of socket buffer.  @trailer will be</span>
<span class="cm"> *	set to point to the skb in which this space begins.</span>
<span class="cm"> *</span>
<span class="cm"> *	The number of scatterlist elements required to completely map the</span>
<span class="cm"> *	COW&#39;d and extended socket buffer will be returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">skb_cow_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tailbits</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">trailer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">copyflag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">elt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb1</span><span class="p">,</span> <span class="o">**</span><span class="n">skb_p</span><span class="p">;</span>

	<span class="cm">/* If skb is cloned or its head is paged, reallocate</span>
<span class="cm">	 * head pulling out all the pages (pages are considered not writable</span>
<span class="cm">	 * at the moment even if they are anonymous).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">||</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">__pskb_pull_tail</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb_pagelen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Easy case. Most of packets will go this way. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* A little of trouble, not enough of space for trailer.</span>
<span class="cm">		 * This should not happen, when stack is tuned to generate</span>
<span class="cm">		 * good frames. OK, on miss we reallocate and reserve even more</span>
<span class="cm">		 * space, 128 bytes is fair. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tailbits</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pskb_expand_head</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tailbits</span><span class="o">-</span><span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">+</span><span class="mi">128</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="cm">/* Voila! */</span>
		<span class="o">*</span><span class="n">trailer</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Misery. We are in troubles, going to mincer fragments... */</span>

	<span class="n">elt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">skb_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frag_list</span><span class="p">;</span>
	<span class="n">copyflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb1</span> <span class="o">=</span> <span class="o">*</span><span class="n">skb_p</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ntail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* The fragment is partially pulled by someone,</span>
<span class="cm">		 * this can happen on input. Copy it and everything</span>
<span class="cm">		 * after it. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb_shared</span><span class="p">(</span><span class="n">skb1</span><span class="p">))</span>
			<span class="n">copyflag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* If the skb is the last, worry about trailer. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">tailbits</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">||</span>
			    <span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tailbits</span><span class="p">)</span>
				<span class="n">ntail</span> <span class="o">=</span> <span class="n">tailbits</span> <span class="o">+</span> <span class="mi">128</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copyflag</span> <span class="o">||</span>
		    <span class="n">skb_cloned</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">ntail</span> <span class="o">||</span>
		    <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">||</span>
		    <span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">skb1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb2</span><span class="p">;</span>

			<span class="cm">/* Fuck, we are miserable poor guys... */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ntail</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">skb2</span> <span class="o">=</span> <span class="n">skb_copy</span><span class="p">(</span><span class="n">skb1</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">skb2</span> <span class="o">=</span> <span class="n">skb_copy_expand</span><span class="p">(</span><span class="n">skb1</span><span class="p">,</span>
						       <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb1</span><span class="p">),</span>
						       <span class="n">ntail</span><span class="p">,</span>
						       <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">skb1</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span>
				<span class="n">skb_set_owner_w</span><span class="p">(</span><span class="n">skb2</span><span class="p">,</span> <span class="n">skb1</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

			<span class="cm">/* Looking around. Are we still alive?</span>
<span class="cm">			 * OK, link new skb, drop old one */</span>

			<span class="n">skb2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">skb1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="o">*</span><span class="n">skb_p</span> <span class="o">=</span> <span class="n">skb2</span><span class="p">;</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb1</span><span class="p">);</span>
			<span class="n">skb1</span> <span class="o">=</span> <span class="n">skb2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">elt</span><span class="o">++</span><span class="p">;</span>
		<span class="o">*</span><span class="n">trailer</span> <span class="o">=</span> <span class="n">skb1</span><span class="p">;</span>
		<span class="n">skb_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">skb1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">elt</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">skb_cow_data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_rmem_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note: We dont mem charge error packets (no sk_forward_alloc changes)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sock_queue_err_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">+</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">&gt;=</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">skb_orphan</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">sock_rmem_free</span><span class="p">;</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>

	<span class="cm">/* before exiting rcu section, make sure dst is refcounted */</span>
	<span class="n">skb_dst_force</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_queue_err_skb</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">skb_tstamp_tx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">orig_skb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="o">*</span><span class="n">hwtstamps</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">orig_skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_exterr_skb</span> <span class="o">*</span><span class="n">serr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">orig_skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hwtstamps</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">skb_hwtstamps</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">=</span>
			<span class="o">*</span><span class="n">hwtstamps</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * no hardware time stamps available,</span>
<span class="cm">		 * so keep the shared tx_flags and only</span>
<span class="cm">		 * store software time stamp</span>
<span class="cm">		 */</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span> <span class="o">=</span> <span class="n">ktime_get_real</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">serr</span> <span class="o">=</span> <span class="n">SKB_EXT_ERR</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">serr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">serr</span><span class="p">));</span>
	<span class="n">serr</span><span class="o">-&gt;</span><span class="n">ee</span><span class="p">.</span><span class="n">ee_errno</span> <span class="o">=</span> <span class="n">ENOMSG</span><span class="p">;</span>
	<span class="n">serr</span><span class="o">-&gt;</span><span class="n">ee</span><span class="p">.</span><span class="n">ee_origin</span> <span class="o">=</span> <span class="n">SO_EE_ORIGIN_TIMESTAMPING</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_queue_err_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">skb_tstamp_tx</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">skb_complete_wifi_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">acked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_exterr_skb</span> <span class="o">*</span><span class="n">serr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">wifi_acked_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">wifi_acked</span> <span class="o">=</span> <span class="n">acked</span><span class="p">;</span>

	<span class="n">serr</span> <span class="o">=</span> <span class="n">SKB_EXT_ERR</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">serr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">serr</span><span class="p">));</span>
	<span class="n">serr</span><span class="o">-&gt;</span><span class="n">ee</span><span class="p">.</span><span class="n">ee_errno</span> <span class="o">=</span> <span class="n">ENOMSG</span><span class="p">;</span>
	<span class="n">serr</span><span class="o">-&gt;</span><span class="n">ee</span><span class="p">.</span><span class="n">ee_origin</span> <span class="o">=</span> <span class="n">SO_EE_ORIGIN_TXSTATUS</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_queue_err_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">skb_complete_wifi_ack</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * skb_partial_csum_set - set up and verify partial csum values for packet</span>
<span class="cm"> * @skb: the skb to set</span>
<span class="cm"> * @start: the number of bytes after skb-&gt;data to start checksumming.</span>
<span class="cm"> * @off: the offset from start to place the checksum.</span>
<span class="cm"> *</span>
<span class="cm"> * For untrusted partially-checksummed packets, we need to make sure the values</span>
<span class="cm"> * for skb-&gt;csum_start and skb-&gt;csum_offset are valid so we don&#39;t oops.</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks and sets those values and skb-&gt;ip_summed: if this</span>
<span class="cm"> * returns false you should drop the packet.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">skb_partial_csum_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u16</span> <span class="n">start</span><span class="p">,</span> <span class="n">u16</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">unlikely</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">start</span> <span class="o">+</span> <span class="n">off</span> <span class="o">&gt;</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;bad partial csum: csum=%u/%u len=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">start</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">ip_summed</span> <span class="o">=</span> <span class="n">CHECKSUM_PARTIAL</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_start</span> <span class="o">=</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">csum_offset</span> <span class="o">=</span> <span class="n">off</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">skb_partial_csum_set</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__skb_warn_lro_forwarding</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;%s: received packets cannot be forwarded while LRO is enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__skb_warn_lro_forwarding</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">kfree_skb_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">head_stolen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head_stolen</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">skbuff_head_cache</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kfree_skb_partial</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * skb_try_coalesce - try to merge skb to prior one</span>
<span class="cm"> * @to: prior buffer</span>
<span class="cm"> * @from: buffer to add</span>
<span class="cm"> * @fragstolen: pointer to boolean</span>
<span class="cm"> * @delta_truesize: how much more was allocated than was requested</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">skb_try_coalesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
		      <span class="n">bool</span> <span class="o">*</span><span class="n">fragstolen</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">delta_truesize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="o">*</span><span class="n">fragstolen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">to</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">to</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">skb_copy_bits</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skb_put</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> <span class="n">len</span><span class="p">));</span>
		<span class="o">*</span><span class="n">delta_truesize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">to</span><span class="p">)</span> <span class="o">||</span> <span class="n">skb_has_frag_list</span><span class="p">(</span><span class="n">from</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb_headlen</span><span class="p">(</span><span class="n">from</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">to</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span>
		    <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">&gt;=</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb_head_is_locked</span><span class="p">(</span><span class="n">from</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">delta</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">-</span> <span class="n">SKB_DATA_ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span><span class="p">));</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">skb_fill_page_desc</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">to</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span>
				   <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">skb_headlen</span><span class="p">(</span><span class="n">from</span><span class="p">));</span>
		<span class="o">*</span><span class="n">fragstolen</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">to</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+</span>
		    <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">&gt;</span> <span class="n">MAX_SKB_FRAGS</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

		<span class="n">delta</span> <span class="o">=</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">-</span>
			<span class="n">SKB_TRUESIZE</span><span class="p">(</span><span class="n">skb_end_pointer</span><span class="p">(</span><span class="n">from</span><span class="p">)</span> <span class="o">-</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">to</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">+</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">to</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">,</span>
	       <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">,</span>
	       <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">skb_frag_t</span><span class="p">));</span>
	<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">to</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">+=</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_cloned</span><span class="p">(</span><span class="n">from</span><span class="p">))</span>
		<span class="n">skb_shinfo</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* if the skb is cloned this does nothing since we set nr_frags to 0 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">from</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nr_frags</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">skb_frag_ref</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">to</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">to</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

	<span class="o">*</span><span class="n">delta_truesize</span> <span class="o">=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">skb_try_coalesce</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
