<!DOCTYPE html>
<html><head><title>joekychen/linux » net › core › net_namespace.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>net_namespace.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/rculist.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/netns/generic.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> *	Our network namespace constructor/destructor lists</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">pernet_list</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">first_device</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pernet_list</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">net_mutex</span><span class="p">);</span>

<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">net_namespace_list</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">net_namespace_list</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">net</span> <span class="n">init_net</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">init_net</span><span class="p">);</span>

<span class="cp">#define INITIAL_NET_GEN_PTRS	13 </span><span class="cm">/* +1 for len +2 for rcu_head */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_gen_ptrs</span> <span class="o">=</span> <span class="n">INITIAL_NET_GEN_PTRS</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_generic</span> <span class="o">*</span><span class="nf">net_alloc_generic</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_generic</span> <span class="o">*</span><span class="n">ng</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">generic_size</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_generic</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="n">max_gen_ptrs</span><span class="p">]);</span>

	<span class="n">ng</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">generic_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ng</span><span class="p">)</span>
		<span class="n">ng</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">max_gen_ptrs</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ng</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">net_assign_generic</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_generic</span> <span class="o">*</span><span class="n">ng</span><span class="p">,</span> <span class="o">*</span><span class="n">old_ng</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mutex_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">old_ng</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">,</span>
					   <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">));</span>
	<span class="n">ng</span> <span class="o">=</span> <span class="n">old_ng</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_ng</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">id</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">assign</span><span class="p">;</span>

	<span class="n">ng</span> <span class="o">=</span> <span class="n">net_alloc_generic</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ng</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some synchronisation notes:</span>
<span class="cm">	 *</span>
<span class="cm">	 * The net_generic explores the net-&gt;gen array inside rcu</span>
<span class="cm">	 * read section. Besides once set the net-&gt;gen-&gt;ptr[x]</span>
<span class="cm">	 * pointer never changes (see rules in netns/generic.h).</span>
<span class="cm">	 *</span>
<span class="cm">	 * That said, we simply duplicate this array and schedule</span>
<span class="cm">	 * the old copy for kfree after a grace period.</span>
<span class="cm">	 */</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ng</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_ng</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">old_ng</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">));</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">,</span> <span class="n">ng</span><span class="p">);</span>
	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">old_ng</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
<span class="nl">assign:</span>
	<span class="n">ng</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ops_init</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">net_assign_generic</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">*</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cleanup:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ops_free</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="o">*</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">net_generic</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">id</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ops_exit_list</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">net_exit_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">net_exit_list</span><span class="p">,</span> <span class="n">exit_list</span><span class="p">)</span>
			<span class="n">ops</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">exit_batch</span><span class="p">)</span>
		<span class="n">ops</span><span class="o">-&gt;</span><span class="n">exit_batch</span><span class="p">(</span><span class="n">net_exit_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ops_free_list</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">net_exit_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">net_exit_list</span><span class="p">,</span> <span class="n">exit_list</span><span class="p">)</span>
			<span class="n">ops_free</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * setup_net runs the initializers for the network namespace object.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__net_init</span> <span class="kt">int</span> <span class="nf">setup_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Must be called with net_mutex held */</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">,</span> <span class="o">*</span><span class="n">saved_ops</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">net_exit_list</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">passive</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">net</span><span class="o">-&gt;</span><span class="n">dev_base_seq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef NETNS_REFCNT_DEBUG</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pernet_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ops_init</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_undo</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">out_undo:</span>
	<span class="cm">/* Walk through the list backwards calling the exit functions</span>
<span class="cm">	 * for the pernet modules whose init functions did not fail.</span>
<span class="cm">	 */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">exit_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>
	<span class="n">saved_ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">list_for_each_entry_continue_reverse</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pernet_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">ops_exit_list</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>

	<span class="n">ops</span> <span class="o">=</span> <span class="n">saved_ops</span><span class="p">;</span>
	<span class="n">list_for_each_entry_continue_reverse</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pernet_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">ops_free_list</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>

	<span class="n">rcu_barrier</span><span class="p">();</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_NET_NS</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">net_cachep</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">netns_wq</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">net_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_generic</span> <span class="o">*</span><span class="n">ng</span><span class="p">;</span>

	<span class="n">ng</span> <span class="o">=</span> <span class="n">net_alloc_generic</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ng</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">net</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">net_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">,</span> <span class="n">ng</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">net</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ng</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">net_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef NETNS_REFCNT_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_emerg</span><span class="p">(</span><span class="s">&quot;network namespace not free! Usage: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">use_count</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">gen</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">net_cachep</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">net_drop_ns</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ns</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">passive</span><span class="p">))</span>
		<span class="n">net_free</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">copy_net_ns</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">old_net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLONE_NEWNET</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">get_net</span><span class="p">(</span><span class="n">old_net</span><span class="p">);</span>

	<span class="n">net</span> <span class="o">=</span> <span class="n">net_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>
	<span class="n">rv</span> <span class="o">=</span> <span class="n">setup_net</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtnl_lock</span><span class="p">();</span>
		<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_namespace_list</span><span class="p">);</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">net_drop_ns</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">rv</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">cleanup_list_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">cleanup_list</span><span class="p">);</span>  <span class="cm">/* Must hold cleanup_list_lock to touch */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cleanup_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">net_kill_list</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">net_exit_list</span><span class="p">);</span>

	<span class="cm">/* Atomically snapshot the list of namespaces to cleanup */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cleanup_list_lock</span><span class="p">);</span>
	<span class="n">list_replace_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cleanup_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_kill_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cleanup_list_lock</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t let anyone else find us. */</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_kill_list</span><span class="p">,</span> <span class="n">cleanup_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">exit_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Another CPU might be rcu-iterating the list, wait for it.</span>
<span class="cm">	 * This needs to be before calling the exit() notifiers, so</span>
<span class="cm">	 * the rcu_barrier() below isn&#39;t sufficient alone.</span>
<span class="cm">	 */</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="cm">/* Run all of the network namespace exit methods */</span>
	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pernet_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">ops_exit_list</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>

	<span class="cm">/* Free the net generic variables */</span>
	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pernet_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">ops_free_list</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>

	<span class="cm">/* Ensure there are no outstanding rcu callbacks using this</span>
<span class="cm">	 * network namespace.</span>
<span class="cm">	 */</span>
	<span class="n">rcu_barrier</span><span class="p">();</span>

	<span class="cm">/* Finally it is safe to free my network namespace structure */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">,</span> <span class="n">exit_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">exit_list</span><span class="p">);</span>
		<span class="n">net_drop_ns</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">net_cleanup_work</span><span class="p">,</span> <span class="n">cleanup_net</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__put_net</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Cleanup the network namespace in process context */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cleanup_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">cleanup_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cleanup_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cleanup_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">queue_work</span><span class="p">(</span><span class="n">netns_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_cleanup_work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__put_net</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">get_net_ns_by_fd</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_inode</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">proc_ns_fget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">PROC_I</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">ns_ops</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">netns_operations</span><span class="p">)</span>
		<span class="n">net</span> <span class="o">=</span> <span class="n">get_net</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">net</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">copy_net_ns</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">old_net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CLONE_NEWNET</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">old_net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">get_net_ns_by_fd</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">get_net_ns_by_pid</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="cm">/* Lookup the network namespace */</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ESRCH</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">tsk</span> <span class="o">=</span> <span class="n">find_task_by_vpid</span><span class="p">(</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nsproxy</span> <span class="o">*</span><span class="n">nsproxy</span><span class="p">;</span>
		<span class="n">nsproxy</span> <span class="o">=</span> <span class="n">task_nsproxy</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsproxy</span><span class="p">)</span>
			<span class="n">net</span> <span class="o">=</span> <span class="n">get_net</span><span class="p">(</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">net_ns</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">get_net_ns_by_pid</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">net_ns_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_generic</span> <span class="o">*</span><span class="n">ng</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="n">net_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;net_namespace&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span><span class="p">),</span>
					<span class="n">SMP_CACHE_BYTES</span><span class="p">,</span>
					<span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Create workqueue for cleanup */</span>
	<span class="n">netns_wq</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;netns&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">netns_wq</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Could not create netns workq&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">ng</span> <span class="o">=</span> <span class="n">net_alloc_generic</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ng</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Could not allocate generic netns&quot;</span><span class="p">);</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">init_net</span><span class="p">.</span><span class="n">gen</span><span class="p">,</span> <span class="n">ng</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">setup_net</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Could not setup the initial network namespace&quot;</span><span class="p">);</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_namespace_list</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pure_initcall</span><span class="p">(</span><span class="n">net_ns_init</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_NS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__register_pernet_operations</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">net_exit_list</span><span class="p">);</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">init</span> <span class="o">||</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&amp;&amp;</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">for_each_net</span><span class="p">(</span><span class="n">net</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">ops_init</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">net</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_undo</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">exit_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_undo:</span>
	<span class="cm">/* If I have an error cleanup all namespaces I initialized */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">ops_exit_list</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>
	<span class="n">ops_free_list</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__unregister_pernet_operations</span><span class="p">(</span><span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">net_exit_list</span><span class="p">);</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">for_each_net</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net</span><span class="o">-&gt;</span><span class="n">exit_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>
	<span class="n">ops_exit_list</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>
	<span class="n">ops_free_list</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__register_pernet_operations</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ops_init</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__unregister_pernet_operations</span><span class="p">(</span><span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">net_exit_list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">.</span><span class="n">exit_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>
	<span class="n">ops_exit_list</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>
	<span class="n">ops_free_list</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">net_exit_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_NET_NS */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">DEFINE_IDA</span><span class="p">(</span><span class="n">net_generic_ids</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">register_pernet_operations</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">again:</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">ida_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_generic_ids</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ida_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_generic_ids</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">max_gen_ptrs</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">max_gen_ptrs</span><span class="p">,</span> <span class="o">*</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">__register_pernet_operations</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_barrier</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
			<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_generic_ids</span><span class="p">,</span> <span class="o">*</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unregister_pernet_operations</span><span class="p">(</span><span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	
	<span class="n">__unregister_pernet_operations</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
	<span class="n">rcu_barrier</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
		<span class="n">ida_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_generic_ids</span><span class="p">,</span> <span class="o">*</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      register_pernet_subsys - register a network namespace subsystem</span>
<span class="cm"> *	@ops:  pernet operations structure for the subsystem</span>
<span class="cm"> *</span>
<span class="cm"> *	Register a subsystem which has init and exit functions</span>
<span class="cm"> *	that are called when network namespaces are created and</span>
<span class="cm"> *	destroyed respectively.</span>
<span class="cm"> *</span>
<span class="cm"> *	When registered all network namespace init functions are</span>
<span class="cm"> *	called for every existing network namespace.  Allowing kernel</span>
<span class="cm"> *	modules to have a race free view of the set of network namespaces.</span>
<span class="cm"> *</span>
<span class="cm"> *	When a new network namespace is created all of the init</span>
<span class="cm"> *	methods are called in the order in which they were registered.</span>
<span class="cm"> *</span>
<span class="cm"> *	When a network namespace is destroyed all of the exit methods</span>
<span class="cm"> *	are called in the reverse of the order with which they were</span>
<span class="cm"> *	registered.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">register_pernet_subsys</span><span class="p">(</span><span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span>  <span class="n">register_pernet_operations</span><span class="p">(</span><span class="n">first_device</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_pernet_subsys</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *      unregister_pernet_subsys - unregister a network namespace subsystem</span>
<span class="cm"> *	@ops: pernet operations structure to manipulate</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove the pernet operations structure from the list to be</span>
<span class="cm"> *	used when network namespaces are created or destroyed.  In</span>
<span class="cm"> *	addition run the exit method for all existing network</span>
<span class="cm"> *	namespaces.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unregister_pernet_subsys</span><span class="p">(</span><span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>
	<span class="n">unregister_pernet_operations</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_pernet_subsys</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *      register_pernet_device - register a network namespace device</span>
<span class="cm"> *	@ops:  pernet operations structure for the subsystem</span>
<span class="cm"> *</span>
<span class="cm"> *	Register a device which has init and exit functions</span>
<span class="cm"> *	that are called when network namespaces are created and</span>
<span class="cm"> *	destroyed respectively.</span>
<span class="cm"> *</span>
<span class="cm"> *	When registered all network namespace init functions are</span>
<span class="cm"> *	called for every existing network namespace.  Allowing kernel</span>
<span class="cm"> *	modules to have a race free view of the set of network namespaces.</span>
<span class="cm"> *</span>
<span class="cm"> *	When a new network namespace is created all of the init</span>
<span class="cm"> *	methods are called in the order in which they were registered.</span>
<span class="cm"> *</span>
<span class="cm"> *	When a network namespace is destroyed all of the exit methods</span>
<span class="cm"> *	are called in the reverse of the order with which they were</span>
<span class="cm"> *	registered.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">register_pernet_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">register_pernet_operations</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pernet_list</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">first_device</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">pernet_list</span><span class="p">))</span>
		<span class="n">first_device</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_pernet_device</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *      unregister_pernet_device - unregister a network namespace netdevice</span>
<span class="cm"> *	@ops: pernet operations structure to manipulate</span>
<span class="cm"> *</span>
<span class="cm"> *	Remove the pernet operations structure from the list to be</span>
<span class="cm"> *	used when network namespaces are created or destroyed.  In</span>
<span class="cm"> *	addition run the exit method for all existing network</span>
<span class="cm"> *	namespaces.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">unregister_pernet_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pernet_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">list</span> <span class="o">==</span> <span class="n">first_device</span><span class="p">)</span>
		<span class="n">first_device</span> <span class="o">=</span> <span class="n">first_device</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">unregister_pernet_operations</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_pernet_device</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NET_NS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">netns_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nsproxy</span> <span class="o">*</span><span class="n">nsproxy</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">nsproxy</span> <span class="o">=</span> <span class="n">task_nsproxy</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nsproxy</span><span class="p">)</span>
		<span class="n">net</span> <span class="o">=</span> <span class="n">get_net</span><span class="p">(</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">net_ns</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">netns_put</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_net</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">netns_install</span><span class="p">(</span><span class="k">struct</span> <span class="n">nsproxy</span> <span class="o">*</span><span class="n">nsproxy</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ns</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_net</span><span class="p">(</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">net_ns</span><span class="p">);</span>
	<span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">net_ns</span> <span class="o">=</span> <span class="n">get_net</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">proc_ns_operations</span> <span class="n">netns_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;net&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">type</span>		<span class="o">=</span> <span class="n">CLONE_NEWNET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span>		<span class="o">=</span> <span class="n">netns_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span>		<span class="o">=</span> <span class="n">netns_put</span><span class="p">,</span>
	<span class="p">.</span><span class="n">install</span>	<span class="o">=</span> <span class="n">netns_install</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
