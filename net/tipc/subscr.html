<!DOCTYPE html>
<html><head><title>joekychen/linux » net › tipc › subscr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>subscr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * net/tipc/subscr.c: TIPC network topology service</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2000-2006, Ericsson AB</span>
<span class="cm"> * Copyright (c) 2005-2007, 2010-2011, Wind River Systems</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *    documentation and/or other materials provided with the distribution.</span>
<span class="cm"> * 3. Neither the names of the copyright holders nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived from</span>
<span class="cm"> *    this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="cm"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="cm"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="cm"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="cm"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="cm"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="cm"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="cm"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;core.h&quot;</span>
<span class="cp">#include &quot;name_table.h&quot;</span>
<span class="cp">#include &quot;port.h&quot;</span>
<span class="cp">#include &quot;subscr.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * struct tipc_subscriber - TIPC network topology subscriber</span>
<span class="cm"> * @port_ref: object reference to server port connecting to subscriber</span>
<span class="cm"> * @lock: pointer to spinlock controlling access to subscriber&#39;s server port</span>
<span class="cm"> * @subscriber_list: adjacent subscribers in top. server&#39;s list of subscribers</span>
<span class="cm"> * @subscription_list: list of subscription objects for this subscriber</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tipc_subscriber</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">port_ref</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">subscriber_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">subscription_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct top_srv - TIPC network topology subscription service</span>
<span class="cm"> * @setup_port: reference to TIPC port that handles subscription requests</span>
<span class="cm"> * @subscription_count: number of active subscriptions (not subscribers!)</span>
<span class="cm"> * @subscriber_list: list of ports subscribing to service</span>
<span class="cm"> * @lock: spinlock govering access to subscriber list</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">top_srv</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">setup_port</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">subscription_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">subscriber_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">top_srv</span> <span class="n">topsrv</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * htohl - convert value to endianness used by destination</span>
<span class="cm"> * @in: value to convert</span>
<span class="cm"> * @swap: non-zero if endianness must be reversed</span>
<span class="cm"> *</span>
<span class="cm"> * Returns converted value</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">htohl</span><span class="p">(</span><span class="n">u32</span> <span class="n">in</span><span class="p">,</span> <span class="kt">int</span> <span class="n">swap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">swap</span> <span class="o">?</span> <span class="n">swab32</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="o">:</span> <span class="n">in</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * subscr_send_event - send a message containing a tipc_event to the subscriber</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Must not hold subscriber&#39;s server port lock, since tipc_send() will</span>
<span class="cm"> *       try to take the lock if the message is rejected and returned!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">subscr_send_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">found_lower</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">found_upper</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">event</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">port_ref</span><span class="p">,</span>
			      <span class="n">u32</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">msg_sect</span><span class="p">;</span>

	<span class="n">msg_sect</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">evt</span><span class="p">;</span>
	<span class="n">msg_sect</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_event</span><span class="p">);</span>

	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">evt</span><span class="p">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">htohl</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">swap</span><span class="p">);</span>
	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">evt</span><span class="p">.</span><span class="n">found_lower</span> <span class="o">=</span> <span class="n">htohl</span><span class="p">(</span><span class="n">found_lower</span><span class="p">,</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">swap</span><span class="p">);</span>
	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">evt</span><span class="p">.</span><span class="n">found_upper</span> <span class="o">=</span> <span class="n">htohl</span><span class="p">(</span><span class="n">found_upper</span><span class="p">,</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">swap</span><span class="p">);</span>
	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">evt</span><span class="p">.</span><span class="n">port</span><span class="p">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">htohl</span><span class="p">(</span><span class="n">port_ref</span><span class="p">,</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">swap</span><span class="p">);</span>
	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">evt</span><span class="p">.</span><span class="n">port</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">htohl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">swap</span><span class="p">);</span>
	<span class="n">tipc_send</span><span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">server_ref</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_sect</span><span class="p">,</span> <span class="n">msg_sect</span><span class="p">.</span><span class="n">iov_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_subscr_overlap - test for subscription overlap with the given values</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if there is overlap, otherwise 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tipc_subscr_overlap</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">found_lower</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">found_upper</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_lower</span> <span class="o">&lt;</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">lower</span><span class="p">)</span>
		<span class="n">found_lower</span> <span class="o">=</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">lower</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_upper</span> <span class="o">&gt;</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">upper</span><span class="p">)</span>
		<span class="n">found_upper</span> <span class="o">=</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">upper</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_lower</span> <span class="o">&gt;</span> <span class="n">found_upper</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_subscr_report_overlap - issue event if there is subscription overlap</span>
<span class="cm"> *</span>
<span class="cm"> * Protected by nameseq.lock in name_table.c</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_subscr_report_overlap</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">found_lower</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">found_upper</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">event</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">port_ref</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">node</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">must</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tipc_subscr_overlap</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">found_lower</span><span class="p">,</span> <span class="n">found_upper</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">must</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="n">TIPC_SUB_PORTS</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">subscr_send_event</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">found_lower</span><span class="p">,</span> <span class="n">found_upper</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">port_ref</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * subscr_timeout - subscription timeout has occurred</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">subscr_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">server_port</span><span class="p">;</span>

	<span class="cm">/* Validate server port reference (in case subscriber is terminating) */</span>
	<span class="n">server_port</span> <span class="o">=</span> <span class="n">tipc_port_lock</span><span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">server_ref</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">server_port</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Validate timeout (in case subscription is being cancelled) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">==</span> <span class="n">TIPC_WAIT_FOREVER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tipc_port_unlock</span><span class="p">(</span><span class="n">server_port</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Unlink subscription from name table */</span>
	<span class="n">tipc_nametbl_unsubscribe</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>

	<span class="cm">/* Unlink subscription from subscriber */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">subscription_list</span><span class="p">);</span>

	<span class="cm">/* Release subscriber&#39;s server port */</span>
	<span class="n">tipc_port_unlock</span><span class="p">(</span><span class="n">server_port</span><span class="p">);</span>

	<span class="cm">/* Notify subscriber of timeout */</span>
	<span class="n">subscr_send_event</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">evt</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">seq</span><span class="p">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">evt</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">seq</span><span class="p">.</span><span class="n">upper</span><span class="p">,</span>
			  <span class="n">TIPC_SUBSCR_TIMEOUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Now destroy subscription */</span>
	<span class="n">k_term_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">subscription_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * subscr_del - delete a subscription within a subscription list</span>
<span class="cm"> *</span>
<span class="cm"> * Called with subscriber port locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">subscr_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">tipc_nametbl_unsubscribe</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">subscription_list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">subscription_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * subscr_terminate - terminate communication with a subscriber</span>
<span class="cm"> *</span>
<span class="cm"> * Called with subscriber port locked.  Routine must temporarily release lock</span>
<span class="cm"> * to enable subscription timeout routine(s) to finish without deadlocking;</span>
<span class="cm"> * the lock is then reclaimed to allow caller to release it upon return.</span>
<span class="cm"> * (This should work even in the unlikely event some other thread creates</span>
<span class="cm"> * a new object reference in the interim that uses this lock; this routine will</span>
<span class="cm"> * simply wait for it to be released, then claim it.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">subscr_terminate</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscriber</span> <span class="o">*</span><span class="n">subscriber</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">port_ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">sub_temp</span><span class="p">;</span>

	<span class="cm">/* Invalidate subscriber reference */</span>
	<span class="n">port_ref</span> <span class="o">=</span> <span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">port_ref</span><span class="p">;</span>
	<span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">port_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Sever connection to subscriber */</span>
	<span class="n">tipc_shutdown</span><span class="p">(</span><span class="n">port_ref</span><span class="p">);</span>
	<span class="n">tipc_deleteport</span><span class="p">(</span><span class="n">port_ref</span><span class="p">);</span>

	<span class="cm">/* Destroy any existing subscriptions for subscriber */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">sub_temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">subscription_list</span><span class="p">,</span>
				 <span class="n">subscription_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">!=</span> <span class="n">TIPC_WAIT_FOREVER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">k_cancel_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
			<span class="n">k_term_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">subscr_del</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Remove subscriber from topology server&#39;s subscriber list */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">subscriber_list</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Reclaim subscriber lock */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Now destroy subscriber */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * subscr_cancel - handle subscription cancellation request</span>
<span class="cm"> *</span>
<span class="cm"> * Called with subscriber port locked.  Routine must temporarily release lock</span>
<span class="cm"> * to enable the subscription timeout routine to finish without deadlocking;</span>
<span class="cm"> * the lock is then reclaimed to allow caller to release it upon return.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that fields of &#39;s&#39; use subscriber&#39;s endianness!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">subscr_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscr</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">tipc_subscriber</span> <span class="o">*</span><span class="n">subscriber</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">sub_temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Find first matching subscription, exit if not found */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">sub_temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">subscription_list</span><span class="p">,</span>
				 <span class="n">subscription_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">evt</span><span class="p">.</span><span class="n">s</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscr</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Cancel subscription timer (if used), then delete subscription */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">!=</span> <span class="n">TIPC_WAIT_FOREVER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sub</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">TIPC_WAIT_FOREVER</span><span class="p">;</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">k_cancel_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">k_term_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">);</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">subscr_del</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * subscr_subscribe - create subscription for subscriber</span>
<span class="cm"> *</span>
<span class="cm"> * Called with subscriber port locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="nf">subscr_subscribe</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscr</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">tipc_subscriber</span> <span class="o">*</span><span class="n">subscriber</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">swap</span><span class="p">;</span>

	<span class="cm">/* Determine subscriber&#39;s endianness */</span>
	<span class="n">swap</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">TIPC_SUB_PORTS</span> <span class="o">|</span> <span class="n">TIPC_SUB_SERVICE</span><span class="p">));</span>

	<span class="cm">/* Detect &amp; process a subscription cancellation request */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="n">htohl</span><span class="p">(</span><span class="n">TIPC_SUB_CANCEL</span><span class="p">,</span> <span class="n">swap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">htohl</span><span class="p">(</span><span class="n">TIPC_SUB_CANCEL</span><span class="p">,</span> <span class="n">swap</span><span class="p">);</span>
		<span class="n">subscr_cancel</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">subscriber</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Refuse subscription if global limit exceeded */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">subscription_count</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tipc_max_subscriptions</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Subscription rejected, subscription limit reached (%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">tipc_max_subscriptions</span><span class="p">);</span>
		<span class="n">subscr_terminate</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate subscription object */</span>
	<span class="n">sub</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sub</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sub</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Subscription rejected, no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">subscr_terminate</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize subscription object */</span>
	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">htohl</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">swap</span><span class="p">);</span>
	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">htohl</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">swap</span><span class="p">);</span>
	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">htohl</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">swap</span><span class="p">);</span>
	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">htohl</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span> <span class="n">swap</span><span class="p">);</span>
	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="n">htohl</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">,</span> <span class="n">swap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="n">TIPC_SUB_PORTS</span><span class="p">)</span> <span class="o">==</span>
	     <span class="o">!</span><span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">&amp;</span> <span class="n">TIPC_SUB_SERVICE</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">lower</span> <span class="o">&gt;</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">upper</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Subscription rejected, illegal request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>
		<span class="n">subscr_terminate</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">nameseq_list</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">subscription_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">subscription_list</span><span class="p">);</span>
	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">server_ref</span> <span class="o">=</span> <span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">port_ref</span><span class="p">;</span>
	<span class="n">sub</span><span class="o">-&gt;</span><span class="n">swap</span> <span class="o">=</span> <span class="n">swap</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">evt</span><span class="p">.</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscr</span><span class="p">));</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">subscription_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">!=</span> <span class="n">TIPC_WAIT_FOREVER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">k_init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">Handler</span><span class="p">)</span><span class="n">subscr_timeout</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sub</span><span class="p">);</span>
		<span class="n">k_start_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">timer</span><span class="p">,</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sub</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * subscr_conn_shutdown_event - handle termination request from subscriber</span>
<span class="cm"> *</span>
<span class="cm"> * Called with subscriber&#39;s server port unlocked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">subscr_conn_shutdown_event</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">usr_handle</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">port_ref</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">buf</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_subscriber</span> <span class="o">*</span><span class="n">subscriber</span> <span class="o">=</span> <span class="n">usr_handle</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">subscriber_lock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tipc_port_lock</span><span class="p">(</span><span class="n">port_ref</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">subscriber_lock</span> <span class="o">=</span> <span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">subscr_terminate</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">subscriber_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * subscr_conn_msg_event - handle new subscription request from subscriber</span>
<span class="cm"> *</span>
<span class="cm"> * Called with subscriber&#39;s server port unlocked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">subscr_conn_msg_event</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">usr_handle</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">port_ref</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">buf</span><span class="p">,</span>
				  <span class="k">const</span> <span class="n">unchar</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_subscriber</span> <span class="o">*</span><span class="n">subscriber</span> <span class="o">=</span> <span class="n">usr_handle</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">subscriber_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">sub</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Lock subscriber&#39;s server port (&amp; make a local copy of lock pointer,</span>
<span class="cm">	 * in case subscriber is deleted while processing subscription request)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tipc_port_lock</span><span class="p">(</span><span class="n">port_ref</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">subscriber_lock</span> <span class="o">=</span> <span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">subscr_terminate</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">subscriber_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sub</span> <span class="o">=</span> <span class="n">subscr_subscribe</span><span class="p">((</span><span class="k">struct</span> <span class="n">tipc_subscr</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span> <span class="n">subscriber</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">subscriber_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sub</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * We must release the server port lock before adding a</span>
<span class="cm">			 * subscription to the name table since TIPC needs to be</span>
<span class="cm">			 * able to (re)acquire the port lock if an event message</span>
<span class="cm">			 * issued by the subscription process is rejected and</span>
<span class="cm">			 * returned.  The subscription cannot be deleted while</span>
<span class="cm">			 * it is being added to the name table because:</span>
<span class="cm">			 * a) the single-threading of the native API port code</span>
<span class="cm">			 *    ensures the subscription cannot be cancelled and</span>
<span class="cm">			 *    the subscriber connection cannot be broken, and</span>
<span class="cm">			 * b) the name table lock ensures the subscription</span>
<span class="cm">			 *    timeout code cannot delete the subscription,</span>
<span class="cm">			 * so the subscription object is still protected.</span>
<span class="cm">			 */</span>
			<span class="n">tipc_nametbl_subscribe</span><span class="p">(</span><span class="n">sub</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * subscr_named_msg_event - handle request to establish a new subscriber</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">subscr_named_msg_event</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">usr_handle</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">port_ref</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">buf</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">unchar</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">size</span><span class="p">,</span>
				   <span class="n">u32</span> <span class="n">importance</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">tipc_portid</span> <span class="k">const</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">tipc_name_seq</span> <span class="k">const</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_subscriber</span> <span class="o">*</span><span class="n">subscriber</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">server_port_ref</span><span class="p">;</span>

	<span class="cm">/* Create subscriber object */</span>
	<span class="n">subscriber</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscriber</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">subscriber</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Subscriber rejected, no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">subscription_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">subscriber_list</span><span class="p">);</span>

	<span class="cm">/* Create server port &amp; establish connection to subscriber */</span>
	<span class="n">tipc_createport</span><span class="p">(</span><span class="n">subscriber</span><span class="p">,</span>
			<span class="n">importance</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="n">subscr_conn_shutdown_event</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="n">subscr_conn_msg_event</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">port_ref</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">port_ref</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Subscriber rejected, unable to create port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tipc_connect2port</span><span class="p">(</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">port_ref</span><span class="p">,</span> <span class="n">orig</span><span class="p">);</span>

	<span class="cm">/* Lock server port (&amp; save lock address for future use) */</span>
	<span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="n">tipc_port_lock</span><span class="p">(</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">port_ref</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>

	<span class="cm">/* Add subscriber to topology server&#39;s subscriber list */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">subscriber_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">subscriber_list</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Unlock server port */</span>
	<span class="n">server_port_ref</span> <span class="o">=</span> <span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">port_ref</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* Send an ACK- to complete connection handshaking */</span>
	<span class="n">tipc_send</span><span class="p">(</span><span class="n">server_port_ref</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Handle optional subscription request */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">subscr_conn_msg_event</span><span class="p">(</span><span class="n">subscriber</span><span class="p">,</span> <span class="n">server_port_ref</span><span class="p">,</span>
				      <span class="n">buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tipc_subscr_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_name_seq</span> <span class="n">seq</span> <span class="o">=</span> <span class="p">{</span><span class="n">TIPC_TOP_SRV</span><span class="p">,</span> <span class="n">TIPC_TOP_SRV</span><span class="p">,</span> <span class="n">TIPC_TOP_SRV</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">subscriber_list</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_createport</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
			      <span class="n">TIPC_CRITICAL_IMPORTANCE</span><span class="p">,</span>
			      <span class="nb">NULL</span><span class="p">,</span>
			      <span class="nb">NULL</span><span class="p">,</span>
			      <span class="nb">NULL</span><span class="p">,</span>
			      <span class="nb">NULL</span><span class="p">,</span>
			      <span class="n">subscr_named_msg_event</span><span class="p">,</span>
			      <span class="nb">NULL</span><span class="p">,</span>
			      <span class="nb">NULL</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">setup_port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_publish</span><span class="p">(</span><span class="n">topsrv</span><span class="p">.</span><span class="n">setup_port</span><span class="p">,</span> <span class="n">TIPC_NODE_SCOPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tipc_deleteport</span><span class="p">(</span><span class="n">topsrv</span><span class="p">.</span><span class="n">setup_port</span><span class="p">);</span>
		<span class="n">topsrv</span><span class="p">.</span><span class="n">setup_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">failed:</span>
	<span class="n">err</span><span class="p">(</span><span class="s">&quot;Failed to create subscription service</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tipc_subscr_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_subscriber</span> <span class="o">*</span><span class="n">subscriber</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_subscriber</span> <span class="o">*</span><span class="n">subscriber_temp</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">subscriber_lock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">topsrv</span><span class="p">.</span><span class="n">setup_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tipc_deleteport</span><span class="p">(</span><span class="n">topsrv</span><span class="p">.</span><span class="n">setup_port</span><span class="p">);</span>
		<span class="n">topsrv</span><span class="p">.</span><span class="n">setup_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">subscriber</span><span class="p">,</span> <span class="n">subscriber_temp</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">topsrv</span><span class="p">.</span><span class="n">subscriber_list</span><span class="p">,</span>
					 <span class="n">subscriber_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">subscriber_lock</span> <span class="o">=</span> <span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="n">subscriber_lock</span><span class="p">);</span>
			<span class="n">subscr_terminate</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">subscriber_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
