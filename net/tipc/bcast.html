<!DOCTYPE html>
<html><head><title>joekychen/linux » net › tipc › bcast.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>bcast.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * net/tipc/bcast.c: TIPC broadcast code</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2004-2006, Ericsson AB</span>
<span class="cm"> * Copyright (c) 2004, Intel Corporation.</span>
<span class="cm"> * Copyright (c) 2005, 2010-2011, Wind River Systems</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *    documentation and/or other materials provided with the distribution.</span>
<span class="cm"> * 3. Neither the names of the copyright holders nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived from</span>
<span class="cm"> *    this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="cm"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="cm"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="cm"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="cm"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="cm"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="cm"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="cm"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;core.h&quot;</span>
<span class="cp">#include &quot;link.h&quot;</span>
<span class="cp">#include &quot;port.h&quot;</span>
<span class="cp">#include &quot;bcast.h&quot;</span>
<span class="cp">#include &quot;name_distr.h&quot;</span>

<span class="cp">#define MAX_PKT_DEFAULT_MCAST 1500	</span><span class="cm">/* bcast link max packet size (fixed) */</span><span class="cp"></span>

<span class="cp">#define BCLINK_WIN_DEFAULT 20		</span><span class="cm">/* bcast link window size (default) */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * struct tipc_bcbearer_pair - a pair of bearers used by broadcast link</span>
<span class="cm"> * @primary: pointer to primary bearer</span>
<span class="cm"> * @secondary: pointer to secondary bearer</span>
<span class="cm"> *</span>
<span class="cm"> * Bearers must have same priority and same set of reachable destinations</span>
<span class="cm"> * to be paired.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">tipc_bcbearer_pair</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_bearer</span> <span class="o">*</span><span class="n">primary</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_bearer</span> <span class="o">*</span><span class="n">secondary</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct tipc_bcbearer - bearer used by broadcast link</span>
<span class="cm"> * @bearer: (non-standard) broadcast bearer structure</span>
<span class="cm"> * @media: (non-standard) broadcast media structure</span>
<span class="cm"> * @bpairs: array of bearer pairs</span>
<span class="cm"> * @bpairs_temp: temporary array of bearer pairs used by tipc_bcbearer_sort()</span>
<span class="cm"> * @remains: temporary node map used by tipc_bcbearer_send()</span>
<span class="cm"> * @remains_new: temporary node map used tipc_bcbearer_send()</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The fields labelled &quot;temporary&quot; are incorporated into the bearer</span>
<span class="cm"> * to avoid consuming potentially limited stack space through the use of</span>
<span class="cm"> * large local variables within multicast routines.  Concurrent access is</span>
<span class="cm"> * prevented through use of the spinlock &quot;bc_lock&quot;.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tipc_bcbearer</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_bearer</span> <span class="n">bearer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_media</span> <span class="n">media</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_bcbearer_pair</span> <span class="n">bpairs</span><span class="p">[</span><span class="n">MAX_BEARERS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tipc_bcbearer_pair</span> <span class="n">bpairs_temp</span><span class="p">[</span><span class="n">TIPC_MAX_LINK_PRI</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tipc_node_map</span> <span class="n">remains</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_node_map</span> <span class="n">remains_new</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct tipc_bclink - link used for broadcast messages</span>
<span class="cm"> * @link: (non-standard) broadcast link structure</span>
<span class="cm"> * @node: (non-standard) node structure representing b&#39;cast link&#39;s peer node</span>
<span class="cm"> * @bcast_nodes: map of broadcast-capable nodes</span>
<span class="cm"> * @retransmit_to: node that most recently requested a retransmit</span>
<span class="cm"> *</span>
<span class="cm"> * Handles sequence numbering, fragmentation, bundling, etc.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tipc_bclink</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_link</span> <span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_node</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_node_map</span> <span class="n">bcast_nodes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_node</span> <span class="o">*</span><span class="n">retransmit_to</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tipc_bcbearer</span> <span class="n">bcast_bearer</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tipc_bclink</span> <span class="n">bcast_link</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tipc_bcbearer</span> <span class="o">*</span><span class="n">bcbearer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcast_bearer</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tipc_bclink</span> <span class="o">*</span><span class="n">bclink</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcast_link</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tipc_link</span> <span class="o">*</span><span class="n">bcl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcast_link</span><span class="p">.</span><span class="n">link</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">bc_lock</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">char</span> <span class="n">tipc_bclink_name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;broadcast-link&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">tipc_nmap_diff</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_node_map</span> <span class="o">*</span><span class="n">nm_a</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">tipc_node_map</span> <span class="o">*</span><span class="n">nm_b</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">tipc_node_map</span> <span class="o">*</span><span class="n">nm_diff</span><span class="p">);</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">bcbuf_acks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">TIPC_SKB_CB</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcbuf_set_acks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">acks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">TIPC_SKB_CB</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">acks</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bcbuf_decr_acks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bcbuf_set_acks</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bcbuf_acks</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tipc_bclink_add_node</span><span class="p">(</span><span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
	<span class="n">tipc_nmap_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bclink</span><span class="o">-&gt;</span><span class="n">bcast_nodes</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tipc_bclink_remove_node</span><span class="p">(</span><span class="n">u32</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
	<span class="n">tipc_nmap_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bclink</span><span class="o">-&gt;</span><span class="n">bcast_nodes</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bclink_set_last_sent</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bcl</span><span class="o">-&gt;</span><span class="n">next_out</span><span class="p">)</span>
		<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">fsm_msg_cnt</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">buf_seqno</span><span class="p">(</span><span class="n">bcl</span><span class="o">-&gt;</span><span class="n">next_out</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">fsm_msg_cnt</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">bcl</span><span class="o">-&gt;</span><span class="n">next_out_no</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u32</span> <span class="nf">tipc_bclink_get_last_sent</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">fsm_msg_cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bclink_update_last_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seqno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_sent</span> <span class="o">=</span> <span class="n">less_eq</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_sent</span><span class="p">,</span> <span class="n">seqno</span><span class="p">)</span> <span class="o">?</span>
						<span class="n">seqno</span> <span class="o">:</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_sent</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * tipc_bclink_retransmit_to - get most recent node to request retransmission</span>
<span class="cm"> *</span>
<span class="cm"> * Called with bc_lock locked</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tipc_node</span> <span class="o">*</span><span class="nf">tipc_bclink_retransmit_to</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bclink</span><span class="o">-&gt;</span><span class="n">retransmit_to</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bclink_retransmit_pkt - retransmit broadcast packets</span>
<span class="cm"> * @after: sequence number of last packet to *not* retransmit</span>
<span class="cm"> * @to: sequence number of last packet to retransmit</span>
<span class="cm"> *</span>
<span class="cm"> * Called with bc_lock locked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bclink_retransmit_pkt</span><span class="p">(</span><span class="n">u32</span> <span class="n">after</span><span class="p">,</span> <span class="n">u32</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">first_out</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">buf</span> <span class="o">&amp;&amp;</span> <span class="n">less_eq</span><span class="p">(</span><span class="n">buf_seqno</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">after</span><span class="p">))</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">tipc_link_retransmit</span><span class="p">(</span><span class="n">bcl</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">mod</span><span class="p">(</span><span class="n">to</span> <span class="o">-</span> <span class="n">after</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_bclink_acknowledge - handle acknowledgement of broadcast packets</span>
<span class="cm"> * @n_ptr: node that sent acknowledgement info</span>
<span class="cm"> * @acked: broadcast sequence # that has been acknowledged</span>
<span class="cm"> *</span>
<span class="cm"> * Node is locked, bc_lock unlocked.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_bclink_acknowledge</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_node</span> <span class="o">*</span><span class="n">n_ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">acked</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">crs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">released</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>

	<span class="cm">/* Bail out if tx queue is empty (no clean up is required) */</span>
	<span class="n">crs</span> <span class="o">=</span> <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">first_out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">crs</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="cm">/* Determine which messages need to be acknowledged */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">acked</span> <span class="o">==</span> <span class="n">INVALID_LINK_SEQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Contact with specified node has been lost, so need to</span>
<span class="cm">		 * acknowledge sent messages only (if other nodes still exist)</span>
<span class="cm">		 * or both sent and unsent messages (otherwise)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bclink</span><span class="o">-&gt;</span><span class="n">bcast_nodes</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
			<span class="n">acked</span> <span class="o">=</span> <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">fsm_msg_cnt</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">acked</span> <span class="o">=</span> <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">next_out_no</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Bail out if specified sequence number does not correspond</span>
<span class="cm">		 * to a message that has been sent and not yet acknowledged</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">less</span><span class="p">(</span><span class="n">acked</span><span class="p">,</span> <span class="n">buf_seqno</span><span class="p">(</span><span class="n">crs</span><span class="p">))</span> <span class="o">||</span>
		    <span class="n">less</span><span class="p">(</span><span class="n">bcl</span><span class="o">-&gt;</span><span class="n">fsm_msg_cnt</span><span class="p">,</span> <span class="n">acked</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">less_eq</span><span class="p">(</span><span class="n">acked</span><span class="p">,</span> <span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">acked</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Skip over packets that node has previously acknowledged */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">crs</span> <span class="o">&amp;&amp;</span> <span class="n">less_eq</span><span class="p">(</span><span class="n">buf_seqno</span><span class="p">(</span><span class="n">crs</span><span class="p">),</span> <span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">acked</span><span class="p">))</span>
		<span class="n">crs</span> <span class="o">=</span> <span class="n">crs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* Update packets that node is now acknowledging */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">crs</span> <span class="o">&amp;&amp;</span> <span class="n">less_eq</span><span class="p">(</span><span class="n">buf_seqno</span><span class="p">(</span><span class="n">crs</span><span class="p">),</span> <span class="n">acked</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">crs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">next_out</span><span class="p">)</span>
			<span class="n">bcbuf_decr_acks</span><span class="p">(</span><span class="n">crs</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">bcbuf_set_acks</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">next_out</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="n">bclink_set_last_sent</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bcbuf_acks</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">first_out</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">out_queue_size</span><span class="o">--</span><span class="p">;</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">crs</span><span class="p">);</span>
			<span class="n">released</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">crs</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">acked</span> <span class="o">=</span> <span class="n">acked</span><span class="p">;</span>

	<span class="cm">/* Try resolving broadcast link congestion, if necessary */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bcl</span><span class="o">-&gt;</span><span class="n">next_out</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tipc_link_push_queue</span><span class="p">(</span><span class="n">bcl</span><span class="p">);</span>
		<span class="n">bclink_set_last_sent</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">released</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcl</span><span class="o">-&gt;</span><span class="n">waiting_ports</span><span class="p">)))</span>
		<span class="n">tipc_link_wakeup_ports</span><span class="p">(</span><span class="n">bcl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * tipc_bclink_update_link_state - update broadcast link state</span>
<span class="cm"> *</span>
<span class="cm"> * tipc_net_lock and node lock set</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_bclink_update_link_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_node</span> <span class="o">*</span><span class="n">n_ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">last_sent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* Ignore &quot;stale&quot; link state info */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">less_eq</span><span class="p">(</span><span class="n">last_sent</span><span class="p">,</span> <span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_in</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Update link synchronization state; quit if in sync */</span>

	<span class="n">bclink_update_last_sent</span><span class="p">(</span><span class="n">n_ptr</span><span class="p">,</span> <span class="n">last_sent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_sent</span> <span class="o">==</span> <span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_in</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Update out-of-sync state; quit if loss is still unconfirmed */</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">++</span><span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">oos_state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">deferred_size</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">TIPC_MIN_LINK_WIN</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">oos_state</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Don&#39;t NACK if one has been recently sent (or seen) */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">oos_state</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Send NACK */</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">tipc_buf_acquire</span><span class="p">(</span><span class="n">INT_H_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">buf_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

		<span class="n">tipc_msg_init</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">BCAST_PROTOCOL</span><span class="p">,</span> <span class="n">STATE_MSG</span><span class="p">,</span>
			      <span class="n">INT_H_SIZE</span><span class="p">,</span> <span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">msg_set_non_seq</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">msg_set_mc_netid</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">tipc_net_id</span><span class="p">);</span>
		<span class="n">msg_set_bcast_ack</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_in</span><span class="p">);</span>
		<span class="n">msg_set_bcgap_after</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_in</span><span class="p">);</span>
		<span class="n">msg_set_bcgap_to</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">deferred_head</span>
				 <span class="o">?</span> <span class="n">buf_seqno</span><span class="p">(</span><span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">deferred_head</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
				 <span class="o">:</span> <span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_sent</span><span class="p">);</span>

		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
		<span class="n">tipc_bearer_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bearer</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sent_nacks</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

		<span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">oos_state</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bclink_peek_nack - monitor retransmission requests sent by other nodes</span>
<span class="cm"> *</span>
<span class="cm"> * Delay any upcoming NACK by this node if another node has already</span>
<span class="cm"> * requested the first message this node is going to ask for.</span>
<span class="cm"> *</span>
<span class="cm"> * Only tipc_net_lock set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bclink_peek_nack</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_node</span> <span class="o">*</span><span class="n">n_ptr</span> <span class="o">=</span> <span class="n">tipc_node_find</span><span class="p">(</span><span class="n">msg_destnode</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">n_ptr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tipc_node_lock</span><span class="p">(</span><span class="n">n_ptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">supported</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_in</span> <span class="o">!=</span> <span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_sent</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_in</span> <span class="o">==</span> <span class="n">msg_bcgap_after</span><span class="p">(</span><span class="n">msg</span><span class="p">)))</span>
		<span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">oos_state</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">tipc_node_unlock</span><span class="p">(</span><span class="n">n_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * tipc_bclink_send_msg - broadcast a packet to all nodes in cluster</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tipc_bclink_send_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bclink</span><span class="o">-&gt;</span><span class="n">bcast_nodes</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">msg_data_sz</span><span class="p">(</span><span class="n">buf_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_link_send_buf</span><span class="p">(</span><span class="n">bcl</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">res</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bclink_set_last_sent</span><span class="p">();</span>
		<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">queue_sz_counts</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">accu_queue_sz</span> <span class="o">+=</span> <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">out_queue_size</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bclink_accept_pkt - accept an incoming, in-sequence broadcast packet</span>
<span class="cm"> *</span>
<span class="cm"> * Called with both sending node&#39;s lock and bc_lock taken.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bclink_accept_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="n">u32</span> <span class="n">seqno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bclink_update_last_sent</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_in</span> <span class="o">=</span> <span class="n">seqno</span><span class="p">;</span>
	<span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">oos_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_info</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unicast an ACK periodically, ensuring that</span>
<span class="cm">	 * all nodes in the cluster don&#39;t ACK at the same time</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">seqno</span> <span class="o">-</span> <span class="n">tipc_own_addr</span><span class="p">)</span> <span class="o">%</span> <span class="n">TIPC_MIN_LINK_WIN</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tipc_link_send_proto_msg</span><span class="p">(</span>
			<span class="n">node</span><span class="o">-&gt;</span><span class="n">active_links</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">],</span>
			<span class="n">STATE_MSG</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sent_acks</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * tipc_bclink_recv_pkt - receive a broadcast packet, and deliver upwards</span>
<span class="cm"> *</span>
<span class="cm"> * tipc_net_lock is read_locked, no other locks set</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_bclink_recv_pkt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">buf_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tipc_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">next_in</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">seqno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">deferred</span><span class="p">;</span>

	<span class="cm">/* Screen out unwanted broadcast messages */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg_mc_netid</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">!=</span> <span class="n">tipc_net_id</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">tipc_node_find</span><span class="p">(</span><span class="n">msg_prevnode</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">tipc_node_lock</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">supported</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="cm">/* Handle broadcast protocol message */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">msg_user</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">==</span> <span class="n">BCAST_PROTOCOL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_type</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">!=</span> <span class="n">STATE_MSG</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_destnode</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">==</span> <span class="n">tipc_own_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tipc_bclink_acknowledge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">msg_bcast_ack</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
			<span class="n">tipc_node_unlock</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
			<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_nacks</span><span class="o">++</span><span class="p">;</span>
			<span class="n">bclink</span><span class="o">-&gt;</span><span class="n">retransmit_to</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
			<span class="n">bclink_retransmit_pkt</span><span class="p">(</span><span class="n">msg_bcgap_after</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span>
					      <span class="n">msg_bcgap_to</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tipc_node_unlock</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="n">bclink_peek_nack</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Handle in-sequence broadcast message */</span>

	<span class="n">seqno</span> <span class="o">=</span> <span class="n">msg_seqno</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">next_in</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">seqno</span> <span class="o">==</span> <span class="n">next_in</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">receive:</span>
		<span class="cm">/* Deliver message to destination */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">msg_isdata</span><span class="p">(</span><span class="n">msg</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
			<span class="n">bclink_accept_pkt</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
			<span class="n">tipc_node_unlock</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">msg_mcast</span><span class="p">(</span><span class="n">msg</span><span class="p">)))</span>
				<span class="n">tipc_port_recv_mcast</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg_user</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">==</span> <span class="n">MSG_BUNDLER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
			<span class="n">bclink_accept_pkt</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>
			<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_bundles</span><span class="o">++</span><span class="p">;</span>
			<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_bundled</span> <span class="o">+=</span> <span class="n">msg_msgcnt</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
			<span class="n">tipc_node_unlock</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="n">tipc_link_recv_bundle</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg_user</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">==</span> <span class="n">MSG_FRAGMENTER</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">tipc_link_recv_fragment</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">defragm</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
			<span class="n">bclink_accept_pkt</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>
			<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_fragments</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_fragmented</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
			<span class="n">tipc_node_unlock</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="n">tipc_net_route_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg_user</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">==</span> <span class="n">NAME_DISTRIBUTOR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
			<span class="n">bclink_accept_pkt</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
			<span class="n">tipc_node_unlock</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="n">tipc_named_recv</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
			<span class="n">bclink_accept_pkt</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
			<span class="n">tipc_node_unlock</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* Determine new synchronization state */</span>

		<span class="n">tipc_node_lock</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">tipc_node_is_up</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_in</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">last_sent</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">deferred_head</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">oos_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">msg</span> <span class="o">=</span> <span class="n">buf_msg</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">deferred_head</span><span class="p">);</span>
		<span class="n">seqno</span> <span class="o">=</span> <span class="n">msg_seqno</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">next_in</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">next_in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">seqno</span> <span class="o">!=</span> <span class="n">next_in</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

		<span class="cm">/* Take in-sequence message from deferred queue &amp; deliver it */</span>

		<span class="n">buf</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">deferred_head</span><span class="p">;</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">deferred_head</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">deferred_size</span><span class="o">--</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">receive</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Handle out-of-sequence broadcast message */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">less</span><span class="p">(</span><span class="n">next_in</span><span class="p">,</span> <span class="n">seqno</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">deferred</span> <span class="o">=</span> <span class="n">tipc_link_defer_pkt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">deferred_head</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">deferred_tail</span><span class="p">,</span>
					       <span class="n">buf</span><span class="p">);</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">deferred_size</span> <span class="o">+=</span> <span class="n">deferred</span><span class="p">;</span>
		<span class="n">bclink_update_last_sent</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">deferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">deferred</span><span class="p">)</span>
		<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">deferred_recv</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">duplicates</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>

<span class="nl">unlock:</span>
	<span class="n">tipc_node_unlock</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u32</span> <span class="nf">tipc_bclink_acks_missing</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_node</span> <span class="o">*</span><span class="n">n_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">supported</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">tipc_bclink_get_last_sent</span><span class="p">()</span> <span class="o">!=</span> <span class="n">n_ptr</span><span class="o">-&gt;</span><span class="n">bclink</span><span class="p">.</span><span class="n">acked</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * tipc_bcbearer_send - send a packet through the broadcast pseudo-bearer</span>
<span class="cm"> *</span>
<span class="cm"> * Send packet over as many bearers as necessary to reach all nodes</span>
<span class="cm"> * that have joined the broadcast link.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 (packet sent successfully) under all circumstances,</span>
<span class="cm"> * since the broadcast link&#39;s pseudo-bearer never blocks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tipc_bcbearer_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">tipc_bearer</span> <span class="o">*</span><span class="n">unused1</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">tipc_media_addr</span> <span class="o">*</span><span class="n">unused2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bp_index</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare broadcast link message for reliable transmission,</span>
<span class="cm">	 * if first time trying to send it;</span>
<span class="cm">	 * preparation is skipped for broadcast link protocol messages</span>
<span class="cm">	 * since they are sent in an unreliable manner and don&#39;t need it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">msg_non_seq</span><span class="p">(</span><span class="n">buf_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">))))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

		<span class="n">bcbuf_set_acks</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">bclink</span><span class="o">-&gt;</span><span class="n">bcast_nodes</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="n">buf_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">msg_set_non_seq</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">msg_set_mc_netid</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">tipc_net_id</span><span class="p">);</span>
		<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sent_info</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bclink</span><span class="o">-&gt;</span><span class="n">bcast_nodes</span><span class="p">.</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dump_stack</span><span class="p">();</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Send buffer over bearers until all targets reached */</span>
	<span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">remains</span> <span class="o">=</span> <span class="n">bclink</span><span class="o">-&gt;</span><span class="n">bcast_nodes</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bp_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bp_index</span> <span class="o">&lt;</span> <span class="n">MAX_BEARERS</span><span class="p">;</span> <span class="n">bp_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tipc_bearer</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bpairs</span><span class="p">[</span><span class="n">bp_index</span><span class="p">].</span><span class="n">primary</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">tipc_bearer</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bpairs</span><span class="p">[</span><span class="n">bp_index</span><span class="p">].</span><span class="n">secondary</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* no more bearers to try */</span>

		<span class="n">tipc_nmap_diff</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">remains</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">remains_new</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">remains_new</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">remains</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>	<span class="cm">/* bearer pair doesn&#39;t add anything */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">blocked</span> <span class="o">||</span>
		    <span class="n">p</span><span class="o">-&gt;</span><span class="n">media</span><span class="o">-&gt;</span><span class="n">send_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">media</span><span class="o">-&gt;</span><span class="n">bcast_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* unable to send on primary bearer */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span> <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">blocked</span> <span class="o">||</span>
			    <span class="n">s</span><span class="o">-&gt;</span><span class="n">media</span><span class="o">-&gt;</span><span class="n">send_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">media</span><span class="o">-&gt;</span><span class="n">bcast_addr</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* unable to send on either bearer */</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bpairs</span><span class="p">[</span><span class="n">bp_index</span><span class="p">].</span><span class="n">primary</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
			<span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bpairs</span><span class="p">[</span><span class="n">bp_index</span><span class="p">].</span><span class="n">secondary</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">remains_new</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* all targets reached */</span>

		<span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">remains</span> <span class="o">=</span> <span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">remains_new</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_bcbearer_sort - create sets of bearer pairs used by broadcast bearer</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_bcbearer_sort</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_bcbearer_pair</span> <span class="o">*</span><span class="n">bp_temp</span> <span class="o">=</span> <span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bpairs_temp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_bcbearer_pair</span> <span class="o">*</span><span class="n">bp_curr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">b_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pri</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>

	<span class="cm">/* Group bearers by priority (can assume max of two per priority) */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bp_temp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bpairs_temp</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">b_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b_index</span> <span class="o">&lt;</span> <span class="n">MAX_BEARERS</span><span class="p">;</span> <span class="n">b_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tipc_bearer</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tipc_bearers</span><span class="p">[</span><span class="n">b_index</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">||</span> <span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp_temp</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">].</span><span class="n">primary</span><span class="p">)</span>
			<span class="n">bp_temp</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">].</span><span class="n">primary</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bp_temp</span><span class="p">[</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">].</span><span class="n">secondary</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create array of bearer pairs for broadcasting */</span>
	<span class="n">bp_curr</span> <span class="o">=</span> <span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bpairs</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bpairs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bpairs</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pri</span> <span class="o">=</span> <span class="n">TIPC_MAX_LINK_PRI</span><span class="p">;</span> <span class="n">pri</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pri</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp_temp</span><span class="p">[</span><span class="n">pri</span><span class="p">].</span><span class="n">primary</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">bp_curr</span><span class="o">-&gt;</span><span class="n">primary</span> <span class="o">=</span> <span class="n">bp_temp</span><span class="p">[</span><span class="n">pri</span><span class="p">].</span><span class="n">primary</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bp_temp</span><span class="p">[</span><span class="n">pri</span><span class="p">].</span><span class="n">secondary</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tipc_nmap_equal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp_temp</span><span class="p">[</span><span class="n">pri</span><span class="p">].</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">bp_temp</span><span class="p">[</span><span class="n">pri</span><span class="p">].</span><span class="n">secondary</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bp_curr</span><span class="o">-&gt;</span><span class="n">secondary</span> <span class="o">=</span> <span class="n">bp_temp</span><span class="p">[</span><span class="n">pri</span><span class="p">].</span><span class="n">secondary</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">bp_curr</span><span class="o">++</span><span class="p">;</span>
				<span class="n">bp_curr</span><span class="o">-&gt;</span><span class="n">primary</span> <span class="o">=</span> <span class="n">bp_temp</span><span class="p">[</span><span class="n">pri</span><span class="p">].</span><span class="n">secondary</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">bp_curr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">tipc_bclink_stats</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">buf_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">print_buf</span> <span class="n">pb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bcl</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tipc_printbuf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pb</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buf_size</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>

	<span class="n">tipc_printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pb</span><span class="p">,</span> <span class="s">&quot;Link &lt;%s&gt;</span><span class="se">\n</span><span class="s">&quot;</span>
			 <span class="s">&quot;  Window:%u packets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">queue_limit</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">tipc_printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pb</span><span class="p">,</span> <span class="s">&quot;  RX packets:%u fragments:%u/%u bundles:%u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_info</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_fragments</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_fragmented</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_bundles</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_bundled</span><span class="p">);</span>
	<span class="n">tipc_printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pb</span><span class="p">,</span> <span class="s">&quot;  TX packets:%u fragments:%u/%u bundles:%u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sent_info</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sent_fragments</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sent_fragmented</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sent_bundles</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sent_bundled</span><span class="p">);</span>
	<span class="n">tipc_printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pb</span><span class="p">,</span> <span class="s">&quot;  RX naks:%u defs:%u dups:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">recv_nacks</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">deferred_recv</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">duplicates</span><span class="p">);</span>
	<span class="n">tipc_printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pb</span><span class="p">,</span> <span class="s">&quot;  TX naks:%u acks:%u dups:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sent_nacks</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">sent_acks</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">retransmitted</span><span class="p">);</span>
	<span class="n">tipc_printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pb</span><span class="p">,</span> <span class="s">&quot;  Congestion bearer:%u link:%u  Send queue max:%u avg:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">bearer_congs</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">link_congs</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">max_queue_sz</span><span class="p">,</span>
		    <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">queue_sz_counts</span>
		    <span class="o">?</span> <span class="p">(</span><span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">accu_queue_sz</span> <span class="o">/</span> <span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">queue_sz_counts</span><span class="p">)</span>
		    <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tipc_printbuf_validate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pb</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tipc_bclink_reset_stats</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bcl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bcl</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">));</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tipc_bclink_set_queue_limits</span><span class="p">(</span><span class="n">u32</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bcl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">limit</span> <span class="o">&lt;</span> <span class="n">TIPC_MIN_LINK_WIN</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="n">TIPC_MAX_LINK_WIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
	<span class="n">tipc_link_set_queue_limits</span><span class="p">(</span><span class="n">bcl</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tipc_bclink_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bearer</span><span class="p">.</span><span class="n">cong_links</span><span class="p">);</span>
	<span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bearer</span><span class="p">.</span><span class="n">media</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">media</span><span class="p">;</span>
	<span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">media</span><span class="p">.</span><span class="n">send_msg</span> <span class="o">=</span> <span class="n">tipc_bcbearer_send</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">media</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;tipc-broadcast&quot;</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcl</span><span class="o">-&gt;</span><span class="n">waiting_ports</span><span class="p">);</span>
	<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">next_out_no</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bclink</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bclink</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
	<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">max_pkt</span> <span class="o">=</span> <span class="n">MAX_PKT_DEFAULT_MCAST</span><span class="p">;</span>
	<span class="n">tipc_link_set_queue_limits</span><span class="p">(</span><span class="n">bcl</span><span class="p">,</span> <span class="n">BCLINK_WIN_DEFAULT</span><span class="p">);</span>
	<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">b_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcbearer</span><span class="o">-&gt;</span><span class="n">bearer</span><span class="p">;</span>
	<span class="n">bcl</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">WORKING_WORKING</span><span class="p">;</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">bcl</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">tipc_bclink_name</span><span class="p">,</span> <span class="n">TIPC_MAX_LINK_NAME</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tipc_bclink_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>
	<span class="n">tipc_link_stop</span><span class="p">(</span><span class="n">bcl</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bc_lock</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bclink</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bclink</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bcbearer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bcbearer</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * tipc_nmap_add - add a node to a node map</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_nmap_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_node_map</span> <span class="o">*</span><span class="n">nm_ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">tipc_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">WSIZE</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">WSIZE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">nm_ptr</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nm_ptr</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">nm_ptr</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_nmap_remove - remove a node from a node map</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_nmap_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_node_map</span> <span class="o">*</span><span class="n">nm_ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">tipc_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">WSIZE</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">WSIZE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">nm_ptr</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nm_ptr</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">nm_ptr</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_nmap_diff - find differences between node maps</span>
<span class="cm"> * @nm_a: input node map A</span>
<span class="cm"> * @nm_b: input node map B</span>
<span class="cm"> * @nm_diff: output node map A-B (i.e. nodes of A that are not in B)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tipc_nmap_diff</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_node_map</span> <span class="o">*</span><span class="n">nm_a</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">tipc_node_map</span> <span class="o">*</span><span class="n">nm_b</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">tipc_node_map</span> <span class="o">*</span><span class="n">nm_diff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">nm_a</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">map</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">nm_diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nm_diff</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map</span> <span class="o">=</span> <span class="n">nm_a</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">^</span> <span class="p">(</span><span class="n">nm_a</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">nm_b</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">w</span><span class="p">]);</span>
		<span class="n">nm_diff</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">WSIZE</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">))</span>
					<span class="n">nm_diff</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_port_list_add - add a port to a port list, ensuring no duplicates</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_port_list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_port_list</span> <span class="o">*</span><span class="n">pl_ptr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_port_list</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">pl_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">item_sz</span> <span class="o">=</span> <span class="n">PLSIZE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">pl_ptr</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="p">;</span> <span class="n">cnt</span> <span class="o">-=</span> <span class="n">item_sz</span><span class="p">,</span> <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">PLSIZE</span><span class="p">)</span>
			<span class="n">item_sz</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">item_sz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">port</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">PLSIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">item</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
			<span class="n">pl_ptr</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Incomplete multicast delivery, no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_port_list_free - free dynamically created entries in port_list chain</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_port_list_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_port_list</span> <span class="o">*</span><span class="n">pl_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_port_list</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port_list</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">item</span> <span class="o">=</span> <span class="n">pl_ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">item</span><span class="p">;</span> <span class="n">item</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
