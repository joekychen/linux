<!DOCTYPE html>
<html><head><title>joekychen/linux » net › tipc › name_table.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>name_table.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * net/tipc/name_table.c: TIPC name table code</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2000-2006, Ericsson AB</span>
<span class="cm"> * Copyright (c) 2004-2008, 2010-2011, Wind River Systems</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *    documentation and/or other materials provided with the distribution.</span>
<span class="cm"> * 3. Neither the names of the copyright holders nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived from</span>
<span class="cm"> *    this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="cm"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="cm"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="cm"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="cm"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="cm"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="cm"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="cm"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;core.h&quot;</span>
<span class="cp">#include &quot;config.h&quot;</span>
<span class="cp">#include &quot;name_table.h&quot;</span>
<span class="cp">#include &quot;name_distr.h&quot;</span>
<span class="cp">#include &quot;subscr.h&quot;</span>
<span class="cp">#include &quot;port.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">tipc_nametbl_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>		<span class="cm">/* must be a power of 2 */</span>

<span class="cm">/**</span>
<span class="cm"> * struct name_info - name sequence publication info</span>
<span class="cm"> * @node_list: circular list of publications made by own node</span>
<span class="cm"> * @cluster_list: circular list of publications made by own cluster</span>
<span class="cm"> * @zone_list: circular list of publications made by own zone</span>
<span class="cm"> * @node_list_size: number of entries in &quot;node_list&quot;</span>
<span class="cm"> * @cluster_list_size: number of entries in &quot;cluster_list&quot;</span>
<span class="cm"> * @zone_list_size: number of entries in &quot;zone_list&quot;</span>
<span class="cm"> *</span>
<span class="cm"> * Note: The zone list always contains at least one entry, since all</span>
<span class="cm"> *       publications of the associated name sequence belong to it.</span>
<span class="cm"> *       (The cluster and node lists may be empty.)</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">name_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cluster_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">zone_list</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node_list_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cluster_list_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">zone_list_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct sub_seq - container for all published instances of a name sequence</span>
<span class="cm"> * @lower: name sequence lower bound</span>
<span class="cm"> * @upper: name sequence upper bound</span>
<span class="cm"> * @info: pointer to name sequence publication info</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sub_seq</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">lower</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">upper</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">name_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct name_seq - container for all published instances of a name type</span>
<span class="cm"> * @type: 32 bit &#39;type&#39; value for name sequence</span>
<span class="cm"> * @sseq: pointer to dynamically-sized array of sub-sequences of this &#39;type&#39;;</span>
<span class="cm"> *        sub-sequences are sorted in ascending order</span>
<span class="cm"> * @alloc: number of sub-sequences currently in array</span>
<span class="cm"> * @first_free: array index of first unused sub-sequence entry</span>
<span class="cm"> * @ns_list: links to adjacent name sequences in hash chain</span>
<span class="cm"> * @subscriptions: list of subscriptions for this &#39;type&#39;</span>
<span class="cm"> * @lock: spinlock controlling access to publication lists of all sub-sequences</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">name_seq</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseqs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">alloc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">first_free</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">ns_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">subscriptions</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct name_table - table containing all existing port name publications</span>
<span class="cm"> * @types: pointer to fixed-sized array of name sequence lists,</span>
<span class="cm"> *         accessed via hashing on &#39;type&#39;; name sequence lists are *not* sorted</span>
<span class="cm"> * @local_publ_count: number of publications issued by this node</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">name_table</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">types</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">local_publ_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">name_table</span> <span class="n">table</span><span class="p">;</span>
<span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hash</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tipc_nametbl_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * publ_create - create a publication structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="nf">publ_create</span><span class="p">(</span><span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lower</span><span class="p">,</span> <span class="n">u32</span> <span class="n">upper</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">scope</span><span class="p">,</span> <span class="n">u32</span> <span class="n">node</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_ref</span><span class="p">,</span>
				       <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="n">publ</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">publ</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">publ</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Publication creation failure, no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">publ</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">publ</span><span class="o">-&gt;</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span><span class="p">;</span>
	<span class="n">publ</span><span class="o">-&gt;</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="p">;</span>
	<span class="n">publ</span><span class="o">-&gt;</span><span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">;</span>
	<span class="n">publ</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">publ</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">=</span> <span class="n">port_ref</span><span class="p">;</span>
	<span class="n">publ</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">local_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">pport_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">subscr</span><span class="p">.</span><span class="n">nodesub_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">publ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_subseq_alloc - allocate a specified number of sub-sequence structures</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="nf">tipc_subseq_alloc</span><span class="p">(</span><span class="n">u32</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseq</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sub_seq</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sseq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_nameseq_create - create a name sequence structure for the specified &#39;type&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates a single sub-sequence structure and sets it to all 0&#39;s.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="nf">tipc_nameseq_create</span><span class="p">(</span><span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">seq_head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">nseq</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nseq</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseq</span> <span class="o">=</span> <span class="n">tipc_subseq_alloc</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nseq</span> <span class="o">||</span> <span class="o">!</span><span class="n">sseq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Name sequence creation failed, no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">nseq</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sseq</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">nseq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span> <span class="o">=</span> <span class="n">sseq</span><span class="p">;</span>
	<span class="n">nseq</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">ns_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">subscriptions</span><span class="p">);</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">ns_list</span><span class="p">,</span> <span class="n">seq_head</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nseq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nameseq_delete_empty - deletes a name sequence structure if now unused</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nameseq_delete_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">first_free</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">subscriptions</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">hlist_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">ns_list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * nameseq_find_subseq - find sub-sequence (if any) matching a name instance</span>
<span class="cm"> *</span>
<span class="cm"> * Very time-critical, so binary searches through sub-sequence array.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="nf">nameseq_find_subseq</span><span class="p">(</span><span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">nseq</span><span class="p">,</span>
					   <span class="n">u32</span> <span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseqs</span> <span class="o">=</span> <span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">nseq</span><span class="o">-&gt;</span><span class="n">first_free</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mid</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">&lt;</span> <span class="n">sseqs</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">lower</span><span class="p">)</span>
			<span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">&gt;</span> <span class="n">sseqs</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">upper</span><span class="p">)</span>
			<span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">sseqs</span><span class="p">[</span><span class="n">mid</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nameseq_locate_subseq - determine position of name instance in sub-sequence</span>
<span class="cm"> *</span>
<span class="cm"> * Returns index in sub-sequence array of the entry that contains the specified</span>
<span class="cm"> * instance value; if no entry contains that value, returns the position</span>
<span class="cm"> * where a new entry for it would be inserted in the array.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Similar to binary search code for locating a sub-sequence.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">nameseq_locate_subseq</span><span class="p">(</span><span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">nseq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseqs</span> <span class="o">=</span> <span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">nseq</span><span class="o">-&gt;</span><span class="n">first_free</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mid</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">&lt;</span> <span class="n">sseqs</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">lower</span><span class="p">)</span>
			<span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">&gt;</span> <span class="n">sseqs</span><span class="p">[</span><span class="n">mid</span><span class="p">].</span><span class="n">upper</span><span class="p">)</span>
			<span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">low</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_nameseq_insert_publ</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="nf">tipc_nameseq_insert_publ</span><span class="p">(</span><span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">nseq</span><span class="p">,</span>
						    <span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lower</span><span class="p">,</span> <span class="n">u32</span> <span class="n">upper</span><span class="p">,</span>
						    <span class="n">u32</span> <span class="n">scope</span><span class="p">,</span> <span class="n">u32</span> <span class="n">node</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="n">publ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">name_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">created_subseq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sseq</span> <span class="o">=</span> <span class="n">nameseq_find_subseq</span><span class="p">(</span><span class="n">nseq</span><span class="p">,</span> <span class="n">lower</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sseq</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Lower end overlaps existing entry =&gt; need an exact match */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sseq</span><span class="o">-&gt;</span><span class="n">lower</span> <span class="o">!=</span> <span class="n">lower</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sseq</span><span class="o">-&gt;</span><span class="n">upper</span> <span class="o">!=</span> <span class="n">upper</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Cannot publish {%u,%u,%u}, overlap error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">type</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">info</span> <span class="o">=</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>

		<span class="cm">/* Check if an identical publication already exists */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">publ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">,</span> <span class="n">zone_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">==</span> <span class="n">port</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">||</span> <span class="p">(</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">==</span> <span class="n">node</span><span class="p">)))</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">inspos</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">freesseq</span><span class="p">;</span>

		<span class="cm">/* Find where lower end should be inserted */</span>
		<span class="n">inspos</span> <span class="o">=</span> <span class="n">nameseq_locate_subseq</span><span class="p">(</span><span class="n">nseq</span><span class="p">,</span> <span class="n">lower</span><span class="p">);</span>

		<span class="cm">/* Fail if upper end overlaps into an existing entry */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inspos</span> <span class="o">&lt;</span> <span class="n">nseq</span><span class="o">-&gt;</span><span class="n">first_free</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">upper</span> <span class="o">&gt;=</span> <span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">[</span><span class="n">inspos</span><span class="p">].</span><span class="n">lower</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Cannot publish {%u,%u,%u}, overlap error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">type</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Ensure there is space for new sub-sequence */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">first_free</span> <span class="o">==</span> <span class="n">nseq</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseqs</span> <span class="o">=</span> <span class="n">tipc_subseq_alloc</span><span class="p">(</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sseqs</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Cannot publish {%u,%u,%u}, no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">type</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">sseqs</span><span class="p">,</span> <span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">,</span>
			       <span class="n">nseq</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sub_seq</span><span class="p">));</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">);</span>
			<span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span> <span class="o">=</span> <span class="n">sseqs</span><span class="p">;</span>
			<span class="n">nseq</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">info</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Cannot publish {%u,%u,%u}, no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">type</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">);</span>

		<span class="cm">/* Insert new sub-sequence */</span>
		<span class="n">sseq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">[</span><span class="n">inspos</span><span class="p">];</span>
		<span class="n">freesseq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">[</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">first_free</span><span class="p">];</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">sseq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sseq</span><span class="p">,</span> <span class="p">(</span><span class="n">freesseq</span> <span class="o">-</span> <span class="n">sseq</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sseq</span><span class="p">));</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">sseq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sseq</span><span class="p">));</span>
		<span class="n">nseq</span><span class="o">-&gt;</span><span class="n">first_free</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sseq</span><span class="o">-&gt;</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span><span class="p">;</span>
		<span class="n">sseq</span><span class="o">-&gt;</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span><span class="p">;</span>
		<span class="n">sseq</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
		<span class="n">created_subseq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Insert a publication */</span>
	<span class="n">publ</span> <span class="o">=</span> <span class="n">publ_create</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">publ</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list_size</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_own_cluster</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">cluster_list_size</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_own_node</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list_size</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Any subscriptions waiting for notification?  */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">subscriptions</span><span class="p">,</span> <span class="n">nameseq_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tipc_subscr_report_overlap</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
					   <span class="n">publ</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">,</span>
					   <span class="n">publ</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">,</span>
					   <span class="n">TIPC_PUBLISHED</span><span class="p">,</span>
					   <span class="n">publ</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span>
					   <span class="n">publ</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span>
					   <span class="n">created_subseq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">publ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_nameseq_remove_publ</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: There may be cases where TIPC is asked to remove a publication</span>
<span class="cm"> * that is not in the name table.  For example, if another node issues a</span>
<span class="cm"> * publication for a name sequence that overlaps an existing name sequence</span>
<span class="cm"> * the publication will not be recorded, which means the publication won&#39;t</span>
<span class="cm"> * be found when the name sequence is later withdrawn by that node.</span>
<span class="cm"> * A failed withdraw request simply returns a failure indication and lets the</span>
<span class="cm"> * caller issue any error or warning messages associated with such a problem.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="nf">tipc_nameseq_remove_publ</span><span class="p">(</span><span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">nseq</span><span class="p">,</span> <span class="n">u32</span> <span class="n">inst</span><span class="p">,</span>
						    <span class="n">u32</span> <span class="n">node</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ref</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="n">publ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseq</span> <span class="o">=</span> <span class="n">nameseq_find_subseq</span><span class="p">(</span><span class="n">nseq</span><span class="p">,</span> <span class="n">inst</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">name_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">free</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">removed_subseq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sseq</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>

	<span class="cm">/* Locate publication, if it exists */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">publ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">,</span> <span class="n">zone_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">ref</span> <span class="o">==</span> <span class="n">ref</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">||</span> <span class="p">(</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">==</span> <span class="n">node</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="cm">/* Remove publication from zone scope list */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list_size</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Remove publication from cluster scope list, if present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_own_cluster</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">cluster_list_size</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remove publication from node scope list, if present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in_own_node</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list_size</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Contract subseq list if no more publications for that subseq */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">free</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">[</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">first_free</span><span class="o">--</span><span class="p">];</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">sseq</span><span class="p">,</span> <span class="n">sseq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">free</span> <span class="o">-</span> <span class="p">(</span><span class="n">sseq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sseq</span><span class="p">));</span>
		<span class="n">removed_subseq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Notify any waiting subscriptions */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">subscriptions</span><span class="p">,</span> <span class="n">nameseq_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tipc_subscr_report_overlap</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
					   <span class="n">publ</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">,</span>
					   <span class="n">publ</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">,</span>
					   <span class="n">TIPC_WITHDRAWN</span><span class="p">,</span>
					   <span class="n">publ</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span>
					   <span class="n">publ</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span>
					   <span class="n">removed_subseq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">publ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_nameseq_subscribe: attach a subscription, and issue</span>
<span class="cm"> * the prescribed number of events if there is any sub-</span>
<span class="cm"> * sequence overlapping with the requested sequence</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">tipc_nameseq_subscribe</span><span class="p">(</span><span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">nseq</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseq</span> <span class="o">=</span> <span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">nameseq_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">subscriptions</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sseq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sseq</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">[</span><span class="n">nseq</span><span class="o">-&gt;</span><span class="n">first_free</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tipc_subscr_overlap</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">,</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="n">crs</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">name_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">must_report</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">,</span> <span class="n">zone_list</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tipc_subscr_report_overlap</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
							   <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">,</span>
							   <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">,</span>
							   <span class="n">TIPC_PUBLISHED</span><span class="p">,</span>
							   <span class="n">crs</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span>
							   <span class="n">crs</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span>
							   <span class="n">must_report</span><span class="p">);</span>
				<span class="n">must_report</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">sseq</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="nf">nametbl_find_seq</span><span class="p">(</span><span class="n">u32</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">seq_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">seq_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">ns</span><span class="p">;</span>

	<span class="n">seq_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">.</span><span class="n">types</span><span class="p">[</span><span class="n">hash</span><span class="p">(</span><span class="n">type</span><span class="p">)];</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">seq_node</span><span class="p">,</span> <span class="n">seq_head</span><span class="p">,</span> <span class="n">ns_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ns</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="nf">tipc_nametbl_insert_publ</span><span class="p">(</span><span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lower</span><span class="p">,</span> <span class="n">u32</span> <span class="n">upper</span><span class="p">,</span>
					     <span class="n">u32</span> <span class="n">scope</span><span class="p">,</span> <span class="n">u32</span> <span class="n">node</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">nametbl_find_seq</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">scope</span> <span class="o">&lt;</span> <span class="n">TIPC_ZONE_SCOPE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">scope</span> <span class="o">&gt;</span> <span class="n">TIPC_NODE_SCOPE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">lower</span> <span class="o">&gt;</span> <span class="n">upper</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dbg</span><span class="p">(</span><span class="s">&quot;Failed to publish illegal {%u,%u,%u} with scope %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">type</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">scope</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="p">)</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">tipc_nameseq_create</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">.</span><span class="n">types</span><span class="p">[</span><span class="n">hash</span><span class="p">(</span><span class="n">type</span><span class="p">)]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tipc_nameseq_insert_publ</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span>
					<span class="n">scope</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="nf">tipc_nametbl_remove_publ</span><span class="p">(</span><span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lower</span><span class="p">,</span>
					     <span class="n">u32</span> <span class="n">node</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ref</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="n">publ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">nametbl_find_seq</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">publ</span> <span class="o">=</span> <span class="n">tipc_nameseq_remove_publ</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="n">nameseq_delete_empty</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">publ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * tipc_nametbl_translate - perform name translation</span>
<span class="cm"> *</span>
<span class="cm"> * On entry, &#39;destnode&#39; is the search domain used during translation.</span>
<span class="cm"> *</span>
<span class="cm"> * On exit:</span>
<span class="cm"> * - if name translation is deferred to another node/cluster/zone,</span>
<span class="cm"> *   leaves &#39;destnode&#39; unchanged (will be non-zero) and returns 0</span>
<span class="cm"> * - if name translation is attempted and succeeds, sets &#39;destnode&#39;</span>
<span class="cm"> *   to publishing node and returns port reference (will be non-zero)</span>
<span class="cm"> * - if name translation is attempted and fails, sets &#39;destnode&#39; to 0</span>
<span class="cm"> *   and returns 0</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">tipc_nametbl_translate</span><span class="p">(</span><span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">instance</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">destnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">name_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="n">publ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tipc_in_scope</span><span class="p">(</span><span class="o">*</span><span class="n">destnode</span><span class="p">,</span> <span class="n">tipc_own_addr</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">nametbl_find_seq</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>
	<span class="n">sseq</span> <span class="o">=</span> <span class="n">nameseq_find_subseq</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sseq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>

	<span class="cm">/* Closest-First Algorithm */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!*</span><span class="n">destnode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">publ</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">publication</span><span class="p">,</span>
						<span class="n">node_list</span><span class="p">);</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">publ</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">publication</span><span class="p">,</span>
						<span class="n">cluster_list</span><span class="p">);</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">publ</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">publication</span><span class="p">,</span>
						<span class="n">zone_list</span><span class="p">);</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Round-Robin Algorithm */</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">destnode</span> <span class="o">==</span> <span class="n">tipc_own_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">no_match</span><span class="p">;</span>
		<span class="n">publ</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">publication</span><span class="p">,</span>
					<span class="n">node_list</span><span class="p">);</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">in_own_cluster_exact</span><span class="p">(</span><span class="o">*</span><span class="n">destnode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">no_match</span><span class="p">;</span>
		<span class="n">publ</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">publication</span><span class="p">,</span>
					<span class="n">cluster_list</span><span class="p">);</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">publ</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">publication</span><span class="p">,</span>
					<span class="n">zone_list</span><span class="p">);</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ref</span> <span class="o">=</span> <span class="n">publ</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">;</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">publ</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
<span class="nl">no_match:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">not_found:</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="o">*</span><span class="n">destnode</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ref</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_nametbl_mc_translate - find multicast destinations</span>
<span class="cm"> *</span>
<span class="cm"> * Creates list of all local ports that overlap the given multicast address;</span>
<span class="cm"> * also determines if any off-node ports overlap.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Publications with a scope narrower than &#39;limit&#39; are ignored.</span>
<span class="cm"> * (i.e. local node-scope publications mustn&#39;t receive messages arriving</span>
<span class="cm"> * from another node, even if the multcast link brought it here)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns non-zero if any off-node ports overlap</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tipc_nametbl_mc_translate</span><span class="p">(</span><span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lower</span><span class="p">,</span> <span class="n">u32</span> <span class="n">upper</span><span class="p">,</span> <span class="n">u32</span> <span class="n">limit</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">tipc_port_list</span> <span class="o">*</span><span class="n">dports</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseq_stop</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">name_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">nametbl_find_seq</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">sseq</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">sseqs</span> <span class="o">+</span> <span class="n">nameseq_locate_subseq</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">lower</span><span class="p">);</span>
	<span class="n">sseq_stop</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">sseqs</span> <span class="o">+</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">first_free</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">sseq</span> <span class="o">!=</span> <span class="n">sseq_stop</span><span class="p">;</span> <span class="n">sseq</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="n">publ</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sseq</span><span class="o">-&gt;</span><span class="n">lower</span> <span class="o">&gt;</span> <span class="n">upper</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">info</span> <span class="o">=</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">publ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list</span><span class="p">,</span> <span class="n">node_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">scope</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">)</span>
				<span class="n">tipc_port_list_add</span><span class="p">(</span><span class="n">dports</span><span class="p">,</span> <span class="n">publ</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cluster_list_size</span> <span class="o">!=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">node_list_size</span><span class="p">)</span>
			<span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * tipc_nametbl_publish - add name publication to network name tables</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="nf">tipc_nametbl_publish</span><span class="p">(</span><span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lower</span><span class="p">,</span> <span class="n">u32</span> <span class="n">upper</span><span class="p">,</span>
				    <span class="n">u32</span> <span class="n">scope</span><span class="p">,</span> <span class="n">u32</span> <span class="n">port_ref</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="n">publ</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">.</span><span class="n">local_publ_count</span> <span class="o">&gt;=</span> <span class="n">tipc_max_publications</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Publication failed, local publication limit reached (%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">tipc_max_publications</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="n">publ</span> <span class="o">=</span> <span class="n">tipc_nametbl_insert_publ</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span>
				   <span class="n">tipc_own_addr</span><span class="p">,</span> <span class="n">port_ref</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">publ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">table</span><span class="p">.</span><span class="n">local_publ_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tipc_named_publish</span><span class="p">(</span><span class="n">publ</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">publ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_nametbl_withdraw - withdraw name publication from network name tables</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tipc_nametbl_withdraw</span><span class="p">(</span><span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lower</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ref</span><span class="p">,</span> <span class="n">u32</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="n">publ</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="n">publ</span> <span class="o">=</span> <span class="n">tipc_nametbl_remove_publ</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">tipc_own_addr</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">publ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">table</span><span class="p">.</span><span class="n">local_publ_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">tipc_named_withdraw</span><span class="p">(</span><span class="n">publ</span><span class="p">);</span>
		<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">pport_list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">publ</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="n">err</span><span class="p">(</span><span class="s">&quot;Unable to remove local publication</span><span class="se">\n</span><span class="s">&quot;</span>
	    <span class="s">&quot;(type=%u, lower=%u, ref=%u, key=%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	    <span class="n">type</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_nametbl_subscribe - add a subscription object to the name table</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_nametbl_subscribe</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">type</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">nametbl_find_seq</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq</span><span class="p">)</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">tipc_nameseq_create</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">.</span><span class="n">types</span><span class="p">[</span><span class="n">hash</span><span class="p">(</span><span class="n">type</span><span class="p">)]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">tipc_nameseq_subscribe</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">warn</span><span class="p">(</span><span class="s">&quot;Failed to create subscription for {%u,%u,%u}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		     <span class="n">s</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">type</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">upper</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_nametbl_unsubscribe - remove a subscription object from name table</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_nametbl_unsubscribe</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_subscription</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">nametbl_find_seq</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seq</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">nameseq_list</span><span class="p">);</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">nameseq_delete_empty</span><span class="p">(</span><span class="n">seq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * subseq_list: print specified sub-sequence contents into the given buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">subseq_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">print_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">depth</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">portIdStr</span><span class="p">[</span><span class="mi">27</span><span class="p">];</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scope_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot; zone&quot;</span><span class="p">,</span> <span class="s">&quot; cluster&quot;</span><span class="p">,</span> <span class="s">&quot; node&quot;</span><span class="p">};</span>
	<span class="k">struct</span> <span class="n">publication</span> <span class="o">*</span><span class="n">publ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">name_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">tipc_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%-10u %-10u &quot;</span><span class="p">,</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">,</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tipc_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">publ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">,</span> <span class="n">zone_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">portIdStr</span><span class="p">,</span> <span class="s">&quot;&lt;%u.%u.%u:%u&gt;&quot;</span><span class="p">,</span>
			 <span class="n">tipc_zone</span><span class="p">(</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">),</span> <span class="n">tipc_cluster</span><span class="p">(</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">),</span>
			 <span class="n">tipc_node</span><span class="p">(</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">),</span> <span class="n">publ</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
		<span class="n">tipc_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%-26s &quot;</span><span class="p">,</span> <span class="n">portIdStr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tipc_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%-10u %s&quot;</span><span class="p">,</span> <span class="n">publ</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
				    <span class="n">scope_str</span><span class="p">[</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">scope</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_is_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">publ</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">zone_list</span><span class="p">))</span>
			<span class="n">tipc_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">%33s&quot;</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
	<span class="p">};</span>

	<span class="n">tipc_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nameseq_list: print specified name sequence contents into the given buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nameseq_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">print_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">depth</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lowbound</span><span class="p">,</span> <span class="n">u32</span> <span class="n">upbound</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sub_seq</span> <span class="o">*</span><span class="n">sseq</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">typearea</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">first_free</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">typearea</span><span class="p">,</span> <span class="s">&quot;%-10u&quot;</span><span class="p">,</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tipc_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">typearea</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">sseq</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">;</span> <span class="n">sseq</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">sseqs</span><span class="p">[</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">first_free</span><span class="p">];</span> <span class="n">sseq</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lowbound</span> <span class="o">&lt;=</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">upper</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">upbound</span> <span class="o">&gt;=</span> <span class="n">sseq</span><span class="o">-&gt;</span><span class="n">lower</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tipc_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">typearea</span><span class="p">);</span>
			<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">subseq_list</span><span class="p">(</span><span class="n">sseq</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">typearea</span><span class="p">,</span> <span class="s">&quot;%10s&quot;</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nametbl_header - print name table header into the given buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nametbl_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">print_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">header</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&quot;Type       &quot;</span><span class="p">,</span>
		<span class="s">&quot;Lower      Upper      &quot;</span><span class="p">,</span>
		<span class="s">&quot;Port Identity              &quot;</span><span class="p">,</span>
		<span class="s">&quot;Publication Scope&quot;</span>
	<span class="p">};</span>

	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">depth</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">tipc_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">header</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">tipc_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nametbl_list - print specified name table contents into the given buffer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nametbl_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">print_buf</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="n">depth_info</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">type</span><span class="p">,</span> <span class="n">u32</span> <span class="n">lowbound</span><span class="p">,</span> <span class="n">u32</span> <span class="n">upbound</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">seq_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">seq_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">name_seq</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">all_types</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">depth</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">all_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">depth_info</span> <span class="o">&amp;</span> <span class="n">TIPC_NTQ_ALLTYPES</span><span class="p">);</span>
	<span class="n">depth</span> <span class="o">=</span> <span class="p">(</span><span class="n">depth_info</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">TIPC_NTQ_ALLTYPES</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">all_types</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* display all entries in name table to specified depth */</span>
		<span class="n">nametbl_header</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
		<span class="n">lowbound</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">upbound</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tipc_nametbl_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">.</span><span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">seq_node</span><span class="p">,</span> <span class="n">seq_head</span><span class="p">,</span> <span class="n">ns_list</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nameseq_list</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
					     <span class="n">lowbound</span><span class="p">,</span> <span class="n">upbound</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* display only the sequence that matches the specified type */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">upbound</span> <span class="o">&lt;</span> <span class="n">lowbound</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tipc_printf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;invalid name sequence specified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nametbl_header</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
		<span class="n">seq_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">.</span><span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">seq_node</span><span class="p">,</span> <span class="n">seq_head</span><span class="p">,</span> <span class="n">ns_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nameseq_list</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
					     <span class="n">lowbound</span><span class="p">,</span> <span class="n">upbound</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define MAX_NAME_TBL_QUERY 32768</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">tipc_nametbl_get</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">req_tlv_area</span><span class="p">,</span> <span class="kt">int</span> <span class="n">req_tlv_space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_name_table_query</span> <span class="o">*</span><span class="n">argv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tlv_desc</span> <span class="o">*</span><span class="n">rep_tlv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">print_buf</span> <span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">str_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TLV_CHECK</span><span class="p">(</span><span class="n">req_tlv_area</span><span class="p">,</span> <span class="n">req_tlv_space</span><span class="p">,</span> <span class="n">TIPC_TLV_NAME_TBL_QUERY</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">tipc_cfg_reply_error_string</span><span class="p">(</span><span class="n">TIPC_CFG_TLV_ERROR</span><span class="p">);</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">tipc_cfg_reply_alloc</span><span class="p">(</span><span class="n">TLV_SPACE</span><span class="p">(</span><span class="n">MAX_NAME_TBL_QUERY</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rep_tlv</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tlv_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">tipc_printbuf_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">TLV_DATA</span><span class="p">(</span><span class="n">rep_tlv</span><span class="p">),</span> <span class="n">MAX_NAME_TBL_QUERY</span><span class="p">);</span>
	<span class="n">argv</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tipc_name_table_query</span> <span class="o">*</span><span class="p">)</span><span class="n">TLV_DATA</span><span class="p">(</span><span class="n">req_tlv_area</span><span class="p">);</span>
	<span class="n">read_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="n">nametbl_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">argv</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">),</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">argv</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">),</span>
		     <span class="n">ntohl</span><span class="p">(</span><span class="n">argv</span><span class="o">-&gt;</span><span class="n">lowbound</span><span class="p">),</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">argv</span><span class="o">-&gt;</span><span class="n">upbound</span><span class="p">));</span>
	<span class="n">read_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="n">str_len</span> <span class="o">=</span> <span class="n">tipc_printbuf_validate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>

	<span class="n">skb_put</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">TLV_SPACE</span><span class="p">(</span><span class="n">str_len</span><span class="p">));</span>
	<span class="n">TLV_SET</span><span class="p">(</span><span class="n">rep_tlv</span><span class="p">,</span> <span class="n">TIPC_TLV_ULTRA_STRING</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">str_len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tipc_nametbl_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">table</span><span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">tipc_nametbl_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span><span class="p">),</span>
			      <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">.</span><span class="n">types</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">table</span><span class="p">.</span><span class="n">local_publ_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tipc_nametbl_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span><span class="p">.</span><span class="n">types</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Verify name table is empty, then release it */</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tipc_nametbl_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">.</span><span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="n">err</span><span class="p">(</span><span class="s">&quot;tipc_nametbl_stop(): hash chain %u is non-null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">table</span><span class="p">.</span><span class="n">types</span><span class="p">);</span>
	<span class="n">table</span><span class="p">.</span><span class="n">types</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_nametbl_lock</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
