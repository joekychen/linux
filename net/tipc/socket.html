<!DOCTYPE html>
<html><head><title>joekychen/linux » net › tipc › socket.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>socket.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * net/tipc/socket.c: TIPC socket API</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2001-2007, Ericsson AB</span>
<span class="cm"> * Copyright (c) 2004-2008, 2010-2011, Wind River Systems</span>
<span class="cm"> * All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<span class="cm"> * modification, are permitted provided that the following conditions are met:</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="cm"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="cm"> *    documentation and/or other materials provided with the distribution.</span>
<span class="cm"> * 3. Neither the names of the copyright holders nor the names of its</span>
<span class="cm"> *    contributors may be used to endorse or promote products derived from</span>
<span class="cm"> *    this software without specific prior written permission.</span>
<span class="cm"> *</span>
<span class="cm"> * Alternatively, this software may be distributed under the terms of the</span>
<span class="cm"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</span>
<span class="cm"> * Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="cm"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="cm"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="cm"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="cm"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="cm"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="cm"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="cm"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="cm"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="cm"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="cm"> * POSSIBILITY OF SUCH DAMAGE.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>

<span class="cp">#include &quot;core.h&quot;</span>
<span class="cp">#include &quot;port.h&quot;</span>

<span class="cp">#define SS_LISTENING	-1	</span><span class="cm">/* socket is listening */</span><span class="cp"></span>
<span class="cp">#define SS_READY	-2	</span><span class="cm">/* socket is connectionless */</span><span class="cp"></span>

<span class="cp">#define OVERLOAD_LIMIT_BASE	5000</span>
<span class="cp">#define CONN_TIMEOUT_DEFAULT	8000	</span><span class="cm">/* default connect timeout = 8s */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">tipc_sock</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_portid</span> <span class="n">peer_name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">conn_timeout</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define tipc_sk(sk) ((struct tipc_sock *)(sk))</span>
<span class="cp">#define tipc_sk_port(sk) ((struct tipc_port *)(tipc_sk(sk)-&gt;p))</span>

<span class="cp">#define tipc_rx_ready(sock) (!skb_queue_empty(&amp;sock-&gt;sk-&gt;sk_receive_queue) || \</span>
<span class="cp">			(sock-&gt;state == SS_DISCONNECTING))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">backlog_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">wakeupdispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">packet_ops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">stream_ops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">msg_ops</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proto</span> <span class="n">tipc_proto</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sockets_enabled</span><span class="p">;</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">tipc_queue_size</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Revised TIPC socket locking policy:</span>
<span class="cm"> *</span>
<span class="cm"> * Most socket operations take the standard socket lock when they start</span>
<span class="cm"> * and hold it until they finish (or until they need to sleep).  Acquiring</span>
<span class="cm"> * this lock grants the owner exclusive access to the fields of the socket</span>
<span class="cm"> * data structures, with the exception of the backlog queue.  A few socket</span>
<span class="cm"> * operations can be done without taking the socket lock because they only</span>
<span class="cm"> * read socket information that never changes during the life of the socket.</span>
<span class="cm"> *</span>
<span class="cm"> * Socket operations may acquire the lock for the associated TIPC port if they</span>
<span class="cm"> * need to perform an operation on the port.  If any routine needs to acquire</span>
<span class="cm"> * both the socket lock and the port lock it must take the socket lock first</span>
<span class="cm"> * to avoid the risk of deadlock.</span>
<span class="cm"> *</span>
<span class="cm"> * The dispatcher handling incoming messages cannot grab the socket lock in</span>
<span class="cm"> * the standard fashion, since invoked it runs at the BH level and cannot block.</span>
<span class="cm"> * Instead, it checks to see if the socket lock is currently owned by someone,</span>
<span class="cm"> * and either handles the message itself or adds it to the socket&#39;s backlog</span>
<span class="cm"> * queue; in the latter case the queued message is processed once the process</span>
<span class="cm"> * owning the socket lock releases it.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Releasing the socket lock while an operation is sleeping overcomes</span>
<span class="cm"> * the problem of a blocked socket operation preventing any other operations</span>
<span class="cm"> * from occurring.  However, applications must be careful if they have</span>
<span class="cm"> * multiple threads trying to send (or receive) on the same socket, as these</span>
<span class="cm"> * operations might interfere with each other.  For example, doing a connect</span>
<span class="cm"> * and a receive at the same time might allow the receive to consume the</span>
<span class="cm"> * ACK message meant for the connect.  While additional work could be done</span>
<span class="cm"> * to try and overcome this, it doesn&#39;t seem to be worthwhile at the present.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Releasing the socket lock while an operation is sleeping also ensures</span>
<span class="cm"> * that another operation that must be performed in a non-blocking manner is</span>
<span class="cm"> * not delayed for very long because the lock has already been taken.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This code assumes that certain fields of a port/socket pair are</span>
<span class="cm"> * constant over its lifetime; such fields can be examined without taking</span>
<span class="cm"> * the socket lock and/or port lock, and do not need to be re-read even</span>
<span class="cm"> * after resuming processing after waiting.  These fields include:</span>
<span class="cm"> *   - socket type</span>
<span class="cm"> *   - pointer to socket sk structure (aka tipc_sock structure)</span>
<span class="cm"> *   - pointer to port structure</span>
<span class="cm"> *   - port reference</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * advance_rx_queue - discard first buffer in socket receive queue</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold socket lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">advance_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">));</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_queue_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * discard_rx_queue - discard all buffers in socket receive queue</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold socket lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">discard_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">buf</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_queue_size</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * reject_rx_queue - reject all buffers in socket receive queue</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold socket lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reject_rx_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">buf</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">tipc_reject_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">TIPC_ERR_NO_PORT</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_queue_size</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_create - create a TIPC socket</span>
<span class="cm"> * @net: network namespace (must be default network)</span>
<span class="cm"> * @sock: pre-allocated socket structure</span>
<span class="cm"> * @protocol: protocol indicator (must be 0)</span>
<span class="cm"> * @kern: caused by kernel or by userspace?</span>
<span class="cm"> *</span>
<span class="cm"> * This routine creates additional data structures used by the TIPC socket,</span>
<span class="cm"> * initializes them, and links them together.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tipc_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">socket_state</span> <span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tp_ptr</span><span class="p">;</span>

	<span class="cm">/* Validate arguments */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">protocol</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOCK_STREAM</span>:
		<span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">stream_ops</span><span class="p">;</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_SEQPACKET</span>:
		<span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">packet_ops</span><span class="p">;</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_DGRAM</span>:
	<span class="k">case</span> <span class="n">SOCK_RDM</span>:
		<span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">msg_ops</span><span class="p">;</span>
		<span class="n">state</span> <span class="o">=</span> <span class="n">SS_READY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTOTYPE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate socket&#39;s protocol area */</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">sk_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">AF_TIPC</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tipc_proto</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Allocate TIPC port for socket to use */</span>
	<span class="n">tp_ptr</span> <span class="o">=</span> <span class="n">tipc_createport_raw</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dispatch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wakeupdispatch</span><span class="p">,</span>
				     <span class="n">TIPC_LOW_IMPORTANCE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">tp_ptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sk_free</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Finish initializing socket data structures */</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">sock_init_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog_rcv</span> <span class="o">=</span> <span class="n">backlog_rcv</span><span class="p">;</span>
	<span class="n">tipc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">tp_ptr</span><span class="p">;</span>
	<span class="n">tipc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">conn_timeout</span> <span class="o">=</span> <span class="n">CONN_TIMEOUT_DEFAULT</span><span class="p">;</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">tp_ptr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tipc_set_portunreturnable</span><span class="p">(</span><span class="n">tp_ptr</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SOCK_DGRAM</span><span class="p">)</span>
			<span class="n">tipc_set_portunreliable</span><span class="p">(</span><span class="n">tp_ptr</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * release - destroy a TIPC socket</span>
<span class="cm"> * @sock: socket to destroy</span>
<span class="cm"> *</span>
<span class="cm"> * This routine cleans up any messages that are still queued on the socket.</span>
<span class="cm"> * For DGRAM and RDM socket types, all queued messages are rejected.</span>
<span class="cm"> * For SEQPACKET and STREAM socket types, the first message is rejected</span>
<span class="cm"> * and any others are discarded.  (If the first message on a STREAM socket</span>
<span class="cm"> * is partially-read, it is discarded and the next one is rejected instead.)</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: Rejected messages are not necessarily returned to the sender!  They</span>
<span class="cm"> * are returned or discarded according to the &quot;destination droppable&quot; setting</span>
<span class="cm"> * specified for the message by the sender.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">release</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Exit if socket isn&#39;t fully initialized (occurs when a failed accept()</span>
<span class="cm">	 * releases a pre-allocated child socket that was never used)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tport</span> <span class="o">=</span> <span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reject all unreceived messages, except on an active connection</span>
<span class="cm">	 * (which disconnects locally &amp; sends a &#39;FIN+&#39; to peer)</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_DISCONNECTING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_queue_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TIPC_SKB_CB</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_CONNECTING</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_CONNECTED</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_DISCONNECTING</span><span class="p">;</span>
				<span class="n">tipc_disconnect</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">tipc_reject_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">TIPC_ERR_NO_PORT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Delete TIPC port; this ensures no more messages are queued</span>
<span class="cm">	 * (also disconnects an active connection &amp; sends a &#39;FIN-&#39; to peer)</span>
<span class="cm">	 */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_deleteport</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>

	<span class="cm">/* Discard any remaining (connection-based) messages in receive queue */</span>
	<span class="n">discard_rx_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Reject any messages that accumulated in backlog queue */</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_DISCONNECTING</span><span class="p">;</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bind - associate or disassocate TIPC name(s) with a socket</span>
<span class="cm"> * @sock: socket structure</span>
<span class="cm"> * @uaddr: socket address describing name(s) and desired operation</span>
<span class="cm"> * @uaddr_len: size of socket address data structure</span>
<span class="cm"> *</span>
<span class="cm"> * Name and name sequence binding is indicated using a positive scope value;</span>
<span class="cm"> * a negative scope value unbinds the specified name.  Specifying no name</span>
<span class="cm"> * (i.e. a socket address length of 0) unbinds all names from the socket.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This routine doesn&#39;t need to take the socket lock since it doesn&#39;t</span>
<span class="cm"> *       access any non-constant socket information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uaddr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="p">)</span><span class="n">uaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">portref</span> <span class="o">=</span> <span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">uaddr_len</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">tipc_withdraw</span><span class="p">(</span><span class="n">portref</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uaddr_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_tipc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">!=</span> <span class="n">AF_TIPC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">addrtype</span> <span class="o">==</span> <span class="n">TIPC_ADDR_NAME</span><span class="p">)</span>
		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">nameseq</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">nameseq</span><span class="p">.</span><span class="n">lower</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">addrtype</span> <span class="o">!=</span> <span class="n">TIPC_ADDR_NAMESEQ</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">nameseq</span><span class="p">.</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">TIPC_RESERVED_TYPES</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">scope</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">tipc_publish</span><span class="p">(</span><span class="n">portref</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">scope</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">nameseq</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">tipc_withdraw</span><span class="p">(</span><span class="n">portref</span><span class="p">,</span> <span class="o">-</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">scope</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">nameseq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_name - get port ID of socket or peer socket</span>
<span class="cm"> * @sock: socket structure</span>
<span class="cm"> * @uaddr: area for returned socket address</span>
<span class="cm"> * @uaddr_len: area for returned length of socket address</span>
<span class="cm"> * @peer: 0 = own ID, 1 = current peer ID, 2 = current/former peer ID</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: This routine doesn&#39;t need to take the socket lock since it only</span>
<span class="cm"> *       accesses socket information that is unchanging (or which changes in</span>
<span class="cm"> *       a completely predictable manner).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="o">*</span><span class="n">uaddr_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">peer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="p">)</span><span class="n">uaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_sock</span> <span class="o">*</span><span class="n">tsock</span> <span class="o">=</span> <span class="n">tipc_sk</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_CONNECTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">((</span><span class="n">peer</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_DISCONNECTING</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">tsock</span><span class="o">-&gt;</span><span class="n">peer_name</span><span class="p">.</span><span class="n">ref</span><span class="p">;</span>
		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">tsock</span><span class="o">-&gt;</span><span class="n">peer_name</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">tsock</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">;</span>
		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">tipc_own_addr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">uaddr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">addrtype</span> <span class="o">=</span> <span class="n">TIPC_ADDR_ID</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">AF_TIPC</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">scope</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">domain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * poll - read and possibly block on pollmask</span>
<span class="cm"> * @file: file structure associated with the socket</span>
<span class="cm"> * @sock: socket for which to calculate the poll bits</span>
<span class="cm"> * @wait: ???</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pollmask value</span>
<span class="cm"> *</span>
<span class="cm"> * COMMENTARY:</span>
<span class="cm"> * It appears that the usual socket locking mechanisms are not useful here</span>
<span class="cm"> * since the pollmask info is potentially out-of-date the moment this routine</span>
<span class="cm"> * exits.  TCP and other protocols seem to rely on higher level poll routines</span>
<span class="cm"> * to handle any preventable race conditions, so TIPC will do the same ...</span>
<span class="cm"> *</span>
<span class="cm"> * TIPC sets the returned events as follows:</span>
<span class="cm"> *</span>
<span class="cm"> * socket state		flags set</span>
<span class="cm"> * ------------		---------</span>
<span class="cm"> * unconnected		no read flags</span>
<span class="cm"> *			no write flags</span>
<span class="cm"> *</span>
<span class="cm"> * connecting		POLLIN/POLLRDNORM if ACK/NACK in rx queue</span>
<span class="cm"> *			no write flags</span>
<span class="cm"> *</span>
<span class="cm"> * connected		POLLIN/POLLRDNORM if data in rx queue</span>
<span class="cm"> *			POLLOUT if port is not congested</span>
<span class="cm"> *</span>
<span class="cm"> * disconnecting	POLLIN/POLLRDNORM/POLLHUP</span>
<span class="cm"> *			no write flags</span>
<span class="cm"> *</span>
<span class="cm"> * listening		POLLIN if SYN in rx queue</span>
<span class="cm"> *			no write flags</span>
<span class="cm"> *</span>
<span class="cm"> * ready		POLLIN/POLLRDNORM if data in rx queue</span>
<span class="cm"> * [connectionless]	POLLOUT (since port cannot be congested)</span>
<span class="cm"> *</span>
<span class="cm"> * IMPORTANT: The fact that a read or write operation is indicated does NOT</span>
<span class="cm"> * imply that the operation will succeed, merely that it should be performed</span>
<span class="cm"> * and will not block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			 <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">wait</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SS_READY</span>:
	<span class="k">case</span> <span class="n">SS_CONNECTED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">congested</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span><span class="p">;</span>
		<span class="cm">/* fall thru&#39; */</span>
	<span class="k">case</span> <span class="n">SS_CONNECTING</span>:
	<span class="k">case</span> <span class="n">SS_LISTENING</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SS_DISCONNECTING</span>:
		<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dest_name_check - verify user is permitted to send to specified port name</span>
<span class="cm"> * @dest: destination address</span>
<span class="cm"> * @m: descriptor for message to be sent</span>
<span class="cm"> *</span>
<span class="cm"> * Prevents restricted configuration commands from being issued by</span>
<span class="cm"> * unauthorized users.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if permission is granted, otherwise errno</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dest_name_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_cfg_msg_hdr</span> <span class="n">hdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">TIPC_RESERVED_TYPES</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TIPC_TOP_SRV</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">TIPC_CFG_SRV</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">||</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ntohs</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">tcm_type</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xC000</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * send_msg - send message in connectionless manner</span>
<span class="cm"> * @iocb: if NULL, indicates that socket lock is already held</span>
<span class="cm"> * @sock: socket structure</span>
<span class="cm"> * @m: message to send</span>
<span class="cm"> * @total_len: length of message</span>
<span class="cm"> *</span>
<span class="cm"> * Message must have an destination specified explicitly.</span>
<span class="cm"> * Used for SOCK_RDM and SOCK_DGRAM messages,</span>
<span class="cm"> * and for &#39;SYN&#39; messages on SOCK_SEQPACKET and SOCK_STREAM connections.</span>
<span class="cm"> * (Note: &#39;SYN+&#39; is prohibited on SOCK_STREAM.)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes sent on success, or errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">total_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span> <span class="o">=</span> <span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">needs_conn</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeout_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EDESTADDRREQ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dest</span><span class="p">))</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">!=</span> <span class="n">AF_TIPC</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">total_len</span> <span class="o">&gt;</span> <span class="n">TIPC_MAX_USER_MSG_SIZE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">INT_MAX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="p">)</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">needs_conn</span> <span class="o">=</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_READY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">needs_conn</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_LISTENING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_UNCONNECTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">published</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">total_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addrtype</span> <span class="o">==</span> <span class="n">TIPC_ADDR_NAME</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tport</span><span class="o">-&gt;</span><span class="n">conn_type</span> <span class="o">=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
			<span class="n">tport</span><span class="o">-&gt;</span><span class="n">conn_instance</span> <span class="o">=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Abort any pending connection attempts (very unlikely) */</span>
		<span class="n">reject_rx_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">timeout_val</span> <span class="o">=</span> <span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addrtype</span> <span class="o">==</span> <span class="n">TIPC_ADDR_NAME</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">dest_name_check</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_send2name</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
					     <span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">domain</span><span class="p">,</span>
					     <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span><span class="p">,</span>
					     <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span>
					     <span class="n">total_len</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addrtype</span> <span class="o">==</span> <span class="n">TIPC_ADDR_ID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_send2port</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
					     <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span><span class="p">,</span>
					     <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span>
					     <span class="n">total_len</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addrtype</span> <span class="o">==</span> <span class="n">TIPC_ADDR_MCAST</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">needs_conn</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">dest_name_check</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_multicast</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">nameseq</span><span class="p">,</span>
					     <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span><span class="p">,</span>
					     <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span>
					     <span class="n">total_len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ELINKCONG</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">needs_conn</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTING</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout_val</span> <span class="o">&lt;=</span> <span class="mi">0L</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">timeout_val</span> <span class="o">?</span> <span class="n">timeout_val</span> <span class="o">:</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">timeout_val</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="o">*</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
					       <span class="o">!</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">congested</span><span class="p">,</span> <span class="n">timeout_val</span><span class="p">);</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="nl">exit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="p">)</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * send_packet - send a connection-oriented message</span>
<span class="cm"> * @iocb: if NULL, indicates that socket lock is already held</span>
<span class="cm"> * @sock: socket structure</span>
<span class="cm"> * @m: message to send</span>
<span class="cm"> * @total_len: length of message</span>
<span class="cm"> *</span>
<span class="cm"> * Used for SOCK_SEQPACKET messages and SOCK_STREAM data.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes sent on success, or errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">total_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span> <span class="o">=</span> <span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeout_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/* Handle implied connection establishment */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dest</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">send_msg</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">total_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">total_len</span> <span class="o">&gt;</span> <span class="n">TIPC_MAX_USER_MSG_SIZE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">INT_MAX</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="p">)</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">timeout_val</span> <span class="o">=</span> <span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_CONNECTED</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_DISCONNECTING</span><span class="p">)</span>
				<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_send</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span>
				<span class="n">total_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ELINKCONG</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout_val</span> <span class="o">&lt;=</span> <span class="mi">0L</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">timeout_val</span> <span class="o">?</span> <span class="n">timeout_val</span> <span class="o">:</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">timeout_val</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="o">*</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
			<span class="p">(</span><span class="o">!</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">congested</span> <span class="o">||</span> <span class="o">!</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">connected</span><span class="p">),</span> <span class="n">timeout_val</span><span class="p">);</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="p">)</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * send_stream - send stream-oriented data</span>
<span class="cm"> * @iocb: (unused)</span>
<span class="cm"> * @sock: socket structure</span>
<span class="cm"> * @m: data to send</span>
<span class="cm"> * @total_len: total length of data to be sent</span>
<span class="cm"> *</span>
<span class="cm"> * Used for SOCK_STREAM data.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes sent on success (or partial success),</span>
<span class="cm"> * or errno if no data sent</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">send_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">total_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span> <span class="o">=</span> <span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">my_msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">my_iov</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">curr_iov</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">curr_iovlen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">curr_start</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">hdr_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">curr_left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes_to_send</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes_sent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Handle special cases where there is no connection */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_CONNECTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_UNCONNECTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">send_packet</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">total_len</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_DISCONNECTING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">total_len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">INT_MAX</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">INT_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Send each iovec entry using one or more messages</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: This algorithm is good for the most likely case</span>
<span class="cm">	 * (i.e. one large iovec entry), but could be improved to pass sets</span>
<span class="cm">	 * of small iovec entries into send_packet().</span>
<span class="cm">	 */</span>
	<span class="n">curr_iov</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">;</span>
	<span class="n">curr_iovlen</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span><span class="p">;</span>
	<span class="n">my_msg</span><span class="p">.</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_iov</span><span class="p">;</span>
	<span class="n">my_msg</span><span class="p">.</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">my_msg</span><span class="p">.</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="p">;</span>
	<span class="n">my_msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bytes_sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hdr_size</span> <span class="o">=</span> <span class="n">msg_hdr_sz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">phdr</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">curr_iovlen</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_start</span> <span class="o">=</span> <span class="n">curr_iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
		<span class="n">curr_left</span> <span class="o">=</span> <span class="n">curr_iov</span><span class="o">-&gt;</span><span class="n">iov_len</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">curr_left</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bytes_to_send</span> <span class="o">=</span> <span class="n">tport</span><span class="o">-&gt;</span><span class="n">max_pkt</span> <span class="o">-</span> <span class="n">hdr_size</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes_to_send</span> <span class="o">&gt;</span> <span class="n">TIPC_MAX_USER_MSG_SIZE</span><span class="p">)</span>
				<span class="n">bytes_to_send</span> <span class="o">=</span> <span class="n">TIPC_MAX_USER_MSG_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">curr_left</span> <span class="o">&lt;</span> <span class="n">bytes_to_send</span><span class="p">)</span>
				<span class="n">bytes_to_send</span> <span class="o">=</span> <span class="n">curr_left</span><span class="p">;</span>
			<span class="n">my_iov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">curr_start</span><span class="p">;</span>
			<span class="n">my_iov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">bytes_to_send</span><span class="p">;</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">send_packet</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_msg</span><span class="p">,</span> <span class="n">bytes_to_send</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bytes_sent</span><span class="p">)</span>
					<span class="n">res</span> <span class="o">=</span> <span class="n">bytes_sent</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">curr_left</span> <span class="o">-=</span> <span class="n">bytes_to_send</span><span class="p">;</span>
			<span class="n">curr_start</span> <span class="o">+=</span> <span class="n">bytes_to_send</span><span class="p">;</span>
			<span class="n">bytes_sent</span> <span class="o">+=</span> <span class="n">bytes_to_send</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">curr_iov</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">bytes_sent</span><span class="p">;</span>
<span class="nl">exit:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * auto_connect - complete connection setup to a remote port</span>
<span class="cm"> * @sock: socket structure</span>
<span class="cm"> * @msg: peer&#39;s response message</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">auto_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tipc_sock</span> <span class="o">*</span><span class="n">tsock</span> <span class="o">=</span> <span class="n">tipc_sk</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg_errcode</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_DISCONNECTING</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tsock</span><span class="o">-&gt;</span><span class="n">peer_name</span><span class="p">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">msg_origport</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">tsock</span><span class="o">-&gt;</span><span class="n">peer_name</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">msg_orignode</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">tipc_connect2port</span><span class="p">(</span><span class="n">tsock</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tsock</span><span class="o">-&gt;</span><span class="n">peer_name</span><span class="p">);</span>
	<span class="n">tipc_set_portimportance</span><span class="p">(</span><span class="n">tsock</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">msg_importance</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * set_orig_addr - capture sender&#39;s address for received message</span>
<span class="cm"> * @m: descriptor for message info</span>
<span class="cm"> * @msg: received message header</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Address is not captured if not requested by receiver.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_orig_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">=</span> <span class="n">AF_TIPC</span><span class="p">;</span>
		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">addrtype</span> <span class="o">=</span> <span class="n">TIPC_ADDR_ID</span><span class="p">;</span>
		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">msg_origport</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">msg_orignode</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">domain</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* could leave uninitialized */</span>
		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">scope</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* could leave uninitialized */</span>
		<span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_tipc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * anc_data_recv - optionally capture ancillary data for received message</span>
<span class="cm"> * @m: descriptor for message info</span>
<span class="cm"> * @msg: received message header</span>
<span class="cm"> * @tport: TIPC port associated with message</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Ancillary data is not captured if not requested by receiver.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if successful, otherwise errno</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">anc_data_recv</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">anc_data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dest_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">has_name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_controllen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Optionally capture errored message object(s) */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">?</span> <span class="n">msg_errcode</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">anc_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">anc_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg_data_sz</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">put_cmsg</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">SOL_TIPC</span><span class="p">,</span> <span class="n">TIPC_ERRINFO</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">anc_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">anc_data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">put_cmsg</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">SOL_TIPC</span><span class="p">,</span> <span class="n">TIPC_RETDATA</span><span class="p">,</span> <span class="n">anc_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
				       <span class="n">msg_data</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Optionally capture message destination object */</span>
	<span class="n">dest_type</span> <span class="o">=</span> <span class="n">msg</span> <span class="o">?</span> <span class="n">msg_type</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">:</span> <span class="n">TIPC_DIRECT_MSG</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dest_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIPC_NAMED_MSG</span>:
		<span class="n">has_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">anc_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg_nametype</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">anc_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg_namelower</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">anc_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg_namelower</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIPC_MCAST_MSG</span>:
		<span class="n">has_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">anc_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg_nametype</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">anc_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg_namelower</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">anc_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg_nameupper</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIPC_CONN_MSG</span>:
		<span class="n">has_name</span> <span class="o">=</span> <span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">conn_type</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">anc_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tport</span><span class="o">-&gt;</span><span class="n">conn_type</span><span class="p">;</span>
		<span class="n">anc_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tport</span><span class="o">-&gt;</span><span class="n">conn_instance</span><span class="p">;</span>
		<span class="n">anc_data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tport</span><span class="o">-&gt;</span><span class="n">conn_instance</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">has_name</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">put_cmsg</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">SOL_TIPC</span><span class="p">,</span> <span class="n">TIPC_DESTNAME</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">anc_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * recv_msg - receive packet-oriented message</span>
<span class="cm"> * @iocb: (unused)</span>
<span class="cm"> * @m: descriptor for message info</span>
<span class="cm"> * @buf_len: total size of user buffer area</span>
<span class="cm"> * @flags: receive flags</span>
<span class="cm"> *</span>
<span class="cm"> * Used for SOCK_DGRAM, SOCK_RDM, and SOCK_SEQPACKET messages.</span>
<span class="cm"> * If the complete message doesn&#39;t fit in user area, truncate it.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns size of returned message data, errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">recv_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span> <span class="o">=</span> <span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/* Catch invalid receive requests */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buf_len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_UNCONNECTED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">sock_rcvtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>
<span class="nl">restart:</span>

	<span class="cm">/* Look for a message in receive queue; wait if necessary */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_DISCONNECTING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;=</span> <span class="mi">0L</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">?</span> <span class="n">timeout</span> <span class="o">:</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="o">*</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
							   <span class="n">tipc_rx_ready</span><span class="p">(</span><span class="n">sock</span><span class="p">),</span>
							   <span class="n">timeout</span><span class="p">);</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Look at first message in receive queue */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">buf_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">sz</span> <span class="o">=</span> <span class="n">msg_data_sz</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">msg_errcode</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* Complete connection setup for an implied connect */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_CONNECTING</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">auto_connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Discard an empty non-errored message &amp; try again */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">sz</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">advance_rx_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Capture sender&#39;s address (optional) */</span>
	<span class="n">set_orig_addr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* Capture ancillary data (optional) */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">anc_data_recv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">tport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="cm">/* Capture message data (if valid) &amp; compute return value (always) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buf_len</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sz</span> <span class="o">=</span> <span class="n">buf_len</span><span class="p">;</span>
			<span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_TRUNC</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">msg_hdr_sz</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span>
					      <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_READY</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">err</span> <span class="o">==</span> <span class="n">TIPC_CONN_SHUTDOWN</span><span class="p">)</span> <span class="o">||</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_control</span><span class="p">))</span>
			<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Consume received message (optional) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_READY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">++</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">conn_unacked</span> <span class="o">&gt;=</span> <span class="n">TIPC_FLOW_CONTROL_WIN</span><span class="p">))</span>
			<span class="n">tipc_acknowledge</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">tport</span><span class="o">-&gt;</span><span class="n">conn_unacked</span><span class="p">);</span>
		<span class="n">advance_rx_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * recv_stream - receive stream-oriented data</span>
<span class="cm"> * @iocb: (unused)</span>
<span class="cm"> * @m: descriptor for message info</span>
<span class="cm"> * @buf_len: total size of user buffer area</span>
<span class="cm"> * @flags: receive flags</span>
<span class="cm"> *</span>
<span class="cm"> * Used for SOCK_STREAM messages only.  If not enough data is available</span>
<span class="cm"> * will optionally wait for more; never truncates data.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns size of returned message data, errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">recv_stream</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">buf_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span> <span class="o">=</span> <span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sz_to_copy</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">needed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sz_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Catch invalid receive attempts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buf_len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_UNCONNECTED</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_CONNECTING</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">target</span> <span class="o">=</span> <span class="n">sock_rcvlowat</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_WAITALL</span><span class="p">,</span> <span class="n">buf_len</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">sock_rcvtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>

<span class="nl">restart:</span>
	<span class="cm">/* Look for a message in receive queue; wait if necessary */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_DISCONNECTING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;=</span> <span class="mi">0L</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">?</span> <span class="n">timeout</span> <span class="o">:</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="o">*</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
							   <span class="n">tipc_rx_ready</span><span class="p">(</span><span class="n">sock</span><span class="p">),</span>
							   <span class="n">timeout</span><span class="p">);</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Look at first message in receive queue */</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="n">buf_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">sz</span> <span class="o">=</span> <span class="n">msg_data_sz</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">msg_errcode</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* Discard an empty non-errored message &amp; try again */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">sz</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">advance_rx_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Optionally capture sender&#39;s address &amp; ancillary data of first msg */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sz_copied</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_orig_addr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">anc_data_recv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">tport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Capture message data (if valid) &amp; compute return value (always) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">TIPC_SKB_CB</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">);</span>

		<span class="n">sz</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">needed</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf_len</span> <span class="o">-</span> <span class="n">sz_copied</span><span class="p">);</span>
		<span class="n">sz_to_copy</span> <span class="o">=</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&lt;=</span> <span class="n">needed</span><span class="p">)</span> <span class="o">?</span> <span class="n">sz</span> <span class="o">:</span> <span class="n">needed</span><span class="p">;</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">msg_hdr_sz</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
					      <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">sz_to_copy</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

		<span class="n">sz_copied</span> <span class="o">+=</span> <span class="n">sz_to_copy</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sz_to_copy</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span>
				<span class="n">TIPC_SKB_CB</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">sz_to_copy</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sz_copied</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span> <span class="cm">/* can&#39;t add error msg to valid data */</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">err</span> <span class="o">==</span> <span class="n">TIPC_CONN_SHUTDOWN</span><span class="p">)</span> <span class="o">||</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">msg_control</span><span class="p">)</span>
			<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Consume received message (optional) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">++</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">conn_unacked</span> <span class="o">&gt;=</span> <span class="n">TIPC_FLOW_CONTROL_WIN</span><span class="p">))</span>
			<span class="n">tipc_acknowledge</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">tport</span><span class="o">-&gt;</span><span class="n">conn_unacked</span><span class="p">);</span>
		<span class="n">advance_rx_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Loop around if more data is required */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sz_copied</span> <span class="o">&lt;</span> <span class="n">buf_len</span><span class="p">)</span> <span class="o">&amp;&amp;</span>	<span class="cm">/* didn&#39;t get all requested data */</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sz_copied</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">))</span> <span class="o">&amp;&amp;</span>	<span class="cm">/* and more is ready or required */</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span> <span class="o">&amp;&amp;</span>	<span class="cm">/* and aren&#39;t just peeking at data */</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span>			<span class="cm">/* and haven&#39;t reached a FIN */</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>

<span class="nl">exit:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sz_copied</span> <span class="o">?</span> <span class="n">sz_copied</span> <span class="o">:</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * rx_queue_full - determine if receive queue can accept another message</span>
<span class="cm"> * @msg: message to be added to queue</span>
<span class="cm"> * @queue_size: current size of queue</span>
<span class="cm"> * @base: nominal maximum size of queue</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if queue is unable to accept message, 0 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">rx_queue_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">u32</span> <span class="n">queue_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">threshold</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">imp</span> <span class="o">=</span> <span class="n">msg_importance</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">imp</span> <span class="o">==</span> <span class="n">TIPC_LOW_IMPORTANCE</span><span class="p">)</span>
		<span class="n">threshold</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">imp</span> <span class="o">==</span> <span class="n">TIPC_MEDIUM_IMPORTANCE</span><span class="p">)</span>
		<span class="n">threshold</span> <span class="o">=</span> <span class="n">base</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">imp</span> <span class="o">==</span> <span class="n">TIPC_HIGH_IMPORTANCE</span><span class="p">)</span>
		<span class="n">threshold</span> <span class="o">=</span> <span class="n">base</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg_connected</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
		<span class="n">threshold</span> <span class="o">*=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">queue_size</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * filter_rcv - validate incoming message</span>
<span class="cm"> * @sk: socket</span>
<span class="cm"> * @buf: message</span>
<span class="cm"> *</span>
<span class="cm"> * Enqueues message on receive queue if acceptable; optionally handles</span>
<span class="cm"> * disconnect indication for a connected socket.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with socket lock already taken; port lock may also be taken.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns TIPC error status code (TIPC_OK if message is not to be rejected)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">filter_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">buf_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">recv_q_len</span><span class="p">;</span>

	<span class="cm">/* Reject message if it is wrong sort of message for socket */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg_type</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">TIPC_DIRECT_MSG</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">TIPC_ERR_NO_PORT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_connected</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">TIPC_ERR_NO_PORT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_mcast</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">TIPC_ERR_NO_PORT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg_connected</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">tipc_port_peer_msg</span><span class="p">(</span><span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">msg</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">TIPC_ERR_NO_PORT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_CONNECTING</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg_connected</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">msg_errcode</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">TIPC_ERR_NO_PORT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_LISTENING</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">msg_connected</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">||</span> <span class="n">msg_errcode</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">TIPC_ERR_NO_PORT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_DISCONNECTING</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">TIPC_ERR_NO_PORT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="cm">/* (sock-&gt;state == SS_UNCONNECTED) */</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">msg_connected</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">||</span> <span class="n">msg_errcode</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">TIPC_ERR_NO_PORT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Reject message if there isn&#39;t room to queue it */</span>
	<span class="n">recv_q_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_queue_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">recv_q_len</span> <span class="o">&gt;=</span> <span class="n">OVERLOAD_LIMIT_BASE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_queue_full</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">recv_q_len</span><span class="p">,</span> <span class="n">OVERLOAD_LIMIT_BASE</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">TIPC_ERR_OVERLOAD</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">recv_q_len</span> <span class="o">=</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">recv_q_len</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">OVERLOAD_LIMIT_BASE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rx_queue_full</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">recv_q_len</span><span class="p">,</span> <span class="n">OVERLOAD_LIMIT_BASE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">TIPC_ERR_OVERLOAD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enqueue message (finally!) */</span>
	<span class="n">TIPC_SKB_CB</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_queue_size</span><span class="p">);</span>
	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="cm">/* Initiate connection termination for an incoming &#39;FIN&#39; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">msg_errcode</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_CONNECTED</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_DISCONNECTING</span><span class="p">;</span>
		<span class="n">tipc_disconnect_port</span><span class="p">(</span><span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">TIPC_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * backlog_rcv - handle incoming message from backlog queue</span>
<span class="cm"> * @sk: socket</span>
<span class="cm"> * @buf: message</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must hold socket lock, but not port lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">backlog_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">filter_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="n">tipc_reject_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dispatch - handle incoming message</span>
<span class="cm"> * @tport: TIPC port that received message</span>
<span class="cm"> * @buf: message</span>
<span class="cm"> *</span>
<span class="cm"> * Called with port lock already taken.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns TIPC error status code (TIPC_OK if message is not to be rejected)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">dispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">usr_handle</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Process message if socket is unlocked; otherwise add to backlog queue</span>
<span class="cm">	 *</span>
<span class="cm">	 * This code is based on sk_receive_skb(), but must be distinct from it</span>
<span class="cm">	 * since a TIPC-specific filter/reject mechanism is utilized</span>
<span class="cm">	 */</span>
	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">filter_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk_add_backlog</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">))</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">TIPC_ERR_OVERLOAD</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">TIPC_OK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * wakeupdispatch - wake up port after congestion</span>
<span class="cm"> * @tport: port to wakeup</span>
<span class="cm"> *</span>
<span class="cm"> * Called with port lock already taken.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wakeupdispatch</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">usr_handle</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * connect - establish a connection to another TIPC port</span>
<span class="cm"> * @sock: socket structure</span>
<span class="cm"> * @dest: socket address for destination port</span>
<span class="cm"> * @destlen: size of socket address data structure</span>
<span class="cm"> * @flags: file-related flags associated with socket</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">destlen</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_tipc</span> <span class="o">*</span><span class="p">)</span><span class="n">dest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">,};</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* For now, TIPC does not allow use of connect() with DGRAM/RDM types */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* For now, TIPC does not support the non-blocking form of connect() */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Issue Posix-compliant error code if socket is in the wrong state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_LISTENING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_CONNECTING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EALREADY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_UNCONNECTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reject connection attempt using multicast address</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: send_msg() validates the rest of the address fields,</span>
<span class="cm">	 *       so there&#39;s no need to do it here</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">addrtype</span> <span class="o">==</span> <span class="n">TIPC_ADDR_MCAST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reject any messages already in receive queue (very unlikely) */</span>
	<span class="n">reject_rx_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Send a &#39;SYN-&#39; to destination */</span>
	<span class="n">m</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
	<span class="n">m</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="n">destlen</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">send_msg</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>

	<span class="cm">/* Wait until an &#39;ACK&#39; or &#39;RST&#39; arrives, or a timeout occurs */</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">tipc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">conn_timeout</span><span class="p">;</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="o">*</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
			<span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_CONNECTING</span><span class="p">)),</span>
			<span class="n">timeout</span> <span class="o">?</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
				<span class="o">:</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">);</span>
	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msg</span> <span class="o">=</span> <span class="n">buf_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">auto_connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg_data_sz</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
					<span class="n">advance_rx_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">SS_CONNECTED</span><span class="p">)</span>
				<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="p">;</span> <span class="cm">/* leave &quot;res&quot; unchanged */</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_DISCONNECTING</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">exit:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * listen - allow socket to listen for incoming connections</span>
<span class="cm"> * @sock: socket structure</span>
<span class="cm"> * @len: (unused)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_UNCONNECTED</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_LISTENING</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * accept - wait for connection request</span>
<span class="cm"> * @sock: listening socket</span>
<span class="cm"> * @newsock: new socket that is to be connected</span>
<span class="cm"> * @flags: file-related flags associated with socket</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">new_sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SS_LISTENING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="o">*</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span>
				<span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)));</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_create</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">),</span> <span class="n">new_sock</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">new_sk</span> <span class="o">=</span> <span class="n">new_sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">tipc_sock</span> <span class="o">*</span><span class="n">new_tsock</span> <span class="o">=</span> <span class="n">tipc_sk</span><span class="p">(</span><span class="n">new_sk</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">new_tport</span> <span class="o">=</span> <span class="n">new_tsock</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">new_ref</span> <span class="o">=</span> <span class="n">new_tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">tipc_msg</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">buf_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

		<span class="n">lock_sock</span><span class="p">(</span><span class="n">new_sk</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Reject any stray messages received by new socket</span>
<span class="cm">		 * before the socket lock was taken (very, very unlikely)</span>
<span class="cm">		 */</span>
		<span class="n">reject_rx_queue</span><span class="p">(</span><span class="n">new_sk</span><span class="p">);</span>

		<span class="cm">/* Connect new socket to it&#39;s peer */</span>
		<span class="n">new_tsock</span><span class="o">-&gt;</span><span class="n">peer_name</span><span class="p">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">msg_origport</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">new_tsock</span><span class="o">-&gt;</span><span class="n">peer_name</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">msg_orignode</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">tipc_connect2port</span><span class="p">(</span><span class="n">new_ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_tsock</span><span class="o">-&gt;</span><span class="n">peer_name</span><span class="p">);</span>
		<span class="n">new_sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>

		<span class="n">tipc_set_portimportance</span><span class="p">(</span><span class="n">new_ref</span><span class="p">,</span> <span class="n">msg_importance</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_named</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">new_tport</span><span class="o">-&gt;</span><span class="n">conn_type</span> <span class="o">=</span> <span class="n">msg_nametype</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
			<span class="n">new_tport</span><span class="o">-&gt;</span><span class="n">conn_instance</span> <span class="o">=</span> <span class="n">msg_nameinst</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Respond to &#39;SYN-&#39; by discarding it &amp; returning &#39;ACK&#39;-.</span>
<span class="cm">		 * Respond to &#39;SYN+&#39; by queuing it on new socket.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg_data_sz</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">,};</span>

			<span class="n">advance_rx_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">send_packet</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">new_sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
			<span class="n">__skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">new_sk</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">exit:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * shutdown - shutdown socket connection</span>
<span class="cm"> * @sock: socket structure</span>
<span class="cm"> * @how: direction to close (must be SHUT_RDWR)</span>
<span class="cm"> *</span>
<span class="cm"> * Terminates connection (if necessary), then purges socket&#39;s receive queue.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span> <span class="o">=</span> <span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">how</span> <span class="o">!=</span> <span class="n">SHUT_RDWR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SS_CONNECTING</span>:
	<span class="k">case</span> <span class="n">SS_CONNECTED</span>:

<span class="nl">restart:</span>
		<span class="cm">/* Disconnect and send a &#39;FIN+&#39; or &#39;FIN-&#39; message to peer */</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_queue_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">TIPC_SKB_CB</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">handle</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">tipc_disconnect</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
			<span class="n">tipc_reject_msg</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">TIPC_CONN_SHUTDOWN</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tipc_shutdown</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_DISCONNECTING</span><span class="p">;</span>

		<span class="cm">/* fall through */</span>

	<span class="k">case</span> <span class="n">SS_DISCONNECTING</span>:

		<span class="cm">/* Discard any unreceived messages; wake up sleeping tasks */</span>
		<span class="n">discard_rx_queue</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
		<span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * setsockopt - set socket option</span>
<span class="cm"> * @sock: socket structure</span>
<span class="cm"> * @lvl: option level</span>
<span class="cm"> * @opt: option identifier</span>
<span class="cm"> * @ov: pointer to new option value</span>
<span class="cm"> * @ol: length of option value</span>
<span class="cm"> *</span>
<span class="cm"> * For stream sockets only, accepts and ignores all IPPROTO_TCP options</span>
<span class="cm"> * (to ease compatibility).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">lvl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opt</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ov</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span> <span class="o">=</span> <span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">lvl</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lvl</span> <span class="o">!=</span> <span class="n">SOL_TIPC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ol</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">ov</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">opt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIPC_IMPORTANCE</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_set_portimportance</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIPC_SRC_DROPPABLE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_set_portunreliable</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIPC_DEST_DROPPABLE</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_set_portunreturnable</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIPC_CONN_TIMEOUT</span>:
		<span class="n">tipc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">conn_timeout</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
		<span class="cm">/* no need to set &quot;res&quot;, since already 0 at this point */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * getsockopt - get socket option</span>
<span class="cm"> * @sock: socket structure</span>
<span class="cm"> * @lvl: option level</span>
<span class="cm"> * @opt: option identifier</span>
<span class="cm"> * @ov: receptacle for option value</span>
<span class="cm"> * @ol: receptacle for length of option value</span>
<span class="cm"> *</span>
<span class="cm"> * For stream sockets only, returns 0 length result for all IPPROTO_TCP options</span>
<span class="cm"> * (to ease compatibility).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">lvl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opt</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tipc_port</span> <span class="o">*</span><span class="n">tport</span> <span class="o">=</span> <span class="n">tipc_sk_port</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">lvl</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lvl</span> <span class="o">!=</span> <span class="n">SOL_TIPC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">opt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TIPC_IMPORTANCE</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_portimportance</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIPC_SRC_DROPPABLE</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_portunreliable</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIPC_DEST_DROPPABLE</span>:
		<span class="n">res</span> <span class="o">=</span> <span class="n">tipc_portunreturnable</span><span class="p">(</span><span class="n">tport</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIPC_CONN_TIMEOUT</span>:
		<span class="n">value</span> <span class="o">=</span> <span class="n">tipc_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">conn_timeout</span><span class="p">;</span>
		<span class="cm">/* no need to set &quot;res&quot;, since already 0 at this point */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIPC_NODE_RECVQ_DEPTH</span>:
		<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_queue_size</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TIPC_SOCK_RECVQ_DEPTH</span>:
		<span class="n">value</span> <span class="o">=</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>	<span class="cm">/* &quot;get&quot; failed */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">ov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">ol</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Protocol switches for the various types of TIPC sockets</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">msg_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">family</span>		<span class="o">=</span> <span class="n">AF_TIPC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>	<span class="o">=</span> <span class="n">connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span>	<span class="o">=</span> <span class="n">sock_no_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span>		<span class="o">=</span> <span class="n">sock_no_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span>	<span class="o">=</span> <span class="n">get_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">sock_no_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listen</span>		<span class="o">=</span> <span class="n">sock_no_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span>	<span class="o">=</span> <span class="n">setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span>	<span class="o">=</span> <span class="n">getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span>	<span class="o">=</span> <span class="n">send_msg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span>	<span class="o">=</span> <span class="n">recv_msg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span>	<span class="o">=</span> <span class="n">sock_no_sendpage</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">packet_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">family</span>		<span class="o">=</span> <span class="n">AF_TIPC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>	<span class="o">=</span> <span class="n">connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span>	<span class="o">=</span> <span class="n">sock_no_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span>		<span class="o">=</span> <span class="n">accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span>	<span class="o">=</span> <span class="n">get_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">sock_no_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listen</span>		<span class="o">=</span> <span class="n">listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span>	<span class="o">=</span> <span class="n">setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span>	<span class="o">=</span> <span class="n">getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span>	<span class="o">=</span> <span class="n">send_packet</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span>	<span class="o">=</span> <span class="n">recv_msg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span>	<span class="o">=</span> <span class="n">sock_no_sendpage</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">stream_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">family</span>		<span class="o">=</span> <span class="n">AF_TIPC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>	<span class="o">=</span> <span class="n">connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span>	<span class="o">=</span> <span class="n">sock_no_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span>		<span class="o">=</span> <span class="n">accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span>	<span class="o">=</span> <span class="n">get_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">sock_no_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listen</span>		<span class="o">=</span> <span class="n">listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span>	<span class="o">=</span> <span class="n">setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span>	<span class="o">=</span> <span class="n">getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span>	<span class="o">=</span> <span class="n">send_stream</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span>	<span class="o">=</span> <span class="n">recv_stream</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span>	<span class="o">=</span> <span class="n">sock_no_sendpage</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_proto_family</span> <span class="n">tipc_family_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">family</span>		<span class="o">=</span> <span class="n">AF_TIPC</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span>		<span class="o">=</span> <span class="n">tipc_create</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proto</span> <span class="n">tipc_proto</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;TIPC&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">obj_size</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tipc_sock</span><span class="p">)</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_socket_init - initialize TIPC socket interface</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, errno otherwise</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tipc_socket_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">proto_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_proto</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span><span class="p">(</span><span class="s">&quot;Failed to register TIPC protocol type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">res</span> <span class="o">=</span> <span class="n">sock_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_family_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span><span class="p">(</span><span class="s">&quot;Failed to register TIPC socket type</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">proto_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_proto</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sockets_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tipc_socket_stop - stop TIPC socket interface</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tipc_socket_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sockets_enabled</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sockets_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sock_unregister</span><span class="p">(</span><span class="n">tipc_family_ops</span><span class="p">.</span><span class="n">family</span><span class="p">);</span>
	<span class="n">proto_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tipc_proto</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
