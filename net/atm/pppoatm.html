<!DOCTYPE html>
<html><head><title>joekychen/linux » net › atm › pppoatm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pppoatm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* net/atm/pppoatm.c - RFC2364 PPP over ATM/AAL5 */</span>

<span class="cm">/* Copyright 1999-2000 by Mitchell Blank Jr */</span>
<span class="cm">/* Based on clip.c; 1995-1999 by Werner Almesberger, EPFL LRC/ICA */</span>
<span class="cm">/* And on ppp_async.c; Copyright 1999 Paul Mackerras */</span>
<span class="cm">/* And help from Jens Axboe */</span>

<span class="cm">/*</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or</span>
<span class="cm"> *  modify it under the terms of the GNU General Public License</span>
<span class="cm"> *  as published by the Free Software Foundation; either version</span>
<span class="cm"> *  2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver provides the encapsulation and framing for sending</span>
<span class="cm"> * and receiving PPP frames in ATM AAL5 PDUs.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * One shortcoming of this driver is that it does not comply with</span>
<span class="cm"> * section 8 of RFC2364 - we are supposed to detect a change</span>
<span class="cm"> * in encapsulation and immediately abort the connection (in order</span>
<span class="cm"> * to avoid a black-hole being created if our peer loses state</span>
<span class="cm"> * and changes encapsulation unilaterally.  However, since the</span>
<span class="cm"> * ppp_generic layer actually does the decapsulation, we need</span>
<span class="cm"> * a way of notifying it when we _think_ there might be a problem)</span>
<span class="cm"> * There&#39;s two cases:</span>
<span class="cm"> *   1.	LLC-encapsulation was missing when it was enabled.  In</span>
<span class="cm"> *	this case, we should tell the upper layer &quot;tear down</span>
<span class="cm"> *	this session if this skb looks ok to you&quot;</span>
<span class="cm"> *   2.	LLC-encapsulation was present when it was disabled.  Then</span>
<span class="cm"> *	we need to tell the upper layer &quot;this packet may be</span>
<span class="cm"> *	ok, but if its in error tear down the session&quot;</span>
<span class="cm"> * These hooks are not yet available in ppp_generic</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;:%s: &quot; fmt, __func__</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/atm.h&gt;</span>
<span class="cp">#include &lt;linux/atmdev.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/ppp_defs.h&gt;</span>
<span class="cp">#include &lt;linux/ppp-ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/ppp_channel.h&gt;</span>
<span class="cp">#include &lt;linux/atmppp.h&gt;</span>

<span class="cp">#include &quot;common.h&quot;</span>

<span class="k">enum</span> <span class="n">pppoatm_encaps</span> <span class="p">{</span>
	<span class="n">e_autodetect</span> <span class="o">=</span> <span class="n">PPPOATM_ENCAPS_AUTODETECT</span><span class="p">,</span>
	<span class="n">e_vc</span> <span class="o">=</span> <span class="n">PPPOATM_ENCAPS_VC</span><span class="p">,</span>
	<span class="n">e_llc</span> <span class="o">=</span> <span class="n">PPPOATM_ENCAPS_LLC</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pppoatm_vcc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">atm_vcc</span>	<span class="o">*</span><span class="n">atmvcc</span><span class="p">;</span>	<span class="cm">/* VCC descriptor */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">old_push</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">old_pop</span><span class="p">)(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
					<span class="cm">/* keep old push/pop for detaching */</span>
	<span class="k">enum</span> <span class="n">pppoatm_encaps</span> <span class="n">encaps</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">inflight</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blocked</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>			<span class="cm">/* SC_COMP_PROT - compress protocol */</span>
	<span class="k">struct</span> <span class="n">ppp_channel</span> <span class="n">chan</span><span class="p">;</span>	<span class="cm">/* interface to generic ppp layer */</span>
	<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">wakeup_tasklet</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * We want to allow two packets in the queue. The one that&#39;s currently in</span>
<span class="cm"> * flight, and *one* queued up ready for the ATM device to send immediately</span>
<span class="cm"> * from its TX done IRQ. We want to be able to use atomic_inc_not_zero(), so</span>
<span class="cm"> * inflight == -2 represents an empty queue, -1 one packet, and zero means</span>
<span class="cm"> * there are two packets in the queue.</span>
<span class="cm"> */</span>
<span class="cp">#define NONE_INFLIGHT -2</span>

<span class="cp">#define BLOCKED 0</span>

<span class="cm">/*</span>
<span class="cm"> * Header used for LLC Encapsulated PPP (4 bytes) followed by the LCP protocol</span>
<span class="cm"> * ID (0xC021) used in autodetection</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pppllc</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mh">0xFE</span><span class="p">,</span> <span class="mh">0xFE</span><span class="p">,</span> <span class="mh">0x03</span><span class="p">,</span> <span class="mh">0xCF</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">,</span> <span class="mh">0x21</span> <span class="p">};</span>
<span class="cp">#define LLC_LEN		(4)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pppoatm_vcc</span> <span class="o">*</span><span class="nf">atmvcc_to_pvcc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">atmvcc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pppoatm_vcc</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">user_back</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">pppoatm_vcc</span> <span class="o">*</span><span class="nf">chan_to_pvcc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ppp_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pppoatm_vcc</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">chan</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We can&#39;t do this directly from our _pop handler, since the ppp code</span>
<span class="cm"> * doesn&#39;t want to be called in interrupt context, so we do it from</span>
<span class="cm"> * a tasklet</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pppoatm_wakeup_sender</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ppp_output_wakeup</span><span class="p">((</span><span class="k">struct</span> <span class="n">ppp_channel</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This gets called every time the ATM card has finished sending our</span>
<span class="cm"> * skb.  The -&gt;old_pop will take care up normal atm flow control,</span>
<span class="cm"> * but we also need to wake up the device if we blocked it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pppoatm_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">atmvcc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pppoatm_vcc</span> <span class="o">*</span><span class="n">pvcc</span> <span class="o">=</span> <span class="n">atmvcc_to_pvcc</span><span class="p">(</span><span class="n">atmvcc</span><span class="p">);</span>

	<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">old_pop</span><span class="p">(</span><span class="n">atmvcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We always used to run the wakeup tasklet unconditionally here, for</span>
<span class="cm">	 * fear of race conditions where we clear the BLOCKED flag just as we</span>
<span class="cm">	 * refuse another packet in pppoatm_send(). This was quite inefficient.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In fact it&#39;s OK. The PPP core will only ever call pppoatm_send()</span>
<span class="cm">	 * while holding the channel-&gt;downl lock. And ppp_output_wakeup() as</span>
<span class="cm">	 * called by the tasklet will *also* grab that lock. So even if another</span>
<span class="cm">	 * CPU is in pppoatm_send() right now, the tasklet isn&#39;t going to race</span>
<span class="cm">	 * with it. The wakeup *will* happen after the other CPU is safely out</span>
<span class="cm">	 * of pppoatm_send() again.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So if the CPU in pppoatm_send() has already set the BLOCKED bit and</span>
<span class="cm">	 * it about to return, that&#39;s fine. We trigger a wakeup which will</span>
<span class="cm">	 * happen later. And if the CPU in pppoatm_send() *hasn&#39;t* set the</span>
<span class="cm">	 * BLOCKED bit yet, that&#39;s fine too because of the double check in</span>
<span class="cm">	 * pppoatm_may_send() which is commented there.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">BLOCKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">))</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">wakeup_tasklet</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unbind from PPP - currently we only do this when closing the socket,</span>
<span class="cm"> * but we could put this into an ioctl if need be</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pppoatm_unassign_vcc</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">atmvcc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pppoatm_vcc</span> <span class="o">*</span><span class="n">pvcc</span><span class="p">;</span>
	<span class="n">pvcc</span> <span class="o">=</span> <span class="n">atmvcc_to_pvcc</span><span class="p">(</span><span class="n">atmvcc</span><span class="p">);</span>
	<span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">push</span> <span class="o">=</span> <span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">old_push</span><span class="p">;</span>
	<span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">pop</span> <span class="o">=</span> <span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">old_pop</span><span class="p">;</span>
	<span class="n">tasklet_kill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">wakeup_tasklet</span><span class="p">);</span>
	<span class="n">ppp_unregister_channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
	<span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">user_back</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pvcc</span><span class="p">);</span>
	<span class="cm">/* Gee, I hope we have the big kernel lock here... */</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Called when an AAL5 PDU comes in */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pppoatm_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">atmvcc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pppoatm_vcc</span> <span class="o">*</span><span class="n">pvcc</span> <span class="o">=</span> <span class="n">atmvcc_to_pvcc</span><span class="p">(</span><span class="n">atmvcc</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* VCC was closed */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;removing ATMPPP VCC %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pvcc</span><span class="p">);</span>
		<span class="n">pppoatm_unassign_vcc</span><span class="p">(</span><span class="n">atmvcc</span><span class="p">);</span>
		<span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">atmvcc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>	<span class="cm">/* Pass along bad news */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atm_return</span><span class="p">(</span><span class="n">atmvcc</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">encaps</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">e_llc</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">LLC_LEN</span> <span class="o">||</span>
		    <span class="n">memcmp</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">pppllc</span><span class="p">,</span> <span class="n">LLC_LEN</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LLC_LEN</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e_autodetect</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">ppp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Not bound yet! */</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pppllc</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">pppllc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pppllc</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">encaps</span> <span class="o">=</span> <span class="n">e_llc</span><span class="p">;</span>
			<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LLC_LEN</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pppllc</span><span class="p">)</span> <span class="o">-</span> <span class="n">LLC_LEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pppllc</span><span class="p">[</span><span class="n">LLC_LEN</span><span class="p">],</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="n">pppllc</span><span class="p">)</span> <span class="o">-</span> <span class="n">LLC_LEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">encaps</span> <span class="o">=</span> <span class="n">e_vc</span><span class="p">;</span>
			<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">mtu</span> <span class="o">+=</span> <span class="n">LLC_LEN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t autodetect yet (skb: %02X %02X %02X %02X %02X %02X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
			 <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e_vc</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ppp_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">ppp_input_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pppoatm_may_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">pppoatm_vcc</span> <span class="o">*</span><span class="n">pvcc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s not clear that we need to bother with using atm_may_send()</span>
<span class="cm">	 * to check we don&#39;t exceed sk-&gt;sk_sndbuf. If userspace sets a</span>
<span class="cm">	 * value of sk_sndbuf which is lower than the MTU, we&#39;re going to</span>
<span class="cm">	 * block for ever. But the code always did that before we introduced</span>
<span class="cm">	 * the packet count limit, so...</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atm_may_send</span><span class="p">(</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">atmvcc</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atomic_inc_not_zero_hint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">,</span> <span class="n">NONE_INFLIGHT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We use test_and_set_bit() rather than set_bit() here because</span>
<span class="cm">	 * we need to ensure there&#39;s a memory barrier after it. The bit</span>
<span class="cm">	 * *must* be set before we do the atomic_inc() on pvcc-&gt;inflight.</span>
<span class="cm">	 * There&#39;s no smp_mb__after_set_bit(), so it&#39;s this or abuse</span>
<span class="cm">	 * smp_mb__after_clear_bit().</span>
<span class="cm">	 */</span>
	<span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">BLOCKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We may have raced with pppoatm_pop(). If it ran for the</span>
<span class="cm">	 * last packet in the queue, *just* before we set the BLOCKED</span>
<span class="cm">	 * bit, then it might never run again and the channel could</span>
<span class="cm">	 * remain permanently blocked. Cope with that race by checking</span>
<span class="cm">	 * *again*. If it did run in that window, we&#39;ll have space on</span>
<span class="cm">	 * the queue now and can return success. It&#39;s harmless to leave</span>
<span class="cm">	 * the BLOCKED flag set, since it&#39;s only used as a trigger to</span>
<span class="cm">	 * run the wakeup tasklet. Another wakeup will never hurt.</span>
<span class="cm">	 * If pppoatm_pop() is running but hasn&#39;t got as far as making</span>
<span class="cm">	 * space on the queue yet, then it hasn&#39;t checked the BLOCKED</span>
<span class="cm">	 * flag yet either, so we&#39;re safe in that case too. It&#39;ll issue</span>
<span class="cm">	 * an &quot;immediate&quot; wakeup... where &quot;immediate&quot; actually involves</span>
<span class="cm">	 * taking the PPP channel&#39;s -&gt;downl lock, which is held by the</span>
<span class="cm">	 * code path that calls pppoatm_send(), and is thus going to</span>
<span class="cm">	 * wait for us to finish.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atm_may_send</span><span class="p">(</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">atmvcc</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Called by the ppp_generic.c to send a packet - returns true if packet</span>
<span class="cm"> * was accepted.  If we return false, then it&#39;s our job to call</span>
<span class="cm"> * ppp_output_wakeup(chan) when we&#39;re feeling more up to it.</span>
<span class="cm"> * Note that in the ENOMEM case (as opposed to the !atm_may_send case)</span>
<span class="cm"> * we should really drop the packet, but the generic layer doesn&#39;t</span>
<span class="cm"> * support this yet.  We just return &#39;DROP_PACKET&#39; which we actually define</span>
<span class="cm"> * as success, just to be clear what we&#39;re really doing.</span>
<span class="cm"> */</span>
<span class="cp">#define DROP_PACKET 1</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pppoatm_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">ppp_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pppoatm_vcc</span> <span class="o">*</span><span class="n">pvcc</span> <span class="o">=</span> <span class="n">chan_to_pvcc</span><span class="p">(</span><span class="n">chan</span><span class="p">);</span>
	<span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">atmvcc</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(skb=0x%p, vcc=0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">atmvcc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SC_COMP_PROT</span><span class="p">))</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">encaps</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* LLC encapsulation needed */</span>
	<span class="k">case</span> <span class="n">e_llc</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">LLC_LEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">skb_realloc_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LLC_LEN</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">pppoatm_may_send</span><span class="p">(</span><span class="n">pvcc</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">nospace</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">DROP_PACKET</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pppoatm_may_send</span><span class="p">(</span><span class="n">pvcc</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">nospace</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">LLC_LEN</span><span class="p">),</span> <span class="n">pppllc</span><span class="p">,</span> <span class="n">LLC_LEN</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e_vc</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pppoatm_may_send</span><span class="p">(</span><span class="n">pvcc</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">nospace</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">e_autodetect</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Trying to send without setting encaps!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk_atm</span><span class="p">(</span><span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">);</span>
	<span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">atm_options</span> <span class="o">=</span> <span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">atm_options</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;atm_skb(%p)-&gt;vcc(%p)-&gt;dev(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">skb</span><span class="p">,</span> <span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">,</span> <span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">send</span><span class="p">(</span><span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span>
	    <span class="o">?</span> <span class="n">DROP_PACKET</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">nospace:</span>
	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t have space to send this SKB now, but we might have</span>
<span class="cm">	 * already applied SC_COMP_PROT compression, so may need to undo</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SC_COMP_PROT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">skb_headroom</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This handles ioctls sent to the /dev/ppp interface */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pppoatm_devppp_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ppp_channel</span> <span class="o">*</span><span class="n">chan</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PPPIOCGFLAGS</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">chan_to_pvcc</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span>
		    <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PPPIOCSFLAGS</span>:
		<span class="k">return</span> <span class="n">get_user</span><span class="p">(</span><span class="n">chan_to_pvcc</span><span class="p">(</span><span class="n">chan</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">)</span>
		    <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ppp_channel_ops</span> <span class="n">pppoatm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start_xmit</span> <span class="o">=</span> <span class="n">pppoatm_send</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span> <span class="n">pppoatm_devppp_ioctl</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pppoatm_assign_vcc</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">atmvcc</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atm_backend_ppp</span> <span class="n">be</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pppoatm_vcc</span> <span class="o">*</span><span class="n">pvcc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Each PPPoATM instance has its own tasklet - this is just a</span>
<span class="cm">	 * prototypical one used to initialize them</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="n">DECLARE_TASKLET</span><span class="p">(</span><span class="n">tasklet_proto</span><span class="p">,</span> <span class="n">pppoatm_wakeup_sender</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">be</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">be</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be</span><span class="p">.</span><span class="n">encaps</span> <span class="o">!=</span> <span class="n">PPPOATM_ENCAPS_AUTODETECT</span> <span class="o">&amp;&amp;</span>
	    <span class="n">be</span><span class="p">.</span><span class="n">encaps</span> <span class="o">!=</span> <span class="n">PPPOATM_ENCAPS_VC</span> <span class="o">&amp;&amp;</span> <span class="n">be</span><span class="p">.</span><span class="n">encaps</span> <span class="o">!=</span> <span class="n">PPPOATM_ENCAPS_LLC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">pvcc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pvcc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pvcc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">atmvcc</span> <span class="o">=</span> <span class="n">atmvcc</span><span class="p">;</span>

	<span class="cm">/* Maximum is zero, so that we can use atomic_inc_not_zero() */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">,</span> <span class="n">NONE_INFLIGHT</span><span class="p">);</span>
	<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">old_push</span> <span class="o">=</span> <span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">;</span>
	<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">old_pop</span> <span class="o">=</span> <span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">;</span>
	<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">encaps</span> <span class="o">=</span> <span class="p">(</span><span class="k">enum</span> <span class="n">pppoatm_encaps</span><span class="p">)</span> <span class="n">be</span><span class="p">.</span><span class="n">encaps</span><span class="p">;</span>
	<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">pvcc</span><span class="p">;</span>
	<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pppoatm_ops</span><span class="p">;</span>
	<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">.</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">qos</span><span class="p">.</span><span class="n">txtp</span><span class="p">.</span><span class="n">max_sdu</span> <span class="o">-</span> <span class="n">PPP_HDRLEN</span> <span class="o">-</span>
	    <span class="p">(</span><span class="n">be</span><span class="p">.</span><span class="n">encaps</span> <span class="o">==</span> <span class="n">e_vc</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">LLC_LEN</span><span class="p">);</span>
	<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">wakeup_tasklet</span> <span class="o">=</span> <span class="n">tasklet_proto</span><span class="p">;</span>
	<span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">wakeup_tasklet</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ppp_register_channel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvcc</span><span class="o">-&gt;</span><span class="n">chan</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pvcc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">user_back</span> <span class="o">=</span> <span class="n">pvcc</span><span class="p">;</span>
	<span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">push</span> <span class="o">=</span> <span class="n">pppoatm_push</span><span class="p">;</span>
	<span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">pop</span> <span class="o">=</span> <span class="n">pppoatm_pop</span><span class="p">;</span>
	<span class="n">__module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>

	<span class="cm">/* re-process everything received between connection setup and</span>
<span class="cm">	   backend setup */</span>
	<span class="n">vcc_process_recv_queue</span><span class="p">(</span><span class="n">atmvcc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This handles ioctls actually performed on our vcc - we must return</span>
<span class="cm"> * -ENOIOCTLCMD for any unrecognized ioctl</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pppoatm_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">atmvcc</span> <span class="o">=</span> <span class="n">ATM_SD</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">ATM_SETBACKEND</span> <span class="o">&amp;&amp;</span> <span class="n">atmvcc</span><span class="o">-&gt;</span><span class="n">push</span> <span class="o">!=</span> <span class="n">pppoatm_push</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATM_SETBACKEND</span>: <span class="p">{</span>
		<span class="n">atm_backend_t</span> <span class="n">b</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">atm_backend_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">argp</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">ATM_BACKEND_PPP</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">pppoatm_assign_vcc</span><span class="p">(</span><span class="n">atmvcc</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">PPPIOCGCHAN</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ppp_channel_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atmvcc_to_pvcc</span><span class="p">(</span><span class="n">atmvcc</span><span class="p">)</span><span class="o">-&gt;</span>
		    <span class="n">chan</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">argp</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PPPIOCGUNIT</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">ppp_unit_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atmvcc_to_pvcc</span><span class="p">(</span><span class="n">atmvcc</span><span class="p">)</span><span class="o">-&gt;</span>
		    <span class="n">chan</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">argp</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">atm_ioctl</span> <span class="n">pppoatm_ioctl_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>	<span class="o">=</span> <span class="n">pppoatm_ioctl</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pppoatm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_atm_ioctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pppoatm_ioctl_ops</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">pppoatm_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">deregister_atm_ioctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pppoatm_ioctl_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">pppoatm_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">pppoatm_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mitchell Blank Jr &lt;mitch@sfgoth.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;RFC2364 PPP over ATM/AAL5&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
