<!DOCTYPE html>
<html><head><title>joekychen/linux » net › atm › clip.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>clip.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* net/atm/clip.c - RFC1577 Classical IP over ATM */</span>

<span class="cm">/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;:%s: &quot; fmt, __func__</span>

<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt; </span><span class="cm">/* for UINT_MAX */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/if_arp.h&gt; </span><span class="cm">/* for some manifest constants */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/atm.h&gt;</span>
<span class="cp">#include &lt;linux/atmdev.h&gt;</span>
<span class="cp">#include &lt;linux/atmclip.h&gt;</span>
<span class="cp">#include &lt;linux/atmarp.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/ip.h&gt; </span><span class="cm">/* for net/route.h */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/in.h&gt; </span><span class="cm">/* for struct sockaddr_in */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/if.h&gt; </span><span class="cm">/* for IFF_UP */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/inetdevice.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/poison.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/jhash.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/route.h&gt; </span><span class="cm">/* for struct rtable and routing */</span><span class="cp"></span>
<span class="cp">#include &lt;net/icmp.h&gt; </span><span class="cm">/* icmp_send */</span><span class="cp"></span>
<span class="cp">#include &lt;net/arp.h&gt;</span>
<span class="cp">#include &lt;linux/param.h&gt; </span><span class="cm">/* for HZ */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt; </span><span class="cm">/* for htons etc. */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>

<span class="cp">#include &quot;common.h&quot;</span>
<span class="cp">#include &quot;resources.h&quot;</span>
<span class="cp">#include &lt;net/atmclip.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">clip_devs</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">atmarpd</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">idle_timer</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">neigh_ops</span> <span class="n">clip_neigh_ops</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">to_atmarpd</span><span class="p">(</span><span class="k">enum</span> <span class="n">atmarp_ctrl_type</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">itf</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atmarp_ctrl</span> <span class="o">*</span><span class="n">ctrl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atmarpd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EUNATCH</span><span class="p">;</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">atmarp_ctrl</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">atmarp_ctrl</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">atmarp_ctrl</span><span class="p">));</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">itf_num</span> <span class="o">=</span> <span class="n">itf</span><span class="p">;</span>
	<span class="n">ctrl</span><span class="o">-&gt;</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
	<span class="n">atm_force_charge</span><span class="p">(</span><span class="n">atmarpd</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">sk_atm</span><span class="p">(</span><span class="n">atmarpd</span><span class="p">);</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">link_vcc</span><span class="p">(</span><span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">clip_vcc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">atmarp_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%p to entry %p (neigh %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clip_vcc</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="p">);</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">xoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* @@@ may overrun buffer by one packet */</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span> <span class="o">=</span> <span class="n">clip_vcc</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_clip_vcc</span><span class="p">(</span><span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">clip_vcc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atmarp_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">**</span><span class="n">walk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;!clip_vcc-&gt;entry (clip_vcc %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clip_vcc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">netif_tx_lock_bh</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* block clip_start_xmit() */</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">walk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="p">;</span> <span class="o">*</span><span class="n">walk</span><span class="p">;</span> <span class="n">walk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">walk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">walk</span> <span class="o">==</span> <span class="n">clip_vcc</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

			<span class="o">*</span><span class="n">walk</span> <span class="o">=</span> <span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>	<span class="cm">/* atomic */</span>
			<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">xoff</span><span class="p">)</span>
				<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* force resolution or expiration */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">neigh_update</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">NUD_NONE</span><span class="p">,</span>
					     <span class="n">NEIGH_UPDATE_F_ADMIN</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
				<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;neigh_update failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;ATMARP: failed (entry %p, vcc 0x%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">clip_vcc</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">netif_tx_unlock_bh</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* The neighbour entry n-&gt;lock is held. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">neigh_check_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atmarp_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">neighbour_priv</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">cv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">clip_neigh_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cv</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="p">;</span> <span class="n">cv</span><span class="p">;</span> <span class="n">cv</span> <span class="o">=</span> <span class="n">cv</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">cv</span><span class="o">-&gt;</span><span class="n">last_use</span> <span class="o">+</span> <span class="n">cv</span><span class="o">-&gt;</span><span class="n">idle_timeout</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="o">-&gt;</span><span class="n">idle_timeout</span> <span class="o">&amp;&amp;</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">exp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;releasing vcc %p-&gt;%p of entry %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">cv</span><span class="p">,</span> <span class="n">cv</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
			<span class="n">vcc_release_async</span><span class="p">(</span><span class="n">cv</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">,</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span> <span class="o">||</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;destruction postponed with ref %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">));</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">arp_queue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;expired neigh %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">idle_timer_check</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__neigh_for_each_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="n">neigh_check_cb</span><span class="p">);</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">CLIP_CHECK_INTERVAL</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clip_arp_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">vcc</span> <span class="o">=</span> <span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcc</span> <span class="o">||</span> <span class="o">!</span><span class="n">atm_charge</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;pushing to %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;using %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">CLIP_VCC</span><span class="p">(</span><span class="n">vcc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">old_push</span><span class="p">);</span>
	<span class="n">CLIP_VCC</span><span class="p">(</span><span class="n">vcc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">old_push</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">llc_oui</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0xaa</span><span class="p">,</span>	<span class="cm">/* DSAP: non-ISO */</span>
	<span class="mh">0xaa</span><span class="p">,</span>	<span class="cm">/* SSAP: non-ISO */</span>
	<span class="mh">0x03</span><span class="p">,</span>	<span class="cm">/* Ctrl: Unnumbered Information Command PDU */</span>
	<span class="mh">0x00</span><span class="p">,</span>	<span class="cm">/* OUI: EtherType */</span>
	<span class="mh">0x00</span><span class="p">,</span>
	<span class="mh">0x00</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clip_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">clip_vcc</span> <span class="o">=</span> <span class="n">CLIP_VCC</span><span class="p">(</span><span class="n">vcc</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clip_devs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atm_return</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;removing VCC %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clip_vcc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">)</span>
			<span class="n">unlink_clip_vcc</span><span class="p">(</span><span class="n">clip_vcc</span><span class="p">);</span>
		<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">old_push</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>	<span class="cm">/* pass on the bad news */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">clip_vcc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atm_return</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">?</span> <span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">:</span> <span class="n">clip_devs</span><span class="p">;</span>
	<span class="cm">/* clip_vcc-&gt;entry == NULL if we don&#39;t have an IP address yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_kfree_skb_any</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">vcc</span><span class="p">;</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">encap</span> <span class="o">||</span>
	    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">RFC1483LLC_LEN</span> <span class="o">||</span>
	    <span class="n">memcmp</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">llc_oui</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">llc_oui</span><span class="p">)))</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="p">((</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">RFC1483LLC_LEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_ARP</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="n">clip_arp_rcv</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">last_use</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">rx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_skb_data</span><span class="p">));</span>
	<span class="n">netif_rx</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Note: these spinlocks _must_not_ block on non-SMP. The only goal is that</span>
<span class="cm"> * clip_pop is atomic with respect to the critical section in clip_start_xmit.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clip_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">clip_vcc</span> <span class="o">=</span> <span class="n">CLIP_VCC</span><span class="p">(</span><span class="n">vcc</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(vcc %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">old_pop</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="cm">/* skb-&gt;dev == NULL in outbound ARP packets */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">xoff_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atm_may_send</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">xoff</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span>
			<span class="n">netif_wake_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">xoff_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clip_neigh_solicit</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">primary_key</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(neigh %p, skb %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">neigh</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">to_atmarpd</span><span class="p">(</span><span class="n">act_need</span><span class="p">,</span> <span class="n">PRIV</span><span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="o">*</span><span class="n">ip</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clip_neigh_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_ATM_CLIP_NO_ICMP</span>
	<span class="n">icmp_send</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ICMP_DEST_UNREACH</span><span class="p">,</span> <span class="n">ICMP_HOST_UNREACH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">neigh_ops</span> <span class="n">clip_neigh_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>		<span class="n">AF_INET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">solicit</span> <span class="o">=</span>		<span class="n">clip_neigh_solicit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_report</span> <span class="o">=</span>		<span class="n">clip_neigh_error</span><span class="p">,</span>
	<span class="p">.</span><span class="n">output</span> <span class="o">=</span>		<span class="n">neigh_direct_output</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connected_output</span> <span class="o">=</span>	<span class="n">neigh_direct_output</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clip_constructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atmarp_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">neighbour_priv</span><span class="p">(</span><span class="n">neigh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">tbl</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">!=</span> <span class="n">AF_INET</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">RTN_UNICAST</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">nud_state</span> <span class="o">=</span> <span class="n">NUD_NONE</span><span class="p">;</span>
	<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">clip_neigh_ops</span><span class="p">;</span>
	<span class="n">neigh</span><span class="o">-&gt;</span><span class="n">output</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span> <span class="o">=</span> <span class="n">neigh</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* @@@ copy bh locking from arp.c -- need to bh-enable atm code before */</span>

<span class="cm">/*</span>
<span class="cm"> * We play with the resolve flag: 0 and 1 have the usual meaning, but -1 means</span>
<span class="cm"> * to allocate the neighbour entry but not to ask atmarpd for resolution. Also,</span>
<span class="cm"> * don&#39;t increment the usage count. This is used to create entries in</span>
<span class="cm"> * clip_setentry.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clip_encap</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">CLIP_VCC</span><span class="p">(</span><span class="n">vcc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">encap</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">netdev_tx_t</span> <span class="nf">clip_start_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clip_priv</span> <span class="o">*</span><span class="n">clip_priv</span> <span class="o">=</span> <span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">skb_dst</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">atmarp_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">daddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(skb %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;skb_dst(skb) == NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rt</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="p">)</span> <span class="n">dst</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">rt_gateway</span><span class="p">)</span>
		<span class="n">daddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">rt_gateway</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">daddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">dst_neigh_lookup</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">daddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;NO NEIGHBOUR !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">neighbour_priv</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* should be resolved */</span>
			<span class="n">entry</span><span class="o">-&gt;</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">ATMARP_RETRY_DELAY</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
			<span class="n">to_atmarpd</span><span class="p">(</span><span class="n">act_need</span><span class="p">,</span> <span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">primary_key</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">arp_queue</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&lt;</span> <span class="n">ATMARP_MAX_UNRES_PACKETS</span><span class="p">)</span>
			<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">arp_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_dropped</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out_release_neigh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;neigh %p, vccs %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="p">);</span>
	<span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">vcc</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;using neighbour %p, vcc %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="o">-&gt;</span><span class="n">encap</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">here</span><span class="p">;</span>

		<span class="n">here</span> <span class="o">=</span> <span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">RFC1483LLC_LEN</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">here</span><span class="p">,</span> <span class="n">llc_oui</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">llc_oui</span><span class="p">));</span>
		<span class="p">((</span><span class="n">__be16</span> <span class="o">*</span><span class="p">)</span> <span class="n">here</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_add</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk_atm</span><span class="p">(</span><span class="n">vcc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">);</span>
	<span class="n">ATM_SKB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">atm_options</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">atm_options</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="o">-&gt;</span><span class="n">last_use</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;atm_skb(%p)-&gt;vcc(%p)-&gt;dev(%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">vcc</span><span class="p">,</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="o">-&gt;</span><span class="n">xoff</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>	<span class="cm">/* assume XOFF ... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;XOFF-&gt;XOFF transition</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_release_neigh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_packets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">tx_bytes</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">send</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atm_may_send</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="o">-&gt;</span><span class="n">xoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_release_neigh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clip_priv</span><span class="o">-&gt;</span><span class="n">xoff_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">netif_stop_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>	<span class="cm">/* XOFF -&gt; throttle immediately */</span>
	<span class="n">barrier</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="o">-&gt;</span><span class="n">xoff</span><span class="p">)</span>
		<span class="n">netif_start_queue</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* Oh, we just raced with clip_pop. netif_start_queue should be</span>
<span class="cm">	   good enough, because nothing should really be asleep because</span>
<span class="cm">	   of the brief netif_stop_queue. If this isn&#39;t true or if it</span>
<span class="cm">	   changes, use netif_wake_queue instead. */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clip_priv</span><span class="o">-&gt;</span><span class="n">xoff_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">out_release_neigh:</span>
	<span class="n">neigh_release</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NETDEV_TX_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clip_mkip</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">clip_vcc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
	<span class="n">clip_vcc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">clip_vcc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clip_vcc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%p vcc %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">clip_vcc</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">vcc</span><span class="p">;</span>
	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">user_back</span> <span class="o">=</span> <span class="n">clip_vcc</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">ATM_VF_IS_CLIP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">xoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">encap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">last_use</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">idle_timeout</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">old_push</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">;</span>
	<span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">old_pop</span> <span class="o">=</span> <span class="n">vcc</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">;</span>
	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">push</span> <span class="o">=</span> <span class="n">clip_push</span><span class="p">;</span>
	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">pop</span> <span class="o">=</span> <span class="n">clip_pop</span><span class="p">;</span>

	<span class="cm">/* re-process everything received between connection setup and MKIP */</span>
	<span class="n">vcc_process_recv_queue</span><span class="p">(</span><span class="n">vcc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clip_setentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">,</span> <span class="n">__be32</span> <span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">neigh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">atmarp_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">clip_vcc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">push</span> <span class="o">!=</span> <span class="n">clip_push</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;non-CLIP VCC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clip_vcc</span> <span class="o">=</span> <span class="n">CLIP_VCC</span><span class="p">(</span><span class="n">vcc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;hiding hidden ATMARP entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;remove</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">unlink_clip_vcc</span><span class="p">(</span><span class="n">clip_vcc</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
	<span class="n">neigh</span> <span class="o">=</span> <span class="n">__neigh_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">,</span> <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ip_rt_put</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">neigh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">neighbour_priv</span><span class="p">(</span><span class="n">neigh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">)</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;add</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;update</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">unlink_clip_vcc</span><span class="p">(</span><span class="n">clip_vcc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">link_vcc</span><span class="p">(</span><span class="n">clip_vcc</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">neigh_update</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="n">llc_oui</span><span class="p">,</span> <span class="n">NUD_PERMANENT</span><span class="p">,</span>
			     <span class="n">NEIGH_UPDATE_F_OVERRIDE</span> <span class="o">|</span> <span class="n">NEIGH_UPDATE_F_ADMIN</span><span class="p">);</span>
	<span class="n">neigh_release</span><span class="p">(</span><span class="n">neigh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_device_ops</span> <span class="n">clip_netdev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ndo_start_xmit</span>		<span class="o">=</span> <span class="n">clip_start_xmit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ndo_neigh_construct</span>	<span class="o">=</span> <span class="n">clip_constructor</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clip_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">clip_netdev_ops</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ARPHRD_ATM</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">neigh_priv_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">atmarp_entry</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">hard_header_len</span> <span class="o">=</span> <span class="n">RFC1483LLC_LEN</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">=</span> <span class="n">RFC1626_MTU</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>	<span class="cm">/* &quot;normal&quot; queue (packets) */</span>
	<span class="cm">/* When using a &quot;real&quot; qdisc, the qdisc determines the queue */</span>
	<span class="cm">/* length. tx_queue_len is only used for the default case, */</span>
	<span class="cm">/* without any more elaborate queuing. 100 is a reasonable */</span>
	<span class="cm">/* compromise between decent burst-tolerance and protection */</span>
	<span class="cm">/* against memory hogs. */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">priv_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IFF_XMIT_DST_RELEASE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clip_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">clip_priv</span> <span class="o">*</span><span class="n">clip_priv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">dev</span> <span class="o">=</span> <span class="n">clip_devs</span><span class="p">;</span> <span class="n">dev</span><span class="p">;</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">==</span> <span class="n">number</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">dev</span> <span class="o">=</span> <span class="n">clip_devs</span><span class="p">;</span> <span class="n">dev</span><span class="p">;</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">&gt;=</span> <span class="n">number</span><span class="p">)</span>
				<span class="n">number</span> <span class="o">=</span> <span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_netdev</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">clip_priv</span><span class="p">),</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">clip_setup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">clip_priv</span> <span class="o">=</span> <span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;atm%d&quot;</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clip_priv</span><span class="o">-&gt;</span><span class="n">xoff_lock</span><span class="p">);</span>
	<span class="n">clip_priv</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">number</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">register_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clip_priv</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">clip_devs</span><span class="p">;</span>
	<span class="n">clip_devs</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;registered (net:%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clip_device_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_eq</span><span class="p">(</span><span class="n">dev_net</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">NETDEV_UNREGISTER</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="cm">/* ignore non-CLIP devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_ATM</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">netdev_ops</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">clip_netdev_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NETDEV_UP</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;NETDEV_UP</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">to_atmarpd</span><span class="p">(</span><span class="n">act_up</span><span class="p">,</span> <span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_GOING_DOWN</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;NETDEV_DOWN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">to_atmarpd</span><span class="p">(</span><span class="n">act_down</span><span class="p">,</span> <span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_CHANGE</span>:
	<span class="k">case</span> <span class="n">NETDEV_CHANGEMTU</span>:
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;NETDEV_CHANGE*</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">to_atmarpd</span><span class="p">(</span><span class="n">act_change</span><span class="p">,</span> <span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clip_inet_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span>
			   <span class="kt">void</span> <span class="o">*</span><span class="n">ifa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">in_device</span> <span class="o">*</span><span class="n">in_dev</span><span class="p">;</span>

	<span class="n">in_dev</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">in_ifaddr</span> <span class="o">*</span><span class="p">)</span><span class="n">ifa</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ifa_dev</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Transitions are of the down-change-up type, so it&#39;s sufficient to</span>
<span class="cm">	 * handle the change on up.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">!=</span> <span class="n">NETDEV_UP</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">clip_device_event</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">NETDEV_CHANGE</span><span class="p">,</span> <span class="n">in_dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">clip_dev_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">clip_device_event</span><span class="p">,</span>
<span class="p">};</span>



<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">clip_inet_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">clip_inet_event</span><span class="p">,</span>
<span class="p">};</span>



<span class="k">static</span> <span class="kt">void</span> <span class="nf">atmarpd_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="n">atmarpd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk_atm</span><span class="p">(</span><span class="n">vcc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;(done)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">atmdev_ops</span> <span class="n">atmarpd_dev_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span> <span class="n">atmarpd_close</span>
<span class="p">};</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">atm_dev</span> <span class="n">atmarpd_dev</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">ops</span> <span class="o">=</span>			<span class="o">&amp;</span><span class="n">atmarpd_dev_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">type</span> <span class="o">=</span>			<span class="s">&quot;arpd&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">number</span> <span class="o">=</span> 		<span class="mi">999</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span>			<span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="n">atmarpd_dev</span><span class="p">.</span><span class="n">lock</span><span class="p">)</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">atm_init_atmarp</span><span class="p">(</span><span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rtnl_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atmarpd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rtnl_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">CLIP_CHECK_INTERVAL</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="n">atmarpd</span> <span class="o">=</span> <span class="n">vcc</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">ATM_VF_META</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">ATM_VF_READY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	    <span class="cm">/* allow replies and avoid getting closed if signaling dies */</span>
	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atmarpd_dev</span><span class="p">;</span>
	<span class="n">vcc_insert_socket</span><span class="p">(</span><span class="n">sk_atm</span><span class="p">(</span><span class="n">vcc</span><span class="p">));</span>
	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">push</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">pop</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* crash */</span>
	<span class="n">vcc</span><span class="o">-&gt;</span><span class="n">push_oam</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* crash */</span>
	<span class="n">rtnl_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clip_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">atm_vcc</span> <span class="o">*</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">ATM_SD</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCMKCLIP</span>:
	<span class="k">case</span> <span class="n">ATMARPD_CTRL</span>:
	<span class="k">case</span> <span class="n">ATMARP_MKIP</span>:
	<span class="k">case</span> <span class="n">ATMARP_SETENTRY</span>:
	<span class="k">case</span> <span class="n">ATMARP_ENCAP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_NET_ADMIN</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCMKCLIP</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">clip_create</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATMARPD_CTRL</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">atm_init_atmarp</span><span class="p">(</span><span class="n">vcc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>
			<span class="n">__module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATMARP_MKIP</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">clip_mkip</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATMARP_SETENTRY</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">clip_setentry</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="p">(</span><span class="n">__force</span> <span class="n">__be32</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATMARP_ENCAP</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">clip_encap</span><span class="p">(</span><span class="n">vcc</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">atm_ioctl</span> <span class="n">clip_ioctl_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span> <span class="n">clip_ioctl</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">svc_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr_atmsvc</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">code</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">e164</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sas_addr</span><span class="p">.</span><span class="n">pub</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sas_addr</span><span class="p">.</span><span class="n">pub</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sas_addr</span><span class="p">.</span><span class="n">prv</span><span class="p">)</span>
			<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;+&#39;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sas_addr</span><span class="p">.</span><span class="n">prv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="s">&quot;(none)&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sas_addr</span><span class="p">.</span><span class="n">prv</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prv</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sas_addr</span><span class="p">.</span><span class="n">prv</span><span class="p">;</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">fields</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

		<span class="n">fields</span> <span class="o">=</span> <span class="o">*</span><span class="n">prv</span> <span class="o">==</span> <span class="n">ATM_AFI_E164</span> <span class="o">?</span> <span class="n">e164</span> <span class="o">:</span> <span class="n">code</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span>
				<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%02X&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">prv</span><span class="o">++</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
				<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* This means the neighbour entry has no attached VCC objects. */</span>
<span class="cp">#define SEQ_NO_VCC_TOKEN	((void *) 2)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atmarp_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">atmarp_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">clip_vcc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">exp</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">svc</span><span class="p">,</span> <span class="n">llc</span><span class="p">,</span> <span class="n">off</span><span class="p">;</span>

	<span class="n">svc</span> <span class="o">=</span> <span class="p">((</span><span class="n">clip_vcc</span> <span class="o">==</span> <span class="n">SEQ_NO_VCC_TOKEN</span><span class="p">)</span> <span class="o">||</span>
	       <span class="p">(</span><span class="n">sk_atm</span><span class="p">(</span><span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">AF_ATMSVC</span><span class="p">));</span>

	<span class="n">llc</span> <span class="o">=</span> <span class="p">((</span><span class="n">clip_vcc</span> <span class="o">==</span> <span class="n">SEQ_NO_VCC_TOKEN</span><span class="p">)</span> <span class="o">||</span> <span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">encap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clip_vcc</span> <span class="o">==</span> <span class="n">SEQ_NO_VCC_TOKEN</span><span class="p">)</span>
		<span class="n">exp</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">used</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">exp</span> <span class="o">=</span> <span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">last_use</span><span class="p">;</span>

	<span class="n">exp</span> <span class="o">=</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">exp</span><span class="p">)</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%-6s%-4s%-4s%5ld &quot;</span><span class="p">,</span>
		   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">svc</span> <span class="o">?</span> <span class="s">&quot;SVC&quot;</span> <span class="o">:</span> <span class="s">&quot;PVC&quot;</span><span class="p">,</span> <span class="n">llc</span> <span class="o">?</span> <span class="s">&quot;LLC&quot;</span> <span class="o">:</span> <span class="s">&quot;NULL&quot;</span><span class="p">,</span> <span class="n">exp</span><span class="p">);</span>

	<span class="n">off</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%pI4&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">primary_key</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">off</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="n">buf</span><span class="p">[</span><span class="n">off</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clip_vcc</span> <span class="o">==</span> <span class="n">SEQ_NO_VCC_TOKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">expires</span><span class="p">))</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;(resolving)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;(expired, ref %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">neigh</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">svc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%d.%d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
			   <span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span> <span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">vci</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">svc_addr</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clip_vcc</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="o">-&gt;</span><span class="n">remote</span><span class="p">);</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">clip_seq_state</span> <span class="p">{</span>
	<span class="cm">/* This member must be first. */</span>
	<span class="k">struct</span> <span class="n">neigh_seq_state</span> <span class="n">ns</span><span class="p">;</span>

	<span class="cm">/* Local to clip specific iteration. */</span>
	<span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">vcc</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="nf">clip_seq_next_vcc</span><span class="p">(</span><span class="k">struct</span> <span class="n">atmarp_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">curr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">vccs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SEQ_NO_VCC_TOKEN</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">curr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">==</span> <span class="n">SEQ_NO_VCC_TOKEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">curr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">clip_seq_vcc_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">clip_seq_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">atmarp_entry</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">;</span>

	<span class="n">vcc</span> <span class="o">=</span> <span class="n">clip_seq_next_vcc</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vcc</span> <span class="o">&amp;&amp;</span> <span class="n">pos</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vcc</span> <span class="o">=</span> <span class="n">clip_seq_next_vcc</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">vcc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vcc</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="o">--</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">vcc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vcc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">clip_seq_sub_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">neigh_seq_state</span> <span class="o">*</span><span class="n">_state</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clip_seq_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">clip_seq_state</span> <span class="o">*</span><span class="p">)</span><span class="n">_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ARPHRD_ATM</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">clip_seq_vcc_walk</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">neighbour_priv</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">clip_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">clip_seq_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">.</span><span class="n">neigh_sub_iter</span> <span class="o">=</span> <span class="n">clip_seq_sub_iter</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">neigh_seq_start</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arp_tbl</span><span class="p">,</span> <span class="n">NEIGH_SEQ_NEIGH_ONLY</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">clip_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">atm_arp_banner</span><span class="p">[]</span> <span class="o">=</span>
	    <span class="s">&quot;IPitf TypeEncp Idle IP address      ATM address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">atm_arp_banner</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">clip_seq_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">clip_vcc</span> <span class="o">*</span><span class="n">vcc</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">vcc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">neighbour</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>

		<span class="n">atmarp_info</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">neighbour_priv</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">vcc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">arp_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">clip_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>	<span class="o">=</span> <span class="n">neigh_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">neigh_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">clip_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">arp_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open_net</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arp_seq_ops</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">clip_seq_state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">arp_seq_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">arp_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release_net</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">atm_clip_exit_noproc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">atm_clip_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_atm_ioctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clip_ioctl_ops</span><span class="p">);</span>
	<span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clip_dev_notifier</span><span class="p">);</span>
	<span class="n">register_inetaddr_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clip_inet_notifier</span><span class="p">);</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle_timer</span><span class="p">,</span> <span class="n">idle_timer_check</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="n">p</span> <span class="o">=</span> <span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;arp&quot;</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">atm_proc_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arp_seq_fops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to initialize /proc/net/atm/arp</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">atm_clip_exit_noproc</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atm_clip_exit_noproc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">unregister_inetaddr_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clip_inet_notifier</span><span class="p">);</span>
	<span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clip_dev_notifier</span><span class="p">);</span>

	<span class="n">deregister_atm_ioctl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clip_ioctl_ops</span><span class="p">);</span>

	<span class="cm">/* First, stop the idle timer, so it stops banging</span>
<span class="cm">	 * on the table.</span>
<span class="cm">	 */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idle_timer</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">clip_devs</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">PRIV</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">unregister_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">free_netdev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">atm_clip_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;arp&quot;</span><span class="p">,</span> <span class="n">atm_proc_root</span><span class="p">);</span>

	<span class="n">atm_clip_exit_noproc</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">atm_clip_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">atm_clip_exit</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Werner Almesberger&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Classical/IP over ATM interface&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
