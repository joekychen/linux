<!DOCTYPE html>
<html><head><title>joekychen/linux » net › socket.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>socket.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * NET		An implementation of the SOCKET network access protocol.</span>
<span class="cm"> *</span>
<span class="cm"> * Version:	@(#)socket.c	1.1.93	18/02/95</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Orest Zborowski, &lt;obz@Kodak.COM&gt;</span>
<span class="cm"> *		Ross Biro</span>
<span class="cm"> *		Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Fixes:</span>
<span class="cm"> *		Anonymous	:	NOTSOCK/BADF cleanup. Error fix in</span>
<span class="cm"> *					shutdown()</span>
<span class="cm"> *		Alan Cox	:	verify_area() fixes</span>
<span class="cm"> *		Alan Cox	:	Removed DDI</span>
<span class="cm"> *		Jonathan Kamens	:	SOCK_DGRAM reconnect bug</span>
<span class="cm"> *		Alan Cox	:	Moved a load of checks to the very</span>
<span class="cm"> *					top level.</span>
<span class="cm"> *		Alan Cox	:	Move address structures to/from user</span>
<span class="cm"> *					mode above the protocol layers.</span>
<span class="cm"> *		Rob Janssen	:	Allow 0 length sends.</span>
<span class="cm"> *		Alan Cox	:	Asynchronous I/O support (cribbed from the</span>
<span class="cm"> *					tty drivers).</span>
<span class="cm"> *		Niibe Yutaka	:	Asynchronous I/O for writes (4.4BSD style)</span>
<span class="cm"> *		Jeff Uphoff	:	Made max number of sockets command-line</span>
<span class="cm"> *					configurable.</span>
<span class="cm"> *		Matti Aarnio	:	Made the number of sockets dynamic,</span>
<span class="cm"> *					to be allocated when needed, and mr.</span>
<span class="cm"> *					Uphoff&#39;s max is used as max to be</span>
<span class="cm"> *					allowed to allocate.</span>
<span class="cm"> *		Linus		:	Argh. removed all the socket allocation</span>
<span class="cm"> *					altogether: it&#39;s in the inode now.</span>
<span class="cm"> *		Alan Cox	:	Made sock_alloc()/sock_release() public</span>
<span class="cm"> *					for NetROM and future kernel nfsd type</span>
<span class="cm"> *					stuff.</span>
<span class="cm"> *		Alan Cox	:	sendmsg/recvmsg basics.</span>
<span class="cm"> *		Tom Dyas	:	Export net symbols.</span>
<span class="cm"> *		Marcin Dalecki	:	Fixed problems with CONFIG_NET=&quot;n&quot;.</span>
<span class="cm"> *		Alan Cox	:	Added thread locking to sys_* calls</span>
<span class="cm"> *					for sockets. May have errors at the</span>
<span class="cm"> *					moment.</span>
<span class="cm"> *		Kevin Buhr	:	Fixed the dumb errors in the above.</span>
<span class="cm"> *		Andi Kleen	:	Some small cleanups, optimizations,</span>
<span class="cm"> *					and fixed a copy_from_user() bug.</span>
<span class="cm"> *		Tigran Aivazian	:	sys_send(args) calls sys_sendto(args, NULL, 0)</span>
<span class="cm"> *		Tigran Aivazian	:	Made listen(2) backlog sanity checks</span>
<span class="cm"> *					protocol-independent</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *	This module is effectively the top level interface to the BSD socket</span>
<span class="cm"> *	paradigm.</span>
<span class="cm"> *</span>
<span class="cm"> *	Based upon Swansea University Computer Society NET3.039</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/thread_info.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/wanrouter.h&gt;</span>
<span class="cp">#include &lt;linux/if_bridge.h&gt;</span>
<span class="cp">#include &lt;linux/if_frad.h&gt;</span>
<span class="cp">#include &lt;linux/if_vlan.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/cache.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>
<span class="cp">#include &lt;linux/wireless.h&gt;</span>
<span class="cp">#include &lt;linux/nsproxy.h&gt;</span>
<span class="cp">#include &lt;linux/magic.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/unistd.h&gt;</span>

<span class="cp">#include &lt;net/compat.h&gt;</span>
<span class="cp">#include &lt;net/wext.h&gt;</span>
<span class="cp">#include &lt;net/cls_cgroup.h&gt;</span>

<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;linux/netfilter.h&gt;</span>

<span class="cp">#include &lt;linux/if_tun.h&gt;</span>
<span class="cp">#include &lt;linux/ipv6_route.h&gt;</span>
<span class="cp">#include &lt;linux/route.h&gt;</span>
<span class="cp">#include &lt;linux/sockios.h&gt;</span>
<span class="cp">#include &lt;linux/atalk.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sock_no_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">irrelevant</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">dontcare</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">sock_aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">sock_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sock_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sock_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sock_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="n">wait</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">sock_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">compat_sock_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sock_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">sock_sendpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">more</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">sock_splice_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	Socket files have a set of &#39;special&#39; operations as well as the generic file ones. These don&#39;t appear</span>
<span class="cm"> *	in the operation structures but are done directly via the socketcall() multiplexor.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">socket_file_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>	<span class="n">no_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span> <span class="o">=</span>	<span class="n">sock_aio_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span> <span class="o">=</span>	<span class="n">sock_aio_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span>		<span class="n">sock_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">sock_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span> <span class="n">compat_sock_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">sock_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span>		<span class="n">sock_no_open</span><span class="p">,</span>	<span class="cm">/* special open code to disallow open via /proc */</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">sock_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span> <span class="o">=</span>	<span class="n">sock_fasync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span> <span class="o">=</span>	<span class="n">sock_sendpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_write</span> <span class="o">=</span> <span class="n">generic_splice_sendpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span> <span class="o">=</span>	<span class="n">sock_splice_read</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	The protocol list. Each protocol is registered in here.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">net_family_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_proto_family</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">net_families</span><span class="p">[</span><span class="n">NPROTO</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *	Statistics counters of the socket lists</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">sockets_in_use</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Support routines.</span>
<span class="cm"> * Move socket addresses back and forth across the kernel/user</span>
<span class="cm"> * divide and look after the messy bits.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *	move_addr_to_kernel	-	copy a socket address into kernel space</span>
<span class="cm"> *	@uaddr: Address in user space</span>
<span class="cm"> *	@kaddr: Address in kernel space</span>
<span class="cm"> *	@ulen: Length in user space</span>
<span class="cm"> *</span>
<span class="cm"> *	The address is copied into kernel space. If the provided address is</span>
<span class="cm"> *	too long an error code of -EINVAL is returned. If the copy gives</span>
<span class="cm"> *	invalid addresses -EFAULT is returned. On a success 0 is returned.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">move_addr_to_kernel</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ulen</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ulen</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ulen</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_storage</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ulen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">kaddr</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span> <span class="n">ulen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">audit_sockaddr</span><span class="p">(</span><span class="n">ulen</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	move_addr_to_user	-	copy an address to user space</span>
<span class="cm"> *	@kaddr: kernel space address</span>
<span class="cm"> *	@klen: length of address in kernel</span>
<span class="cm"> *	@uaddr: user space address</span>
<span class="cm"> *	@ulen: pointer to user length field</span>
<span class="cm"> *</span>
<span class="cm"> *	The value pointed to by ulen on entry is the buffer length available.</span>
<span class="cm"> *	This is overwritten with the buffer space used. -EINVAL is returned</span>
<span class="cm"> *	if an overlong buffer is specified or a negative buffer size. -EFAULT</span>
<span class="cm"> *	is returned if either the buffer or the length field are not</span>
<span class="cm"> *	accessible.</span>
<span class="cm"> *	After copying the data up to the limit the user specifies, the true</span>
<span class="cm"> *	length of the data is written over the length limit the user</span>
<span class="cm"> *	specified. Zero is returned for a success.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">move_addr_to_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">klen</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ulen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">ulen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">klen</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">klen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_storage</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">audit_sockaddr</span><span class="p">(</span><span class="n">klen</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *      &quot;fromlen shall refer to the value before truncation..&quot;</span>
<span class="cm">	 *                      1003.1g</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">klen</span><span class="p">,</span> <span class="n">ulen</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">sock_inode_cachep</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">sock_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_alloc</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">sock_inode_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wq</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sock_inode_cachep</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">fasync_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">wq</span><span class="p">,</span> <span class="n">wq</span><span class="p">);</span>

	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_alloc</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket_alloc</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">socket</span><span class="p">.</span><span class="n">wq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">kfree_rcu</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">rcu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">sock_inode_cachep</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_once</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_alloc</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">socket_alloc</span> <span class="o">*</span><span class="p">)</span><span class="n">foo</span><span class="p">;</span>

	<span class="n">inode_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_inodecache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sock_inode_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;sock_inode_cache&quot;</span><span class="p">,</span>
					      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket_alloc</span><span class="p">),</span>
					      <span class="mi">0</span><span class="p">,</span>
					      <span class="p">(</span><span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span>
					       <span class="n">SLAB_RECLAIM_ACCOUNT</span> <span class="o">|</span>
					       <span class="n">SLAB_MEM_SPREAD</span><span class="p">),</span>
					      <span class="n">init_once</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_inode_cachep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">sockfs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc_inode</span>	<span class="o">=</span> <span class="n">sock_alloc_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy_inode</span>	<span class="o">=</span> <span class="n">sock_destroy_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">statfs</span>		<span class="o">=</span> <span class="n">simple_statfs</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * sockfs_dname() is called from d_path().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sockfs_dname</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dynamic_dname</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="s">&quot;socket:[%lu]&quot;</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">sockfs_dentry_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">d_dname</span>  <span class="o">=</span> <span class="n">sockfs_dname</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">sockfs_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mount_pseudo</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="s">&quot;socket:&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sockfs_ops</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">sockfs_dentry_operations</span><span class="p">,</span> <span class="n">SOCKFS_MAGIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">sock_mnt</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">sock_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;sockfs&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span> <span class="o">=</span>	<span class="n">sockfs_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span> <span class="o">=</span>	<span class="n">kill_anon_super</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Obtains the first available file descriptor and sets it up for use.</span>
<span class="cm"> *</span>
<span class="cm"> *	These functions create file structures and maps them to fd space</span>
<span class="cm"> *	of the current process. On success it returns file descriptor</span>
<span class="cm"> *	and file struct implicitly stored in sock-&gt;file.</span>
<span class="cm"> *	Note that another thread may close file descriptor before we return</span>
<span class="cm"> *	from this function. We use the fact that now we do not refer</span>
<span class="cm"> *	to socket after mapping. If one day we will need it, this</span>
<span class="cm"> *	function will increment ref. count on file by 1.</span>
<span class="cm"> *</span>
<span class="cm"> *	In any case returned fd MAY BE not valid!</span>
<span class="cm"> *	This race condition is unavoidable</span>
<span class="cm"> *	with shared fd spaces, we cannot solve it inside kernel,</span>
<span class="cm"> *	but we take care of internal coherence yet.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sock_alloc_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">**</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">name</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">get_unused_fd_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>

	<span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">d_alloc_pseudo</span><span class="p">(</span><span class="n">sock_mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="n">mntget</span><span class="p">(</span><span class="n">sock_mnt</span><span class="p">);</span>

	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">,</span> <span class="n">SOCK_INODE</span><span class="p">(</span><span class="n">sock</span><span class="p">));</span>
	<span class="n">SOCK_INODE</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">socket_file_ops</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">alloc_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_WRITE</span><span class="p">,</span>
		  <span class="o">&amp;</span><span class="n">socket_file_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* drop dentry, keep inode */</span>
		<span class="n">ihold</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">=</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>

	<span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sock_map_fd</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">newfile</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">sock_alloc_file</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newfile</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">fd_install</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">newfile</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_map_fd</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="nf">sock_from_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">socket_file_ops</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>	<span class="cm">/* set in sock_map_fd */</span>

	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTSOCK</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sockfd_lookup - Go from a file number to its socket slot</span>
<span class="cm"> *	@fd: file handle</span>
<span class="cm"> *	@err: pointer to an error code return</span>
<span class="cm"> *</span>
<span class="cm"> *	The file handle passed in is locked and the socket it is bound</span>
<span class="cm"> *	too is returned. If an error occurs the err pointer is overwritten</span>
<span class="cm"> *	with a negative errno code and NULL is returned. The function checks</span>
<span class="cm"> *	for both invalid handles and passing a handle which is not a socket.</span>
<span class="cm"> *</span>
<span class="cm"> *	On a success the socket object pointer is returned.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="nf">sockfd_lookup</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sock_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sock</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sockfd_lookup</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="nf">sockfd_lookup_light</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">err</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">fput_needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>

	<span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sock</span> <span class="o">=</span> <span class="n">sock_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">sock</span><span class="p">;</span>
		<span class="n">fput_light</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	sock_alloc	-	allocate a socket</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate a new inode and socket object. The two are bound together</span>
<span class="cm"> *	and initialised. The socket is then returned. If we are out of inodes</span>
<span class="cm"> *	NULL is returned.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="nf">sock_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode_pseudo</span><span class="p">(</span><span class="n">sock_mnt</span><span class="o">-&gt;</span><span class="n">mnt_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">SOCKET_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">kmemcheck_annotate_bitfield</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">get_next_ino</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFSOCK</span> <span class="o">|</span> <span class="n">S_IRWXUGO</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">current_fsgid</span><span class="p">();</span>

	<span class="n">this_cpu_add</span><span class="p">(</span><span class="n">sockets_in_use</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sock</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	In theory you can&#39;t get an open on this inode, but /proc provides</span>
<span class="cm"> *	a back door. Remember to keep it shut otherwise you&#39;ll let the</span>
<span class="cm"> *	creepy crawlies in.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sock_no_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">irrelevant</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">dontcare</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">bad_sock_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sock_no_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	sock_release	-	close a socket</span>
<span class="cm"> *	@sock: socket to close</span>
<span class="cm"> *</span>
<span class="cm"> *	The socket is released from the protocol stack if it has a release</span>
<span class="cm"> *	callback, and the inode is then released if the socket is bound to</span>
<span class="cm"> *	an inode not a file.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">sock_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>

		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fasync_list</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sock_release: fasync list not empty!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">this_cpu_sub</span><span class="p">(</span><span class="n">sockets_in_use</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">SOCK_INODE</span><span class="p">(</span><span class="n">sock</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_release</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_tx_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">__u8</span> <span class="o">*</span><span class="n">tx_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">tx_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_TX_HARDWARE</span><span class="p">))</span>
		<span class="o">*</span><span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">SKBTX_HW_TSTAMP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_TX_SOFTWARE</span><span class="p">))</span>
		<span class="o">*</span><span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">SKBTX_SW_TSTAMP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WIFI_STATUS</span><span class="p">))</span>
		<span class="o">*</span><span class="n">tx_flags</span> <span class="o">|=</span> <span class="n">SKBTX_WIFI_STATUS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_tx_timestamp</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__sock_sendmsg_nosec</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">kiocb_to_siocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>

	<span class="n">sock_update_classid</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sock_update_netprioidx</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">si</span><span class="o">-&gt;</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">scm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sendmsg</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__sock_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">?:</span> <span class="n">__sock_sendmsg_nosec</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sock_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="n">siocb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">init_sync_kiocb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">iocb</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">siocb</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__sock_sendmsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="n">EIOCBQUEUED</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_on_sync_kiocb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_sendmsg</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sock_sendmsg_nosec</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="n">siocb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">init_sync_kiocb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">iocb</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">siocb</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__sock_sendmsg_nosec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="n">EIOCBQUEUED</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_on_sync_kiocb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kernel_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_segment_t</span> <span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * the following is safe, since for compiler definitions of kvec and</span>
<span class="cm">	 * iovec are identical, yielding the same in-core layout and alignment</span>
<span class="cm">	 */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">)</span><span class="n">vec</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sock_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_sendmsg</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ktime2ts</span><span class="p">(</span><span class="n">ktime_t</span> <span class="n">kt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kt</span><span class="p">.</span><span class="n">tv64</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="n">ktime_to_timespec</span><span class="p">(</span><span class="n">kt</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * called from sock_recv_timestamp() if sock_flag(sk, SOCK_RCVTSTAMP)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__sock_recv_timestamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">need_software_tstamp</span> <span class="o">=</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMP</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">empty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">skb_shared_hwtstamps</span> <span class="o">*</span><span class="n">shhwtstamps</span> <span class="o">=</span>
		<span class="n">skb_hwtstamps</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Race occurred between timestamp enabling and packet</span>
<span class="cm">	   receiving.  Fill in the current time for now. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_software_tstamp</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">.</span><span class="n">tv64</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">__net_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_software_tstamp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMPNS</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
			<span class="n">skb_get_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
			<span class="n">put_cmsg</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SCM_TIMESTAMP</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">tv</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">skb_get_timestampns</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">put_cmsg</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SCM_TIMESTAMPNS</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="n">memset</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ts</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">tstamp</span><span class="p">.</span><span class="n">tv64</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_SOFTWARE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_get_timestampns</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ts</span> <span class="o">+</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shhwtstamps</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_SYS_HARDWARE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ktime2ts</span><span class="p">(</span><span class="n">shhwtstamps</span><span class="o">-&gt;</span><span class="n">syststamp</span><span class="p">,</span> <span class="n">ts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_TIMESTAMPING_RAW_HARDWARE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ktime2ts</span><span class="p">(</span><span class="n">shhwtstamps</span><span class="o">-&gt;</span><span class="n">hwtstamp</span><span class="p">,</span> <span class="n">ts</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
			<span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">)</span>
		<span class="n">put_cmsg</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span>
			 <span class="n">SCM_TIMESTAMPING</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ts</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ts</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__sock_recv_timestamp</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">__sock_recv_wifi_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ack</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WIFI_STATUS</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">wifi_acked_valid</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ack</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">wifi_acked</span><span class="p">;</span>

	<span class="n">put_cmsg</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SCM_WIFI_STATUS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ack</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">ack</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__sock_recv_wifi_status</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sock_recv_drops</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RXQ_OVFL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span> <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dropcount</span><span class="p">)</span>
		<span class="n">put_cmsg</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_RXQ_OVFL</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dropcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__sock_recv_ts_and_drops</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sock_recv_timestamp</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">sock_recv_drops</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__sock_recv_ts_and_drops</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__sock_recvmsg_nosec</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">kiocb_to_siocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>

	<span class="n">sock_update_classid</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">si</span><span class="o">-&gt;</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">scm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">recvmsg</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__sock_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_recvmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span> <span class="o">?:</span> <span class="n">__sock_recvmsg_nosec</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sock_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="n">siocb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">init_sync_kiocb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">iocb</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">siocb</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__sock_recvmsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="n">EIOCBQUEUED</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_on_sync_kiocb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_recvmsg</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sock_recvmsg_nosec</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			      <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kiocb</span> <span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="n">siocb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">init_sync_kiocb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">iocb</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">siocb</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__sock_recvmsg_nosec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="n">EIOCBQUEUED</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_on_sync_kiocb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * kernel_recvmsg - Receive a message from a socket (kernel space)</span>
<span class="cm"> * @sock:       The socket to receive the message from</span>
<span class="cm"> * @msg:        Received message</span>
<span class="cm"> * @vec:        Input s/g array for message data</span>
<span class="cm"> * @num:        Size of input s/g array</span>
<span class="cm"> * @size:       Number of bytes to read</span>
<span class="cm"> * @flags:      Message flags (MSG_DONTWAIT, etc...)</span>
<span class="cm"> *</span>
<span class="cm"> * On return the msg structure contains the scatter/gather array passed in the</span>
<span class="cm"> * vec argument. The array is modified so that it consists of the unfilled</span>
<span class="cm"> * portion of the original array.</span>
<span class="cm"> *</span>
<span class="cm"> * The returned value is the total number of bytes received, or an error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kernel_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_segment_t</span> <span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * the following is safe, since for compiler definitions of kvec and</span>
<span class="cm">	 * iovec are identical, yielding the same in-core layout and alignment</span>
<span class="cm">	 */</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">)</span><span class="n">vec</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sock_recvmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_recvmsg</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_aio_dtor</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sock_sendpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">more</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="o">?</span> <span class="n">MSG_DONTWAIT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* more is a combination of MSG_MORE and MSG_SENDPAGE_NOTLAST */</span>
	<span class="n">flags</span> <span class="o">|=</span> <span class="n">more</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">kernel_sendpage</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sock_splice_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">pipe_inode_info</span> <span class="o">*</span><span class="n">pipe</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">splice_read</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sock_update_classid</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">splice_read</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">pipe</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock_iocb</span> <span class="o">*</span><span class="nf">alloc_sock_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">sock_iocb</span> <span class="o">*</span><span class="n">siocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sync_kiocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">siocb</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">siocb</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">siocb</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_dtor</span> <span class="o">=</span> <span class="n">sock_aio_dtor</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">siocb</span><span class="o">-&gt;</span><span class="n">kiocb</span> <span class="o">=</span> <span class="n">iocb</span><span class="p">;</span>
	<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">siocb</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">siocb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">do_sock_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_segs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_control</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_controllen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">)</span><span class="n">iov</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="n">nr_segs</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="o">?</span> <span class="n">MSG_DONTWAIT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__sock_recvmsg</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sock_aio_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="n">siocb</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* Match SYS5 behaviour */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>


	<span class="n">x</span> <span class="o">=</span> <span class="n">alloc_sock_iocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">siocb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">do_sock_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">async_msg</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">do_sock_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_segs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_control</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_controllen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">)</span><span class="n">iov</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="n">nr_segs</span><span class="p">;</span>
	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="o">?</span> <span class="n">MSG_DONTWAIT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_EOR</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__sock_sendmsg</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sock_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="n">siocb</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>

	<span class="n">x</span> <span class="o">=</span> <span class="n">alloc_sock_iocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">siocb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">do_sock_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">async_msg</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Atomic setting of ioctl hooks to avoid race</span>
<span class="cm"> * with module unload.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">br_ioctl_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">br_ioctl_hook</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">brioctl_set</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br_ioctl_mutex</span><span class="p">);</span>
	<span class="n">br_ioctl_hook</span> <span class="o">=</span> <span class="n">hook</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br_ioctl_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">brioctl_set</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">vlan_ioctl_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">vlan_ioctl_hook</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">vlan_ioctl_set</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vlan_ioctl_mutex</span><span class="p">);</span>
	<span class="n">vlan_ioctl_hook</span> <span class="o">=</span> <span class="n">hook</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vlan_ioctl_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vlan_ioctl_set</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">dlci_ioctl_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">dlci_ioctl_hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">dlci_ioctl_set</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci_ioctl_mutex</span><span class="p">);</span>
	<span class="n">dlci_ioctl_hook</span> <span class="o">=</span> <span class="n">hook</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci_ioctl_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">dlci_ioctl_set</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">sock_do_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this ioctl is unknown try to hand it down</span>
<span class="cm">	 * to the NIC driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	With an ioctl, arg may well be a user mode pointer, but we don&#39;t know</span>
<span class="cm"> *	what to do with it - that&#39;s up to the protocol still.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">sock_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&gt;=</span> <span class="n">SIOCDEVPRIVATE</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">SIOCDEVPRIVATE</span> <span class="o">+</span> <span class="mi">15</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#ifdef CONFIG_WEXT_CORE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&gt;=</span> <span class="n">SIOCIWFIRST</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span> <span class="o">&lt;=</span> <span class="n">SIOCIWLAST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FIOSETOWN</span>:
		<span class="k">case</span> <span class="n">SIOCSPGRP</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">argp</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">f_setown</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">FIOGETOWN</span>:
		<span class="k">case</span> <span class="n">SIOCGPGRP</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">f_getown</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">),</span>
				       <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">argp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SIOCGIFBR</span>:
		<span class="k">case</span> <span class="n">SIOCSIFBR</span>:
		<span class="k">case</span> <span class="n">SIOCBRADDBR</span>:
		<span class="k">case</span> <span class="n">SIOCBRDELBR</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPKG</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">br_ioctl_hook</span><span class="p">)</span>
				<span class="n">request_module</span><span class="p">(</span><span class="s">&quot;bridge&quot;</span><span class="p">);</span>

			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br_ioctl_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">br_ioctl_hook</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">br_ioctl_hook</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">br_ioctl_mutex</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SIOCGIFVLAN</span>:
		<span class="k">case</span> <span class="n">SIOCSIFVLAN</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPKG</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vlan_ioctl_hook</span><span class="p">)</span>
				<span class="n">request_module</span><span class="p">(</span><span class="s">&quot;8021q&quot;</span><span class="p">);</span>

			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vlan_ioctl_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vlan_ioctl_hook</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">vlan_ioctl_hook</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vlan_ioctl_mutex</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SIOCADDDLCI</span>:
		<span class="k">case</span> <span class="n">SIOCDELDLCI</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPKG</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlci_ioctl_hook</span><span class="p">)</span>
				<span class="n">request_module</span><span class="p">(</span><span class="s">&quot;dlci&quot;</span><span class="p">);</span>

			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci_ioctl_mutex</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dlci_ioctl_hook</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">dlci_ioctl_hook</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dlci_ioctl_mutex</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">sock_do_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sock_create_lite</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">**</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_create</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sock_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_post_create</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">out_release:</span>
	<span class="n">sock_release</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="n">sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_create_lite</span><span class="p">);</span>

<span class="cm">/* No kernel lock held - perfect */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sock_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *      We can&#39;t return errors to poll, so it&#39;s either yes or no.</span>
<span class="cm">	 */</span>
	<span class="n">sock</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sock_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sock_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *      It was possible the inode is NULL we were</span>
<span class="cm">	 *      closing an unfinished socket.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;sock_close: NULL inode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sock_release</span><span class="p">(</span><span class="n">SOCKET_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Update the socket async list</span>
<span class="cm"> *</span>
<span class="cm"> *	Fasync_list locking strategy.</span>
<span class="cm"> *</span>
<span class="cm"> *	1. fasync_list is modified only under process context socket lock</span>
<span class="cm"> *	   i.e. under semaphore.</span>
<span class="cm"> *	2. fasync_list is used under read_lock(&amp;sk-&gt;sk_callback_lock)</span>
<span class="cm"> *	   or under socket lock</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sock_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span> <span class="n">sock_owned_by_user</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="n">fasync_helper</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">fasync_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">fasync_list</span><span class="p">)</span>
		<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_FASYNC</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_FASYNC</span><span class="p">);</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function may be called only under socket lock or callback_lock or rcu_lock */</span>

<span class="kt">int</span> <span class="nf">sock_wake_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">,</span> <span class="kt">int</span> <span class="n">band</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wq</span> <span class="o">||</span> <span class="o">!</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">fasync_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">how</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOCK_WAKE_WAITD</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_WAITDATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">call_kill</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_WAKE_SPACE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">SOCK_WAKE_IO</span>:
<span class="nl">call_kill:</span>
		<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">fasync_list</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">band</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_WAKE_URG</span>:
		<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">fasync_list</span><span class="p">,</span> <span class="n">SIGURG</span><span class="p">,</span> <span class="n">band</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_wake_async</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">__sock_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">socket</span> <span class="o">**</span><span class="n">res</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">net_proto_family</span> <span class="o">*</span><span class="n">pf</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *      Check protocol is in range</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">family</span> <span class="o">&gt;=</span> <span class="n">NPROTO</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">type</span> <span class="o">&gt;=</span> <span class="n">SOCK_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Compatibility.</span>

<span class="cm">	   This uglymoron is moved from INET layer to here to avoid</span>
<span class="cm">	   deadlock in module load.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_INET</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">SOCK_PACKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">int</span> <span class="n">warned</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">warned</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">warned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s uses obsolete (PF_INET,SOCK_PACKET)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">family</span> <span class="o">=</span> <span class="n">PF_PACKET</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_create</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">kern</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Allocate the socket and allow the family to set things up. if</span>
<span class="cm">	 *	the protocol is 0, the family is instructed to select an appropriate</span>
<span class="cm">	 *	default.</span>
<span class="cm">	 */</span>
	<span class="n">sock</span> <span class="o">=</span> <span class="n">sock_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;socket: no more sockets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>	<span class="cm">/* Not exactly a match, but its the</span>
<span class="cm">				   closest posix thing */</span>
	<span class="p">}</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_MODULES</span>
	<span class="cm">/* Attempt to load a protocol module if the find failed.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user</span>
<span class="cm">	 * requested real, full-featured networking support upon configuration.</span>
<span class="cm">	 * Otherwise module support will break!</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_access_pointer</span><span class="p">(</span><span class="n">net_families</span><span class="p">[</span><span class="n">family</span><span class="p">])</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">request_module</span><span class="p">(</span><span class="s">&quot;net-pf-%d&quot;</span><span class="p">,</span> <span class="n">family</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">pf</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">net_families</span><span class="p">[</span><span class="n">family</span><span class="p">]);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We will call the -&gt;create function, that possibly is in a loadable</span>
<span class="cm">	 * module, so we have to bump that loadable module refcnt first.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>

	<span class="cm">/* Now protected by module ref count */</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">kern</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_module_put</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now to bump the refcnt of the [loadable] module that owns this</span>
<span class="cm">	 * socket at sock_release time we decrement its refcnt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_module_busy</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that we&#39;re done with the -&gt;create function, the [loadable]</span>
<span class="cm">	 * module can have its refcnt decremented</span>
<span class="cm">	 */</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_post_create</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">kern</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_sock_release</span><span class="p">;</span>
	<span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_module_busy:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAFNOSUPPORT</span><span class="p">;</span>
<span class="nl">out_module_put:</span>
	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">pf</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
<span class="nl">out_sock_release:</span>
	<span class="n">sock_release</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_release:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">goto</span> <span class="n">out_sock_release</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__sock_create</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">**</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__sock_create</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">net_ns</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_create</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sock_create_kern</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">**</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__sock_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_create_kern</span><span class="p">);</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Check the SOCK_* constants for consistency.  */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SOCK_CLOEXEC</span> <span class="o">!=</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">((</span><span class="n">SOCK_MAX</span> <span class="o">|</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SOCK_CLOEXEC</span> <span class="o">&amp;</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SOCK_NONBLOCK</span> <span class="o">&amp;</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">);</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOCK_TYPE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SOCK_CLOEXEC</span> <span class="o">|</span> <span class="n">SOCK_NONBLOCK</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">type</span> <span class="o">&amp;=</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SOCK_NONBLOCK</span> <span class="o">!=</span> <span class="n">O_NONBLOCK</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SOCK_NONBLOCK</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOCK_NONBLOCK</span><span class="p">)</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sock_create</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sock_map_fd</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">O_CLOEXEC</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="cm">/* It may be already another descriptor 8) Not kernel problem. */</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

<span class="nl">out_release:</span>
	<span class="n">sock_release</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Create a pair of connected sockets.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">socketpair</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">usockvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock1</span><span class="p">,</span> <span class="o">*</span><span class="n">sock2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd1</span><span class="p">,</span> <span class="n">fd2</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">newfile1</span><span class="p">,</span> <span class="o">*</span><span class="n">newfile2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOCK_TYPE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SOCK_CLOEXEC</span> <span class="o">|</span> <span class="n">SOCK_NONBLOCK</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">type</span> <span class="o">&amp;=</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SOCK_NONBLOCK</span> <span class="o">!=</span> <span class="n">O_NONBLOCK</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SOCK_NONBLOCK</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOCK_NONBLOCK</span><span class="p">)</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Obtain the first socket and check if the underlying protocol</span>
<span class="cm">	 * supports the socketpair call.</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_create</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_create</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release_1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock1</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">socketpair</span><span class="p">(</span><span class="n">sock1</span><span class="p">,</span> <span class="n">sock2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_release_both</span><span class="p">;</span>

	<span class="n">fd1</span> <span class="o">=</span> <span class="n">sock_alloc_file</span><span class="p">(</span><span class="n">sock1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newfile1</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fd1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fd1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_release_both</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fd2</span> <span class="o">=</span> <span class="n">sock_alloc_file</span><span class="p">(</span><span class="n">sock2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newfile2</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fd2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">fd2</span><span class="p">;</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">newfile1</span><span class="p">);</span>
		<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">fd1</span><span class="p">);</span>
		<span class="n">sock_release</span><span class="p">(</span><span class="n">sock2</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">audit_fd_pair</span><span class="p">(</span><span class="n">fd1</span><span class="p">,</span> <span class="n">fd2</span><span class="p">);</span>
	<span class="n">fd_install</span><span class="p">(</span><span class="n">fd1</span><span class="p">,</span> <span class="n">newfile1</span><span class="p">);</span>
	<span class="n">fd_install</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span> <span class="n">newfile2</span><span class="p">);</span>
	<span class="cm">/* fd1 and fd2 may be already another descriptors.</span>
<span class="cm">	 * Not kernel problem.</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">fd1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usockvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">fd2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usockvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sys_close</span><span class="p">(</span><span class="n">fd2</span><span class="p">);</span>
	<span class="n">sys_close</span><span class="p">(</span><span class="n">fd1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_release_both:</span>
	<span class="n">sock_release</span><span class="p">(</span><span class="n">sock2</span><span class="p">);</span>
<span class="nl">out_release_1:</span>
	<span class="n">sock_release</span><span class="p">(</span><span class="n">sock1</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Bind a name to a socket. Nothing much to do here since it&#39;s</span>
<span class="cm"> *	the protocol&#39;s responsibility to handle the local address.</span>
<span class="cm"> *</span>
<span class="cm"> *	We move the socket address to kernel space before we call</span>
<span class="cm"> *	the protocol layer (having also checked the address is ok).</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">umyaddr</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">move_addr_to_kernel</span><span class="p">(</span><span class="n">umyaddr</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span>
						   <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span>
						   <span class="n">addrlen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span>
						      <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span>
						      <span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Perform a listen. Basically, we allow the protocol to do anything</span>
<span class="cm"> *	necessary for a listen, and if that works, we mark the socket as</span>
<span class="cm"> *	ready for listening.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">listen</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">somaxconn</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">somaxconn</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">core</span><span class="p">.</span><span class="n">sysctl_somaxconn</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">backlog</span> <span class="o">&gt;</span> <span class="n">somaxconn</span><span class="p">)</span>
			<span class="n">backlog</span> <span class="o">=</span> <span class="n">somaxconn</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>

		<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	For accept, we attempt to create a new socket, set up the link</span>
<span class="cm"> *	with the client, wake up the client, then return the new</span>
<span class="cm"> *	connected fd. We collect the address of the connector in kernel</span>
<span class="cm"> *	space and move it to user at the very end. This is unclean because</span>
<span class="cm"> *	we open the socket then return an error.</span>
<span class="cm"> *</span>
<span class="cm"> *	1003.1g adds the ability to recvmsg() to query connection pending</span>
<span class="cm"> *	status to recvmsg. We need to add that support in a way thats</span>
<span class="cm"> *	clean when we restucture accept also.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">accept4</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">upeer_sockaddr</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">upeer_addrlen</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="o">*</span><span class="n">newsock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">newfile</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">newfd</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SOCK_CLOEXEC</span> <span class="o">|</span> <span class="n">SOCK_NONBLOCK</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SOCK_NONBLOCK</span> <span class="o">!=</span> <span class="n">O_NONBLOCK</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SOCK_NONBLOCK</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOCK_NONBLOCK</span><span class="p">)</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENFILE</span><span class="p">;</span>
	<span class="n">newsock</span> <span class="o">=</span> <span class="n">sock_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newsock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">newsock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">newsock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t need try_module_get here, as the listening socket (sock)</span>
<span class="cm">	 * has the protocol module (sock-&gt;ops-&gt;owner) held.</span>
<span class="cm">	 */</span>
	<span class="n">__module_get</span><span class="p">(</span><span class="n">newsock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>

	<span class="n">newfd</span> <span class="o">=</span> <span class="n">sock_alloc_file</span><span class="p">(</span><span class="n">newsock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newfile</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">newfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">newfd</span><span class="p">;</span>
		<span class="n">sock_release</span><span class="p">(</span><span class="n">newsock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_accept</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">newsock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fd</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">newsock</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">upeer_sockaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newsock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">getname</span><span class="p">(</span><span class="n">newsock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNABORTED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_fd</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">move_addr_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span>
					<span class="n">len</span><span class="p">,</span> <span class="n">upeer_sockaddr</span><span class="p">,</span> <span class="n">upeer_addrlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_fd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* File flags are not inherited via accept() unlike another OSes. */</span>

	<span class="n">fd_install</span><span class="p">(</span><span class="n">newfd</span><span class="p">,</span> <span class="n">newfile</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">newfd</span><span class="p">;</span>

<span class="nl">out_put:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">out_fd:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">newfile</span><span class="p">);</span>
	<span class="n">put_unused_fd</span><span class="p">(</span><span class="n">newfd</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">accept</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">upeer_sockaddr</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">upeer_addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_accept4</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">upeer_sockaddr</span><span class="p">,</span> <span class="n">upeer_addrlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Attempt to connect to a socket with the server address.  The address</span>
<span class="cm"> *	is in user space so we verify it is OK and move it to kernel space.</span>
<span class="cm"> *</span>
<span class="cm"> *	For 1003.1g we need to add clean support for a bind to AF_UNSPEC to</span>
<span class="cm"> *	break bindings</span>
<span class="cm"> *</span>
<span class="cm"> *	NOTE: 1003.1g draft 6.3 is broken with respect to AX.25/NetROM and</span>
<span class="cm"> *	other SEQPACKET protocols that take time to connect() as it doesn&#39;t</span>
<span class="cm"> *	include the -EINPROGRESS status for such sockets.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">connect</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">uservaddr</span><span class="p">,</span>
		<span class="kt">int</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">move_addr_to_kernel</span><span class="p">(</span><span class="n">uservaddr</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span>
	    <span class="n">security_socket_connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">,</span>
				 <span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">);</span>
<span class="nl">out_put:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Get the local address (&#39;name&#39;) of a socket object. Move the obtained</span>
<span class="cm"> *	name to user space.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">getsockname</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">usockaddr</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">usockaddr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_getsockname</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">getname</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">move_addr_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">usockaddr</span><span class="p">,</span> <span class="n">usockaddr_len</span><span class="p">);</span>

<span class="nl">out_put:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Get the remote address (&#39;name&#39;) of a socket object. Move the obtained</span>
<span class="cm"> *	name to user space.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">getpeername</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">usockaddr</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">usockaddr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_getpeername</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span>
		    <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">getname</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span>
				       <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">move_addr_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">usockaddr</span><span class="p">,</span>
						<span class="n">usockaddr_len</span><span class="p">);</span>
		<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Send a datagram to a given address. We move the address into kernel</span>
<span class="cm"> *	space and check the user space data area is readable before invoking</span>
<span class="cm"> *	the protocol.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">sendto</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">int</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">iov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">buff</span><span class="p">;</span>
	<span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_control</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_controllen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">move_addr_to_kernel</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="n">addr_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

<span class="nl">out_put:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Send a datagram down a socket.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">send</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_sendto</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Receive a frame from the socket and optionally record the address of the</span>
<span class="cm"> *	sender. We verify the buffers are writable and if needed move the</span>
<span class="cm"> *	sender address from kernel to user space.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">recvfrom</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">err2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">msg</span><span class="p">.</span><span class="n">msg_control</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_controllen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_iovlen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_iov</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">;</span>
	<span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">iov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">ubuf</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">;</span>
	<span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_recvmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err2</span> <span class="o">=</span> <span class="n">move_addr_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span>
					 <span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">err2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Receive a datagram from a socket.</span>
<span class="cm"> */</span>

<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">sys_recv</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ubuf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_recvfrom</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">ubuf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Set a socket option. Because we don&#39;t know the option lengths we have</span>
<span class="cm"> *	to pass the user mode parameter for the protocols to sort out.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">setsockopt</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span>
		<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">SOL_SOCKET</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span>
			    <span class="n">sock_setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
					    <span class="n">optlen</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span>
			    <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
						  <span class="n">optlen</span><span class="p">);</span>
<span class="nl">out_put:</span>
		<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Get a socket option. Because we don&#39;t know the option lengths we have</span>
<span class="cm"> *	to pass a user mode parameter for the protocols to sort out.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">getsockopt</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span>
		<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_getsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">SOL_SOCKET</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span>
			    <span class="n">sock_getsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
					    <span class="n">optlen</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span>
			    <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">optval</span><span class="p">,</span>
						  <span class="n">optlen</span><span class="p">);</span>
<span class="nl">out_put:</span>
		<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Shutdown a socket.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">shutdown</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">security_socket_shutdown</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">how</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">how</span><span class="p">);</span>
		<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* A couple of helpful macros for getting the address of the 32/64 bit</span>
<span class="cm"> * fields which are the same type (int / unsigned) on our platforms.</span>
<span class="cm"> */</span>
<span class="cp">#define COMPAT_MSG(msg, member)	((MSG_CMSG_COMPAT &amp; flags) ? &amp;msg##_compat-&gt;member : &amp;msg-&gt;member)</span>
<span class="cp">#define COMPAT_NAMELEN(msg)	COMPAT_MSG(msg, msg_namelen)</span>
<span class="cp">#define COMPAT_FLAGS(msg)	COMPAT_MSG(msg, msg_flags)</span>

<span class="k">struct</span> <span class="n">used_address</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">name_len</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__sys_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg_sys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">used_address</span> <span class="o">*</span><span class="n">used_address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compat_msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">msg_compat</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">compat_msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iovstack</span><span class="p">[</span><span class="n">UIO_FASTIOV</span><span class="p">],</span> <span class="o">*</span><span class="n">iov</span> <span class="o">=</span> <span class="n">iovstack</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ctl</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">20</span><span class="p">]</span>
	    <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">__kernel_size_t</span><span class="p">))));</span>
	<span class="cm">/* 20 is size of ipv6_pktinfo */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ctl_buf</span> <span class="o">=</span> <span class="n">ctl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ctl_len</span><span class="p">,</span> <span class="n">total_len</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MSG_CMSG_COMPAT</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_compat_msghdr</span><span class="p">(</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">msg_compat</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">&gt;</span> <span class="n">UIO_FASTIOV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">&gt;</span> <span class="n">UIO_MAXIOV</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">iov</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span><span class="p">),</span>
			      <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iov</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This will also move the address data into kernel space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MSG_CMSG_COMPAT</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">verify_compat_iovec</span><span class="p">(</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">VERIFY_READ</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">verify_iovec</span><span class="p">(</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">VERIFY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_freeiov</span><span class="p">;</span>
	<span class="n">total_len</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_controllen</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_freeiov</span><span class="p">;</span>
	<span class="n">ctl_len</span> <span class="o">=</span> <span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_controllen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">MSG_CMSG_COMPAT</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ctl_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span>
		    <span class="n">cmsghdr_from_user_compat_to_kern</span><span class="p">(</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">ctl</span><span class="p">,</span>
						     <span class="k">sizeof</span><span class="p">(</span><span class="n">ctl</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_freeiov</span><span class="p">;</span>
		<span class="n">ctl_buf</span> <span class="o">=</span> <span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_control</span><span class="p">;</span>
		<span class="n">ctl_len</span> <span class="o">=</span> <span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_controllen</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ctl_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctl_len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ctl</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ctl_buf</span> <span class="o">=</span> <span class="n">sock_kmalloc</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">ctl_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ctl_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_freeiov</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Careful! Before this, msg_sys-&gt;msg_control contains a user pointer.</span>
<span class="cm">		 * Afterwards, it will be a kernel pointer. Thus the compiler-assisted</span>
<span class="cm">		 * checking falls down on this.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">ctl_buf</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_control</span><span class="p">,</span>
				   <span class="n">ctl_len</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_freectl</span><span class="p">;</span>
		<span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_control</span> <span class="o">=</span> <span class="n">ctl_buf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
		<span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this is sendmmsg() and current destination address is same as</span>
<span class="cm">	 * previously succeeded address, omit asking LSM&#39;s decision.</span>
<span class="cm">	 * used_address-&gt;name_len is initialized to UINT_MAX so that the first</span>
<span class="cm">	 * destination address never matches.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used_address</span> <span class="o">&amp;&amp;</span> <span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_name</span> <span class="o">&amp;&amp;</span>
	    <span class="n">used_address</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">==</span> <span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">used_address</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">,</span>
		    <span class="n">used_address</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_sendmsg_nosec</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg_sys</span><span class="p">,</span> <span class="n">total_len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_freectl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg_sys</span><span class="p">,</span> <span class="n">total_len</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this is sendmmsg() and sending to current destination address was</span>
<span class="cm">	 * successful, remember it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used_address</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">used_address</span><span class="o">-&gt;</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_namelen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">used_address</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">,</span>
			       <span class="n">used_address</span><span class="o">-&gt;</span><span class="n">name_len</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_freectl:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctl_buf</span> <span class="o">!=</span> <span class="n">ctl</span><span class="p">)</span>
		<span class="n">sock_kfree_s</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">ctl_buf</span><span class="p">,</span> <span class="n">ctl_len</span><span class="p">);</span>
<span class="nl">out_freeiov:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iov</span> <span class="o">!=</span> <span class="n">iovstack</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iov</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	BSD sendmsg interface</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">sendmsg</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg_sys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__sys_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Linux sendmmsg interface</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">__sys_sendmmsg</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">mmsg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vlen</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">datagrams</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">compat_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg_sys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">used_address</span> <span class="n">used_address</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vlen</span> <span class="o">&gt;</span> <span class="n">UIO_MAXIOV</span><span class="p">)</span>
		<span class="n">vlen</span> <span class="o">=</span> <span class="n">UIO_MAXIOV</span><span class="p">;</span>

	<span class="n">datagrams</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">used_address</span><span class="p">.</span><span class="n">name_len</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">mmsg</span><span class="p">;</span>
	<span class="n">compat_entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">compat_mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">mmsg</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">datagrams</span> <span class="o">&lt;</span> <span class="n">vlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">MSG_CMSG_COMPAT</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">__sys_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">compat_entry</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">used_address</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compat_entry</span><span class="o">-&gt;</span><span class="n">msg_len</span><span class="p">);</span>
			<span class="o">++</span><span class="n">compat_entry</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">__sys_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">entry</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">used_address</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">msg_len</span><span class="p">);</span>
			<span class="o">++</span><span class="n">entry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="o">++</span><span class="n">datagrams</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>

	<span class="cm">/* We only return an error if no datagrams were able to be sent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">datagrams</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">datagrams</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE4</span><span class="p">(</span><span class="n">sendmmsg</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">mmsg</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__sys_sendmmsg</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">mmsg</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__sys_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg_sys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nosec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compat_msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">msg_compat</span> <span class="o">=</span>
	    <span class="p">(</span><span class="k">struct</span> <span class="n">compat_msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">msg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="n">iovstack</span><span class="p">[</span><span class="n">UIO_FASTIOV</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span> <span class="o">=</span> <span class="n">iovstack</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cmsg_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">total_len</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* kernel mode address */</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/* user mode address pointers */</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uaddr_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">MSG_CMSG_COMPAT</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_compat_msghdr</span><span class="p">(</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">msg_compat</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">&gt;</span> <span class="n">UIO_FASTIOV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">&gt;</span> <span class="n">UIO_MAXIOV</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">iov</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_iovlen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iovec</span><span class="p">),</span>
			      <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iov</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *      Save the user-mode address (verify_iovec will change the</span>
<span class="cm">	 *      kernel msghdr to use the kernel address space)</span>
<span class="cm">	 */</span>

	<span class="n">uaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>
	<span class="n">uaddr_len</span> <span class="o">=</span> <span class="n">COMPAT_NAMELEN</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MSG_CMSG_COMPAT</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">verify_compat_iovec</span><span class="p">(</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">VERIFY_WRITE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">verify_iovec</span><span class="p">(</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">VERIFY_WRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_freeiov</span><span class="p">;</span>
	<span class="n">total_len</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">cmsg_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_control</span><span class="p">;</span>
	<span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MSG_CMSG_CLOEXEC</span><span class="o">|</span><span class="n">MSG_CMSG_COMPAT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">nosec</span> <span class="o">?</span> <span class="n">sock_recvmsg_nosec</span> <span class="o">:</span> <span class="n">sock_recvmsg</span><span class="p">)(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg_sys</span><span class="p">,</span>
							  <span class="n">total_len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_freeiov</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uaddr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">move_addr_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span>
					<span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_namelen</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">,</span>
					<span class="n">uaddr_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_freeiov</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">((</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSG_CMSG_COMPAT</span><span class="p">),</span>
			 <span class="n">COMPAT_FLAGS</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_freeiov</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MSG_CMSG_COMPAT</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_control</span> <span class="o">-</span> <span class="n">cmsg_ptr</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">msg_compat</span><span class="o">-&gt;</span><span class="n">msg_controllen</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">msg_sys</span><span class="o">-&gt;</span><span class="n">msg_control</span> <span class="o">-</span> <span class="n">cmsg_ptr</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_controllen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_freeiov</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">out_freeiov:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iov</span> <span class="o">!=</span> <span class="n">iovstack</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iov</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	BSD recvmsg interface</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">recvmsg</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg_sys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__sys_recvmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *     Linux recvmmsg interface</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">__sys_recvmmsg</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">mmsg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vlen</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">datagrams</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="n">compat_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg_sys</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">end_time</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&amp;&amp;</span>
	    <span class="n">poll_select_set_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_time</span><span class="p">,</span> <span class="n">timeout</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">,</span>
				    <span class="n">timeout</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">datagrams</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">mmsg</span><span class="p">;</span>
	<span class="n">compat_entry</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">compat_mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">mmsg</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">datagrams</span> <span class="o">&lt;</span> <span class="n">vlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * No need to ask LSM for more than the first datagram.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">MSG_CMSG_COMPAT</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">__sys_recvmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">compat_entry</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSG_WAITFORONE</span><span class="p">,</span>
					    <span class="n">datagrams</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compat_entry</span><span class="o">-&gt;</span><span class="n">msg_len</span><span class="p">);</span>
			<span class="o">++</span><span class="n">compat_entry</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">__sys_recvmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">entry</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">msg_sys</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MSG_WAITFORONE</span><span class="p">,</span>
					    <span class="n">datagrams</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">msg_len</span><span class="p">);</span>
			<span class="o">++</span><span class="n">entry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="o">++</span><span class="n">datagrams</span><span class="p">;</span>

		<span class="cm">/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_WAITFORONE</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ktime_get_ts</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
			<span class="o">*</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timespec_sub</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">timeout</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">timeout</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Timeout, return less than vlen datagrams */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Out of band data, return right away */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg_sys</span><span class="p">.</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_OOB</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_put:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">datagrams</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">datagrams</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We may return less entries than requested (vlen) if the</span>
<span class="cm">		 * sock is non block and there aren&#39;t enough datagrams...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * ... or  if recvmsg returns an error after we</span>
<span class="cm">			 * received some datagrams, where we record the</span>
<span class="cm">			 * error to return on the next call or if the</span>
<span class="cm">			 * app asks about it using getsockopt(SO_ERROR).</span>
<span class="cm">			 */</span>
			<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="o">-</span><span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">datagrams</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">recvmmsg</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">mmsg</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">datagrams</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">timeout_sys</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeout</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__sys_recvmmsg</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">mmsg</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout_sys</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">timeout_sys</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">datagrams</span> <span class="o">=</span> <span class="n">__sys_recvmmsg</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">mmsg</span><span class="p">,</span> <span class="n">vlen</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout_sys</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">datagrams</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">copy_to_user</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout_sys</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">timeout_sys</span><span class="p">)))</span>
		<span class="n">datagrams</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">datagrams</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_SOCKETCALL</span>
<span class="cm">/* Argument list sizes for sys_socketcall */</span>
<span class="cp">#define AL(x) ((x) * sizeof(unsigned long))</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">nargs</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">AL</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">AL</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
	<span class="n">AL</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
	<span class="n">AL</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">AL</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">};</span>

<span class="cp">#undef AL</span>

<span class="cm">/*</span>
<span class="cm"> *	System call vectors.</span>
<span class="cm"> *</span>
<span class="cm"> *	Argument checking cleaned up. Saved 20% in size.</span>
<span class="cm"> *  This function doesn&#39;t need to set the kernel lock because</span>
<span class="cm"> *  it is set by the callees.</span>
<span class="cm"> */</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">socketcall</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">call</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">call</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">call</span> <span class="o">&gt;</span> <span class="n">SYS_SENDMMSG</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">nargs</span><span class="p">[</span><span class="n">call</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* copy_from_user should be SMP safe. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">audit_socketcall</span><span class="p">(</span><span class="n">nargs</span><span class="p">[</span><span class="n">call</span><span class="p">]</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span> <span class="n">a</span><span class="p">);</span>

	<span class="n">a0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">a1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">call</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SYS_SOCKET</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_socket</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_BIND</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_bind</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_CONNECT</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_connect</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_LISTEN</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_listen</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_ACCEPT</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_accept4</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_GETSOCKNAME</span>:
		<span class="n">err</span> <span class="o">=</span>
		    <span class="n">sys_getsockname</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_GETPEERNAME</span>:
		<span class="n">err</span> <span class="o">=</span>
		    <span class="n">sys_getpeername</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_SOCKETPAIR</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_socketpair</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_SEND</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_send</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_SENDTO</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_sendto</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
				 <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_RECV</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_recv</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_RECVFROM</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_recvfrom</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
				   <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				   <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_SHUTDOWN</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_shutdown</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_SETSOCKOPT</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_setsockopt</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_GETSOCKOPT</span>:
		<span class="n">err</span> <span class="o">=</span>
		    <span class="n">sys_getsockopt</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
				   <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_SENDMSG</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_sendmsg</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_SENDMMSG</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_sendmmsg</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_RECVMSG</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_recvmsg</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_RECVMMSG</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_recvmmsg</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mmsghdr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
				   <span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYS_ACCEPT4</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">sys_accept4</span><span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a1</span><span class="p">,</span>
				  <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif				</span><span class="cm">/* __ARCH_WANT_SYS_SOCKETCALL */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> *	sock_register - add a socket protocol handler</span>
<span class="cm"> *	@ops: description of protocol</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called by a protocol handler that wants to</span>
<span class="cm"> *	advertise its address family, and have it linked into the</span>
<span class="cm"> *	socket interface. The value ops-&gt;family coresponds to the</span>
<span class="cm"> *	socket system call protocol family.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sock_register</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">net_proto_family</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">&gt;=</span> <span class="n">NPROTO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;protocol %d &gt;= NPROTO(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">,</span>
		       <span class="n">NPROTO</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_family_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rcu_dereference_protected</span><span class="p">(</span><span class="n">net_families</span><span class="p">[</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">],</span>
				      <span class="n">lockdep_is_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_family_lock</span><span class="p">)))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">net_families</span><span class="p">[</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">],</span> <span class="n">ops</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_family_lock</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NET: Registered protocol family %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ops</span><span class="o">-&gt;</span><span class="n">family</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	sock_unregister - remove a protocol handler</span>
<span class="cm"> *	@family: protocol family to remove</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called by a protocol handler that wants to</span>
<span class="cm"> *	remove its address family, and have it unlinked from the</span>
<span class="cm"> *	new socket creation.</span>
<span class="cm"> *</span>
<span class="cm"> *	If protocol handler is a module, then it can use module reference</span>
<span class="cm"> *	counts to protect against new references. If protocol handler is not</span>
<span class="cm"> *	a module then it needs to provide its own protection in</span>
<span class="cm"> *	the ops-&gt;create routine.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sock_unregister</span><span class="p">(</span><span class="kt">int</span> <span class="n">family</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">family</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">family</span> <span class="o">&gt;=</span> <span class="n">NPROTO</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_family_lock</span><span class="p">);</span>
	<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">net_families</span><span class="p">[</span><span class="n">family</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">net_family_lock</span><span class="p">);</span>

	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NET: Unregistered protocol family %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">family</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_unregister</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sock_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *      Initialize the network sysctl infrastructure.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">net_sysctl_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *      Initialize sock SLAB cache.</span>
<span class="cm">	 */</span>

	<span class="n">sk_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 *      Initialize skbuff SLAB cache</span>
<span class="cm">	 */</span>
	<span class="n">skb_init</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 *      Initialize the protocols module.</span>
<span class="cm">	 */</span>

	<span class="n">init_inodecache</span><span class="p">();</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sock_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fs</span><span class="p">;</span>
	<span class="n">sock_mnt</span> <span class="o">=</span> <span class="n">kern_mount</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sock_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sock_mnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sock_mnt</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_mount</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The real protocol initialization is performed in later initcalls.</span>
<span class="cm">	 */</span>

<span class="cp">#ifdef CONFIG_NETFILTER</span>
	<span class="n">netfilter_init</span><span class="p">();</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NETWORK_PHY_TIMESTAMPING</span>
	<span class="n">skb_timestamping_init</span><span class="p">();</span>
<span class="cp">#endif</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_mount:</span>
	<span class="n">unregister_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sock_fs_type</span><span class="p">);</span>
<span class="nl">out_fs:</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">core_initcall</span><span class="p">(</span><span class="n">sock_init</span><span class="p">);</span>	<span class="cm">/* early initcall */</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="kt">void</span> <span class="nf">socket_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
	    <span class="n">counter</span> <span class="o">+=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">sockets_in_use</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="cm">/* It can be negative, by the way. 8) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;sockets: used %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_siocgstamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">up</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">ktv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_do_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ktv</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">compat_put_timeval</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ktv</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_siocgstampns</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">up</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">kts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_do_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">kts</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">compat_put_timespec</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kts</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_ifname32</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compat_ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifr32</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">uifr</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="n">uifr</span><span class="p">,</span> <span class="n">uifr32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">SIOCGIFNAME</span><span class="p">,</span> <span class="n">uifr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="n">uifr32</span><span class="p">,</span> <span class="n">uifr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_ifconf</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compat_ifconf</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifc32</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compat_ifconf</span> <span class="n">ifc32</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifconf</span> <span class="n">ifc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifconf</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ifr32</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ifr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifc32</span><span class="p">,</span> <span class="n">uifc32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifconf</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ifc32</span><span class="p">.</span><span class="n">ifcbuf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ifc32</span><span class="p">.</span><span class="n">ifc_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ifc</span><span class="p">.</span><span class="n">ifc_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ifc</span><span class="p">.</span><span class="n">ifc_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">uifc</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifconf</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="p">((</span><span class="n">ifc32</span><span class="p">.</span><span class="n">ifc_len</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">);</span>
		<span class="n">uifc</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifconf</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">ifc</span><span class="p">.</span><span class="n">ifc_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">ifr</span> <span class="o">=</span> <span class="n">ifc</span><span class="p">.</span><span class="n">ifc_req</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="n">uifc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ifr32</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">ifc32</span><span class="p">.</span><span class="n">ifcbuf</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ifc32</span><span class="p">.</span><span class="n">ifc_len</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">,</span> <span class="n">ifr32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">)))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="n">ifr</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ifr32</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">uifc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifconf</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">SIOCGIFCONF</span><span class="p">,</span> <span class="n">uifc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifc</span><span class="p">,</span> <span class="n">uifc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifconf</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ifr</span> <span class="o">=</span> <span class="n">ifc</span><span class="p">.</span><span class="n">ifc_req</span><span class="p">;</span>
	<span class="n">ifr32</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">ifc32</span><span class="p">.</span><span class="n">ifcbuf</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ifc32</span><span class="p">.</span><span class="n">ifc_len</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ifc</span><span class="p">.</span><span class="n">ifc_len</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">),</span> <span class="n">j</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="n">ifr32</span><span class="p">,</span> <span class="n">ifr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">ifr32</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ifr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ifc32</span><span class="p">.</span><span class="n">ifcbuf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Translate from 64-bit structure multiple to</span>
<span class="cm">		 * a 32-bit one.</span>
<span class="cm">		 */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">ifc</span><span class="p">.</span><span class="n">ifc_len</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="p">((</span><span class="n">i</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">))</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">));</span>
		<span class="n">ifc32</span><span class="p">.</span><span class="n">ifc_len</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ifc32</span><span class="p">.</span><span class="n">ifc_len</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">uifc32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifc32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifconf</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ethtool_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compat_ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ifr32</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compat_ethtool_rxnfc</span> <span class="n">__user</span> <span class="o">*</span><span class="n">compat_rxnfc</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">convert_in</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">convert_out</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">buf_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ethtool_rxnfc</span> <span class="n">__user</span> <span class="o">*</span><span class="n">rxnfc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ifr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rule_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">actual_rule_cnt</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ethcmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr32</span><span class="o">-&gt;</span><span class="n">ifr_ifru</span><span class="p">.</span><span class="n">ifru_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">compat_rxnfc</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">ethcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compat_rxnfc</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Most ethtool structures are defined without padding.</span>
<span class="cm">	 * Unfortunately struct ethtool_rxnfc is an exception.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ethcmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ETHTOOL_GRXCLSRLALL</span>:
		<span class="cm">/* Buffer size is variable */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">rule_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compat_rxnfc</span><span class="o">-&gt;</span><span class="n">rule_cnt</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rule_cnt</span> <span class="o">&gt;</span> <span class="n">KMALLOC_MAX_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">buf_size</span> <span class="o">+=</span> <span class="n">rule_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">ETHTOOL_GRXRINGS</span>:
	<span class="k">case</span> <span class="n">ETHTOOL_GRXCLSRLCNT</span>:
	<span class="k">case</span> <span class="n">ETHTOOL_GRXCLSRULE</span>:
	<span class="k">case</span> <span class="n">ETHTOOL_SRXCLSRLINS</span>:
		<span class="n">convert_out</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">ETHTOOL_SRXCLSRLDEL</span>:
		<span class="n">buf_size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ethtool_rxnfc</span><span class="p">);</span>
		<span class="n">convert_in</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ifr</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="n">buf_size</span><span class="p">);</span>
	<span class="n">rxnfc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ifr</span> <span class="o">+</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr32</span><span class="o">-&gt;</span><span class="n">ifr_name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">convert_in</span> <span class="o">?</span> <span class="n">rxnfc</span> <span class="o">:</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
		     <span class="o">&amp;</span><span class="n">ifr</span><span class="o">-&gt;</span><span class="n">ifr_ifru</span><span class="p">.</span><span class="n">ifru_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">convert_in</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We expect there to be holes between fs.m_ext and</span>
<span class="cm">		 * fs.ring_cookie and at the end of fs, but nowhere else.</span>
<span class="cm">		 */</span>
		<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ethtool_rxnfc</span><span class="p">,</span> <span class="n">fs</span><span class="p">.</span><span class="n">m_ext</span><span class="p">)</span> <span class="o">+</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="n">compat_rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">m_ext</span><span class="p">)</span> <span class="o">!=</span>
			     <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ethtool_rxnfc</span><span class="p">,</span> <span class="n">fs</span><span class="p">.</span><span class="n">m_ext</span><span class="p">)</span> <span class="o">+</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">m_ext</span><span class="p">));</span>
		<span class="n">BUILD_BUG_ON</span><span class="p">(</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ethtool_rxnfc</span><span class="p">,</span> <span class="n">fs</span><span class="p">.</span><span class="n">location</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ethtool_rxnfc</span><span class="p">,</span> <span class="n">fs</span><span class="p">.</span><span class="n">ring_cookie</span><span class="p">)</span> <span class="o">!=</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ethtool_rxnfc</span><span class="p">,</span> <span class="n">fs</span><span class="p">.</span><span class="n">location</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ethtool_rxnfc</span><span class="p">,</span> <span class="n">fs</span><span class="p">.</span><span class="n">ring_cookie</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="n">rxnfc</span><span class="p">,</span> <span class="n">compat_rxnfc</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">m_ext</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
				 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rxnfc</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">ring_cookie</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">compat_rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">ring_cookie</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">location</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
				 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">ring_cookie</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">rule_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">compat_rxnfc</span><span class="o">-&gt;</span><span class="n">rule_cnt</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">rule_cnt</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">SIOCETHTOOL</span><span class="p">,</span> <span class="n">ifr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">convert_out</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="n">compat_rxnfc</span><span class="p">,</span> <span class="n">rxnfc</span><span class="p">,</span>
				 <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">m_ext</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
				 <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">rxnfc</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compat_rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">ring_cookie</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">ring_cookie</span><span class="p">,</span>
				 <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">location</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
				 <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">fs</span><span class="p">.</span><span class="n">ring_cookie</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compat_rxnfc</span><span class="o">-&gt;</span><span class="n">rule_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">rule_cnt</span><span class="p">,</span>
				 <span class="k">sizeof</span><span class="p">(</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">rule_cnt</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ethcmd</span> <span class="o">==</span> <span class="n">ETHTOOL_GRXCLSRLALL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* As an optimisation, we only copy the actual</span>
<span class="cm">			 * number of rules that the underlying</span>
<span class="cm">			 * function returned.  Since Mallory might</span>
<span class="cm">			 * change the rule count in user memory, we</span>
<span class="cm">			 * check that it is less than the rule count</span>
<span class="cm">			 * originally given (as the user buffer size),</span>
<span class="cm">			 * which has been range-checked.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">actual_rule_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">rule_cnt</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">actual_rule_cnt</span> <span class="o">&lt;</span> <span class="n">rule_cnt</span><span class="p">)</span>
				<span class="n">rule_cnt</span> <span class="o">=</span> <span class="n">actual_rule_cnt</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compat_rxnfc</span><span class="o">-&gt;</span><span class="n">rule_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					 <span class="o">&amp;</span><span class="n">rxnfc</span><span class="o">-&gt;</span><span class="n">rule_locs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					 <span class="n">rule_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_siocwandev</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compat_ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifr32</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uptr</span><span class="p">;</span>
	<span class="n">compat_uptr_t</span> <span class="n">uptr32</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifr</span><span class="p">;</span>

	<span class="n">uifr</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uifr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="n">uifr</span><span class="p">,</span> <span class="n">uifr32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">uptr32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifr32</span><span class="o">-&gt;</span><span class="n">ifr_settings</span><span class="p">.</span><span class="n">ifs_ifsu</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">uptr</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">uptr32</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">uptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifr</span><span class="o">-&gt;</span><span class="n">ifr_settings</span><span class="p">.</span><span class="n">ifs_ifsu</span><span class="p">.</span><span class="n">raw_hdlc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">SIOCWANDEV</span><span class="p">,</span> <span class="n">uifr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bond_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">compat_ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ifr32</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">kifr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifr</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">datap</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCBONDENSLAVE</span>:
	<span class="k">case</span> <span class="n">SIOCBONDRELEASE</span>:
	<span class="k">case</span> <span class="n">SIOCBONDSETHWADDR</span>:
	<span class="k">case</span> <span class="n">SIOCBONDCHANGEACTIVE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kifr</span><span class="p">,</span> <span class="n">ifr32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
		<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">kifr</span><span class="p">);</span>
		<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCBONDSLAVEINFOQUERY</span>:
	<span class="k">case</span> <span class="n">SIOCBONDINFOQUERY</span>:
		<span class="n">uifr</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uifr</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uifr</span><span class="o">-&gt;</span><span class="n">ifr_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr32</span><span class="o">-&gt;</span><span class="n">ifr_name</span><span class="p">,</span> <span class="n">IFNAMSIZ</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr32</span><span class="o">-&gt;</span><span class="n">ifr_ifru</span><span class="p">.</span><span class="n">ifru_data</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">datap</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">datap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifr</span><span class="o">-&gt;</span><span class="n">ifr_ifru</span><span class="p">.</span><span class="n">ifru_data</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">uifr</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">siocdevprivate_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">compat_ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_ifreq32</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_ifreq64</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tmp_buf</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data64</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data32</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">u_ifreq32</span><span class="o">-&gt;</span><span class="n">ifr_ifrn</span><span class="p">.</span><span class="n">ifrn_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			   <span class="n">IFNAMSIZ</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__get_user</span><span class="p">(</span><span class="n">data32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_ifreq32</span><span class="o">-&gt;</span><span class="n">ifr_ifru</span><span class="p">.</span><span class="n">ifru_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">data64</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">data32</span><span class="p">);</span>

	<span class="n">u_ifreq64</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">u_ifreq64</span><span class="p">));</span>

	<span class="cm">/* Don&#39;t check these user accesses, just let that get trapped</span>
<span class="cm">	 * in the ioctl handler instead.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u_ifreq64</span><span class="o">-&gt;</span><span class="n">ifr_ifrn</span><span class="p">.</span><span class="n">ifrn_name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">tmp_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			 <span class="n">IFNAMSIZ</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">data64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_ifreq64</span><span class="o">-&gt;</span><span class="n">ifr_ifru</span><span class="p">.</span><span class="n">ifru_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">u_ifreq64</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dev_ifsioc</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compat_ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifr32</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">uifr</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uifr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="n">uifr</span><span class="p">,</span> <span class="n">uifr32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uifr32</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_do_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">uifr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SIOCGIFFLAGS</span>:
		<span class="k">case</span> <span class="n">SIOCGIFMETRIC</span>:
		<span class="k">case</span> <span class="n">SIOCGIFMTU</span>:
		<span class="k">case</span> <span class="n">SIOCGIFMEM</span>:
		<span class="k">case</span> <span class="n">SIOCGIFHWADDR</span>:
		<span class="k">case</span> <span class="n">SIOCGIFINDEX</span>:
		<span class="k">case</span> <span class="n">SIOCGIFADDR</span>:
		<span class="k">case</span> <span class="n">SIOCGIFBRDADDR</span>:
		<span class="k">case</span> <span class="n">SIOCGIFDSTADDR</span>:
		<span class="k">case</span> <span class="n">SIOCGIFNETMASK</span>:
		<span class="k">case</span> <span class="n">SIOCGIFPFLAGS</span>:
		<span class="k">case</span> <span class="n">SIOCGIFTXQLEN</span>:
		<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:
		<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="n">uifr32</span><span class="p">,</span> <span class="n">uifr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uifr32</span><span class="p">)))</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_sioc_ifmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">compat_ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifr32</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">ifr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">compat_ifmap</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifmap32</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">uifmap32</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">uifr32</span><span class="o">-&gt;</span><span class="n">ifr_ifru</span><span class="p">.</span><span class="n">ifru_map</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="n">uifr32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">));</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">mem_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">mem_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">mem_end</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">base_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span>  <span class="n">__user</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ifr</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">SIOCGIFMAP</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">uifr32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">));</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">mem_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">mem_start</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">mem_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">mem_end</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">base_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">dma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="n">__put_user</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_map</span><span class="p">.</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifmap32</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_siocshwtstamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compat_ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifr32</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uptr</span><span class="p">;</span>
	<span class="n">compat_uptr_t</span> <span class="n">uptr32</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ifreq</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uifr</span><span class="p">;</span>

	<span class="n">uifr</span> <span class="o">=</span> <span class="n">compat_alloc_user_space</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uifr</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_in_user</span><span class="p">(</span><span class="n">uifr</span><span class="p">,</span> <span class="n">uifr32</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">compat_ifreq</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">uptr32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifr32</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">uptr</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">uptr32</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">uptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uifr</span><span class="o">-&gt;</span><span class="n">ifr_data</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dev_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">SIOCSHWTSTAMP</span><span class="p">,</span> <span class="n">uifr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">rtentry32</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">rt_pad1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">rt_dst</span><span class="p">;</span>         <span class="cm">/* target address               */</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">rt_gateway</span><span class="p">;</span>     <span class="cm">/* gateway addr (RTF_GATEWAY)   */</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">rt_genmask</span><span class="p">;</span>     <span class="cm">/* target network mask (IP)     */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>	<span class="n">rt_flags</span><span class="p">;</span>
	<span class="kt">short</span>		<span class="n">rt_pad2</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">rt_pad3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">rt_tos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">rt_class</span><span class="p">;</span>
	<span class="kt">short</span>		<span class="n">rt_pad4</span><span class="p">;</span>
	<span class="kt">short</span>		<span class="n">rt_metric</span><span class="p">;</span>      <span class="cm">/* +1 for binary compatibility! */</span>
	<span class="cm">/* char * */</span> <span class="n">u32</span> <span class="n">rt_dev</span><span class="p">;</span>        <span class="cm">/* forcing the device at add    */</span>
	<span class="n">u32</span>		<span class="n">rt_mtu</span><span class="p">;</span>         <span class="cm">/* per route MTU/Window         */</span>
	<span class="n">u32</span>		<span class="n">rt_window</span><span class="p">;</span>      <span class="cm">/* Window clamping              */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">rt_irtt</span><span class="p">;</span>        <span class="cm">/* Initial RTT                  */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">in6_rtmsg32</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">in6_addr</span>		<span class="n">rtmsg_dst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in6_addr</span>		<span class="n">rtmsg_src</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in6_addr</span>		<span class="n">rtmsg_gateway</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">rtmsg_type</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">rtmsg_dst_len</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">rtmsg_src_len</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">rtmsg_metric</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">rtmsg_info</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">rtmsg_flags</span><span class="p">;</span>
	<span class="n">s32</span>			<span class="n">rtmsg_ifindex</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">routing_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">in6_rtmsg</span> <span class="n">r6</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rtentry</span> <span class="n">r4</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">devname</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">rtdev</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ipv6 */</span>
		<span class="k">struct</span> <span class="n">in6_rtmsg32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ur6</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r6</span><span class="p">.</span><span class="n">rtmsg_dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur6</span><span class="o">-&gt;</span><span class="n">rtmsg_dst</span><span class="p">),</span>
			<span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">in6_addr</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r6</span><span class="p">.</span><span class="n">rtmsg_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur6</span><span class="o">-&gt;</span><span class="n">rtmsg_type</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r6</span><span class="p">.</span><span class="n">rtmsg_dst_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur6</span><span class="o">-&gt;</span><span class="n">rtmsg_dst_len</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r6</span><span class="p">.</span><span class="n">rtmsg_src_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur6</span><span class="o">-&gt;</span><span class="n">rtmsg_src_len</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r6</span><span class="p">.</span><span class="n">rtmsg_metric</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur6</span><span class="o">-&gt;</span><span class="n">rtmsg_metric</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r6</span><span class="p">.</span><span class="n">rtmsg_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur6</span><span class="o">-&gt;</span><span class="n">rtmsg_info</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r6</span><span class="p">.</span><span class="n">rtmsg_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur6</span><span class="o">-&gt;</span><span class="n">rtmsg_flags</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r6</span><span class="p">.</span><span class="n">rtmsg_ifindex</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur6</span><span class="o">-&gt;</span><span class="n">rtmsg_ifindex</span><span class="p">));</span>

		<span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">r6</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* ipv4 */</span>
		<span class="k">struct</span> <span class="n">rtentry32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ur4</span> <span class="o">=</span> <span class="n">argp</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r4</span><span class="p">.</span><span class="n">rt_dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur4</span><span class="o">-&gt;</span><span class="n">rt_dst</span><span class="p">),</span>
					<span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r4</span><span class="p">.</span><span class="n">rt_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur4</span><span class="o">-&gt;</span><span class="n">rt_flags</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r4</span><span class="p">.</span><span class="n">rt_metric</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur4</span><span class="o">-&gt;</span><span class="n">rt_metric</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r4</span><span class="p">.</span><span class="n">rt_mtu</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur4</span><span class="o">-&gt;</span><span class="n">rt_mtu</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r4</span><span class="p">.</span><span class="n">rt_window</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur4</span><span class="o">-&gt;</span><span class="n">rt_window</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">r4</span><span class="p">.</span><span class="n">rt_irtt</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur4</span><span class="o">-&gt;</span><span class="n">rt_irtt</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">|=</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">rtdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ur4</span><span class="o">-&gt;</span><span class="n">rt_dev</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rtdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">|=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">devname</span><span class="p">,</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">rtdev</span><span class="p">),</span> <span class="mi">15</span><span class="p">);</span>
			<span class="n">r4</span><span class="p">.</span><span class="n">rt_dev</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span><span class="n">devname</span><span class="p">;</span>
			<span class="n">devname</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">r4</span><span class="p">.</span><span class="n">rt_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">r4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sock_do_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">r</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Since old style bridge ioctl&#39;s endup using SIOCDEVPRIVATE</span>
<span class="cm"> * for some operations; this forces use of the newer bridge-utils that</span>
<span class="cm"> * use compatible ioctls</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">old_bridge_ioctl</span><span class="p">(</span><span class="n">compat_ulong_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">compat_ulong_t</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">argp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">BRCTL_GET_VERSION</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BRCTL_VERSION</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compat_sock_ioctl_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="n">compat_ptr</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&gt;=</span> <span class="n">SIOCDEVPRIVATE</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">SIOCDEVPRIVATE</span> <span class="o">+</span> <span class="mi">15</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">siocdevprivate_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCSIFBR</span>:
	<span class="k">case</span> <span class="n">SIOCGIFBR</span>:
		<span class="k">return</span> <span class="n">old_bridge_ioctl</span><span class="p">(</span><span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SIOCGIFNAME</span>:
		<span class="k">return</span> <span class="n">dev_ifname32</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SIOCGIFCONF</span>:
		<span class="k">return</span> <span class="n">dev_ifconf</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SIOCETHTOOL</span>:
		<span class="k">return</span> <span class="n">ethtool_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SIOCWANDEV</span>:
		<span class="k">return</span> <span class="n">compat_siocwandev</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SIOCGIFMAP</span>:
	<span class="k">case</span> <span class="n">SIOCSIFMAP</span>:
		<span class="k">return</span> <span class="n">compat_sioc_ifmap</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SIOCBONDENSLAVE</span>:
	<span class="k">case</span> <span class="n">SIOCBONDRELEASE</span>:
	<span class="k">case</span> <span class="n">SIOCBONDSETHWADDR</span>:
	<span class="k">case</span> <span class="n">SIOCBONDSLAVEINFOQUERY</span>:
	<span class="k">case</span> <span class="n">SIOCBONDINFOQUERY</span>:
	<span class="k">case</span> <span class="n">SIOCBONDCHANGEACTIVE</span>:
		<span class="k">return</span> <span class="n">bond_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SIOCADDRT</span>:
	<span class="k">case</span> <span class="n">SIOCDELRT</span>:
		<span class="k">return</span> <span class="n">routing_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SIOCGSTAMP</span>:
		<span class="k">return</span> <span class="n">do_siocgstamp</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SIOCGSTAMPNS</span>:
		<span class="k">return</span> <span class="n">do_siocgstampns</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SIOCSHWTSTAMP</span>:
		<span class="k">return</span> <span class="n">compat_siocshwtstamp</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">FIOSETOWN</span>:
	<span class="k">case</span> <span class="n">SIOCSPGRP</span>:
	<span class="k">case</span> <span class="n">FIOGETOWN</span>:
	<span class="k">case</span> <span class="n">SIOCGPGRP</span>:
	<span class="k">case</span> <span class="n">SIOCBRADDBR</span>:
	<span class="k">case</span> <span class="n">SIOCBRDELBR</span>:
	<span class="k">case</span> <span class="n">SIOCGIFVLAN</span>:
	<span class="k">case</span> <span class="n">SIOCSIFVLAN</span>:
	<span class="k">case</span> <span class="n">SIOCADDDLCI</span>:
	<span class="k">case</span> <span class="n">SIOCDELDLCI</span>:
		<span class="k">return</span> <span class="n">sock_ioctl</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SIOCGIFFLAGS</span>:
	<span class="k">case</span> <span class="n">SIOCSIFFLAGS</span>:
	<span class="k">case</span> <span class="n">SIOCGIFMETRIC</span>:
	<span class="k">case</span> <span class="n">SIOCSIFMETRIC</span>:
	<span class="k">case</span> <span class="n">SIOCGIFMTU</span>:
	<span class="k">case</span> <span class="n">SIOCSIFMTU</span>:
	<span class="k">case</span> <span class="n">SIOCGIFMEM</span>:
	<span class="k">case</span> <span class="n">SIOCSIFMEM</span>:
	<span class="k">case</span> <span class="n">SIOCGIFHWADDR</span>:
	<span class="k">case</span> <span class="n">SIOCSIFHWADDR</span>:
	<span class="k">case</span> <span class="n">SIOCADDMULTI</span>:
	<span class="k">case</span> <span class="n">SIOCDELMULTI</span>:
	<span class="k">case</span> <span class="n">SIOCGIFINDEX</span>:
	<span class="k">case</span> <span class="n">SIOCGIFADDR</span>:
	<span class="k">case</span> <span class="n">SIOCSIFADDR</span>:
	<span class="k">case</span> <span class="n">SIOCSIFHWBROADCAST</span>:
	<span class="k">case</span> <span class="n">SIOCDIFADDR</span>:
	<span class="k">case</span> <span class="n">SIOCGIFBRDADDR</span>:
	<span class="k">case</span> <span class="n">SIOCSIFBRDADDR</span>:
	<span class="k">case</span> <span class="n">SIOCGIFDSTADDR</span>:
	<span class="k">case</span> <span class="n">SIOCSIFDSTADDR</span>:
	<span class="k">case</span> <span class="n">SIOCGIFNETMASK</span>:
	<span class="k">case</span> <span class="n">SIOCSIFNETMASK</span>:
	<span class="k">case</span> <span class="n">SIOCSIFPFLAGS</span>:
	<span class="k">case</span> <span class="n">SIOCGIFPFLAGS</span>:
	<span class="k">case</span> <span class="n">SIOCGIFTXQLEN</span>:
	<span class="k">case</span> <span class="n">SIOCSIFTXQLEN</span>:
	<span class="k">case</span> <span class="n">SIOCBRADDIF</span>:
	<span class="k">case</span> <span class="n">SIOCBRDELIF</span>:
	<span class="k">case</span> <span class="n">SIOCSIFNAME</span>:
	<span class="k">case</span> <span class="n">SIOCGMIIPHY</span>:
	<span class="k">case</span> <span class="n">SIOCGMIIREG</span>:
	<span class="k">case</span> <span class="n">SIOCSMIIREG</span>:
		<span class="k">return</span> <span class="n">dev_ifsioc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">SIOCSARP</span>:
	<span class="k">case</span> <span class="n">SIOCGARP</span>:
	<span class="k">case</span> <span class="n">SIOCDARP</span>:
	<span class="k">case</span> <span class="n">SIOCATMARK</span>:
		<span class="k">return</span> <span class="n">sock_do_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">compat_sock_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">compat_ioctl</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">compat_ioctl</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cmd</span> <span class="o">&gt;=</span> <span class="n">SIOCIWFIRST</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span> <span class="o">&lt;=</span> <span class="n">SIOCIWLAST</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_wext_handle_ioctl</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">compat_sock_ioctl_trans</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">kernel_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_bind</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kernel_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">listen</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">backlog</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_listen</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kernel_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">**</span><span class="n">newsock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_create_lite</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_family</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span><span class="p">,</span>
			       <span class="n">newsock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">*</span><span class="n">newsock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sock_release</span><span class="p">(</span><span class="o">*</span><span class="n">newsock</span><span class="p">);</span>
		<span class="o">*</span><span class="n">newsock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">(</span><span class="o">*</span><span class="n">newsock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>
	<span class="n">__module_get</span><span class="p">((</span><span class="o">*</span><span class="n">newsock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_accept</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kernel_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addrlen</span><span class="p">,</span>
		   <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_connect</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kernel_getsockname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">getname</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_getsockname</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kernel_getpeername</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">getname</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_getpeername</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kernel_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_segment_t</span> <span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uoptval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uoptlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">uoptval</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span> <span class="n">optval</span><span class="p">;</span>
	<span class="n">uoptlen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span> <span class="n">optlen</span><span class="p">;</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">SOL_SOCKET</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_getsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">uoptval</span><span class="p">,</span> <span class="n">uoptlen</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">getsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">uoptval</span><span class="p">,</span>
					    <span class="n">uoptlen</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_getsockopt</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kernel_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_segment_t</span> <span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">uoptval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">uoptval</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="n">__force</span> <span class="o">*</span><span class="p">)</span> <span class="n">optval</span><span class="p">;</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">SOL_SOCKET</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">uoptval</span><span class="p">,</span> <span class="n">optlen</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">optname</span><span class="p">,</span> <span class="n">uoptval</span><span class="p">,</span>
					    <span class="n">optlen</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_setsockopt</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kernel_sendpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
		    <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sock_update_classid</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sendpage</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sendpage</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sock_no_sendpage</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_sendpage</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kernel_sock_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mm_segment_t</span> <span class="n">oldfs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ioctl</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">oldfs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_sock_ioctl</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">kernel_sock_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">enum</span> <span class="n">sock_shutdown_cmd</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">shutdown</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">how</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kernel_sock_shutdown</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
