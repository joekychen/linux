<!DOCTYPE html>
<html><head><title>joekychen/linux » net › iucv › af_iucv.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>af_iucv.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  IUCV protocol stack for Linux on zSeries</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright IBM Corp. 2006, 2009</span>
<span class="cm"> *</span>
<span class="cm"> *  Author(s):	Jennifer Hunt &lt;jenhunt@us.ibm.com&gt;</span>
<span class="cm"> *		Hendrik Brueckner &lt;brueckner@linux.vnet.ibm.com&gt;</span>
<span class="cm"> *  PM functions:</span>
<span class="cm"> *		Ursula Braun &lt;ursula.braun@de.ibm.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#define KMSG_COMPONENT &quot;af_iucv&quot;</span>
<span class="cp">#define pr_fmt(fmt) KMSG_COMPONENT &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;asm/ebcdic.h&gt;</span>
<span class="cp">#include &lt;asm/cpcmd.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>

<span class="cp">#include &lt;net/iucv/af_iucv.h&gt;</span>

<span class="cp">#define VERSION &quot;1.2&quot;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">iucv_userid</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">iucv_sock_ops</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proto</span> <span class="n">iucv_proto</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;AF_IUCV&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">obj_size</span>	<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_sock</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iucv_interface</span> <span class="o">*</span><span class="n">pr_iucv</span><span class="p">;</span>

<span class="cm">/* special AF_IUCV IPRM messages */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">iprm_shutdown</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span>
	<span class="p">{</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">};</span>

<span class="cp">#define TRGCLS_SIZE	(sizeof(((struct iucv_message *)0)-&gt;class))</span>

<span class="cm">/* macros to set/get socket control buffer at correct offset */</span>
<span class="cp">#define CB_TAG(skb)	((skb)-&gt;cb)		</span><span class="cm">/* iucv message tag */</span><span class="cp"></span>
<span class="cp">#define CB_TAG_LEN	(sizeof(((struct iucv_message *) 0)-&gt;tag))</span>
<span class="cp">#define CB_TRGCLS(skb)	((skb)-&gt;cb + CB_TAG_LEN) </span><span class="cm">/* iucv msg target class */</span><span class="cp"></span>
<span class="cp">#define CB_TRGCLS_LEN	(TRGCLS_SIZE)</span>

<span class="cp">#define __iucv_sock_wait(sk, condition, timeo, ret)			\</span>
<span class="cp">do {									\</span>
<span class="cp">	DEFINE_WAIT(__wait);						\</span>
<span class="cp">	long __timeo = timeo;						\</span>
<span class="cp">	ret = 0;							\</span>
<span class="cp">	prepare_to_wait(sk_sleep(sk), &amp;__wait, TASK_INTERRUPTIBLE);	\</span>
<span class="cp">	while (!(condition)) {						\</span>
<span class="cp">		if (!__timeo) {						\</span>
<span class="cp">			ret = -EAGAIN;					\</span>
<span class="cp">			break;						\</span>
<span class="cp">		}							\</span>
<span class="cp">		if (signal_pending(current)) {				\</span>
<span class="cp">			ret = sock_intr_errno(__timeo);			\</span>
<span class="cp">			break;						\</span>
<span class="cp">		}							\</span>
<span class="cp">		release_sock(sk);					\</span>
<span class="cp">		__timeo = schedule_timeout(__timeo);			\</span>
<span class="cp">		lock_sock(sk);						\</span>
<span class="cp">		ret = sock_error(sk);					\</span>
<span class="cp">		if (ret)						\</span>
<span class="cp">			break;						\</span>
<span class="cp">	}								\</span>
<span class="cp">	finish_wait(sk_sleep(sk), &amp;__wait);				\</span>
<span class="cp">} while (0)</span>

<span class="cp">#define iucv_sock_wait(sk, condition, timeo)				\</span>
<span class="cp">({									\</span>
<span class="cp">	int __ret = 0;							\</span>
<span class="cp">	if (!(condition))						\</span>
<span class="cp">		__iucv_sock_wait(sk, condition, timeo, __ret);		\</span>
<span class="cp">	__ret;								\</span>
<span class="cp">})</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">iucv_sock_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">iucv_sock_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">iucv_sever_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">afiucv_hs_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">afiucv_hs_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">imsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">afiucv_hs_callback_txnotify</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">,</span> <span class="k">enum</span> <span class="n">iucv_tx_notify</span><span class="p">);</span>

<span class="cm">/* Call Back functions */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">iucv_callback_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">iucv_callback_txdone</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">iucv_callback_connack</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">iucv_callback_connreq</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipvmid</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span>
				 <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">iucv_callback_connrej</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">iucv_callback_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iucv_sock_list</span> <span class="n">iucv_sk_list</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">__RW_LOCK_UNLOCKED</span><span class="p">(</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">autobind_name</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iucv_handler</span> <span class="n">af_iucv_handler</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">path_pending</span>	  <span class="o">=</span> <span class="n">iucv_callback_connreq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">path_complete</span>	  <span class="o">=</span> <span class="n">iucv_callback_connack</span><span class="p">,</span>
	<span class="p">.</span><span class="n">path_severed</span>	  <span class="o">=</span> <span class="n">iucv_callback_connrej</span><span class="p">,</span>
	<span class="p">.</span><span class="n">message_pending</span>  <span class="o">=</span> <span class="n">iucv_callback_rx</span><span class="p">,</span>
	<span class="p">.</span><span class="n">message_complete</span> <span class="o">=</span> <span class="n">iucv_callback_txdone</span><span class="p">,</span>
	<span class="p">.</span><span class="n">path_quiesced</span>	  <span class="o">=</span> <span class="n">iucv_callback_shutdown</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">high_nmcpy</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
       <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">low_nmcpy</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
       <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">src</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_pm_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;afiucv_pm_prepare</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">afiucv_pm_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;afiucv_pm_complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * afiucv_pm_freeze() - Freeze PM callback</span>
<span class="cm"> * @dev:	AFIUCV dummy device</span>
<span class="cm"> *</span>
<span class="cm"> * Sever all established IUCV communication pathes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_pm_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;afiucv_pm_freeze</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sk_for_each</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IUCV_DISCONN</span>:
		<span class="k">case</span> <span class="n">IUCV_CLOSING</span>:
		<span class="k">case</span> <span class="n">IUCV_CONNECTED</span>:
			<span class="n">iucv_sever_path</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IUCV_OPEN</span>:
		<span class="k">case</span> <span class="n">IUCV_BOUND</span>:
		<span class="k">case</span> <span class="n">IUCV_LISTEN</span>:
		<span class="k">case</span> <span class="n">IUCV_CLOSED</span>:
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">);</span>
		<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * afiucv_pm_restore_thaw() - Thaw and restore PM callback</span>
<span class="cm"> * @dev:	AFIUCV dummy device</span>
<span class="cm"> *</span>
<span class="cm"> * socket clean up after freeze</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_pm_restore_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;afiucv_pm_restore_thaw</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sk_for_each</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IUCV_CONNECTED</span>:
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">EPIPE</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_DISCONN</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IUCV_DISCONN</span>:
		<span class="k">case</span> <span class="n">IUCV_CLOSING</span>:
		<span class="k">case</span> <span class="n">IUCV_LISTEN</span>:
		<span class="k">case</span> <span class="n">IUCV_BOUND</span>:
		<span class="k">case</span> <span class="n">IUCV_OPEN</span>:
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">afiucv_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span> <span class="n">afiucv_pm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">complete</span> <span class="o">=</span> <span class="n">afiucv_pm_complete</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze</span> <span class="o">=</span> <span class="n">afiucv_pm_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span> <span class="o">=</span> <span class="n">afiucv_pm_restore_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore</span> <span class="o">=</span> <span class="n">afiucv_pm_restore_thaw</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="n">af_iucv_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;afiucv&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pm</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">afiucv_pm_ops</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* dummy device used as trigger for PM functions */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">af_iucv_dev</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_msg_length() - Returns the length of an iucv message.</span>
<span class="cm"> * @msg:	Pointer to struct iucv_message, MUST NOT be NULL</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns the length of the specified iucv message @msg of data</span>
<span class="cm"> * stored in a buffer and of data stored in the parameter list (PRMDATA).</span>
<span class="cm"> *</span>
<span class="cm"> * For IUCV_IPRMDATA, AF_IUCV uses the following convention to transport socket</span>
<span class="cm"> * data:</span>
<span class="cm"> *	PRMDATA[0..6]	socket data (max 7 bytes);</span>
<span class="cm"> *	PRMDATA[7]	socket data length value (len is 0xff - PRMDATA[7])</span>
<span class="cm"> *</span>
<span class="cm"> * The socket data length is computed by subtracting the socket data length</span>
<span class="cm"> * value from 0xFF.</span>
<span class="cm"> * If the socket data len is greater 7, then PRMDATA can be used for special</span>
<span class="cm"> * notifications (see iucv_sock_shutdown); and further,</span>
<span class="cm"> * if the socket data len is &gt; 7, the function returns 8.</span>
<span class="cm"> *</span>
<span class="cm"> * Use this function to allocate socket buffers to store iucv message data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">iucv_msg_length</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">datalen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IUCV_IPRMDATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">datalen</span> <span class="o">=</span> <span class="mh">0xff</span> <span class="o">-</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">rmmsg</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">datalen</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">?</span> <span class="n">datalen</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_sock_in_state() - check for specific states</span>
<span class="cm"> * @sk:		sock structure</span>
<span class="cm"> * @state:	first iucv sk state</span>
<span class="cm"> * @state:	second iucv sk state</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if the socket in either in the first or second state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_in_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">state</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">state2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_below_msglim() - function to check if messages can be sent</span>
<span class="cm"> * @sk:		sock structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if the send queue length is lower than the message limit.</span>
<span class="cm"> * Always returns true if the socket is not connected (no iucv path for</span>
<span class="cm"> * checking the message limit).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iucv_below_msglim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_CONNECTED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">AF_IUCV_TRANS_IUCV</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">msglim</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_sent</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit_peer</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">pendings</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_sock_wake_msglim() - Wake up thread waiting on msg limit</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_sock_wake_msglim</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq_has_sleeper</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span>
		<span class="n">wake_up_interruptible_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_SPACE</span><span class="p">,</span> <span class="n">POLL_OUT</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * afiucv_hs_send() - send a message through HiperSockets transport</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_hs_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">imsg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="n">phs_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">confirm_recv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">);</span>
	<span class="n">phs_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span><span class="p">));</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">);</span>
	<span class="n">skb_reset_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">phs_hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span><span class="p">));</span>

	<span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">ETH_P_AF_IUCV</span><span class="p">;</span>
	<span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">AF_IUCV_FLAG_SYN</span><span class="p">)</span>
		<span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">=</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">==</span> <span class="n">AF_IUCV_FLAG_WIN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">confirm_recv</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_recv</span><span class="p">);</span>
		<span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">=</span> <span class="n">confirm_recv</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">confirm_recv</span><span class="p">)</span>
			<span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">AF_IUCV_FLAG_WIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">destUserID</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">dst_user_id</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">destAppName</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">dst_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">srcUserID</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_user_id</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">srcAppName</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">destUserID</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">destUserID</span><span class="p">));</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">destAppName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">destAppName</span><span class="p">));</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">srcUserID</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">srcUserID</span><span class="p">));</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">srcAppName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">srcAppName</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">imsg</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phs_hdr</span><span class="o">-&gt;</span><span class="n">iucv_hdr</span><span class="p">,</span> <span class="n">imsg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_message</span><span class="p">));</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">hs_dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">netif_carrier_ok</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENETDOWN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">skb_trim</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ETH_P_AF_IUCV</span><span class="p">;</span>
	<span class="n">nskb</span> <span class="o">=</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nskb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">,</span> <span class="n">nskb</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">net_xmit_eval</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_unlink</span><span class="p">(</span><span class="n">nskb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">atomic_sub</span><span class="p">(</span><span class="n">confirm_recv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_recv</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_recv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">net_xmit_eval</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">__iucv_get_sock_by_name</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">nm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">sk_for_each</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_sock_destruct</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_queue</span><span class="p">);</span>

	<span class="n">sk_mem_reclaim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Attempt to release alive iucv socket %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_queued</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_forward_alloc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Cleanup Listen */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_sock_cleanup_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* Close non-accepted connections */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">sk</span> <span class="o">=</span> <span class="n">iucv_accept_dequeue</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">iucv_sock_close</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">iucv_sock_kill</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_CLOSED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Kill socket (only if zapped and orphaned) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_sock_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">)</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">iucv_sock_unlink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Terminate an IUCV path */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_sever_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">with_user_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">user_data</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">with_user_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">low_nmcpy</span><span class="p">(</span><span class="n">user_data</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">);</span>
			<span class="n">high_nmcpy</span><span class="p">(</span><span class="n">user_data</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">dst_name</span><span class="p">);</span>
			<span class="n">ASCEBC</span><span class="p">(</span><span class="n">user_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">user_data</span><span class="p">));</span>
			<span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">path_sever</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">user_data</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">path_sever</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">iucv_path_free</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Send FIN through an IUCV socket for HIPER transport */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_send_ctrl</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">blen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">;</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_alloc_send_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">blen</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">afiucv_hs_send</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Close an IUCV socket */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_sock_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IUCV_LISTEN</span>:
		<span class="n">iucv_sock_cleanup_listen</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IUCV_CONNECTED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">AF_IUCV_TRANS_HIPER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">iucv_send_ctrl</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">AF_IUCV_FLAG_FIN</span><span class="p">);</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_DISCONN</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">IUCV_DISCONN</span>:   <span class="cm">/* fall through */</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_CLOSING</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_LINGER</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lingertime</span><span class="p">)</span>
				<span class="n">timeo</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_lingertime</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">timeo</span> <span class="o">=</span> <span class="n">IUCV_DISCONN_TIMEOUT</span><span class="p">;</span>
			<span class="n">iucv_sock_wait</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
					<span class="n">iucv_sock_in_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">IUCV_CLOSED</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
					<span class="n">timeo</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="k">case</span> <span class="n">IUCV_CLOSING</span>:   <span class="cm">/* fall through */</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_CLOSED</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">ECONNRESET</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">);</span>
		<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">);</span>

	<span class="nl">default:</span>   <span class="cm">/* fall through */</span>
		<span class="n">iucv_sever_path</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">hs_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_put</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">hs_dev</span><span class="p">);</span>
		<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">hs_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* mark socket for deletion by iucv_sock_kill() */</span>
	<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">);</span>

	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_sock_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">iucv_sock_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">proto</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span><span class="p">;</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">sk_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">PF_IUCV</span><span class="p">,</span> <span class="n">prio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_proto</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sock_init_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">accept_q</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">accept_q_lock</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">);</span>
	<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">pendings</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_sent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_recv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">sk_txnotify</span> <span class="o">=</span> <span class="n">afiucv_hs_callback_txnotify</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_user_id</span> <span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pr_iucv</span><span class="p">)</span>
		<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">AF_IUCV_TRANS_IUCV</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">AF_IUCV_TRANS_HIPER</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span> <span class="o">=</span> <span class="n">iucv_sock_destruct</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndtimeo</span> <span class="o">=</span> <span class="n">IUCV_CONN_TIMEOUT</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span> <span class="o">=</span> <span class="n">GFP_DMA</span><span class="p">;</span>

	<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span> <span class="o">=</span> <span class="n">proto</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>	<span class="o">=</span> <span class="n">IUCV_OPEN</span><span class="p">;</span>

	<span class="n">iucv_sock_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Create an IUCV socket */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">&amp;&amp;</span> <span class="n">protocol</span> <span class="o">!=</span> <span class="n">PF_IUCV</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOCK_STREAM</span>:
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iucv_sock_ops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_SEQPACKET</span>:
		<span class="cm">/* currently, proto ops can handle both sk types */</span>
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iucv_sock_ops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESOCKTNOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">iucv_sock_alloc</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">iucv_sock_init</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iucv_sock_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_sock_list</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sk_add_node</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iucv_sock_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_sock_list</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sk_del_node_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iucv_accept_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">accept_q_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">accept_q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">accept_q</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">accept_q_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">sk_acceptq_added</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">iucv_accept_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">accept_q_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">accept_q</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">par</span><span class="o">-&gt;</span><span class="n">accept_q_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sk_acceptq_removed</span><span class="p">(</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">iucv_accept_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">isk</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">isk</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">accept_q</span><span class="p">,</span> <span class="n">accept_q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span> <span class="n">isk</span><span class="p">;</span>
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_CLOSED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iucv_accept_unlink</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_CONNECTED</span> <span class="o">||</span>
		    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_DISCONN</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">newsock</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iucv_accept_unlink</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newsock</span><span class="p">)</span>
				<span class="n">sock_graft</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">newsock</span><span class="p">);</span>

			<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Bind an unbound socket */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_iucv</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_iucv</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">uid</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>

	<span class="cm">/* Verify the input sockaddr */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span> <span class="o">||</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">AF_IUCV</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_OPEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__iucv_get_sock_by_name</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">siucv_name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done_unlock</span><span class="p">;</span>

	<span class="cm">/* Bind the socket */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pr_iucv</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">siucv_user_id</span><span class="p">,</span> <span class="n">iucv_userid</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">vm_bind</span><span class="p">;</span> <span class="cm">/* VM IUCV transport */</span>

	<span class="cm">/* try hiper transport */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">siucv_user_id</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uid</span><span class="p">));</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">uid</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">for_each_netdev_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">perm_addr</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">siucv_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_user_id</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">siucv_user_id</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">ifindex</span><span class="p">;</span>
			<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">hs_dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
			<span class="n">dev_hold</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_BOUND</span><span class="p">;</span>
			<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">AF_IUCV_TRANS_HIPER</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span><span class="p">)</span>
				<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span> <span class="o">=</span> <span class="n">IUCV_HIPER_MSGLIM_DEFAULT</span><span class="p">;</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">done_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="nl">vm_bind:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pr_iucv</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* use local userid for backward compat */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">siucv_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_user_id</span><span class="p">,</span> <span class="n">iucv_userid</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_BOUND</span><span class="p">;</span>
		<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">AF_IUCV_TRANS_IUCV</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span><span class="p">)</span>
			<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span> <span class="o">=</span> <span class="n">IUCV_QUEUELEN_DEFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* found no dev to bind */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="nl">done_unlock:</span>
	<span class="cm">/* Release the socket list lock */</span>
	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Automatically bind an unbound socket */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_autobind</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pr_iucv</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_user_id</span><span class="p">,</span> <span class="n">iucv_userid</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">write_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%08x&quot;</span><span class="p">,</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">autobind_name</span><span class="p">));</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__iucv_get_sock_by_name</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;%08x&quot;</span><span class="p">,</span>
			<span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">autobind_name</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">write_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span><span class="p">)</span>
		<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span> <span class="o">=</span> <span class="n">IUCV_QUEUELEN_DEFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_path_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_iucv</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_iucv</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">user_data</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">high_nmcpy</span><span class="p">(</span><span class="n">user_data</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">siucv_name</span><span class="p">);</span>
	<span class="n">low_nmcpy</span><span class="p">(</span><span class="n">user_data</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">);</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">user_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">user_data</span><span class="p">));</span>

	<span class="cm">/* Create path. */</span>
	<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">iucv_path_alloc</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span><span class="p">,</span>
				     <span class="n">IUCV_IPRMDATA</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">path_connect</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">af_iucv_handler</span><span class="p">,</span>
				    <span class="n">sa</span><span class="o">-&gt;</span><span class="n">siucv_user_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">user_data</span><span class="p">,</span>
				    <span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iucv_path_free</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x0b</span>:	<span class="cm">/* Target communicator is not logged on */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENETUNREACH</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x0d</span>:	<span class="cm">/* Max connections for this guest exceeded */</span>
		<span class="k">case</span> <span class="mh">0x0e</span>:	<span class="cm">/* Max connections for target guest exceeded */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x0f</span>:	<span class="cm">/* Missing IUCV authorization */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Connect an unconnected socket */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">alen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_iucv</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_iucv</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">AF_IUCV</span> <span class="o">||</span> <span class="n">alen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_iucv</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_OPEN</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_BOUND</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_OPEN</span> <span class="o">&amp;&amp;</span>
	    <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">AF_IUCV_TRANS_HIPER</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span> <span class="cm">/* explicit bind required */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_STREAM</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_OPEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">iucv_sock_autobind</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Set the destination information */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">dst_user_id</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">siucv_user_id</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">dst_name</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">siucv_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">AF_IUCV_TRANS_HIPER</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">iucv_send_ctrl</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">AF_IUCV_FLAG_SYN</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">afiucv_path_connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_CONNECTED</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">iucv_sock_wait</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">iucv_sock_in_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">IUCV_CONNECTED</span><span class="p">,</span>
							    <span class="n">IUCV_DISCONN</span><span class="p">),</span>
				     <span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_DISCONN</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_CLOSED</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">AF_IUCV_TRANS_IUCV</span><span class="p">)</span>
		<span class="n">iucv_sever_path</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Move a socket into listening state. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_BOUND</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SOCK_STREAM</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span> <span class="o">=</span> <span class="n">backlog</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_ack_backlog</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_LISTEN</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Accept a pending connection */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="o">*</span><span class="n">nsk</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lock_sock_nested</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_LISTEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_rcvtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>

	<span class="cm">/* Wait for an incoming connection */</span>
	<span class="n">add_wait_queue_exclusive</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nsk</span> <span class="o">=</span> <span class="n">iucv_accept_dequeue</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">newsock</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">timeo</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
		<span class="n">lock_sock_nested</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_LISTEN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">newsock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>

<span class="nl">done:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_getname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">peer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_iucv</span> <span class="o">*</span><span class="n">siucv</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_iucv</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">=</span> <span class="n">AF_IUCV</span><span class="p">;</span>
	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_iucv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">siucv</span><span class="o">-&gt;</span><span class="n">siucv_user_id</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">dst_user_id</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">siucv</span><span class="o">-&gt;</span><span class="n">siucv_name</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">dst_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">siucv</span><span class="o">-&gt;</span><span class="n">siucv_user_id</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_user_id</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">siucv</span><span class="o">-&gt;</span><span class="n">siucv_name</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">siucv</span><span class="o">-&gt;</span><span class="n">siucv_port</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">siucv</span><span class="o">-&gt;</span><span class="n">siucv_port</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">siucv</span><span class="o">-&gt;</span><span class="n">siucv_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">siucv</span><span class="o">-&gt;</span><span class="n">siucv_addr</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">siucv</span><span class="o">-&gt;</span><span class="n">siucv_nodeid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">siucv</span><span class="o">-&gt;</span><span class="n">siucv_nodeid</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_send_iprm() - Send socket data in parameter list of an iucv message.</span>
<span class="cm"> * @path:	IUCV path</span>
<span class="cm"> * @msg:	Pointer to a struct iucv_message</span>
<span class="cm"> * @skb:	The socket data to send, skb-&gt;len MUST BE &lt;= 7</span>
<span class="cm"> *</span>
<span class="cm"> * Send the socket data in the parameter list in the iucv message</span>
<span class="cm"> * (IUCV_IPRMDATA). The socket data is stored at index 0 to 6 in the parameter</span>
<span class="cm"> * list and the socket data len at index 7 (last byte).</span>
<span class="cm"> * See also iucv_msg_length().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the error code from the iucv_message_send() call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_send_iprm</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">prmdata</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">prmdata</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">prmdata</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xff</span> <span class="o">-</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">message_send</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">IUCV_IPRMDATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">prmdata</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_message</span> <span class="n">txmsg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cmsghdr</span> <span class="o">*</span><span class="n">cmsg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmsg_done</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">user_id</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">appl_id</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">noblock</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_OOB</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/* SOCK_SEQPACKET: we do not support segmented records */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_SEQPACKET</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_EOR</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Return if the socket is not in connected state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* initialize defaults */</span>
	<span class="n">cmsg_done</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* check for duplicate headers */</span>
	<span class="n">txmsg</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* iterate over control messages */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cmsg</span> <span class="o">=</span> <span class="n">CMSG_FIRSTHDR</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span> <span class="n">cmsg</span><span class="p">;</span>
		<span class="n">cmsg</span> <span class="o">=</span> <span class="n">CMSG_NXTHDR</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">cmsg</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CMSG_OK</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">cmsg</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_level</span> <span class="o">!=</span> <span class="n">SOL_IUCV</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_type</span> <span class="o">&amp;</span> <span class="n">cmsg_done</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cmsg_done</span> <span class="o">|=</span> <span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_type</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCM_IUCV_TRGCLS</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">cmsg</span><span class="o">-&gt;</span><span class="n">cmsg_len</span> <span class="o">!=</span> <span class="n">CMSG_LEN</span><span class="p">(</span><span class="n">TRGCLS_SIZE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* set iucv message target class */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txmsg</span><span class="p">.</span><span class="n">class</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">CMSG_DATA</span><span class="p">(</span><span class="n">cmsg</span><span class="p">),</span> <span class="n">TRGCLS_SIZE</span><span class="p">);</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* allocate one skb for each iucv message:</span>
<span class="cm">	 * this is fine for SOCK_SEQPACKET (unless we want to support</span>
<span class="cm">	 * segmented records using the MSG_EOR flag), but</span>
<span class="cm">	 * for SOCK_STREAM we might want to improve it in future */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">AF_IUCV_TRANS_HIPER</span><span class="p">)</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_alloc_send_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
			<span class="n">len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">,</span>
			<span class="n">noblock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_alloc_send_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">noblock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">AF_IUCV_TRANS_HIPER</span><span class="p">)</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcpy_fromiovec</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* wait if outstanding messages for iucv path has reached */</span>
	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">noblock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">iucv_sock_wait</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">iucv_below_msglim</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">timeo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* return -ECONNRESET if the socket is no longer connected */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* increment and save iucv message tag for msg_completion cbk */</span>
	<span class="n">txmsg</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_tag</span><span class="o">++</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">CB_TAG</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">txmsg</span><span class="p">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">CB_TAG_LEN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">AF_IUCV_TRANS_HIPER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_sent</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">afiucv_hs_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txmsg</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_sent</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IUCV_IPRMDATA</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
	      <span class="o">&amp;&amp;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">iucv_send_iprm</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txmsg</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="cm">/* on success: there is no message_complete callback</span>
<span class="cm">		 * for an IPRMDATA msg; remove skb from send queue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* this error should never happen since the</span>
<span class="cm">		 * IUCV_IPRMDATA path flag is set... sever path */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mh">0x15</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">path_sever</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">message_send</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txmsg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">user_id</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">dst_user_id</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">appl_id</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">appl_id</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">dst_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Application %s on z/VM guest %s&quot;</span>
				<span class="s">&quot; exceeds message limit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">appl_id</span><span class="p">,</span> <span class="n">user_id</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
		<span class="n">skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">release:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* iucv_fragment_skb() - Fragment a single IUCV message into multiple skb&#39;s</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: must be called with message_q.lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_fragment_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dataleft</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span><span class="p">;</span>

	<span class="n">dataleft</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dataleft</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dataleft</span> <span class="o">&gt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">dataleft</span><span class="p">;</span>

		<span class="n">nskb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nskb</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="cm">/* copy target class to control buffer of new skb */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">CB_TRGCLS</span><span class="p">(</span><span class="n">nskb</span><span class="p">),</span> <span class="n">CB_TRGCLS</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">CB_TRGCLS_LEN</span><span class="p">);</span>

		<span class="cm">/* copy data fragment */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">nskb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">copied</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">copied</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">dataleft</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
		<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">nskb</span><span class="p">);</span>
		<span class="n">nskb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">,</span> <span class="n">nskb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* iucv_process_message() - Receive a single outstanding IUCV message</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: must be called with message_q.lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_process_message</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">iucv_msg_length</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>

	<span class="cm">/* store msg target class in the second 4 bytes of skb ctrl buffer */</span>
	<span class="cm">/* Note: the first 4 bytes are reserved for msg tag */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">CB_TRGCLS</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">,</span> <span class="n">CB_TRGCLS_LEN</span><span class="p">);</span>

	<span class="cm">/* check for special IPRM messages (e.g. iucv_sock_shutdown) */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IUCV_IPRMDATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">rmmsg</span><span class="p">,</span> <span class="n">iprm_shutdown</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">message_receive</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span>
					      <span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IUCV_IPRMDATA</span><span class="p">,</span>
					      <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* we need to fragment iucv messages for SOCK_STREAM only;</span>
<span class="cm">		 * for SOCK_SEQPACKET, it is only relevant if we support</span>
<span class="cm">		 * record segmentation using MSG_EOR (see also recvmsg()) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span> <span class="o">&amp;&amp;</span>
		    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span> <span class="o">&gt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_fragment_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">path_sever</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_queue_rcv_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* iucv_process_message_q() - Process outstanding IUCV messages</span>
<span class="cm"> *</span>
<span class="cm"> * Locking: must be called with message_q.lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_process_message_q</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_msg_q</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">iucv_msg_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">iucv_process_message</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">noblock</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">copied</span><span class="p">,</span> <span class="n">rlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="o">*</span><span class="n">rskb</span><span class="p">,</span> <span class="o">*</span><span class="n">cskb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_DISCONN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MSG_OOB</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/* receive/dequeue next skb:</span>
<span class="cm">	 * the function understands MSG_PEEK and, thus, does not dequeue skb */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_recv_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">noblock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rlen</span>   <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>		<span class="cm">/* real length of skb */</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">rlen</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rlen</span><span class="p">)</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">|</span> <span class="n">RCV_SHUTDOWN</span><span class="p">;</span>

	<span class="n">cskb</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">cskb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">copied</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span>
			<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* SOCK_SEQPACKET: set MSG_TRUNC if recv buf size is too small */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">rlen</span><span class="p">)</span>
			<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_TRUNC</span><span class="p">;</span>
		<span class="cm">/* each iucv message contains a complete record */</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_EOR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* create control message to store iucv msg target class:</span>
<span class="cm">	 * get the trgcls from the control buffer of the skb due to</span>
<span class="cm">	 * fragmentation of original iucv message. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">put_cmsg</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">SOL_IUCV</span><span class="p">,</span> <span class="n">SCM_IUCV_TRGCLS</span><span class="p">,</span>
			<span class="n">CB_TRGCLS_LEN</span><span class="p">,</span> <span class="n">CB_TRGCLS</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span>
			<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark read part of skb as used */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* SOCK_STREAM: re-queue skb if it contains unreceived data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">AF_IUCV_TRANS_HIPER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_recv</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_recv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">iucv_sock_close</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Queue backlog skbs */</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">rskb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">rskb</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sock_queue_rcv_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">rskb</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">skb_queue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">,</span>
						<span class="n">rskb</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">rskb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">list</span><span class="p">))</span>
				<span class="n">iucv_process_message_q</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_recv</span><span class="p">)</span> <span class="o">&gt;=</span>
							<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">iucv_send_ctrl</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">AF_IUCV_FLAG_WIN</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_DISCONN</span><span class="p">;</span>
					<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="cm">/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_SEQPACKET</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_TRUNC</span><span class="p">))</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">rlen</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">iucv_accept_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">isk</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">isk</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">accept_q</span><span class="p">,</span> <span class="n">accept_q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">)</span> <span class="n">isk</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_CONNECTED</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">iucv_sock_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			    <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sock_poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_LISTEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">iucv_accept_poll</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">||</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_queue</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLERR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLRDHUP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">==</span> <span class="n">SHUTDOWN_MASK</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_CLOSED</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_DISCONN</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_writeable</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">iucv_below_msglim</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span> <span class="o">|</span> <span class="n">POLLWRBAND</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iucv_message</span> <span class="n">txmsg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">how</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">how</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SHUTDOWN_MASK</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">how</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IUCV_LISTEN</span>:
	<span class="k">case</span> <span class="n">IUCV_DISCONN</span>:
	<span class="k">case</span> <span class="n">IUCV_CLOSING</span>:
	<span class="k">case</span> <span class="n">IUCV_CLOSED</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">how</span> <span class="o">==</span> <span class="n">SEND_SHUTDOWN</span> <span class="o">||</span> <span class="n">how</span> <span class="o">==</span> <span class="n">SHUTDOWN_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">AF_IUCV_TRANS_IUCV</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">txmsg</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">txmsg</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">message_send</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txmsg</span><span class="p">,</span>
				<span class="n">IUCV_IPRMDATA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">iprm_shutdown</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">switch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="mi">1</span>:
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="mi">2</span>:
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">iucv_send_ctrl</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">AF_IUCV_FLAG_SHT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">|=</span> <span class="n">how</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">how</span> <span class="o">==</span> <span class="n">RCV_SHUTDOWN</span> <span class="o">||</span> <span class="n">how</span> <span class="o">==</span> <span class="n">SHUTDOWN_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">==</span> <span class="n">AF_IUCV_TRANS_IUCV</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">path_quiesce</span><span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
<span class="cm">/*			skb_queue_purge(&amp;sk-&gt;sk_receive_queue); */</span>
		<span class="p">}</span>
		<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Wake up anyone sleeping in poll */</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

<span class="nl">fail:</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">iucv_sock_close</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sock_orphan</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">iucv_sock_kill</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* getsockopt and setsockopt */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_setsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
				<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">SOL_IUCV</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">optlen</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">optval</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">optname</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SO_IPRMDATA_MSG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
			<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IUCV_IPRMDATA</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">IUCV_IPRMDATA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SO_MSGLIMIT</span>:
		<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IUCV_OPEN</span>:
		<span class="k">case</span> <span class="n">IUCV_BOUND</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="o">~</span><span class="mi">0</span><span class="p">))</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sock_getsockopt</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">optname</span><span class="p">,</span>
				<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">optlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">SOL_IUCV</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">optname</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SO_IPRMDATA_MSG</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IUCV_IPRMDATA</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SO_MSGLIMIT</span>:
		<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">msglim</span>	<span class="cm">/* connected */</span>
					   <span class="o">:</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span><span class="p">;</span>	<span class="cm">/* default */</span>
		<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SO_MSGSIZE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_OPEN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">hs_dev</span><span class="p">)</span> <span class="o">?</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">hs_dev</span><span class="o">-&gt;</span><span class="n">mtu</span> <span class="o">-</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span><span class="p">)</span> <span class="o">-</span> <span class="n">ETH_HLEN</span> <span class="o">:</span>
				<span class="mh">0x7fffffff</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOPROTOOPT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">put_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">optlen</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">optval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Callback wrappers - called from iucv base support */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_callback_connreq</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="n">u8</span> <span class="n">ipvmid</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">user_data</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">nuser_data</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">src_name</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="o">*</span><span class="n">nsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span><span class="p">,</span> <span class="o">*</span><span class="n">niucv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="n">ipuser</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">EBCASC</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="cm">/* Find out if this path belongs to af_iucv. */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">iucv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sk_for_each</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_LISTEN</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="n">src_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Found a listening socket with</span>
<span class="cm">			 * src_name == ipuser[0-7].</span>
<span class="cm">			 */</span>
			<span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="p">)</span>
		<span class="cm">/* No socket found, not one of our paths. */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Check if parent socket is listening */</span>
	<span class="n">low_nmcpy</span><span class="p">(</span><span class="n">user_data</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">);</span>
	<span class="n">high_nmcpy</span><span class="p">(</span><span class="n">user_data</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">dst_name</span><span class="p">);</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">user_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">user_data</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_LISTEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">path_sever</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">user_data</span><span class="p">);</span>
		<span class="n">iucv_path_free</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for backlog size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk_acceptq_is_full</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">path_sever</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">user_data</span><span class="p">);</span>
		<span class="n">iucv_path_free</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Create the new socket */</span>
	<span class="n">nsk</span> <span class="o">=</span> <span class="n">iucv_sock_alloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nsk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">path_sever</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">user_data</span><span class="p">);</span>
		<span class="n">iucv_path_free</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">niucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">nsk</span><span class="p">);</span>
	<span class="n">iucv_sock_init</span><span class="p">(</span><span class="n">nsk</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Set the new iucv_sock */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">niucv</span><span class="o">-&gt;</span><span class="n">dst_name</span><span class="p">,</span> <span class="n">ipuser</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">EBCASC</span><span class="p">(</span><span class="n">niucv</span><span class="o">-&gt;</span><span class="n">dst_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">niucv</span><span class="o">-&gt;</span><span class="n">dst_user_id</span><span class="p">,</span> <span class="n">ipvmid</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">niucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">niucv</span><span class="o">-&gt;</span><span class="n">src_user_id</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_user_id</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">niucv</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>

	<span class="cm">/* Call iucv_accept */</span>
	<span class="n">high_nmcpy</span><span class="p">(</span><span class="n">nuser_data</span><span class="p">,</span> <span class="n">ipuser</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">nuser_data</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">niucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">nuser_data</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="cm">/* set message limit for path based on msglimit of accepting socket */</span>
	<span class="n">niucv</span><span class="o">-&gt;</span><span class="n">msglimit</span> <span class="o">=</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">msglim</span> <span class="o">=</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">path_accept</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">af_iucv_handler</span><span class="p">,</span> <span class="n">nuser_data</span><span class="p">,</span> <span class="n">nsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iucv_sever_path</span><span class="p">(</span><span class="n">nsk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">iucv_sock_kill</span><span class="p">(</span><span class="n">nsk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iucv_accept_enqueue</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nsk</span><span class="p">);</span>

	<span class="cm">/* Wake up accept */</span>
	<span class="n">nsk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_CONNECTED</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_callback_connack</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_CONNECTED</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_callback_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock_msg_q</span> <span class="o">*</span><span class="n">save_msg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">message_reject</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">list</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">save_message</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">SKB_TRUESIZE</span><span class="p">(</span><span class="n">iucv_msg_length</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">save_message</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">iucv_msg_length</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">save_message</span><span class="p">;</span>

	<span class="n">iucv_process_message</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

<span class="nl">save_message:</span>
	<span class="n">save_msg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock_msg_q</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">save_msg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">save_msg</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
	<span class="n">save_msg</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="o">*</span><span class="n">msg</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">save_msg</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_callback_txdone</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">list_skb</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">list_skb</span> <span class="o">!=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span> <span class="n">CB_TAG</span><span class="p">(</span><span class="n">list_skb</span><span class="p">),</span> <span class="n">CB_TAG_LEN</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">this</span> <span class="o">=</span> <span class="n">list_skb</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">list_skb</span> <span class="o">=</span> <span class="n">list_skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span>
			<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="cm">/* wake up any process waiting for sending */</span>
			<span class="n">iucv_sock_wake_msglim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_CLOSING</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_CLOSED</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_callback_connrej</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_CLOSED</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">iucv_sever_path</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_DISCONN</span><span class="p">;</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* called if the other communication side shuts down its RECV direction;</span>
<span class="cm"> * in turn, the callback sets SEND_SHUTDOWN to disable sending of data.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_callback_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_CLOSED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">|=</span> <span class="n">SEND_SHUTDOWN</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/***************** HiperSockets transport callbacks ********************/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">afiucv_swap_src_dest</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="n">trans_hdr</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tmpID</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">tmpName</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destUserID</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destUserID</span><span class="p">));</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destAppName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destAppName</span><span class="p">));</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcUserID</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcUserID</span><span class="p">));</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcAppName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcAppName</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">tmpID</span><span class="p">,</span> <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcUserID</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">tmpName</span><span class="p">,</span> <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcAppName</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcUserID</span><span class="p">,</span> <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destUserID</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcAppName</span><span class="p">,</span> <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destAppName</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destUserID</span><span class="p">,</span> <span class="n">tmpID</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destAppName</span><span class="p">,</span> <span class="n">tmpName</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * afiucv_hs_callback_syn - react on received SYN</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_hs_callback_syn</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">nsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span><span class="p">,</span> <span class="o">*</span><span class="n">niucv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="n">trans_hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">trans_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no sock - connection refused */</span>
		<span class="n">afiucv_swap_src_dest</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">AF_IUCV_FLAG_SYN</span> <span class="o">|</span> <span class="n">AF_IUCV_FLAG_FIN</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nsk</span> <span class="o">=</span> <span class="n">iucv_sock_alloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_LISTEN</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">sk_acceptq_is_full</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">nsk</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* error on server socket - connection refused */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsk</span><span class="p">)</span>
			<span class="n">sk_free</span><span class="p">(</span><span class="n">nsk</span><span class="p">);</span>
		<span class="n">afiucv_swap_src_dest</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">AF_IUCV_FLAG_SYN</span> <span class="o">|</span> <span class="n">AF_IUCV_FLAG_FIN</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">niucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">nsk</span><span class="p">);</span>
	<span class="n">iucv_sock_init</span><span class="p">(</span><span class="n">nsk</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">niucv</span><span class="o">-&gt;</span><span class="n">transport</span> <span class="o">=</span> <span class="n">AF_IUCV_TRANS_HIPER</span><span class="p">;</span>
	<span class="n">niucv</span><span class="o">-&gt;</span><span class="n">msglimit</span> <span class="o">=</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">)</span>
		<span class="n">niucv</span><span class="o">-&gt;</span><span class="n">msglimit_peer</span> <span class="o">=</span> <span class="n">IUCV_HIPER_MSGLIM_DEFAULT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">niucv</span><span class="o">-&gt;</span><span class="n">msglimit_peer</span> <span class="o">=</span> <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">niucv</span><span class="o">-&gt;</span><span class="n">dst_name</span><span class="p">,</span> <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcAppName</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">niucv</span><span class="o">-&gt;</span><span class="n">dst_user_id</span><span class="p">,</span> <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcUserID</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">niucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">niucv</span><span class="o">-&gt;</span><span class="n">src_user_id</span><span class="p">,</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">src_user_id</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">nsk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_bound_dev_if</span><span class="p">;</span>
	<span class="n">niucv</span><span class="o">-&gt;</span><span class="n">hs_dev</span> <span class="o">=</span> <span class="n">iucv</span><span class="o">-&gt;</span><span class="n">hs_dev</span><span class="p">;</span>
	<span class="n">dev_hold</span><span class="p">(</span><span class="n">niucv</span><span class="o">-&gt;</span><span class="n">hs_dev</span><span class="p">);</span>
	<span class="n">afiucv_swap_src_dest</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">AF_IUCV_FLAG_SYN</span> <span class="o">|</span> <span class="n">AF_IUCV_FLAG_ACK</span><span class="p">;</span>
	<span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">window</span> <span class="o">=</span> <span class="n">niucv</span><span class="o">-&gt;</span><span class="n">msglimit</span><span class="p">;</span>
	<span class="cm">/* if receiver acks the xmit connection is established */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">dev_queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iucv_accept_enqueue</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">nsk</span><span class="p">);</span>
		<span class="n">nsk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_CONNECTED</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">iucv_sock_kill</span><span class="p">(</span><span class="n">nsk</span><span class="p">);</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * afiucv_hs_callback_synack() - react on received SYN-ACK</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_hs_callback_synack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="n">trans_hdr</span> <span class="o">=</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_BOUND</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msglimit_peer</span> <span class="o">=</span> <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_CONNECTED</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * afiucv_hs_callback_synfin() - react on received SYN_FIN</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_hs_callback_synfin</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_BOUND</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_DISCONN</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * afiucv_hs_callback_fin() - react on received FIN</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_hs_callback_fin</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* other end of connection closed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">bh_lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_DISCONN</span><span class="p">;</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bh_unlock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * afiucv_hs_callback_win() - react on received WIN</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_hs_callback_win</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="n">trans_hdr</span> <span class="o">=</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_CONNECTED</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>

	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">msg_sent</span><span class="p">);</span>
	<span class="n">iucv_sock_wake_msglim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * afiucv_hs_callback_rx() - react on received data</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_hs_callback_rx</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">IUCV_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

		<span class="cm">/* write stuff from iucv_msg to skb cb */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span><span class="p">));</span>
	<span class="n">skb_reset_transport_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_reset_network_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_queue_rcv_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* handle rcv queue full */</span>
			<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">backlog_skb_q</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">message_q</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NET_RX_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * afiucv_hs_rcv() - base function for arriving data through HiperSockets</span>
<span class="cm"> *                   transport</span>
<span class="cm"> *                   called from netif RX softirq</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_hs_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="n">trans_hdr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">nullstring</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">);</span>
	<span class="n">trans_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">EBCASC</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destAppName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destAppName</span><span class="p">));</span>
	<span class="n">EBCASC</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destUserID</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destUserID</span><span class="p">));</span>
	<span class="n">EBCASC</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcAppName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcAppName</span><span class="p">));</span>
	<span class="n">EBCASC</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcUserID</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcUserID</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">nullstring</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nullstring</span><span class="p">));</span>
	<span class="n">iucv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">sk_for_each</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">==</span> <span class="n">AF_IUCV_FLAG_SYN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span>
				     <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destAppName</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">src_user_id</span><span class="p">,</span>
				     <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destUserID</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dst_name</span><span class="p">,</span> <span class="n">nullstring</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dst_user_id</span><span class="p">,</span>
				     <span class="n">nullstring</span><span class="p">,</span> <span class="mi">8</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">src_name</span><span class="p">,</span>
				     <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destAppName</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">src_user_id</span><span class="p">,</span>
				     <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">destUserID</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dst_name</span><span class="p">,</span>
				     <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcAppName</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dst_user_id</span><span class="p">,</span>
				     <span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">srcUserID</span><span class="p">,</span> <span class="mi">8</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span><span class="p">)</span>
		<span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* no sock</span>
<span class="cm">	how should we send with no sock</span>
<span class="cm">	1) send without sock no send rc checking?</span>
<span class="cm">	2) introduce default sock to handle this cases</span>

<span class="cm">	 SYN -&gt; send SYN|ACK in good case, send SYN|FIN in bad case</span>
<span class="cm">	 data -&gt; send FIN</span>
<span class="cm">	 SYN|ACK, SYN|FIN, FIN -&gt; no action? */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_IUCV_FLAG_SYN</span>:
		<span class="cm">/* connect request */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">afiucv_hs_callback_syn</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="p">(</span><span class="n">AF_IUCV_FLAG_SYN</span> <span class="o">|</span> <span class="n">AF_IUCV_FLAG_ACK</span><span class="p">)</span>:
		<span class="cm">/* connect request confirmed */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">afiucv_hs_callback_synack</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="p">(</span><span class="n">AF_IUCV_FLAG_SYN</span> <span class="o">|</span> <span class="n">AF_IUCV_FLAG_FIN</span><span class="p">)</span>:
		<span class="cm">/* connect request refused */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">afiucv_hs_callback_synfin</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="p">(</span><span class="n">AF_IUCV_FLAG_FIN</span><span class="p">)</span>:
		<span class="cm">/* close request */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">afiucv_hs_callback_fin</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="p">(</span><span class="n">AF_IUCV_FLAG_WIN</span><span class="p">)</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">afiucv_hs_callback_win</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">af_iucv_trans_hdr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* fall through and receive non-zero length data */</span>
	<span class="k">case</span> <span class="p">(</span><span class="n">AF_IUCV_FLAG_SHT</span><span class="p">)</span>:
		<span class="cm">/* shutdown request */</span>
		<span class="cm">/* fall through and receive zero length data */</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="cm">/* plain data frame */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">CB_TRGCLS</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">trans_hdr</span><span class="o">-&gt;</span><span class="n">iucv_hdr</span><span class="p">.</span><span class="n">class</span><span class="p">,</span>
		       <span class="n">CB_TRGCLS_LEN</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">afiucv_hs_callback_rx</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * afiucv_hs_callback_txnotify() - handle send notifcations from HiperSockets</span>
<span class="cm"> *                                 transport</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">afiucv_hs_callback_txnotify</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">iucv_tx_notify</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">isk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">list_skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">nskb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sk_for_each</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="n">isk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv</span> <span class="o">||</span> <span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_ZAPPED</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">list_skb</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">nskb</span> <span class="o">=</span> <span class="n">list_skb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">list_skb</span> <span class="o">!=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">)</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_shinfo</span><span class="p">(</span><span class="n">list_skb</span><span class="p">)</span> <span class="o">==</span> <span class="n">skb_shinfo</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">TX_NOTIFY_OK</span>:
				<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">list_skb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">list_skb</span><span class="p">);</span>
				<span class="n">iucv_sock_wake_msglim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">TX_NOTIFY_PENDING</span>:
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">pendings</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">TX_NOTIFY_DELAYED_OK</span>:
				<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">list_skb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">pendings</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">pendings</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">iucv_sock_wake_msglim</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">list_skb</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">TX_NOTIFY_UNREACHABLE</span>:
			<span class="k">case</span> <span class="n">TX_NOTIFY_DELAYED_UNREACHABLE</span>:
			<span class="k">case</span> <span class="n">TX_NOTIFY_TPQFULL</span>: <span class="cm">/* not yet used */</span>
			<span class="k">case</span> <span class="n">TX_NOTIFY_GENERALERROR</span>:
			<span class="k">case</span> <span class="n">TX_NOTIFY_DELAYED_GENERALERROR</span>:
				<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">list_skb</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
				<span class="n">kfree_skb</span><span class="p">(</span><span class="n">list_skb</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_CONNECTED</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_DISCONN</span><span class="p">;</span>
					<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_skb</span> <span class="o">=</span> <span class="n">nskb</span><span class="p">;</span>
		<span class="n">nskb</span> <span class="o">=</span> <span class="n">nskb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_CLOSING</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">send_skb_q</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_CLOSED</span><span class="p">;</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * afiucv_netdev_event: handle netdev notifier chain events</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_netdev_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">event_dev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_sock</span> <span class="o">*</span><span class="n">iucv</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NETDEV_REBOOT</span>:
	<span class="k">case</span> <span class="n">NETDEV_GOING_DOWN</span>:
		<span class="n">sk_for_each</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_sk_list</span><span class="p">.</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iucv</span> <span class="o">=</span> <span class="n">iucv_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">iucv</span><span class="o">-&gt;</span><span class="n">hs_dev</span> <span class="o">==</span> <span class="n">event_dev</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">IUCV_CONNECTED</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="o">==</span> <span class="n">NETDEV_GOING_DOWN</span><span class="p">)</span>
					<span class="n">iucv_send_ctrl</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">AF_IUCV_FLAG_FIN</span><span class="p">);</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">IUCV_DISCONN</span><span class="p">;</span>
				<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NETDEV_DOWN</span>:
	<span class="k">case</span> <span class="n">NETDEV_UNREGISTER</span>:
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">afiucv_netdev_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">afiucv_netdev_event</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">iucv_sock_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span>		<span class="o">=</span> <span class="n">PF_IUCV</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">iucv_sock_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span>		<span class="o">=</span> <span class="n">iucv_sock_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span>	<span class="o">=</span> <span class="n">iucv_sock_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listen</span>		<span class="o">=</span> <span class="n">iucv_sock_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span>		<span class="o">=</span> <span class="n">iucv_sock_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span>	<span class="o">=</span> <span class="n">iucv_sock_getname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span>	<span class="o">=</span> <span class="n">iucv_sock_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span>	<span class="o">=</span> <span class="n">iucv_sock_recvmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">iucv_sock_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span>		<span class="o">=</span> <span class="n">sock_no_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span>	<span class="o">=</span> <span class="n">sock_no_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">iucv_sock_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span>	<span class="o">=</span> <span class="n">iucv_sock_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span>	<span class="o">=</span> <span class="n">iucv_sock_getsockopt</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_proto_family</span> <span class="n">iucv_sock_family_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span>	<span class="o">=</span> <span class="n">AF_IUCV</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span>	<span class="o">=</span> <span class="n">iucv_sock_create</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">packet_type</span> <span class="n">iucv_packet_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_AF_IUCV</span><span class="p">),</span>
	<span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">afiucv_hs_rcv</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">afiucv_iucv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">iucv_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">af_iucv_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* establish dummy device */</span>
	<span class="n">af_iucv_driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">af_iucv_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_iucv</span><span class="p">;</span>
	<span class="n">af_iucv_dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">af_iucv_dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_driver</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_set_name</span><span class="p">(</span><span class="n">af_iucv_dev</span><span class="p">,</span> <span class="s">&quot;af_iucv&quot;</span><span class="p">);</span>
	<span class="n">af_iucv_dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">;</span>
	<span class="n">af_iucv_dev</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">af_iucv_dev</span><span class="o">-&gt;</span><span class="n">release</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">))</span><span class="n">kfree</span><span class="p">;</span>
	<span class="n">af_iucv_dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">af_iucv_driver</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">device_register</span><span class="p">(</span><span class="n">af_iucv_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_driver</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_driver:</span>
	<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">af_iucv_driver</span><span class="p">);</span>
<span class="nl">out_iucv:</span>
	<span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">iucv_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">af_iucv_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">afiucv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">MACHINE_IS_VM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpcmd</span><span class="p">(</span><span class="s">&quot;QUERY USERID&quot;</span><span class="p">,</span> <span class="n">iucv_userid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">iucv_userid</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pr_iucv</span> <span class="o">=</span> <span class="n">try_then_request_module</span><span class="p">(</span><span class="n">symbol_get</span><span class="p">(</span><span class="n">iucv_if</span><span class="p">),</span> <span class="s">&quot;iucv&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pr_iucv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;iucv_if lookup failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_userid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">iucv_userid</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_userid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">iucv_userid</span><span class="p">));</span>
		<span class="n">pr_iucv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">proto_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_proto</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_sock_family_ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_proto</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pr_iucv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">afiucv_iucv_init</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_sock</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">register_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">afiucv_netdev_notifier</span><span class="p">);</span>
	<span class="n">dev_add_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_packet_type</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_sock:</span>
	<span class="n">sock_unregister</span><span class="p">(</span><span class="n">PF_IUCV</span><span class="p">);</span>
<span class="nl">out_proto:</span>
	<span class="n">proto_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_proto</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pr_iucv</span><span class="p">)</span>
		<span class="n">symbol_put</span><span class="p">(</span><span class="n">iucv_if</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">afiucv_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pr_iucv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">device_unregister</span><span class="p">(</span><span class="n">af_iucv_dev</span><span class="p">);</span>
		<span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">af_iucv_driver</span><span class="p">);</span>
		<span class="n">pr_iucv</span><span class="o">-&gt;</span><span class="n">iucv_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">af_iucv_handler</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">symbol_put</span><span class="p">(</span><span class="n">iucv_if</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">unregister_netdevice_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">afiucv_netdev_notifier</span><span class="p">);</span>
	<span class="n">dev_remove_pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_packet_type</span><span class="p">);</span>
	<span class="n">sock_unregister</span><span class="p">(</span><span class="n">PF_IUCV</span><span class="p">);</span>
	<span class="n">proto_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_proto</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">afiucv_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">afiucv_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Jennifer Hunt &lt;jenhunt@us.ibm.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;IUCV Sockets ver &quot;</span> <span class="n">VERSION</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">VERSION</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_NETPROTO</span><span class="p">(</span><span class="n">PF_IUCV</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
