<!DOCTYPE html>
<html><head><title>joekychen/linux » net › iucv › iucv.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>iucv.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * IUCV base infrastructure.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright IBM Corp. 2001, 2009</span>
<span class="cm"> *</span>
<span class="cm"> * Author(s):</span>
<span class="cm"> *    Original source:</span>
<span class="cm"> *	Alan Altmark (Alan_Altmark@us.ibm.com)	Sept. 2000</span>
<span class="cm"> *	Xenia Tkatschow (xenia@us.ibm.com)</span>
<span class="cm"> *    2Gb awareness and general cleanup:</span>
<span class="cm"> *	Fritz Elfert (elfert@de.ibm.com, felfert@millenux.com)</span>
<span class="cm"> *    Rewritten for af_iucv:</span>
<span class="cm"> *	Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;</span>
<span class="cm"> *    PM functions:</span>
<span class="cm"> *	Ursula Braun (ursula.braun@de.ibm.com)</span>
<span class="cm"> *</span>
<span class="cm"> * Documentation used:</span>
<span class="cm"> *    The original source</span>
<span class="cm"> *    CP Programming Service, IBM document # SC24-5760</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> */</span>

<span class="cp">#define KMSG_COMPONENT &quot;iucv&quot;</span>
<span class="cp">#define pr_fmt(fmt) KMSG_COMPONENT &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;net/iucv/iucv.h&gt;</span>
<span class="cp">#include &lt;linux/atomic.h&gt;</span>
<span class="cp">#include &lt;asm/ebcdic.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/smp.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * FLAGS:</span>
<span class="cm"> * All flags are defined in the field IPFLAGS1 of each function</span>
<span class="cm"> * and can be found in CP Programming Services.</span>
<span class="cm"> * IPSRCCLS - Indicates you have specified a source class.</span>
<span class="cm"> * IPTRGCLS - Indicates you have specified a target class.</span>
<span class="cm"> * IPFGPID  - Indicates you have specified a pathid.</span>
<span class="cm"> * IPFGMID  - Indicates you have specified a message ID.</span>
<span class="cm"> * IPNORPY  - Indicates a one-way message. No reply expected.</span>
<span class="cm"> * IPALL    - Indicates that all paths are affected.</span>
<span class="cm"> */</span>
<span class="cp">#define IUCV_IPSRCCLS	0x01</span>
<span class="cp">#define IUCV_IPTRGCLS	0x01</span>
<span class="cp">#define IUCV_IPFGPID	0x02</span>
<span class="cp">#define IUCV_IPFGMID	0x04</span>
<span class="cp">#define IUCV_IPNORPY	0x10</span>
<span class="cp">#define IUCV_IPALL	0x80</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_bus_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">iucv_pm_states</span> <span class="p">{</span>
	<span class="n">IUCV_PM_INITIAL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IUCV_PM_FREEZING</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">IUCV_PM_THAWING</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IUCV_PM_RESTORING</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">iucv_pm_states</span> <span class="n">iucv_pm_state</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">iucv_pm_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">iucv_pm_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">iucv_pm_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">iucv_pm_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">iucv_pm_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dev_pm_ops</span> <span class="n">iucv_pm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">prepare</span> <span class="o">=</span> <span class="n">iucv_pm_prepare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">complete</span> <span class="o">=</span> <span class="n">iucv_pm_complete</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze</span> <span class="o">=</span> <span class="n">iucv_pm_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span> <span class="o">=</span> <span class="n">iucv_pm_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore</span> <span class="o">=</span> <span class="n">iucv_pm_restore</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">iucv_bus</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;iucv&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">iucv_bus_match</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iucv_pm_ops</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_bus</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">iucv_root</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_root</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">iucv_available</span><span class="p">;</span>

<span class="cm">/* General IUCV interrupt structure */</span>
<span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipflags1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iptype</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res2</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">iucv_irq_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="o">*</span><span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">iucv_buffer_cpumask</span> <span class="o">=</span> <span class="p">{</span> <span class="n">CPU_BITS_NONE</span> <span class="p">};</span>
<span class="k">static</span> <span class="n">cpumask_t</span> <span class="n">iucv_irq_cpumask</span> <span class="o">=</span> <span class="p">{</span> <span class="n">CPU_BITS_NONE</span> <span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Queue of interrupt buffers lock for delivery via the tasklet</span>
<span class="cm"> * (fast but can&#39;t call smp_call_function).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">iucv_task_queue</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The tasklet for fast delivery of iucv interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">iucv_tasklet_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_TASKLET</span><span class="p">(</span><span class="n">iucv_tasklet</span><span class="p">,</span> <span class="n">iucv_tasklet_fn</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Queue of interrupt buffers for delivery via a work queue</span>
<span class="cm"> * (slower but can call smp_call_function).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">iucv_work_queue</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The work element to deliver path pending interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">iucv_work_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">iucv_work</span><span class="p">,</span> <span class="n">iucv_work_fn</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Spinlock protecting task and work queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">iucv_queue_lock</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">iucv_command_codes</span> <span class="p">{</span>
	<span class="n">IUCV_QUERY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">IUCV_RETRIEVE_BUFFER</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">IUCV_SEND</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">IUCV_RECEIVE</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
	<span class="n">IUCV_REPLY</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
	<span class="n">IUCV_REJECT</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">IUCV_PURGE</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
	<span class="n">IUCV_ACCEPT</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
	<span class="n">IUCV_CONNECT</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
	<span class="n">IUCV_DECLARE_BUFFER</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
	<span class="n">IUCV_QUIESCE</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>
	<span class="n">IUCV_RESUME</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>
	<span class="n">IUCV_SEVER</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
	<span class="n">IUCV_SETMASK</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
	<span class="n">IUCV_SETCONTROLMASK</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Error messages that are used with the iucv_sever function. They get</span>
<span class="cm"> * converted to EBCDIC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">iucv_error_no_listener</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;NO LISTENER&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">iucv_error_no_memory</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;NO MEMORY&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">iucv_error_pathid</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;INVALID PATHID&quot;</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * iucv_handler_list: List of registered handlers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">iucv_handler_list</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * iucv_path_table: an array of iucv_path structures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">**</span><span class="n">iucv_path_table</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iucv_max_pathid</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * iucv_lock: spinlock protecting iucv_handler_list and iucv_pathid_table</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">iucv_table_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * iucv_active_cpu: contains the number of the cpu executing the tasklet</span>
<span class="cm"> * or the work handler. Needed for iucv_path_sever called from tasklet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">iucv_active_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Mutex and wait queue for iucv_register/iucv_unregister.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">iucv_register_mutex</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Counter for number of non-smp capable handlers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">iucv_nonsmp_handler</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * IUCV control data structure. Used by iucv_path_accept, iucv_path_connect,</span>
<span class="cm"> * iucv_path_quiesce and iucv_path_sever.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_cmd_control</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipflags1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iprcode</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ipmsglim</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">res1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipvmid</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">iptarget</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">,</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * Data in parameter list iucv structure. Used by iucv_message_send,</span>
<span class="cm"> * iucv_message_send2way and iucv_message_reply.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_cmd_dpl</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipflags1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iprcode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipmsgid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iptrgcls</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iprmmsg</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">ipsrccls</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipmsgtag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipbfadr2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipbfln2f</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">,</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * Data in buffer iucv structure. Used by iucv_message_receive,</span>
<span class="cm"> * iucv_message_reject, iucv_message_send, iucv_message_send2way</span>
<span class="cm"> * and iucv_declare_cpu.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_cmd_db</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipflags1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iprcode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipmsgid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iptrgcls</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipbfadr1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipbfln1f</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipsrccls</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipmsgtag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipbfadr2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipbfln2f</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">,</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * Purge message iucv structure. Used by iucv_message_purge.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_cmd_purge</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipflags1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iprcode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipmsgid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipaudit</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">res1</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">res2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipsrccls</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipmsgtag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res3</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">,</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

<span class="cm">/*</span>
<span class="cm"> * Set mask iucv structure. Used by iucv_enable_cpu.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_cmd_set_mask</span> <span class="p">{</span>
	<span class="n">u8</span>  <span class="n">ipmask</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">iprcode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res2</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">packed</span><span class="p">,</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

<span class="k">union</span> <span class="n">iucv_param</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_cmd_control</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_cmd_dpl</span> <span class="n">dpl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_cmd_db</span> <span class="n">db</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_cmd_purge</span> <span class="n">purge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_cmd_set_mask</span> <span class="n">set_mask</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Anchor for per-cpu IUCV command parameter block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">iucv_param</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="k">static</span> <span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_call_b2f0</span>
<span class="cm"> * @code: identifier of IUCV call to CP.</span>
<span class="cm"> * @parm: pointer to a struct iucv_parm block</span>
<span class="cm"> *</span>
<span class="cm"> * Calls CP to execute IUCV commands.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result of the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">iucv_call_b2f0</span><span class="p">(</span><span class="kt">int</span> <span class="n">command</span><span class="p">,</span> <span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg0</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;0&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg1</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ccode</span><span class="p">;</span>

	<span class="n">reg0</span> <span class="o">=</span> <span class="n">command</span><span class="p">;</span>
	<span class="n">reg1</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">parm</span><span class="p">);</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">&quot;	.long 0xb2f01000</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	ipm	%0</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	srl	%0,28</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=d&quot;</span> <span class="p">(</span><span class="n">ccode</span><span class="p">),</span> <span class="s">&quot;=m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">parm</span><span class="p">),</span> <span class="s">&quot;+d&quot;</span> <span class="p">(</span><span class="n">reg0</span><span class="p">),</span> <span class="s">&quot;+a&quot;</span> <span class="p">(</span><span class="n">reg1</span><span class="p">)</span>
		<span class="o">:</span>  <span class="s">&quot;m&quot;</span> <span class="p">(</span><span class="o">*</span><span class="n">parm</span><span class="p">)</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ccode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">iprcode</span> <span class="o">:</span> <span class="n">ccode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_query_maxconn</span>
<span class="cm"> *</span>
<span class="cm"> * Determines the maximum number of connections that may be established.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the maximum number of connections or -EPERM is IUCV is not</span>
<span class="cm"> * available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_query_maxconn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg0</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;0&quot;</span><span class="p">);</span>
	<span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reg1</span> <span class="n">asm</span> <span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">param</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ccode</span><span class="p">;</span>

	<span class="n">param</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">GFP_DMA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">param</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">reg0</span> <span class="o">=</span> <span class="n">IUCV_QUERY</span><span class="p">;</span>
	<span class="n">reg1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">param</span><span class="p">;</span>
	<span class="n">asm</span> <span class="k">volatile</span> <span class="p">(</span>
		<span class="s">&quot;	.long	0xb2f01000</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	ipm	%0</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;	srl	%0,28</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="o">:</span> <span class="s">&quot;=d&quot;</span> <span class="p">(</span><span class="n">ccode</span><span class="p">),</span> <span class="s">&quot;+d&quot;</span> <span class="p">(</span><span class="n">reg0</span><span class="p">),</span> <span class="s">&quot;+d&quot;</span> <span class="p">(</span><span class="n">reg1</span><span class="p">)</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ccode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">iucv_max_pathid</span> <span class="o">=</span> <span class="n">reg1</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ccode</span> <span class="o">?</span> <span class="o">-</span><span class="n">EPERM</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_allow_cpu</span>
<span class="cm"> * @data: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Allow iucv interrupts on this cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_allow_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable all iucv interrupts.</span>
<span class="cm">	 * ipmask contains bits for the different interrupts</span>
<span class="cm">	 *	0x80 - Flag to allow nonpriority message pending interrupts</span>
<span class="cm">	 *	0x40 - Flag to allow priority message pending interrupts</span>
<span class="cm">	 *	0x20 - Flag to allow nonpriority message completion interrupts</span>
<span class="cm">	 *	0x10 - Flag to allow priority message completion interrupts</span>
<span class="cm">	 *	0x08 - Flag to allow IUCV control interrupts</span>
<span class="cm">	 */</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">set_mask</span><span class="p">.</span><span class="n">ipmask</span> <span class="o">=</span> <span class="mh">0xf8</span><span class="p">;</span>
	<span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_SETMASK</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Enable all iucv control interrupts.</span>
<span class="cm">	 * ipmask contains bits for the different interrupts</span>
<span class="cm">	 *	0x80 - Flag to allow pending connections interrupts</span>
<span class="cm">	 *	0x40 - Flag to allow connection complete interrupts</span>
<span class="cm">	 *	0x20 - Flag to allow connection severed interrupts</span>
<span class="cm">	 *	0x10 - Flag to allow connection quiesced interrupts</span>
<span class="cm">	 *	0x08 - Flag to allow connection resumed interrupts</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">set_mask</span><span class="p">.</span><span class="n">ipmask</span> <span class="o">=</span> <span class="mh">0xf8</span><span class="p">;</span>
	<span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_SETCONTROLMASK</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="cm">/* Set indication that iucv interrupts are allowed for this cpu. */</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_irq_cpumask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_block_cpu</span>
<span class="cm"> * @data: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Block iucv interrupts on this cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_block_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>

	<span class="cm">/* Disable all iucv interrupts. */</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_SETMASK</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>

	<span class="cm">/* Clear indication that iucv interrupts are allowed for this cpu. */</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_irq_cpumask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_block_cpu_almost</span>
<span class="cm"> * @data: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Allow connection-severed interrupts only on this cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_block_cpu_almost</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>

	<span class="cm">/* Allow iucv control interrupts only */</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">set_mask</span><span class="p">.</span><span class="n">ipmask</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">;</span>
	<span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_SETMASK</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="cm">/* Allow iucv-severed interrupt only */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">set_mask</span><span class="p">.</span><span class="n">ipmask</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_SETCONTROLMASK</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>

	<span class="cm">/* Clear indication that iucv interrupts are allowed for this cpu. */</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_irq_cpumask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_declare_cpu</span>
<span class="cm"> * @data: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Declare a interrupt buffer on this cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_declare_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Declare interrupt buffer. */</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfadr1</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_DECLARE_BUFFER</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x03</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="s">&quot;Directory error&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x0a</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="s">&quot;Invalid length&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x13</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="s">&quot;Buffer already exists&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x3e</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="s">&quot;Buffer overlap&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x5c</span>:
			<span class="n">err</span> <span class="o">=</span> <span class="s">&quot;Paging or storage error&quot;</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Defining an interrupt buffer on CPU %i&quot;</span>
			   <span class="s">&quot; failed with 0x%02x (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set indication that an iucv buffer exists for this cpu. */</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iucv_nonsmp_handler</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_irq_cpumask</span><span class="p">))</span>
		<span class="cm">/* Enable iucv interrupts on this cpu. */</span>
		<span class="n">iucv_allow_cpu</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* Disable iucv interrupts on this cpu. */</span>
		<span class="n">iucv_block_cpu</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_retrieve_cpu</span>
<span class="cm"> * @data: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Retrieve interrupt buffer on this cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_retrieve_cpu</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Block iucv interrupts. */</span>
	<span class="n">iucv_block_cpu</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Retrieve interrupt buffer. */</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
	<span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_RETRIEVE_BUFFER</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>

	<span class="cm">/* Clear indication that an iucv buffer exists for this cpu. */</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_setmask_smp</span>
<span class="cm"> *</span>
<span class="cm"> * Allow iucv interrupts on all cpus.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_setmask_mp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="cm">/* Enable all cpus with a declared buffer. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_irq_cpumask</span><span class="p">))</span>
			<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">iucv_allow_cpu</span><span class="p">,</span>
						 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_setmask_up</span>
<span class="cm"> *</span>
<span class="cm"> * Allow iucv interrupts on a single cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_setmask_up</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_t</span> <span class="n">cpumask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/* Disable all cpu but the first in cpu_irq_cpumask. */</span>
	<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpumask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_irq_cpumask</span><span class="p">);</span>
	<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpumask_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_irq_cpumask</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cpumask</span><span class="p">);</span>
	<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpumask</span><span class="p">)</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">iucv_block_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_enable</span>
<span class="cm"> *</span>
<span class="cm"> * This function makes iucv ready for use. It allocates the pathid</span>
<span class="cm"> * table, declares an iucv interrupt buffer and enables the iucv</span>
<span class="cm"> * interrupts. Called when the first user has registered an iucv</span>
<span class="cm"> * handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">alloc_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">iucv_max_pathid</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span><span class="p">);</span>
	<span class="n">iucv_path_table</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv_path_table</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* Declare per cpu buffers. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">iucv_declare_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span>
		<span class="cm">/* No cpu could declare an iucv buffer. */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_path_table</span><span class="p">);</span>
	<span class="n">iucv_path_table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_disable</span>
<span class="cm"> *</span>
<span class="cm"> * This function shuts down iucv. It disables iucv interrupts, retrieves</span>
<span class="cm"> * the iucv interrupt buffer and frees the pathid table. Called after the</span>
<span class="cm"> * last user unregister its iucv handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">iucv_retrieve_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_path_table</span><span class="p">);</span>
	<span class="n">iucv_path_table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">iucv_cpu_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cpumask_t</span> <span class="n">cpumask</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">hcpu</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_UP_PREPARE_FROZEN</span>:
		<span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_irq_data</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">GFP_DMA</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

		<span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">),</span>
				     <span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">GFP_DMA</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
			<span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">GFP_DMA</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
			<span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
			<span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED_FROZEN</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD_FROZEN</span>:
		<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_ONLINE</span>:
	<span class="k">case</span> <span class="n">CPU_ONLINE_FROZEN</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_FAILED_FROZEN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv_path_table</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">iucv_declare_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE</span>:
	<span class="k">case</span> <span class="n">CPU_DOWN_PREPARE_FROZEN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv_path_table</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cpumask_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpumask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">);</span>
		<span class="n">cpumask_clear_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpumask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cpumask</span><span class="p">))</span>
			<span class="cm">/* Can&#39;t offline last IUCV enabled cpu. */</span>
			<span class="k">return</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">iucv_retrieve_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_irq_cpumask</span><span class="p">))</span>
			<span class="n">smp_call_function_single</span><span class="p">(</span>
				<span class="n">cpumask_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">),</span>
				<span class="n">iucv_allow_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__refdata</span> <span class="n">iucv_cpu_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">iucv_cpu_notify</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_sever_pathid</span>
<span class="cm"> * @pathid: path identification number.</span>
<span class="cm"> * @userdata: 16-bytes of user data.</span>
<span class="cm"> *</span>
<span class="cm"> * Sever an iucv path to free up the pathid. Used internally.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_sever_pathid</span><span class="p">(</span><span class="n">u16</span> <span class="n">pathid</span><span class="p">,</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>

	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userdata</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipuser</span><span class="p">,</span> <span class="n">userdata</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipuser</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">pathid</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_SEVER</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __iucv_cleanup_queue</span>
<span class="cm"> * @dummy: unused dummy argument</span>
<span class="cm"> *</span>
<span class="cm"> * Nop function called via smp_call_function to force work items from</span>
<span class="cm"> * pending external iucv interrupts to the work queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__iucv_cleanup_queue</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_cleanup_queue</span>
<span class="cm"> *</span>
<span class="cm"> * Function called after a path has been severed to find all remaining</span>
<span class="cm"> * work items for the now stale pathid. The caller needs to hold the</span>
<span class="cm"> * iucv_table_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_cleanup_queue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_irq_list</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When a path is severed, the pathid can be reused immediately</span>
<span class="cm">	 * on a iucv connect or a connection pending interrupt. Remove</span>
<span class="cm">	 * all entries from the task queue that refer to a stale pathid</span>
<span class="cm">	 * (iucv_path_table[ix] == NULL). Only then do the iucv connect</span>
<span class="cm">	 * or deliver the connection pending interrupt. To get all the</span>
<span class="cm">	 * pending interrupts force them to the work queue by calling</span>
<span class="cm">	 * an empty function on all cpus.</span>
<span class="cm">	 */</span>
	<span class="n">smp_call_function</span><span class="p">(</span><span class="n">__iucv_cleanup_queue</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_queue_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_task_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Remove stale work items from the task queue. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iucv_path_table</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">ippathid</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_queue_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_register:</span>
<span class="cm"> * @handler: address of iucv handler structure</span>
<span class="cm"> * @smp: != 0 indicates that the handler can deal with out of order messages</span>
<span class="cm"> *</span>
<span class="cm"> * Registers a driver with IUCV.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -ENOMEM if the memory allocation for the pathid</span>
<span class="cm"> * table failed, or -EIO if IUCV_DECLARE_BUFFER failed on all cpus.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">int</span> <span class="n">smp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv_available</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_register_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smp</span><span class="p">)</span>
		<span class="n">iucv_nonsmp_handler</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_handler_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_enable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_mutex</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smp</span> <span class="o">&amp;&amp;</span> <span class="n">iucv_nonsmp_handler</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">iucv_setmask_up</span><span class="p">();</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">paths</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_handler_list</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_mutex:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_register_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_unregister</span>
<span class="cm"> * @handler:  address of iucv handler structure</span>
<span class="cm"> * @smp: != 0 indicates that the handler can deal with out of order messages</span>
<span class="cm"> *</span>
<span class="cm"> * Unregister driver from IUCV.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">iucv_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span> <span class="kt">int</span> <span class="n">smp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_register_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">);</span>
	<span class="cm">/* Remove handler from the iucv_handler_list. */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="cm">/* Sever all pathids still referring to the handler. */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">paths</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iucv_sever_pathid</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">iucv_path_table</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">iucv_path_free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smp</span><span class="p">)</span>
		<span class="n">iucv_nonsmp_handler</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_handler_list</span><span class="p">))</span>
		<span class="n">iucv_disable</span><span class="p">();</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smp</span> <span class="o">&amp;&amp;</span> <span class="n">iucv_nonsmp_handler</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">iucv_setmask_mp</span><span class="p">();</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_register_mutex</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_unregister</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_reboot_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">event</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">on_each_cpu</span><span class="p">(</span><span class="n">iucv_block_cpu</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iucv_max_pathid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iucv_path_table</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">iucv_sever_pathid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="n">iucv_disable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">iucv_reboot_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">iucv_reboot_event</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_accept</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @handler: address of iucv handler structure</span>
<span class="cm"> * @userdata: 16 bytes of data reflected to the communication partner</span>
<span class="cm"> * @private: private data passed to interrupt handlers for this path</span>
<span class="cm"> *</span>
<span class="cm"> * This function is issued after the user received a connection pending</span>
<span class="cm"> * external interrupt and now wishes to complete the IUCV communication path.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result of the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_path_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span>
		     <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Prepare parameter block. */</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipmsglim</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">msglim</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userdata</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipuser</span><span class="p">,</span> <span class="n">userdata</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipuser</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipflags1</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_ACCEPT</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">private</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">msglim</span> <span class="o">=</span> <span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipmsglim</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipflags1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_path_accept</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_connect</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @handler: address of iucv handler structure</span>
<span class="cm"> * @userid: 8-byte user identification</span>
<span class="cm"> * @system: 8-byte target system identification</span>
<span class="cm"> * @userdata: 16 bytes of data reflected to the communication partner</span>
<span class="cm"> * @private: private data passed to interrupt handlers for this path</span>
<span class="cm"> *</span>
<span class="cm"> * This function establishes an IUCV path. Although the connect may complete</span>
<span class="cm"> * successfully, you are not able to use the path until you receive an IUCV</span>
<span class="cm"> * Connection Complete external interrupt.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result of the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_path_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">,</span>
		      <span class="n">u8</span> <span class="n">userid</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">u8</span> <span class="n">system</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">);</span>
	<span class="n">iucv_cleanup_queue</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipmsglim</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">msglim</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipflags1</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipvmid</span><span class="p">,</span> <span class="n">userid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipvmid</span><span class="p">));</span>
		<span class="n">ASCEBC</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipvmid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipvmid</span><span class="p">));</span>
		<span class="n">EBC_TOUPPER</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipvmid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipvmid</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">system</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">iptarget</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">iptarget</span><span class="p">));</span>
		<span class="n">ASCEBC</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">iptarget</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">iptarget</span><span class="p">));</span>
		<span class="n">EBC_TOUPPER</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">iptarget</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">iptarget</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userdata</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipuser</span><span class="p">,</span> <span class="n">userdata</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipuser</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_CONNECT</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">&lt;</span> <span class="n">iucv_max_pathid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span> <span class="o">=</span> <span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ippathid</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">msglim</span> <span class="o">=</span> <span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipmsglim</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipflags1</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">private</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">paths</span><span class="p">);</span>
			<span class="n">iucv_path_table</span><span class="p">[</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">iucv_sever_pathid</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ippathid</span><span class="p">,</span>
					  <span class="n">iucv_error_pathid</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_path_connect</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_quiesce:</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @userdata: 16 bytes of data reflected to the communication partner</span>
<span class="cm"> *</span>
<span class="cm"> * This function temporarily suspends incoming messages on an IUCV path.</span>
<span class="cm"> * You can later reactivate the path by invoking the iucv_resume function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_path_quiesce</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userdata</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipuser</span><span class="p">,</span> <span class="n">userdata</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipuser</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_QUIESCE</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_path_quiesce</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_resume:</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @userdata: 16 bytes of data reflected to the communication partner</span>
<span class="cm"> *</span>
<span class="cm"> * This function resumes incoming messages on an IUCV path that has</span>
<span class="cm"> * been stopped with iucv_path_quiesce.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_path_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">userdata</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipuser</span><span class="p">,</span> <span class="n">userdata</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ipuser</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">ctrl</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_RESUME</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_sever</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @userdata: 16 bytes of data reflected to the communication partner</span>
<span class="cm"> *</span>
<span class="cm"> * This function terminates an IUCV path.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_path_sever</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u8</span> <span class="n">userdata</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iucv_active_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span>
		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_sever_pathid</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">,</span> <span class="n">userdata</span><span class="p">);</span>
	<span class="n">iucv_path_table</span><span class="p">[</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iucv_active_cpu</span> <span class="o">!=</span> <span class="n">smp_processor_id</span><span class="p">())</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_path_sever</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_purge</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @srccls: source class of message</span>
<span class="cm"> *</span>
<span class="cm"> * Cancels a message you have sent.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_message_purge</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="n">srccls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">purge</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">purge</span><span class="p">.</span><span class="n">ipmsgid</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">purge</span><span class="p">.</span><span class="n">ipsrccls</span> <span class="o">=</span> <span class="n">srccls</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">purge</span><span class="p">.</span><span class="n">ipflags1</span> <span class="o">=</span> <span class="n">IUCV_IPSRCCLS</span> <span class="o">|</span> <span class="n">IUCV_IPFGMID</span> <span class="o">|</span> <span class="n">IUCV_IPFGPID</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_PURGE</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">audit</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">purge</span><span class="p">.</span><span class="n">ipaudit</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">parm</span><span class="o">-&gt;</span><span class="n">purge</span><span class="p">.</span><span class="n">ipmsgtag</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_message_purge</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_receive_iprmdata</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: how the message is received (IUCV_IPBUFLST)</span>
<span class="cm"> * @buffer: address of data buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of data buffer</span>
<span class="cm"> * @residual:</span>
<span class="cm"> *</span>
<span class="cm"> * Internal function used by iucv_message_receive and __iucv_message_receive</span>
<span class="cm"> * to receive RMDATA data stored in struct iucv_message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_message_receive_iprmdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
					 <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">residual</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_array</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">rmmsg</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">copy</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Message is 8 bytes long and has been stored to the</span>
<span class="cm">	 * message descriptor itself.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">residual</span><span class="p">)</span>
		<span class="o">*</span><span class="n">residual</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">rmmsg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">rmmsg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IUCV_IPBUFLST</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Copy to struct iucv_array. */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">?</span> <span class="n">size</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">array</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">array</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">copy</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span>
				<span class="n">rmmsg</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
			<span class="n">rmmsg</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Copy to direct buffer. */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">rmmsg</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">8</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __iucv_message_receive</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: how the message is received (IUCV_IPBUFLST)</span>
<span class="cm"> * @buffer: address of data buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of data buffer</span>
<span class="cm"> * @residual:</span>
<span class="cm"> *</span>
<span class="cm"> * This function receives messages that are being sent to you over</span>
<span class="cm"> * established paths. This function will deal with RMDATA messages</span>
<span class="cm"> * embedded in struct iucv_message as well.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking:	no locking</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__iucv_message_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			   <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">residual</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IUCV_IPRMDATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">iucv_message_receive_iprmdata</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
						     <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">residual</span><span class="p">);</span>
	 <span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfadr1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfln1f</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipmsgid</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">iptrgcls</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipflags1</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">|</span> <span class="n">IUCV_IPFGPID</span> <span class="o">|</span>
			     <span class="n">IUCV_IPFGMID</span> <span class="o">|</span> <span class="n">IUCV_IPTRGCLS</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_RECEIVE</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">||</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipflags1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">residual</span><span class="p">)</span>
			<span class="o">*</span><span class="n">residual</span> <span class="o">=</span> <span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfln1f</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__iucv_message_receive</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_receive</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: how the message is received (IUCV_IPBUFLST)</span>
<span class="cm"> * @buffer: address of data buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of data buffer</span>
<span class="cm"> * @residual:</span>
<span class="cm"> *</span>
<span class="cm"> * This function receives messages that are being sent to you over</span>
<span class="cm"> * established paths. This function will deal with RMDATA messages</span>
<span class="cm"> * embedded in struct iucv_message as well.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking:	local_bh_enable/local_bh_disable</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_message_receive</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			 <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">residual</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IUCV_IPRMDATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">iucv_message_receive_iprmdata</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
						     <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">residual</span><span class="p">);</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">__iucv_message_receive</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">residual</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_message_receive</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_reject</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> *</span>
<span class="cm"> * The reject function refuses a specified message. Between the time you</span>
<span class="cm"> * are notified of a message and the time that you complete the message,</span>
<span class="cm"> * the message may be rejected.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_message_reject</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipmsgid</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">iptrgcls</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
	<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipflags1</span> <span class="o">=</span> <span class="p">(</span><span class="n">IUCV_IPTRGCLS</span> <span class="o">|</span> <span class="n">IUCV_IPFGMID</span> <span class="o">|</span> <span class="n">IUCV_IPFGPID</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_REJECT</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_message_reject</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_reply</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: how the reply is sent (IUCV_IPRMDATA, IUCV_IPPRTY, IUCV_IPBUFLST)</span>
<span class="cm"> * @reply: address of reply data buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of reply data buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function responds to the two-way messages that you receive. You</span>
<span class="cm"> * must identify completely the message to which you wish to reply. ie,</span>
<span class="cm"> * pathid, msgid, and trgcls. Prmmsg signifies the data is moved into</span>
<span class="cm"> * the parameter list.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_message_reply</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		       <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reply</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IUCV_IPRMDATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ipflags1</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ipmsgid</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">iptrgcls</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">iprmmsg</span><span class="p">,</span> <span class="n">reply</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">8</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfadr1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">reply</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfln1f</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipflags1</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipmsgid</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">iptrgcls</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_REPLY</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_message_reply</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __iucv_message_send</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: how the message is sent (IUCV_IPRMDATA, IUCV_IPPRTY, IUCV_IPBUFLST)</span>
<span class="cm"> * @srccls: source class of message</span>
<span class="cm"> * @buffer: address of send buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of send buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function transmits data to another application. Data to be</span>
<span class="cm"> * transmitted is in a buffer and this is a one-way message and the</span>
<span class="cm"> * receiver will not reply to the message.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking:	no locking</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__iucv_message_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		      <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">srccls</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IUCV_IPRMDATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Message of 8 bytes can be placed into the parameter list. */</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ipflags1</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">IUCV_IPNORPY</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">iptrgcls</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ipsrccls</span> <span class="o">=</span> <span class="n">srccls</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ipmsgtag</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">iprmmsg</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfadr1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">buffer</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfln1f</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipflags1</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">IUCV_IPNORPY</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">iptrgcls</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipsrccls</span> <span class="o">=</span> <span class="n">srccls</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipmsgtag</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_SEND</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipmsgid</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__iucv_message_send</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_send</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: how the message is sent (IUCV_IPRMDATA, IUCV_IPPRTY, IUCV_IPBUFLST)</span>
<span class="cm"> * @srccls: source class of message</span>
<span class="cm"> * @buffer: address of send buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of send buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function transmits data to another application. Data to be</span>
<span class="cm"> * transmitted is in a buffer and this is a one-way message and the</span>
<span class="cm"> * receiver will not reply to the message.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking:	local_bh_enable/local_bh_disable</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_message_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
		      <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">srccls</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">__iucv_message_send</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">srccls</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_message_send</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_send2way</span>
<span class="cm"> * @path: address of iucv path structure</span>
<span class="cm"> * @msg: address of iucv msg structure</span>
<span class="cm"> * @flags: how the message is sent and the reply is received</span>
<span class="cm"> *	   (IUCV_IPRMDATA, IUCV_IPBUFLST, IUCV_IPPRTY, IUCV_ANSLST)</span>
<span class="cm"> * @srccls: source class of message</span>
<span class="cm"> * @buffer: address of send buffer or address of struct iucv_array</span>
<span class="cm"> * @size: length of send buffer</span>
<span class="cm"> * @ansbuf: address of answer buffer or address of struct iucv_array</span>
<span class="cm"> * @asize: size of reply buffer</span>
<span class="cm"> *</span>
<span class="cm"> * This function transmits data to another application. Data to be</span>
<span class="cm"> * transmitted is in a buffer. The receiver of the send is expected to</span>
<span class="cm"> * reply to the message and a buffer is provided into which IUCV moves</span>
<span class="cm"> * the reply to this message.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the result from the CP IUCV call.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_message_send2way</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iucv_message</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
			  <span class="n">u8</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u32</span> <span class="n">srccls</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="o">*</span><span class="n">answer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">asize</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">residual</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">iucv_param</span> <span class="o">*</span><span class="n">parm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_buffer_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parm</span> <span class="o">=</span> <span class="n">iucv_param</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">parm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IUCV_IPRMDATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ipflags1</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>	<span class="cm">/* priority message */</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">iptrgcls</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ipsrccls</span> <span class="o">=</span> <span class="n">srccls</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ipmsgtag</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ipbfadr2</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">answer</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">ipbfln2f</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">asize</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">parm</span><span class="o">-&gt;</span><span class="n">dpl</span><span class="p">.</span><span class="n">iprmmsg</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ippathid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipflags1</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>	<span class="cm">/* priority message */</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">iptrgcls</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipsrccls</span> <span class="o">=</span> <span class="n">srccls</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipmsgtag</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfadr1</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">buffer</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfln1f</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfadr2</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">addr_t</span><span class="p">)</span> <span class="n">answer</span><span class="p">;</span>
		<span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipbfln2f</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">asize</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_call_b2f0</span><span class="p">(</span><span class="n">IUCV_SEND</span><span class="p">,</span> <span class="n">parm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">parm</span><span class="o">-&gt;</span><span class="n">db</span><span class="p">.</span><span class="n">ipmsgid</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_message_send2way</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_pending</span>
<span class="cm"> * @data: Pointer to external interrupt buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Process connection pending work item. Called from tasklet while holding</span>
<span class="cm"> * iucv_table_lock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_path_pending</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipflags1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iptype</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ipmsglim</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">res1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipvmid</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">res3</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ippollfg</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res4</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_path_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_path_pending</span> <span class="o">*</span><span class="n">ipp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_handler</span> <span class="o">*</span><span class="n">handler</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iucv_path_table</span><span class="p">[</span><span class="n">ipp</span><span class="o">-&gt;</span><span class="n">ippathid</span><span class="p">]);</span>
	<span class="cm">/* New pathid, handler found. Create a new path struct. */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">iucv_error_no_memory</span><span class="p">;</span>
	<span class="n">path</span> <span class="o">=</span> <span class="n">iucv_path_alloc</span><span class="p">(</span><span class="n">ipp</span><span class="o">-&gt;</span><span class="n">ipmsglim</span><span class="p">,</span> <span class="n">ipp</span><span class="o">-&gt;</span><span class="n">ipflags1</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_sever</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span> <span class="o">=</span> <span class="n">ipp</span><span class="o">-&gt;</span><span class="n">ippathid</span><span class="p">;</span>
	<span class="n">iucv_path_table</span><span class="p">[</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
	<span class="n">EBCASC</span><span class="p">(</span><span class="n">ipp</span><span class="o">-&gt;</span><span class="n">ipvmid</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="cm">/* Call registered handler until one is found that wants the path. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_handler_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">path_pending</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Add path to handler to allow a call to iucv_path_sever</span>
<span class="cm">		 * inside the path_pending function. If the handler returns</span>
<span class="cm">		 * an error remove the path from the handler again.</span>
<span class="cm">		 */</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">paths</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">path_pending</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ipp</span><span class="o">-&gt;</span><span class="n">ipvmid</span><span class="p">,</span> <span class="n">ipp</span><span class="o">-&gt;</span><span class="n">ipuser</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* No handler wanted the path. */</span>
	<span class="n">iucv_path_table</span><span class="p">[</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">iucv_path_free</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">iucv_error_no_listener</span><span class="p">;</span>
<span class="nl">out_sever:</span>
	<span class="n">iucv_sever_pathid</span><span class="p">(</span><span class="n">ipp</span><span class="o">-&gt;</span><span class="n">ippathid</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_complete</span>
<span class="cm"> * @data: Pointer to external interrupt buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Process connection complete work item. Called from tasklet while holding</span>
<span class="cm"> * iucv_table_lock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_path_complete</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipflags1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iptype</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">ipmsglim</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">res1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res2</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">res3</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ippollfg</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res4</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_path_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_path_complete</span> <span class="o">*</span><span class="n">ipc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">iucv_path_table</span><span class="p">[</span><span class="n">ipc</span><span class="o">-&gt;</span><span class="n">ippathid</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ipc</span><span class="o">-&gt;</span><span class="n">ipflags1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">path_complete</span><span class="p">)</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">path_complete</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ipc</span><span class="o">-&gt;</span><span class="n">ipuser</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_severed</span>
<span class="cm"> * @data: Pointer to external interrupt buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Process connection severed work item. Called from tasklet while holding</span>
<span class="cm"> * iucv_table_lock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_path_severed</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iptype</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res2</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res3</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">res4</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ippollfg</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res5</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_path_severed</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_path_severed</span> <span class="o">*</span><span class="n">ips</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">iucv_path_table</span><span class="p">[</span><span class="n">ips</span><span class="o">-&gt;</span><span class="n">ippathid</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span> <span class="o">||</span> <span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">)</span>	<span class="cm">/* Already severed */</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">path_severed</span><span class="p">)</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">path_severed</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ips</span><span class="o">-&gt;</span><span class="n">ipuser</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">iucv_sever_pathid</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">iucv_path_table</span><span class="p">[</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">pathid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">iucv_path_free</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_quiesced</span>
<span class="cm"> * @data: Pointer to external interrupt buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Process connection quiesced work item. Called from tasklet while holding</span>
<span class="cm"> * iucv_table_lock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_path_quiesced</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iptype</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res2</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res3</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">res4</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ippollfg</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res5</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_path_quiesced</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_path_quiesced</span> <span class="o">*</span><span class="n">ipq</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">iucv_path_table</span><span class="p">[</span><span class="n">ipq</span><span class="o">-&gt;</span><span class="n">ippathid</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">path_quiesced</span><span class="p">)</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">path_quiesced</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ipq</span><span class="o">-&gt;</span><span class="n">ipuser</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_resumed</span>
<span class="cm"> * @data: Pointer to external interrupt buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Process connection resumed work item. Called from tasklet while holding</span>
<span class="cm"> * iucv_table_lock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_path_resumed</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iptype</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res2</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res3</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u8</span>  <span class="n">ipuser</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">res4</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ippollfg</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res5</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_path_resumed</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_path_resumed</span> <span class="o">*</span><span class="n">ipr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">iucv_path_table</span><span class="p">[</span><span class="n">ipr</span><span class="o">-&gt;</span><span class="n">ippathid</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">path_resumed</span><span class="p">)</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">path_resumed</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ipr</span><span class="o">-&gt;</span><span class="n">ipuser</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_complete</span>
<span class="cm"> * @data: Pointer to external interrupt buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Process message complete work item. Called from tasklet while holding</span>
<span class="cm"> * iucv_table_lock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_message_complete</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipflags1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iptype</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipmsgid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipaudit</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iprmmsg</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">ipsrccls</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipmsgtag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipbfln2f</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ippollfg</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_message_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_message_complete</span> <span class="o">*</span><span class="n">imc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">iucv_path_table</span><span class="p">[</span><span class="n">imc</span><span class="o">-&gt;</span><span class="n">ippathid</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iucv_message</span> <span class="n">msg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">message_complete</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">imc</span><span class="o">-&gt;</span><span class="n">ipflags1</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">imc</span><span class="o">-&gt;</span><span class="n">ipmsgid</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">audit</span> <span class="o">=</span> <span class="n">imc</span><span class="o">-&gt;</span><span class="n">ipaudit</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">rmmsg</span><span class="p">,</span> <span class="n">imc</span><span class="o">-&gt;</span><span class="n">iprmmsg</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">imc</span><span class="o">-&gt;</span><span class="n">ipsrccls</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">imc</span><span class="o">-&gt;</span><span class="n">ipmsgtag</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">imc</span><span class="o">-&gt;</span><span class="n">ipbfln2f</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">message_complete</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_message_pending</span>
<span class="cm"> * @data: Pointer to external interrupt buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Process message pending work item. Called from tasklet while holding</span>
<span class="cm"> * iucv_table_lock.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">iucv_message_pending</span> <span class="p">{</span>
	<span class="n">u16</span> <span class="n">ippathid</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ipflags1</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">iptype</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ipmsgid</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">iptrgcls</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">iprmmsg1_u32</span><span class="p">;</span>
		<span class="n">u8</span>  <span class="n">iprmmsg1</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">ln1msg1</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ipbfln1f</span><span class="p">;</span>
		<span class="n">u8</span>  <span class="n">iprmmsg2</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">ln1msg2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">res1</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">ipbfln2f</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">ippollfg</span><span class="p">;</span>
	<span class="n">u8</span>  <span class="n">res2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_message_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_message_pending</span> <span class="o">*</span><span class="n">imp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">iucv_path_table</span><span class="p">[</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">ippathid</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">iucv_message</span> <span class="n">msg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">message_pending</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">imp</span><span class="o">-&gt;</span><span class="n">ipflags1</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">imp</span><span class="o">-&gt;</span><span class="n">ipmsgid</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">class</span> <span class="o">=</span> <span class="n">imp</span><span class="o">-&gt;</span><span class="n">iptrgcls</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">imp</span><span class="o">-&gt;</span><span class="n">ipflags1</span> <span class="o">&amp;</span> <span class="n">IUCV_IPRMDATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">rmmsg</span><span class="p">,</span> <span class="n">imp</span><span class="o">-&gt;</span><span class="n">ln1msg1</span><span class="p">.</span><span class="n">iprmmsg1</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
			<span class="n">msg</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">msg</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">imp</span><span class="o">-&gt;</span><span class="n">ln1msg2</span><span class="p">.</span><span class="n">ipbfln1f</span><span class="p">;</span>
		<span class="n">msg</span><span class="p">.</span><span class="n">reply_size</span> <span class="o">=</span> <span class="n">imp</span><span class="o">-&gt;</span><span class="n">ipbfln2f</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">message_pending</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_tasklet_fn:</span>
<span class="cm"> *</span>
<span class="cm"> * This tasklet loops over the queue of irq buffers created by</span>
<span class="cm"> * iucv_external_interrupt, calls the appropriate action handler</span>
<span class="cm"> * and then frees the buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_tasklet_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ignored</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">typedef</span> <span class="kt">void</span> <span class="n">iucv_irq_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">static</span> <span class="n">iucv_irq_fn</span> <span class="o">*</span><span class="n">irq_fn</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">[</span><span class="mh">0x02</span><span class="p">]</span> <span class="o">=</span> <span class="n">iucv_path_complete</span><span class="p">,</span>
		<span class="p">[</span><span class="mh">0x03</span><span class="p">]</span> <span class="o">=</span> <span class="n">iucv_path_severed</span><span class="p">,</span>
		<span class="p">[</span><span class="mh">0x04</span><span class="p">]</span> <span class="o">=</span> <span class="n">iucv_path_quiesced</span><span class="p">,</span>
		<span class="p">[</span><span class="mh">0x05</span><span class="p">]</span> <span class="o">=</span> <span class="n">iucv_path_resumed</span><span class="p">,</span>
		<span class="p">[</span><span class="mh">0x06</span><span class="p">]</span> <span class="o">=</span> <span class="n">iucv_message_complete</span><span class="p">,</span>
		<span class="p">[</span><span class="mh">0x07</span><span class="p">]</span> <span class="o">=</span> <span class="n">iucv_message_complete</span><span class="p">,</span>
		<span class="p">[</span><span class="mh">0x08</span><span class="p">]</span> <span class="o">=</span> <span class="n">iucv_message_pending</span><span class="p">,</span>
		<span class="p">[</span><span class="mh">0x09</span><span class="p">]</span> <span class="o">=</span> <span class="n">iucv_message_pending</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">task_queue</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iucv_irq_list</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="cm">/* Serialize tasklet, iucv_path_sever and iucv_path_connect. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_tasklet</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iucv_active_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_queue_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_task_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task_queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_queue_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">irq_fn</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">iptype</span><span class="p">](</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">iucv_active_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_work_fn:</span>
<span class="cm"> *</span>
<span class="cm"> * This work function loops over the queue of path pending irq blocks</span>
<span class="cm"> * created by iucv_external_interrupt, calls the appropriate action</span>
<span class="cm"> * handler and then frees the buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_work_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">work_queue</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">iucv_irq_list</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="cm">/* Serialize tasklet, iucv_path_sever and iucv_path_connect. */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">);</span>
	<span class="n">iucv_active_cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_queue_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_work_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_queue</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_queue_lock</span><span class="p">);</span>

	<span class="n">iucv_cleanup_queue</span><span class="p">();</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">iucv_path_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">iucv_active_cpu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_table_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_external_interrupt</span>
<span class="cm"> * @code: irq code</span>
<span class="cm"> *</span>
<span class="cm"> * Handles external interrupts coming in from CP.</span>
<span class="cm"> * Places the interrupt buffer on a queue and schedules iucv_tasklet_fn().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_external_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ext_code</span> <span class="n">ext_code</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">param32</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param64</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_irq_data</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_irq_list</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

	<span class="n">kstat_cpu</span><span class="p">(</span><span class="n">smp_processor_id</span><span class="p">()).</span><span class="n">irqs</span><span class="p">[</span><span class="n">EXTINT_IUC</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">smp_processor_id</span><span class="p">()];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ippathid</span> <span class="o">&gt;=</span> <span class="n">iucv_max_pathid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ippathid</span> <span class="o">&gt;=</span> <span class="n">iucv_max_pathid</span><span class="p">);</span>
		<span class="n">iucv_sever_pathid</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ippathid</span><span class="p">,</span> <span class="n">iucv_error_no_listener</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">iptype</span>  <span class="o">&lt;</span> <span class="mh">0x01</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">iptype</span> <span class="o">&gt;</span> <span class="mh">0x09</span><span class="p">);</span>
	<span class="n">work</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_irq_list</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;iucv_external_interrupt: out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_queue_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">iptype</span> <span class="o">==</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Path pending interrupt. */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_work_queue</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* The other interrupts. */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_task_queue</span><span class="p">);</span>
		<span class="n">tasklet_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_tasklet</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_queue_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_pm_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;iucv_pm_prepare</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">prepare</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">prepare</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">iucv_pm_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;iucv_pm_complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_path_table_empty() - determine if iucv path table is empty</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if there are still iucv pathes defined</span>
<span class="cm"> *	   1 if there are no iucv pathes defined</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iucv_path_table_empty</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iucv_max_pathid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iucv_path_table</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_pm_freeze() - Freeze PM callback</span>
<span class="cm"> * @dev:	iucv-based device</span>
<span class="cm"> *</span>
<span class="cm"> * disable iucv interrupts</span>
<span class="cm"> * invoke callback function of the iucv-based driver</span>
<span class="cm"> * shut down iucv, if no iucv-pathes are established anymore</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_pm_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iucv_irq_list</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;iucv_pm_freeze</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iucv_pm_state</span> <span class="o">!=</span> <span class="n">IUCV_PM_FREEZING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_irq_cpumask</span><span class="p">)</span>
			<span class="n">smp_call_function_single</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">iucv_block_cpu_almost</span><span class="p">,</span>
						 <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_work</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_work_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">iucv_sever_pathid</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">ippathid</span><span class="p">,</span>
					  <span class="n">iucv_error_no_listener</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">iucv_pm_state</span> <span class="o">=</span> <span class="n">IUCV_PM_FREEZING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">freeze</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">freeze</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iucv_path_table_empty</span><span class="p">())</span>
		<span class="n">iucv_disable</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_pm_thaw() - Thaw PM callback</span>
<span class="cm"> * @dev:	iucv-based device</span>
<span class="cm"> *</span>
<span class="cm"> * make iucv ready for use again: allocate path table, declare interrupt buffers</span>
<span class="cm"> *				  and enable iucv interrupts</span>
<span class="cm"> * invoke callback function of the iucv-based driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_pm_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;iucv_pm_thaw</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">iucv_pm_state</span> <span class="o">=</span> <span class="n">IUCV_PM_THAWING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv_path_table</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_enable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_irq_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iucv_nonsmp_handler</span><span class="p">)</span>
			<span class="cm">/* enable interrupts on one cpu */</span>
			<span class="n">iucv_allow_cpu</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="cm">/* enable interrupts on all cpus */</span>
			<span class="n">iucv_setmask_mp</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">thaw</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">thaw</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_pm_restore() - Restore PM callback</span>
<span class="cm"> * @dev:	iucv-based device</span>
<span class="cm"> *</span>
<span class="cm"> * make iucv ready for use again: allocate path table, declare interrupt buffers</span>
<span class="cm"> *				  and enable iucv interrupts</span>
<span class="cm"> * invoke callback function of the iucv-based driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">iucv_pm_restore</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PM_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;iucv_pm_restore %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iucv_path_table</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">iucv_pm_state</span> <span class="o">!=</span> <span class="n">IUCV_PM_RESTORING</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">iucv_path_table</span><span class="p">)</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;Suspending Linux did not completely close all IUCV &quot;</span>
			<span class="s">&quot;connections</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">iucv_pm_state</span> <span class="o">=</span> <span class="n">IUCV_PM_RESTORING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_irq_cpumask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_query_maxconn</span><span class="p">();</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_enable</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">restore</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">restore</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">iucv_interface</span> <span class="n">iucv_if</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">message_receive</span> <span class="o">=</span> <span class="n">iucv_message_receive</span><span class="p">,</span>
	<span class="p">.</span><span class="n">__message_receive</span> <span class="o">=</span> <span class="n">__iucv_message_receive</span><span class="p">,</span>
	<span class="p">.</span><span class="n">message_reply</span> <span class="o">=</span> <span class="n">iucv_message_reply</span><span class="p">,</span>
	<span class="p">.</span><span class="n">message_reject</span> <span class="o">=</span> <span class="n">iucv_message_reject</span><span class="p">,</span>
	<span class="p">.</span><span class="n">message_send</span> <span class="o">=</span> <span class="n">iucv_message_send</span><span class="p">,</span>
	<span class="p">.</span><span class="n">__message_send</span> <span class="o">=</span> <span class="n">__iucv_message_send</span><span class="p">,</span>
	<span class="p">.</span><span class="n">message_send2way</span> <span class="o">=</span> <span class="n">iucv_message_send2way</span><span class="p">,</span>
	<span class="p">.</span><span class="n">message_purge</span> <span class="o">=</span> <span class="n">iucv_message_purge</span><span class="p">,</span>
	<span class="p">.</span><span class="n">path_accept</span> <span class="o">=</span> <span class="n">iucv_path_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">path_connect</span> <span class="o">=</span> <span class="n">iucv_path_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">path_quiesce</span> <span class="o">=</span> <span class="n">iucv_path_quiesce</span><span class="p">,</span>
	<span class="p">.</span><span class="n">path_resume</span> <span class="o">=</span> <span class="n">iucv_path_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">path_sever</span> <span class="o">=</span> <span class="n">iucv_path_sever</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iucv_register</span> <span class="o">=</span> <span class="n">iucv_register</span><span class="p">,</span>
	<span class="p">.</span><span class="n">iucv_unregister</span> <span class="o">=</span> <span class="n">iucv_unregister</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">iucv_if</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_init</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates and initializes various data structures.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">iucv_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MACHINE_IS_VM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ctl_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">iucv_query_maxconn</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ctl</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_external_interrupt</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">,</span> <span class="n">iucv_external_interrupt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_ctl</span><span class="p">;</span>
	<span class="n">iucv_root</span> <span class="o">=</span> <span class="n">root_device_register</span><span class="p">(</span><span class="s">&quot;iucv&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">iucv_root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">iucv_root</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_int</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Note: GFP_DMA used to get memory below 2G */</span>
		<span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iucv_irq_data</span><span class="p">),</span>
				     <span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">GFP_DMA</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Allocate parameter blocks. */</span>
		<span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">),</span>
				  <span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">GFP_DMA</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">iucv_param</span><span class="p">),</span>
				  <span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">GFP_DMA</span><span class="p">,</span> <span class="n">cpu_to_node</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_cpu_notifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_reboot_notifier</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_cpu</span><span class="p">;</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">iucv_error_no_listener</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">iucv_error_no_memory</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">ASCEBC</span><span class="p">(</span><span class="n">iucv_error_pathid</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">iucv_available</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_bus</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_reboot</span><span class="p">;</span>
	<span class="n">iucv_if</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">iucv_root</span><span class="p">;</span>
	<span class="n">iucv_if</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iucv_bus</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_reboot:</span>
	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_reboot_notifier</span><span class="p">);</span>
<span class="nl">out_cpu:</span>
	<span class="n">unregister_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_cpu_notifier</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">root_device_unregister</span><span class="p">(</span><span class="n">iucv_root</span><span class="p">);</span>
<span class="nl">out_int:</span>
	<span class="n">unregister_external_interrupt</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">,</span> <span class="n">iucv_external_interrupt</span><span class="p">);</span>
<span class="nl">out_ctl:</span>
	<span class="n">ctl_clear_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * iucv_exit</span>
<span class="cm"> *</span>
<span class="cm"> * Frees everything allocated from iucv_init.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">iucv_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">iucv_irq_list</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_queue_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_task_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iucv_work_queue</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_queue_lock</span><span class="p">);</span>
	<span class="n">unregister_reboot_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_reboot_notifier</span><span class="p">);</span>
	<span class="n">unregister_hotcpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_cpu_notifier</span><span class="p">);</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">iucv_param_irq</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">iucv_param</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
		<span class="n">iucv_irq_data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">root_device_unregister</span><span class="p">(</span><span class="n">iucv_root</span><span class="p">);</span>
	<span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iucv_bus</span><span class="p">);</span>
	<span class="n">unregister_external_interrupt</span><span class="p">(</span><span class="mh">0x4000</span><span class="p">,</span> <span class="n">iucv_external_interrupt</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">iucv_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">iucv_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;(C) 2001 IBM Corp. by Fritz Elfert (felfert@millenux.com)&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Linux for S/390 IUCV lowlevel driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
