<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sched › sch_htb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sch_htb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * net/sched/sch_htb.c	Hierarchical token bucket, feed tree version</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Martin Devera, &lt;devik@cdi.cz&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Credits (in time order) for older HTB versions:</span>
<span class="cm"> *              Stef Coene &lt;stef.coene@docum.org&gt;</span>
<span class="cm"> *			HTB support at LARTC mailing list</span>
<span class="cm"> *		Ondrej Kraus, &lt;krauso@barr.cz&gt;</span>
<span class="cm"> *			found missing INIT_QDISC(htb)</span>
<span class="cm"> *		Vladimir Smelhaus, Aamer Akhter, Bert Hubert</span>
<span class="cm"> *			helped a lot to locate nasty class stall bug</span>
<span class="cm"> *		Andi Kleen, Jamal Hadi, Bert Hubert</span>
<span class="cm"> *			code review and helpful comments on shaping</span>
<span class="cm"> *		Tomasz Wrona, &lt;tw@eter.tym.pl&gt;</span>
<span class="cm"> *			created test case so that I was able to fix nasty bug</span>
<span class="cm"> *		Wilfried Weissmann</span>
<span class="cm"> *			spotted bug in dequeue code and helped with fix</span>
<span class="cm"> *		Jiri Fojtasek</span>
<span class="cm"> *			fixed requeue routine</span>
<span class="cm"> *		and many others. thanks.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;net/netlink.h&gt;</span>
<span class="cp">#include &lt;net/pkt_sched.h&gt;</span>

<span class="cm">/* HTB algorithm.</span>
<span class="cm">    Author: devik@cdi.cz</span>
<span class="cm">    ========================================================================</span>
<span class="cm">    HTB is like TBF with multiple classes. It is also similar to CBQ because</span>
<span class="cm">    it allows to assign priority to each class in hierarchy.</span>
<span class="cm">    In fact it is another implementation of Floyd&#39;s formal sharing.</span>

<span class="cm">    Levels:</span>
<span class="cm">    Each class is assigned level. Leaf has ALWAYS level 0 and root</span>
<span class="cm">    classes have level TC_HTB_MAXDEPTH-1. Interior nodes has level</span>
<span class="cm">    one less than their parent.</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">htb_hysteresis</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* whether to use mode hysteresis for speedup */</span>
<span class="cp">#define HTB_VER 0x30011		</span><span class="cm">/* major must be matched with number suplied by TC as version */</span><span class="cp"></span>

<span class="cp">#if HTB_VER &gt;&gt; 16 != TC_HTB_PROTOVER</span>
<span class="cp">#error &quot;Mismatched sch_htb.c and pkt_sch.h&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/* Module parameter and sysfs export */</span>
<span class="n">module_param</span>    <span class="p">(</span><span class="n">htb_hysteresis</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0640</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">htb_hysteresis</span><span class="p">,</span> <span class="s">&quot;Hysteresis mode, less CPU load, less accurate&quot;</span><span class="p">);</span>

<span class="cm">/* used internaly to keep status of single class */</span>
<span class="k">enum</span> <span class="n">htb_cmode</span> <span class="p">{</span>
	<span class="n">HTB_CANT_SEND</span><span class="p">,</span>		<span class="cm">/* class can&#39;t send and can&#39;t borrow */</span>
	<span class="n">HTB_MAY_BORROW</span><span class="p">,</span>		<span class="cm">/* class can&#39;t send but may borrow */</span>
	<span class="n">HTB_CAN_SEND</span>		<span class="cm">/* class can send */</span>
<span class="p">};</span>

<span class="cm">/* interior &amp; leaf nodes; props specific to leaves are marked L: */</span>
<span class="k">struct</span> <span class="n">htb_class</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Qdisc_class_common</span> <span class="n">common</span><span class="p">;</span>
	<span class="cm">/* general class parameters */</span>
	<span class="k">struct</span> <span class="n">gnet_stats_basic_packed</span> <span class="n">bstats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gnet_stats_queue</span> <span class="n">qstats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gnet_stats_rate_est</span> <span class="n">rate_est</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tc_htb_xstats</span> <span class="n">xstats</span><span class="p">;</span>	<span class="cm">/* our special stats */</span>
	<span class="kt">int</span> <span class="n">refcnt</span><span class="p">;</span>		<span class="cm">/* usage count of this class */</span>

	<span class="cm">/* topology */</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>		<span class="cm">/* our level (see above) */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">children</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>	<span class="cm">/* parent class */</span>

	<span class="kt">int</span> <span class="n">prio</span><span class="p">;</span>		<span class="cm">/* these two are used only by leaves... */</span>
	<span class="kt">int</span> <span class="n">quantum</span><span class="p">;</span>		<span class="cm">/* but stored for parent-to-leaf return */</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">htb_class_leaf</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">deficit</span><span class="p">[</span><span class="n">TC_HTB_MAXDEPTH</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="n">drop_list</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">leaf</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">htb_class_inner</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">feed</span><span class="p">[</span><span class="n">TC_HTB_NUMPRIO</span><span class="p">];</span>	<span class="cm">/* feed trees */</span>
			<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">ptr</span><span class="p">[</span><span class="n">TC_HTB_NUMPRIO</span><span class="p">];</span>	<span class="cm">/* current class ptr */</span>
			<span class="cm">/* When class changes from state 1-&gt;2 and disconnects from</span>
<span class="cm">			 * parent&#39;s feed then we lost ptr value and start from the</span>
<span class="cm">			 * first child again. Here we store classid of the</span>
<span class="cm">			 * last valid ptr (used when ptr is NULL).</span>
<span class="cm">			 */</span>
			<span class="n">u32</span> <span class="n">last_ptr_id</span><span class="p">[</span><span class="n">TC_HTB_NUMPRIO</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">inner</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">un</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">node</span><span class="p">[</span><span class="n">TC_HTB_NUMPRIO</span><span class="p">];</span>	<span class="cm">/* node for self or feed tree */</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">pq_node</span><span class="p">;</span>	<span class="cm">/* node for event queue */</span>
	<span class="n">psched_time_t</span> <span class="n">pq_key</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">prio_activity</span><span class="p">;</span>	<span class="cm">/* for which prios are we active */</span>
	<span class="k">enum</span> <span class="n">htb_cmode</span> <span class="n">cmode</span><span class="p">;</span>	<span class="cm">/* current mode of the class */</span>

	<span class="cm">/* class attached filters */</span>
	<span class="k">struct</span> <span class="n">tcf_proto</span> <span class="o">*</span><span class="n">filter_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">filter_cnt</span><span class="p">;</span>

	<span class="cm">/* token bucket parameters */</span>
	<span class="k">struct</span> <span class="n">qdisc_rate_table</span> <span class="o">*</span><span class="n">rate</span><span class="p">;</span>	<span class="cm">/* rate table of the class itself */</span>
	<span class="k">struct</span> <span class="n">qdisc_rate_table</span> <span class="o">*</span><span class="n">ceil</span><span class="p">;</span>	<span class="cm">/* ceiling rate (limits borrows too) */</span>
	<span class="kt">long</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">cbuffer</span><span class="p">;</span>	<span class="cm">/* token bucket depth/rate */</span>
	<span class="n">psched_tdiff_t</span> <span class="n">mbuffer</span><span class="p">;</span>	<span class="cm">/* max wait time */</span>
	<span class="kt">long</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">ctokens</span><span class="p">;</span>	<span class="cm">/* current number of tokens */</span>
	<span class="n">psched_time_t</span> <span class="n">t_c</span><span class="p">;</span>	<span class="cm">/* checkpoint time */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">htb_sched</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Qdisc_class_hash</span> <span class="n">clhash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">drops</span><span class="p">[</span><span class="n">TC_HTB_NUMPRIO</span><span class="p">];</span><span class="cm">/* active leaves (for drops) */</span>

	<span class="cm">/* self list - roots of self generating tree */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">row</span><span class="p">[</span><span class="n">TC_HTB_MAXDEPTH</span><span class="p">][</span><span class="n">TC_HTB_NUMPRIO</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">row_mask</span><span class="p">[</span><span class="n">TC_HTB_MAXDEPTH</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">ptr</span><span class="p">[</span><span class="n">TC_HTB_MAXDEPTH</span><span class="p">][</span><span class="n">TC_HTB_NUMPRIO</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">last_ptr_id</span><span class="p">[</span><span class="n">TC_HTB_MAXDEPTH</span><span class="p">][</span><span class="n">TC_HTB_NUMPRIO</span><span class="p">];</span>

	<span class="cm">/* self wait list - roots of wait PQs per row */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">wait_pq</span><span class="p">[</span><span class="n">TC_HTB_MAXDEPTH</span><span class="p">];</span>

	<span class="cm">/* time of nearest event per level (row) */</span>
	<span class="n">psched_time_t</span> <span class="n">near_ev_cache</span><span class="p">[</span><span class="n">TC_HTB_MAXDEPTH</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">defcls</span><span class="p">;</span>		<span class="cm">/* class where unclassified flows go to */</span>

	<span class="cm">/* filters for qdisc itself */</span>
	<span class="k">struct</span> <span class="n">tcf_proto</span> <span class="o">*</span><span class="n">filter_list</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">rate2quantum</span><span class="p">;</span>	<span class="cm">/* quant = rate / rate2quantum */</span>
	<span class="n">psched_time_t</span> <span class="n">now</span><span class="p">;</span>	<span class="cm">/* cached dequeue time */</span>
	<span class="k">struct</span> <span class="n">qdisc_watchdog</span> <span class="n">watchdog</span><span class="p">;</span>

	<span class="cm">/* non shaped skbs; let them go directly thru */</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">direct_queue</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">direct_qlen</span><span class="p">;</span>	<span class="cm">/* max qlen of above */</span>

	<span class="kt">long</span> <span class="n">direct_pkts</span><span class="p">;</span>

<span class="cp">#define HTB_WARN_TOOMANYEVENTS	0x1</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">warned</span><span class="p">;</span>	<span class="cm">/* only one warning */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* find class in global hash table using given handle */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="nf">htb_find</span><span class="p">(</span><span class="n">u32</span> <span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Qdisc_class_common</span> <span class="o">*</span><span class="n">clc</span><span class="p">;</span>

	<span class="n">clc</span> <span class="o">=</span> <span class="n">qdisc_class_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">clc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">clc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span><span class="p">,</span> <span class="n">common</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_classify - classify a packet into class</span>
<span class="cm"> *</span>
<span class="cm"> * It returns NULL if the packet should be dropped or -1 if the packet</span>
<span class="cm"> * should be passed directly thru. In all other cases leaf class is returned.</span>
<span class="cm"> * We allow direct class selection by classid in priority. The we examine</span>
<span class="cm"> * filters in qdisc and in inner nodes (if higher filter points to the inner</span>
<span class="cm"> * node). If we end up with classid MAJOR:0 we enqueue the skb into special</span>
<span class="cm"> * internal fifo (direct). These packets then go directly thru. If we still</span>
<span class="cm"> * have no valid leaf we try to use MAJOR:default leaf. It still unsuccessful</span>
<span class="cm"> * then finish and return direct queue.</span>
<span class="cm"> */</span>
<span class="cp">#define HTB_DIRECT ((struct htb_class *)-1L)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="nf">htb_classify</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="o">*</span><span class="n">qerr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcf_result</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcf_proto</span> <span class="o">*</span><span class="n">tcf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* allow to select class by setting skb-&gt;priority to valid classid;</span>
<span class="cm">	 * note that nfmark can be used too by attaching filter fw with no</span>
<span class="cm">	 * rules in it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">==</span> <span class="n">sch</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">HTB_DIRECT</span><span class="p">;</span>	<span class="cm">/* X:0 (direct flow) selected */</span>
	<span class="n">cl</span> <span class="o">=</span> <span class="n">htb_find</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">,</span> <span class="n">sch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span> <span class="o">&amp;&amp;</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cl</span><span class="p">;</span>

	<span class="o">*</span><span class="n">qerr</span> <span class="o">=</span> <span class="n">NET_XMIT_SUCCESS</span> <span class="o">|</span> <span class="n">__NET_XMIT_BYPASS</span><span class="p">;</span>
	<span class="n">tcf</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">filter_list</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tcf</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="n">tc_classify</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tcf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_NET_CLS_ACT</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TC_ACT_QUEUED</span>:
		<span class="k">case</span> <span class="n">TC_ACT_STOLEN</span>:
			<span class="o">*</span><span class="n">qerr</span> <span class="o">=</span> <span class="n">NET_XMIT_SUCCESS</span> <span class="o">|</span> <span class="n">__NET_XMIT_STOLEN</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TC_ACT_SHOT</span>:
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">classid</span> <span class="o">==</span> <span class="n">sch</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">HTB_DIRECT</span><span class="p">;</span>	<span class="cm">/* X:0 (direct flow) */</span>
			<span class="n">cl</span> <span class="o">=</span> <span class="n">htb_find</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">classid</span><span class="p">,</span> <span class="n">sch</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>	<span class="cm">/* filter selected invalid classid */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cl</span><span class="p">;</span>	<span class="cm">/* we hit leaf; return it */</span>

		<span class="cm">/* we have got inner class; apply inner filter chain */</span>
		<span class="n">tcf</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">filter_list</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* classification failed; try to use default class */</span>
	<span class="n">cl</span> <span class="o">=</span> <span class="n">htb_find</span><span class="p">(</span><span class="n">TC_H_MAKE</span><span class="p">(</span><span class="n">TC_H_MAJ</span><span class="p">(</span><span class="n">sch</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">),</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">defcls</span><span class="p">),</span> <span class="n">sch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span> <span class="o">||</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">HTB_DIRECT</span><span class="p">;</span>	<span class="cm">/* bad default .. this is safe bet */</span>
	<span class="k">return</span> <span class="n">cl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_add_to_id_tree - adds class to the round robin list</span>
<span class="cm"> *</span>
<span class="cm"> * Routine adds class to the list (actually tree) sorted by classid.</span>
<span class="cm"> * Make sure that class is not already on such list for given prio.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_add_to_id_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="n">prio</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="n">prio</span><span class="p">],</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="n">prio</span><span class="p">],</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_add_to_wait_tree - adds class to the event queue with delay</span>
<span class="cm"> *</span>
<span class="cm"> * The class is added to priority event queue to indicate that class will</span>
<span class="cm"> * change its mode in cl-&gt;pq_key microseconds. Make sure that class is not</span>
<span class="cm"> * already in the queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_add_to_wait_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_pq</span><span class="p">[</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">].</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_key</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span> <span class="o">+</span> <span class="n">delay</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_key</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">)</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_key</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* update the nearest event cache */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">near_ev_cache</span><span class="p">[</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_key</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">near_ev_cache</span><span class="p">[</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_key</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span><span class="p">,</span> <span class="n">pq_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_key</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">pq_key</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_pq</span><span class="p">[</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_next_rb_node - finds next node in binary tree</span>
<span class="cm"> *</span>
<span class="cm"> * When we are past last key we return NULL.</span>
<span class="cm"> * Average complexity is 2 steps per call.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">htb_next_rb_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_add_class_to_row - add class to its row</span>
<span class="cm"> *</span>
<span class="cm"> * The class is added to row at priorities marked in mask.</span>
<span class="cm"> * It does nothing if mask == 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">htb_add_class_to_row</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">row_mask</span><span class="p">[</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">prio</span><span class="p">);</span>
		<span class="n">htb_add_to_id_tree</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">[</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* If this triggers, it is a bug in this code, but it need not be fatal */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_safe_rb_erase</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="n">rb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="n">rb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * htb_remove_class_from_row - removes class from its row</span>
<span class="cm"> *</span>
<span class="cm"> * The class is removed from row at priorities marked in mask.</span>
<span class="cm"> * It does nothing if mask == 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">htb_remove_class_from_row</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">);</span>

		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">prio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">][</span><span class="n">prio</span><span class="p">]</span> <span class="o">==</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">+</span> <span class="n">prio</span><span class="p">)</span>
			<span class="n">htb_next_rb_node</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">);</span>

		<span class="n">htb_safe_rb_erase</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">+</span> <span class="n">prio</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">[</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">[</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">][</span><span class="n">prio</span><span class="p">].</span><span class="n">rb_node</span><span class="p">)</span>
			<span class="n">m</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">prio</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">row_mask</span><span class="p">[</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">m</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_activate_prios - creates active classe&#39;s feed chain</span>
<span class="cm"> *</span>
<span class="cm"> * The class is connected to ancestors and/or appropriate rows</span>
<span class="cm"> * for priorities it is participating on. cl-&gt;cmode must be new</span>
<span class="cm"> * (activated) mode. It does nothing if cl-&gt;prio_activity == 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_activate_prios</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">m</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio_activity</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">==</span> <span class="n">HTB_MAY_BORROW</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">m</span><span class="p">);</span>
			<span class="n">m</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">prio</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">feed</span><span class="p">[</span><span class="n">prio</span><span class="p">].</span><span class="n">rb_node</span><span class="p">)</span>
				<span class="cm">/* parent already has its feed in use so that</span>
<span class="cm">				 * reset bit in mask as parent is already ok</span>
<span class="cm">				 */</span>
				<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">prio</span><span class="p">);</span>

			<span class="n">htb_add_to_id_tree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">feed</span> <span class="o">+</span> <span class="n">prio</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio_activity</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">cl</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">==</span> <span class="n">HTB_CAN_SEND</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span><span class="p">)</span>
		<span class="n">htb_add_class_to_row</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_deactivate_prios - remove class from feed chain</span>
<span class="cm"> *</span>
<span class="cm"> * cl-&gt;cmode must represent old mode (before deactivation). It does</span>
<span class="cm"> * nothing if cl-&gt;prio_activity == 0. Class is removed from all feed</span>
<span class="cm"> * chains and rows.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_deactivate_prios</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">m</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio_activity</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">==</span> <span class="n">HTB_MAY_BORROW</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">m</span><span class="p">);</span>
			<span class="n">m</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">prio</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">prio</span><span class="p">]</span> <span class="o">==</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">+</span> <span class="n">prio</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* we are removing child which is pointed to from</span>
<span class="cm">				 * parent feed - forget the pointer but remember</span>
<span class="cm">				 * classid</span>
<span class="cm">				 */</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">last_ptr_id</span><span class="p">[</span><span class="n">prio</span><span class="p">]</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span><span class="p">;</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">prio</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">htb_safe_rb_erase</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">+</span> <span class="n">prio</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">feed</span> <span class="o">+</span> <span class="n">prio</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">feed</span><span class="p">[</span><span class="n">prio</span><span class="p">].</span><span class="n">rb_node</span><span class="p">)</span>
				<span class="n">mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">prio</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio_activity</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="n">cl</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">==</span> <span class="n">HTB_CAN_SEND</span> <span class="o">&amp;&amp;</span> <span class="n">mask</span><span class="p">)</span>
		<span class="n">htb_remove_class_from_row</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">htb_lowater</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">htb_hysteresis</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">!=</span> <span class="n">HTB_CANT_SEND</span> <span class="o">?</span> <span class="o">-</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">cbuffer</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="nf">htb_hiwater</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">htb_hysteresis</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">==</span> <span class="n">HTB_CAN_SEND</span> <span class="o">?</span> <span class="o">-</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * htb_class_mode - computes and returns current class mode</span>
<span class="cm"> *</span>
<span class="cm"> * It computes cl&#39;s mode at time cl-&gt;t_c+diff and returns it. If mode</span>
<span class="cm"> * is not HTB_CAN_SEND then cl-&gt;pq_key is updated to time difference</span>
<span class="cm"> * from now to time when cl will change its state.</span>
<span class="cm"> * Also it is worth to note that class mode doesn&#39;t change simply</span>
<span class="cm"> * at cl-&gt;{c,}tokens == 0 but there can rather be hysteresis of</span>
<span class="cm"> * 0 .. -cl-&gt;{c,}buffer range. It is meant to limit number of</span>
<span class="cm"> * mode transitions per time unit. The speed gain is about 1/6.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">htb_cmode</span>
<span class="nf">htb_class_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">diff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">toks</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">toks</span> <span class="o">=</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">ctokens</span> <span class="o">+</span> <span class="o">*</span><span class="n">diff</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">htb_lowater</span><span class="p">(</span><span class="n">cl</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">toks</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">HTB_CANT_SEND</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">toks</span> <span class="o">=</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">tokens</span> <span class="o">+</span> <span class="o">*</span><span class="n">diff</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">htb_hiwater</span><span class="p">(</span><span class="n">cl</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">HTB_CAN_SEND</span><span class="p">;</span>

	<span class="o">*</span><span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">toks</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">HTB_MAY_BORROW</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_change_class_mode - changes classe&#39;s mode</span>
<span class="cm"> *</span>
<span class="cm"> * This should be the only way how to change classe&#39;s mode under normal</span>
<span class="cm"> * cirsumstances. Routine will update feed lists linkage, change mode</span>
<span class="cm"> * and add class to the wait event queue if appropriate. New mode should</span>
<span class="cm"> * be different from old one and cl-&gt;pq_key has to be valid if changing</span>
<span class="cm"> * to mode other than HTB_CAN_SEND (see htb_add_to_wait_tree).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">htb_change_class_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">diff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">htb_cmode</span> <span class="n">new_mode</span> <span class="o">=</span> <span class="n">htb_class_mode</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">diff</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_mode</span> <span class="o">==</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio_activity</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* not necessary: speed optimization */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">!=</span> <span class="n">HTB_CANT_SEND</span><span class="p">)</span>
			<span class="n">htb_deactivate_prios</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">=</span> <span class="n">new_mode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_mode</span> <span class="o">!=</span> <span class="n">HTB_CANT_SEND</span><span class="p">)</span>
			<span class="n">htb_activate_prios</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">=</span> <span class="n">new_mode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_activate - inserts leaf cl into appropriate active feeds</span>
<span class="cm"> *</span>
<span class="cm"> * Routine learns (new) priority of leaf and activates feed chain</span>
<span class="cm"> * for the prio. It can be called on already active leaf safely.</span>
<span class="cm"> * It also adds leaf into droplist.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">htb_activate</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">||</span> <span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span> <span class="o">||</span> <span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio_activity</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio_activity</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
		<span class="n">htb_activate_prios</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">drop_list</span><span class="p">,</span>
			      <span class="n">q</span><span class="o">-&gt;</span><span class="n">drops</span> <span class="o">+</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_deactivate - remove leaf cl from active feeds</span>
<span class="cm"> *</span>
<span class="cm"> * Make sure that leaf is active. In the other words it can&#39;t be called</span>
<span class="cm"> * with non-active leaf. It also removes class from the drop list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">htb_deactivate</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio_activity</span><span class="p">);</span>

	<span class="n">htb_deactivate_prios</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
	<span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio_activity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">drop_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">htb_enqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="n">htb_classify</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span> <span class="o">==</span> <span class="n">HTB_DIRECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* enqueue to helper queue */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_queue</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_qlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_pkts</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">qdisc_drop</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sch</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#ifdef CONFIG_NET_CLS_ACT</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">__NET_XMIT_BYPASS</span><span class="p">)</span>
			<span class="n">sch</span><span class="o">-&gt;</span><span class="n">qstats</span><span class="p">.</span><span class="n">drops</span><span class="o">++</span><span class="p">;</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">qdisc_enqueue</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">))</span> <span class="o">!=</span> <span class="n">NET_XMIT_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">net_xmit_drop_count</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sch</span><span class="o">-&gt;</span><span class="n">qstats</span><span class="p">.</span><span class="n">drops</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cl</span><span class="o">-&gt;</span><span class="n">qstats</span><span class="p">.</span><span class="n">drops</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">htb_activate</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sch</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">NET_XMIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">htb_accnt_tokens</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">long</span> <span class="n">diff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">toks</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">+</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">tokens</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">toks</span> <span class="o">&gt;</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">)</span>
		<span class="n">toks</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">toks</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">qdisc_l2t</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">toks</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">mbuffer</span><span class="p">)</span>
		<span class="n">toks</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">mbuffer</span><span class="p">;</span>

	<span class="n">cl</span><span class="o">-&gt;</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">toks</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">htb_accnt_ctokens</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">long</span> <span class="n">diff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">toks</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">+</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">ctokens</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">toks</span> <span class="o">&gt;</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">cbuffer</span><span class="p">)</span>
		<span class="n">toks</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">cbuffer</span><span class="p">;</span>
	<span class="n">toks</span> <span class="o">-=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">qdisc_l2t</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">ceil</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">toks</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">mbuffer</span><span class="p">)</span>
		<span class="n">toks</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">mbuffer</span><span class="p">;</span>

	<span class="n">cl</span><span class="o">-&gt;</span><span class="n">ctokens</span> <span class="o">=</span> <span class="n">toks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_charge_class - charges amount &quot;bytes&quot; to leaf and ancestors</span>
<span class="cm"> *</span>
<span class="cm"> * Routine assumes that packet &quot;bytes&quot; long was dequeued from leaf cl</span>
<span class="cm"> * borrowing from &quot;level&quot;. It accounts bytes to ceil leaky bucket for</span>
<span class="cm"> * leaf and all ancestors and to rate bucket for ancestors at levels</span>
<span class="cm"> * &quot;level&quot; and higher. It also handles possible change of mode resulting</span>
<span class="cm"> * from the update. Note that mode can also increase here (MAY_BORROW to</span>
<span class="cm"> * CAN_SEND) because we can use more precise clock that event queue here.</span>
<span class="cm"> * In such case we remove class from event queue first.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_charge_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">qdisc_pkt_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">htb_cmode</span> <span class="n">old_mode</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">diff</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">diff</span> <span class="o">=</span> <span class="n">psched_tdiff_bounded</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">,</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">t_c</span><span class="p">,</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">mbuffer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&gt;=</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="n">level</span><span class="p">)</span>
				<span class="n">cl</span><span class="o">-&gt;</span><span class="n">xstats</span><span class="p">.</span><span class="n">lends</span><span class="o">++</span><span class="p">;</span>
			<span class="n">htb_accnt_tokens</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">diff</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cl</span><span class="o">-&gt;</span><span class="n">xstats</span><span class="p">.</span><span class="n">borrows</span><span class="o">++</span><span class="p">;</span>
			<span class="n">cl</span><span class="o">-&gt;</span><span class="n">tokens</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span>	<span class="cm">/* we moved t_c; update tokens */</span>
		<span class="p">}</span>
		<span class="n">htb_accnt_ctokens</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">diff</span><span class="p">);</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">t_c</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">;</span>

		<span class="n">old_mode</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span><span class="p">;</span>
		<span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">htb_change_class_mode</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">diff</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_mode</span> <span class="o">!=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">old_mode</span> <span class="o">!=</span> <span class="n">HTB_CAN_SEND</span><span class="p">)</span>
				<span class="n">htb_safe_rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_node</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_pq</span> <span class="o">+</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">!=</span> <span class="n">HTB_CAN_SEND</span><span class="p">)</span>
				<span class="n">htb_add_to_wait_tree</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">diff</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* update basic stats except for leaves which are already updated */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span>
			<span class="n">bstats_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">bstats</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">cl</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_do_events - make mode changes to classes at the level</span>
<span class="cm"> *</span>
<span class="cm"> * Scans event queue for pending events and applies them. Returns time of</span>
<span class="cm"> * next pending event (0 for no event in pq, q-&gt;now for too many events).</span>
<span class="cm"> * Note: Applied are events whose have cl-&gt;pq_key &lt;= q-&gt;now.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">psched_time_t</span> <span class="nf">htb_do_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* don&#39;t run for longer than 2 jiffies; 2 is used instead of</span>
<span class="cm">	 * 1 to simplify things when jiffy is going to be incremented</span>
<span class="cm">	 * too soon</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stop_at</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">stop_at</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">diff</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_pq</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cl</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span><span class="p">,</span> <span class="n">pq_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_key</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_key</span><span class="p">;</span>

		<span class="n">htb_safe_rb_erase</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_pq</span> <span class="o">+</span> <span class="n">level</span><span class="p">);</span>
		<span class="n">diff</span> <span class="o">=</span> <span class="n">psched_tdiff_bounded</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">,</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">t_c</span><span class="p">,</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">mbuffer</span><span class="p">);</span>
		<span class="n">htb_change_class_mode</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">diff</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">!=</span> <span class="n">HTB_CAN_SEND</span><span class="p">)</span>
			<span class="n">htb_add_to_wait_tree</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">diff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* too much load - let&#39;s continue after a break for scheduling */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">warned</span> <span class="o">&amp;</span> <span class="n">HTB_WARN_TOOMANYEVENTS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;htb: too many events!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">warned</span> <span class="o">|=</span> <span class="n">HTB_WARN_TOOMANYEVENTS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns class-&gt;node+prio from id-tree where classe&#39;s id is &gt;= id. NULL</span>
<span class="cm"> * is no such one exists.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="nf">htb_id_find_next_upper</span><span class="p">(</span><span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
					      <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span>
		    <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="n">prio</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * htb_lookup_leaf - returns next leaf class in DRR order</span>
<span class="cm"> *</span>
<span class="cm"> * Find leaf where current feed pointers points to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="nf">htb_lookup_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">pptr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">pptr</span><span class="p">;</span>
		<span class="n">u32</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">stk</span><span class="p">[</span><span class="n">TC_HTB_MAXDEPTH</span><span class="p">],</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">stk</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span> <span class="o">=</span> <span class="n">pptr</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">65535</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ptr was invalidated but id is valid - try to recover</span>
<span class="cm">			 * the original or next ptr</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span> <span class="o">=</span>
			    <span class="n">htb_id_find_next_upper</span><span class="p">(</span><span class="n">prio</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="o">*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* ptr is valid now so that remove this hint as it</span>
<span class="cm">				 * can become out of date quickly</span>
<span class="cm">				 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* we are at right end; rewind &amp; go up */</span>
			<span class="o">*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span>
				<span class="o">*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sp</span> <span class="o">&gt;</span> <span class="n">stk</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sp</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
					<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">htb_next_rb_node</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">;</span>
			<span class="n">cl</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="n">prio</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">cl</span><span class="p">;</span>
			<span class="p">(</span><span class="o">++</span><span class="n">sp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">feed</span><span class="p">[</span><span class="n">prio</span><span class="p">].</span><span class="n">rb_node</span><span class="p">;</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">pptr</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">prio</span><span class="p">;</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">last_ptr_id</span> <span class="o">+</span> <span class="n">prio</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* dequeues packet at given priority and level; call only if</span>
<span class="cm"> * you are sure that there is active class at prio/level</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">htb_dequeue_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="cm">/* look initial class up in the row */</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">cl</span> <span class="o">=</span> <span class="n">htb_lookup_leaf</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">,</span> <span class="n">prio</span><span class="p">,</span>
				     <span class="n">q</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">,</span>
				     <span class="n">q</span><span class="o">-&gt;</span><span class="n">last_ptr_id</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
<span class="nl">next:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* class can be empty - it is unlikely but can be true if leaf</span>
<span class="cm">		 * qdisc drops packets in enqueue routine or if someone used</span>
<span class="cm">		 * graft operation on the leaf since last dequeue;</span>
<span class="cm">		 * simply deactivate and skip such class</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
			<span class="n">htb_deactivate</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>

			<span class="cm">/* row/level might become empty */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">row_mask</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">prio</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">next</span> <span class="o">=</span> <span class="n">htb_lookup_leaf</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">,</span>
					       <span class="n">prio</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">,</span>
					       <span class="n">q</span><span class="o">-&gt;</span><span class="n">last_ptr_id</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cl</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span>	<span class="cm">/* fix start if we just deleted it */</span>
				<span class="n">start</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="n">cl</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">dequeue</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">qdisc_warn_nonwc</span><span class="p">(</span><span class="s">&quot;htb&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">);</span>
		<span class="n">htb_next_rb_node</span><span class="p">((</span><span class="n">level</span> <span class="o">?</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">ptr</span> <span class="o">:</span> <span class="n">q</span><span class="o">-&gt;</span>
				  <span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">prio</span><span class="p">);</span>
		<span class="n">cl</span> <span class="o">=</span> <span class="n">htb_lookup_leaf</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">,</span> <span class="n">prio</span><span class="p">,</span>
				     <span class="n">q</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">,</span>
				     <span class="n">q</span><span class="o">-&gt;</span><span class="n">last_ptr_id</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="n">prio</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">cl</span> <span class="o">!=</span> <span class="n">start</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bstats_update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">bstats</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">deficit</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">-=</span> <span class="n">qdisc_pkt_len</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">deficit</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">deficit</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">quantum</span><span class="p">;</span>
			<span class="n">htb_next_rb_node</span><span class="p">((</span><span class="n">level</span> <span class="o">?</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="n">ptr</span> <span class="o">:</span> <span class="n">q</span><span class="o">-&gt;</span>
					  <span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">prio</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* this used to be after charge_class but this constelation</span>
<span class="cm">		 * gives us slightly better performance</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="p">)</span>
			<span class="n">htb_deactivate</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
		<span class="n">htb_charge_class</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">htb_dequeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">psched_time_t</span> <span class="n">next_event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_at</span><span class="p">;</span>

	<span class="cm">/* try to dequeue direct packets as high prio (!) to minimize cpu work */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">ok:</span>
		<span class="n">qdisc_bstats_update</span><span class="p">(</span><span class="n">sch</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">qdisc_unthrottled</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
		<span class="n">sch</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="o">--</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sch</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fin</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span> <span class="o">=</span> <span class="n">psched_get_time</span><span class="p">();</span>
	<span class="n">start_at</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">next_event</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">PSCHED_TICKS_PER_SEC</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">TC_HTB_MAXDEPTH</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* common case optimization - skip event handler quickly */</span>
		<span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
		<span class="n">psched_time_t</span> <span class="n">event</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">near_ev_cache</span><span class="p">[</span><span class="n">level</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">event</span> <span class="o">=</span> <span class="n">htb_do_events</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">start_at</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
				<span class="n">event</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span> <span class="o">+</span> <span class="n">PSCHED_TICKS_PER_SEC</span><span class="p">;</span>
			<span class="n">q</span><span class="o">-&gt;</span><span class="n">near_ev_cache</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">event</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">near_ev_cache</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">next_event</span> <span class="o">&gt;</span> <span class="n">event</span><span class="p">)</span>
			<span class="n">next_event</span> <span class="o">=</span> <span class="n">event</span><span class="p">;</span>

		<span class="n">m</span> <span class="o">=</span> <span class="o">~</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">row_mask</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">ffz</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

			<span class="n">m</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">prio</span><span class="p">;</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">htb_dequeue_tree</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">prio</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">ok</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">sch</span><span class="o">-&gt;</span><span class="n">qstats</span><span class="p">.</span><span class="n">overlimits</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">next_event</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">now</span><span class="p">))</span>
		<span class="n">qdisc_watchdog_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">,</span> <span class="n">next_event</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="nl">fin:</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* try to drop from each class (by prio) until one succeed */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">htb_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">prio</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">prio</span> <span class="o">=</span> <span class="n">TC_HTB_NUMPRIO</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">prio</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">prio</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">list_for_each</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">drops</span> <span class="o">+</span> <span class="n">prio</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span><span class="p">,</span>
							  <span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">drop_list</span><span class="p">);</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">drop</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">len</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">drop</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">sch</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="p">)</span>
					<span class="n">htb_deactivate</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* reset all classes */</span>
<span class="cm">/* always caled under BH &amp; queue lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">.</span><span class="n">hashsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">common</span><span class="p">.</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span>
				<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">));</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">)</span>
					<span class="n">qdisc_reset</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">);</span>
				<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">drop_list</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio_activity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">=</span> <span class="n">HTB_CAN_SEND</span><span class="p">;</span>

		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">qdisc_watchdog_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">);</span>
	<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_queue</span><span class="p">);</span>
	<span class="n">sch</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">row</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">row_mask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">row_mask</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_pq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_pq</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TC_HTB_NUMPRIO</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">drops</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="n">htb_policy</span><span class="p">[</span><span class="n">TCA_HTB_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">TCA_HTB_PARMS</span><span class="p">]</span>	<span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tc_htb_opt</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">TCA_HTB_INIT</span><span class="p">]</span>	<span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tc_htb_glob</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">TCA_HTB_CTAB</span><span class="p">]</span>	<span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_BINARY</span><span class="p">,</span> <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">TC_RTAB_SIZE</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">TCA_HTB_RTAB</span><span class="p">]</span>	<span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_BINARY</span><span class="p">,</span> <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">TC_RTAB_SIZE</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_work_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_sched</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">.</span><span class="n">qdisc</span><span class="p">;</span>

	<span class="n">__netif_schedule</span><span class="p">(</span><span class="n">qdisc_root</span><span class="p">(</span><span class="n">sch</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">htb_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">opt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[</span><span class="n">TCA_HTB_INIT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tc_htb_glob</span> <span class="o">*</span><span class="n">gopt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opt</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nla_parse_nested</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">TCA_HTB_INIT</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">htb_policy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">TCA_HTB_INIT</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;HTB: hey probably you have bad tc tool ?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">gopt</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">TCA_HTB_INIT</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gopt</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">!=</span> <span class="n">HTB_VER</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;HTB: need tc/htb version %d (minor is %d), you have %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">HTB_VER</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">HTB_VER</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="n">gopt</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">qdisc_class_hash_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TC_HTB_NUMPRIO</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">drops</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">qdisc_watchdog_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">,</span> <span class="n">sch</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">htb_work_func</span><span class="p">);</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_queue</span><span class="p">);</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_qlen</span> <span class="o">=</span> <span class="n">qdisc_dev</span><span class="p">(</span><span class="n">sch</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tx_queue_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_qlen</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>	<span class="cm">/* some devices have zero tx_queue_len */</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_qlen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">rate2quantum</span> <span class="o">=</span> <span class="n">gopt</span><span class="o">-&gt;</span><span class="n">rate2quantum</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">rate2quantum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">defcls</span> <span class="o">=</span> <span class="n">gopt</span><span class="o">-&gt;</span><span class="n">defcls</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">htb_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">root_lock</span> <span class="o">=</span> <span class="n">qdisc_root_sleeping_lock</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tc_htb_glob</span> <span class="n">gopt</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>

	<span class="n">gopt</span><span class="p">.</span><span class="n">direct_pkts</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_pkts</span><span class="p">;</span>
	<span class="n">gopt</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">HTB_VER</span><span class="p">;</span>
	<span class="n">gopt</span><span class="p">.</span><span class="n">rate2quantum</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rate2quantum</span><span class="p">;</span>
	<span class="n">gopt</span><span class="p">.</span><span class="n">defcls</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">defcls</span><span class="p">;</span>
	<span class="n">gopt</span><span class="p">.</span><span class="n">debug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nest</span> <span class="o">=</span> <span class="n">nla_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TCA_OPTIONS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nest</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TCA_HTB_INIT</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">gopt</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">gopt</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
	<span class="n">nla_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nest</span><span class="p">);</span>

	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
	<span class="n">nla_nest_cancel</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nest</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">htb_dump_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcmsg</span> <span class="o">*</span><span class="n">tcm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">root_lock</span> <span class="o">=</span> <span class="n">qdisc_root_sleeping_lock</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tc_htb_opt</span> <span class="n">opt</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
	<span class="n">tcm</span><span class="o">-&gt;</span><span class="n">tcm_parent</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">?</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span> <span class="o">:</span> <span class="n">TC_H_ROOT</span><span class="p">;</span>
	<span class="n">tcm</span><span class="o">-&gt;</span><span class="n">tcm_handle</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&amp;&amp;</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">)</span>
		<span class="n">tcm</span><span class="o">-&gt;</span><span class="n">tcm_info</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">;</span>

	<span class="n">nest</span> <span class="o">=</span> <span class="n">nla_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TCA_OPTIONS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nest</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">));</span>

	<span class="n">opt</span><span class="p">.</span><span class="n">rate</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">rate</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>
	<span class="n">opt</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">opt</span><span class="p">.</span><span class="n">ceil</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">ceil</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">;</span>
	<span class="n">opt</span><span class="p">.</span><span class="n">cbuffer</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">cbuffer</span><span class="p">;</span>
	<span class="n">opt</span><span class="p">.</span><span class="n">quantum</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">quantum</span><span class="p">;</span>
	<span class="n">opt</span><span class="p">.</span><span class="n">prio</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">;</span>
	<span class="n">opt</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TCA_HTB_PARMS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">opt</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">opt</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>

	<span class="n">nla_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nest</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="n">root_lock</span><span class="p">);</span>
	<span class="n">nla_nest_cancel</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">nest</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">htb_dump_class_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gnet_dump</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&amp;&amp;</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">)</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">qstats</span><span class="p">.</span><span class="n">qlen</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="p">;</span>
	<span class="n">cl</span><span class="o">-&gt;</span><span class="n">xstats</span><span class="p">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">tokens</span><span class="p">;</span>
	<span class="n">cl</span><span class="o">-&gt;</span><span class="n">xstats</span><span class="p">.</span><span class="n">ctokens</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">ctokens</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gnet_stats_copy_basic</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">bstats</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">gnet_stats_copy_rate_est</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">rate_est</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">gnet_stats_copy_queue</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">qstats</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">gnet_stats_copy_app</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">xstats</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">xstats</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">htb_graft</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">**</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">new</span> <span class="o">=</span> <span class="n">qdisc_create_dflt</span><span class="p">(</span><span class="n">sch</span><span class="o">-&gt;</span><span class="n">dev_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfifo_qdisc_ops</span><span class="p">,</span>
				     <span class="n">cl</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="n">sch_tree_lock</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">;</span>
	<span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">old</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qdisc_tree_decrease_qlen</span><span class="p">(</span><span class="o">*</span><span class="n">old</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">old</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="p">);</span>
		<span class="n">qdisc_reset</span><span class="p">(</span><span class="o">*</span><span class="n">old</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sch_tree_unlock</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="nf">htb_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">?</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_qlen_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">htb_deactivate</span><span class="p">(</span><span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">),</span> <span class="n">cl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">htb_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="n">u32</span> <span class="n">classid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="n">htb_find</span><span class="p">(</span><span class="n">classid</span><span class="p">,</span> <span class="n">sch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="p">)</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">htb_parent_last_child</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="cm">/* the root class */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* not the last child */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_parent_to_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">new_q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">||</span> <span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span> <span class="o">||</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio_activity</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">!=</span> <span class="n">HTB_CAN_SEND</span><span class="p">)</span>
		<span class="n">htb_safe_rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">pq_node</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_pq</span> <span class="o">+</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>

	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">drop_list</span><span class="p">);</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">new_q</span> <span class="o">?</span> <span class="n">new_q</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">noop_qdisc</span><span class="p">;</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">ctokens</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">cbuffer</span><span class="p">;</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">t_c</span> <span class="o">=</span> <span class="n">psched_get_time</span><span class="p">();</span>
	<span class="n">parent</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">=</span> <span class="n">HTB_CAN_SEND</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_destroy_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">);</span>
		<span class="n">qdisc_destroy</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">gen_kill_estimator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">bstats</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">rate_est</span><span class="p">);</span>
	<span class="n">qdisc_put_rtab</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>
	<span class="n">qdisc_put_rtab</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">ceil</span><span class="p">);</span>

	<span class="n">tcf_destroy_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">filter_list</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="n">qdisc_watchdog_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">watchdog</span><span class="p">);</span>
	<span class="cm">/* This line used to be after htb_destroy_class call below</span>
<span class="cm">	 * and surprisingly it worked in 2.4. But it must precede it</span>
<span class="cm">	 * because filter need its target class alive to be able to call</span>
<span class="cm">	 * unbind_filter on it (without Oops).</span>
<span class="cm">	 */</span>
	<span class="n">tcf_destroy_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">filter_list</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">.</span><span class="n">hashsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">common</span><span class="p">.</span><span class="n">hnode</span><span class="p">)</span>
			<span class="n">tcf_destroy_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">filter_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">.</span><span class="n">hashsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_for_each_entry_safe</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					  <span class="n">common</span><span class="p">.</span><span class="n">hnode</span><span class="p">)</span>
			<span class="n">htb_destroy_class</span><span class="p">(</span><span class="n">sch</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">qdisc_class_hash_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">);</span>
	<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">direct_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">htb_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qlen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">new_q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_child</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>TODO: why don't allow to delete subtree ? references ? does
tc subsys quarantee us that in htb_destroy it holds no class
refs so that we can remove children safely there ?</p></td><td class="code"><div class="highlight"><pre>	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">children</span> <span class="o">||</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">filter_cnt</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&amp;&amp;</span> <span class="n">htb_parent_last_child</span><span class="p">(</span><span class="n">cl</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_q</span> <span class="o">=</span> <span class="n">qdisc_create_dflt</span><span class="p">(</span><span class="n">sch</span><span class="o">-&gt;</span><span class="n">dev_queue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pfifo_qdisc_ops</span><span class="p">,</span>
					  <span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span><span class="p">);</span>
		<span class="n">last_child</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sch_tree_lock</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qlen</span> <span class="o">=</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="p">;</span>
		<span class="n">qdisc_reset</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">);</span>
		<span class="n">qdisc_tree_decrease_qlen</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">,</span> <span class="n">qlen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* delete from hash and active; remainder in destroy_class */</span>
	<span class="n">qdisc_class_hash_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio_activity</span><span class="p">)</span>
		<span class="n">htb_deactivate</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">!=</span> <span class="n">HTB_CAN_SEND</span><span class="p">)</span>
		<span class="n">htb_safe_rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_node</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_pq</span> <span class="o">+</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_child</span><span class="p">)</span>
		<span class="n">htb_parent_to_leaf</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">new_q</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">--</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This shouldn&#39;t happen: we &quot;hold&quot; one cops-&gt;get() when called</span>
<span class="cm">	 * from tc_ctl_tclass; the destroy method is done from cops-&gt;put().</span>
<span class="cm">	 */</span>

	<span class="n">sch_tree_unlock</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">htb_destroy_class</span><span class="p">(</span><span class="n">sch</span><span class="p">,</span> <span class="n">cl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">htb_change_class</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="n">u32</span> <span class="n">classid</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">parentid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">**</span><span class="n">tca</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">opt</span> <span class="o">=</span> <span class="n">tca</span><span class="p">[</span><span class="n">TCA_OPTIONS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">qdisc_rate_table</span> <span class="o">*</span><span class="n">rtab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">ctab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[</span><span class="n">__TCA_HTB_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">tc_htb_opt</span> <span class="o">*</span><span class="n">hopt</span><span class="p">;</span>

	<span class="cm">/* extract all subattrs from opt attr */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">opt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nla_parse_nested</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">TCA_HTB_MAX</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">htb_policy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">TCA_HTB_PARMS</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">parentid</span> <span class="o">==</span> <span class="n">TC_H_ROOT</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">htb_find</span><span class="p">(</span><span class="n">parentid</span><span class="p">,</span> <span class="n">sch</span><span class="p">);</span>

	<span class="n">hopt</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">tb</span><span class="p">[</span><span class="n">TCA_HTB_PARMS</span><span class="p">]);</span>

	<span class="n">rtab</span> <span class="o">=</span> <span class="n">qdisc_get_rtab</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hopt</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">,</span> <span class="n">tb</span><span class="p">[</span><span class="n">TCA_HTB_RTAB</span><span class="p">]);</span>
	<span class="n">ctab</span> <span class="o">=</span> <span class="n">qdisc_get_rtab</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hopt</span><span class="o">-&gt;</span><span class="n">ceil</span><span class="p">,</span> <span class="n">tb</span><span class="p">[</span><span class="n">TCA_HTB_CTAB</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtab</span> <span class="o">||</span> <span class="o">!</span><span class="n">ctab</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* new class */</span>
		<span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">new_q</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">prio</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">nlattr</span>		<span class="n">nla</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">gnet_estimator</span>	<span class="n">opt</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">est</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">nla</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">nla_len</span>	<span class="o">=</span> <span class="n">nla_attr_size</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">est</span><span class="p">.</span><span class="n">opt</span><span class="p">)),</span>
				<span class="p">.</span><span class="n">nla_type</span>	<span class="o">=</span> <span class="n">TCA_RATE</span><span class="p">,</span>
			<span class="p">},</span>
			<span class="p">.</span><span class="n">opt</span> <span class="o">=</span> <span class="p">{</span>
				<span class="cm">/* 4s interval, 16s averaging constant */</span>
				<span class="p">.</span><span class="n">interval</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
				<span class="p">.</span><span class="n">ewma_log</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
			<span class="p">},</span>
		<span class="p">};</span>

		<span class="cm">/* check for valid classid */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">classid</span> <span class="o">||</span> <span class="n">TC_H_MAJ</span><span class="p">(</span><span class="n">classid</span> <span class="o">^</span> <span class="n">sch</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">htb_find</span><span class="p">(</span><span class="n">classid</span><span class="p">,</span> <span class="n">sch</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

		<span class="cm">/* check maximal depth */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;htb: tree is too deep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
		<span class="n">cl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cl</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">gen_new_estimator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">bstats</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">rate_est</span><span class="p">,</span>
					<span class="n">qdisc_root_sleeping_lock</span><span class="p">(</span><span class="n">sch</span><span class="p">),</span>
					<span class="n">tca</span><span class="p">[</span><span class="n">TCA_RATE</span><span class="p">]</span> <span class="o">?</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">est</span><span class="p">.</span><span class="n">nla</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">cl</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">failure</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">children</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">drop_list</span><span class="p">);</span>
		<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">pq_node</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">prio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">prio</span> <span class="o">&lt;</span> <span class="n">TC_HTB_NUMPRIO</span><span class="p">;</span> <span class="n">prio</span><span class="o">++</span><span class="p">)</span>
			<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="n">prio</span><span class="p">]);</span>

		<span class="cm">/* create leaf qdisc early because it uses kmalloc(GFP_KERNEL)</span>
<span class="cm">		 * so that can&#39;t be used inside of sch_tree_lock</span>
<span class="cm">		 * -- thanks to Karlis Peisenieks</span>
<span class="cm">		 */</span>
		<span class="n">new_q</span> <span class="o">=</span> <span class="n">qdisc_create_dflt</span><span class="p">(</span><span class="n">sch</span><span class="o">-&gt;</span><span class="n">dev_queue</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">pfifo_qdisc_ops</span><span class="p">,</span> <span class="n">classid</span><span class="p">);</span>
		<span class="n">sch_tree_lock</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">qlen</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="p">.</span><span class="n">qlen</span><span class="p">;</span>

			<span class="cm">/* turn parent into inner node */</span>
			<span class="n">qdisc_reset</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">);</span>
			<span class="n">qdisc_tree_decrease_qlen</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">,</span> <span class="n">qlen</span><span class="p">);</span>
			<span class="n">qdisc_destroy</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">prio_activity</span><span class="p">)</span>
				<span class="n">htb_deactivate</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

			<span class="cm">/* remove from evt list because of level change */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">!=</span> <span class="n">HTB_CAN_SEND</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">htb_safe_rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">pq_node</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_pq</span><span class="p">);</span>
				<span class="n">parent</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">=</span> <span class="n">HTB_CAN_SEND</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">parent</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">?</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">level</span>
					 <span class="o">:</span> <span class="n">TC_HTB_MAXDEPTH</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">inner</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/* leaf (we) needs elementary qdisc */</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">leaf</span><span class="p">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">new_q</span> <span class="o">?</span> <span class="n">new_q</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">noop_qdisc</span><span class="p">;</span>

		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span> <span class="o">=</span> <span class="n">classid</span><span class="p">;</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>

		<span class="cm">/* set class to be in HTB_CAN_SEND state */</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">hopt</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">ctokens</span> <span class="o">=</span> <span class="n">hopt</span><span class="o">-&gt;</span><span class="n">cbuffer</span><span class="p">;</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">mbuffer</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">PSCHED_TICKS_PER_SEC</span><span class="p">;</span>	<span class="cm">/* 1min */</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">t_c</span> <span class="o">=</span> <span class="n">psched_get_time</span><span class="p">();</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">cmode</span> <span class="o">=</span> <span class="n">HTB_CAN_SEND</span><span class="p">;</span>

		<span class="cm">/* attach to the hash list and parent&#39;s family */</span>
		<span class="n">qdisc_class_hash_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">parent</span><span class="o">-&gt;</span><span class="n">children</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tca</span><span class="p">[</span><span class="n">TCA_RATE</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">gen_replace_estimator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">bstats</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">rate_est</span><span class="p">,</span>
						    <span class="n">qdisc_root_sleeping_lock</span><span class="p">(</span><span class="n">sch</span><span class="p">),</span>
						    <span class="n">tca</span><span class="p">[</span><span class="n">TCA_RATE</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sch_tree_lock</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* it used to be a nasty bug here, we have to check that node</span>
<span class="cm">	 * is really leaf before changing cl-&gt;un.leaf !</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">quantum</span> <span class="o">=</span> <span class="n">rtab</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">.</span><span class="n">rate</span> <span class="o">/</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">rate2quantum</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hopt</span><span class="o">-&gt;</span><span class="n">quantum</span> <span class="o">&amp;&amp;</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">quantum</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span>
			       <span class="s">&quot;HTB: quantum of class %X is small. Consider r2q change.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cl</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span><span class="p">);</span>
			<span class="n">cl</span><span class="o">-&gt;</span><span class="n">quantum</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hopt</span><span class="o">-&gt;</span><span class="n">quantum</span> <span class="o">&amp;&amp;</span> <span class="n">cl</span><span class="o">-&gt;</span><span class="n">quantum</span> <span class="o">&gt;</span> <span class="mi">200000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warning</span><span class="p">(</span>
			       <span class="s">&quot;HTB: quantum of class %X is big. Consider r2q change.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">cl</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">.</span><span class="n">classid</span><span class="p">);</span>
			<span class="n">cl</span><span class="o">-&gt;</span><span class="n">quantum</span> <span class="o">=</span> <span class="mi">200000</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hopt</span><span class="o">-&gt;</span><span class="n">quantum</span><span class="p">)</span>
			<span class="n">cl</span><span class="o">-&gt;</span><span class="n">quantum</span> <span class="o">=</span> <span class="n">hopt</span><span class="o">-&gt;</span><span class="n">quantum</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">hopt</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">TC_HTB_NUMPRIO</span><span class="p">)</span>
			<span class="n">cl</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">TC_HTB_NUMPRIO</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cl</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">hopt</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">cl</span><span class="o">-&gt;</span><span class="n">cbuffer</span> <span class="o">=</span> <span class="n">hopt</span><span class="o">-&gt;</span><span class="n">cbuffer</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">)</span>
		<span class="n">qdisc_put_rtab</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">rate</span><span class="p">);</span>
	<span class="n">cl</span><span class="o">-&gt;</span><span class="n">rate</span> <span class="o">=</span> <span class="n">rtab</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">ceil</span><span class="p">)</span>
		<span class="n">qdisc_put_rtab</span><span class="p">(</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">ceil</span><span class="p">);</span>
	<span class="n">cl</span><span class="o">-&gt;</span><span class="n">ceil</span> <span class="o">=</span> <span class="n">ctab</span><span class="p">;</span>
	<span class="n">sch_tree_unlock</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>

	<span class="n">qdisc_class_hash_grow</span><span class="p">(</span><span class="n">sch</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">);</span>

	<span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">failure:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rtab</span><span class="p">)</span>
		<span class="n">qdisc_put_rtab</span><span class="p">(</span><span class="n">rtab</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ctab</span><span class="p">)</span>
		<span class="n">qdisc_put_rtab</span><span class="p">(</span><span class="n">ctab</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tcf_proto</span> <span class="o">**</span><span class="nf">htb_find_tcf</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcf_proto</span> <span class="o">**</span><span class="n">fl</span> <span class="o">=</span> <span class="n">cl</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">cl</span><span class="o">-&gt;</span><span class="n">filter_list</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">filter_list</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">htb_bind_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parent</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">classid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="n">htb_find</span><span class="p">(</span><span class="n">classid</span><span class="p">,</span> <span class="n">sch</span><span class="p">);</span>

	<span class="cm">/*if (cl &amp;&amp; !cl-&gt;level) return 0;</span>
<span class="cm">	 * The line above used to be there to prevent attaching filters to</span>
<span class="cm">	 * leaves. But at least tc_index filter uses this just to get class</span>
<span class="cm">	 * for other reasons so that we have to allow for it.</span>
<span class="cm">	 * ----</span>
<span class="cm">	 * 19.6.2002 As Werner explained it is ok - bind filter is just</span>
<span class="cm">	 * another way to &quot;lock&quot; the class - unlike &quot;get&quot; this lock can</span>
<span class="cm">	 * be broken by class during destroy IIUC.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="p">)</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">filter_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_unbind_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cl</span><span class="p">)</span>
		<span class="n">cl</span><span class="o">-&gt;</span><span class="n">filter_cnt</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">htb_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">Qdisc</span> <span class="o">*</span><span class="n">sch</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qdisc_walker</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">htb_sched</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">qdisc_priv</span><span class="p">(</span><span class="n">sch</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">htb_class</span> <span class="o">*</span><span class="n">cl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">.</span><span class="n">hashsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">clhash</span><span class="p">.</span><span class="n">hash</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">common</span><span class="p">.</span><span class="n">hnode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">arg</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">(</span><span class="n">sch</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cl</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">arg</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">arg</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">Qdisc_class_ops</span> <span class="n">htb_class_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">graft</span>		<span class="o">=</span>	<span class="n">htb_graft</span><span class="p">,</span>
	<span class="p">.</span><span class="n">leaf</span>		<span class="o">=</span>	<span class="n">htb_leaf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">qlen_notify</span>	<span class="o">=</span>	<span class="n">htb_qlen_notify</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get</span>		<span class="o">=</span>	<span class="n">htb_get</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put</span>		<span class="o">=</span>	<span class="n">htb_put</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change</span>		<span class="o">=</span>	<span class="n">htb_change_class</span><span class="p">,</span>
	<span class="p">.</span><span class="n">delete</span>		<span class="o">=</span>	<span class="n">htb_delete</span><span class="p">,</span>
	<span class="p">.</span><span class="n">walk</span>		<span class="o">=</span>	<span class="n">htb_walk</span><span class="p">,</span>
	<span class="p">.</span><span class="n">tcf_chain</span>	<span class="o">=</span>	<span class="n">htb_find_tcf</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind_tcf</span>	<span class="o">=</span>	<span class="n">htb_bind_filter</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unbind_tcf</span>	<span class="o">=</span>	<span class="n">htb_unbind_filter</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dump</span>		<span class="o">=</span>	<span class="n">htb_dump_class</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dump_stats</span>	<span class="o">=</span>	<span class="n">htb_dump_class_stats</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">Qdisc_ops</span> <span class="n">htb_qdisc_ops</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">cl_ops</span>		<span class="o">=</span>	<span class="o">&amp;</span><span class="n">htb_class_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id</span>		<span class="o">=</span>	<span class="s">&quot;htb&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">priv_size</span>	<span class="o">=</span>	<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">htb_sched</span><span class="p">),</span>
	<span class="p">.</span><span class="n">enqueue</span>	<span class="o">=</span>	<span class="n">htb_enqueue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dequeue</span>	<span class="o">=</span>	<span class="n">htb_dequeue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">peek</span>		<span class="o">=</span>	<span class="n">qdisc_peek_dequeued</span><span class="p">,</span>
	<span class="p">.</span><span class="n">drop</span>		<span class="o">=</span>	<span class="n">htb_drop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init</span>		<span class="o">=</span>	<span class="n">htb_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset</span>		<span class="o">=</span>	<span class="n">htb_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span>	<span class="o">=</span>	<span class="n">htb_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dump</span>		<span class="o">=</span>	<span class="n">htb_dump</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">htb_module_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">register_qdisc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htb_qdisc_ops</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">htb_module_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_qdisc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">htb_qdisc_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">htb_module_init</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">htb_module_exit</span><span class="p">)</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
