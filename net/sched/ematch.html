<!DOCTYPE html>
<html><head><title>joekychen/linux » net › sched › ematch.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ematch.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * net/sched/ematch.c		Extended Match API</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Thomas Graf &lt;tgraf@suug.ch&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * ==========================================================================</span>
<span class="cm"> *</span>
<span class="cm"> * An extended match (ematch) is a small classification tool not worth</span>
<span class="cm"> * writing a full classifier for. Ematches can be interconnected to form</span>
<span class="cm"> * a logic expression and get attached to classifiers to extend their</span>
<span class="cm"> * functionatlity.</span>
<span class="cm"> *</span>
<span class="cm"> * The userspace part transforms the logic expressions into an array</span>
<span class="cm"> * consisting of multiple sequences of interconnected ematches separated</span>
<span class="cm"> * by markers. Precedence is implemented by a special ematch kind</span>
<span class="cm"> * referencing a sequence beyond the marker of the current sequence</span>
<span class="cm"> * causing the current position in the sequence to be pushed onto a stack</span>
<span class="cm"> * to allow the current position to be overwritten by the position referenced</span>
<span class="cm"> * in the special ematch. Matching continues in the new sequence until a</span>
<span class="cm"> * marker is reached causing the position to be restored from the stack.</span>
<span class="cm"> *</span>
<span class="cm"> * Example:</span>
<span class="cm"> *          A AND (B1 OR B2) AND C AND D</span>
<span class="cm"> *</span>
<span class="cm"> *              -------&gt;-PUSH-------</span>
<span class="cm"> *    --&gt;--    /         --&gt;--      \   --&gt;--</span>
<span class="cm"> *   /     \  /         /     \      \ /     \</span>
<span class="cm"> * +-------+-------+-------+-------+-------+--------+</span>
<span class="cm"> * | A AND | B AND | C AND | D END | B1 OR | B2 END |</span>
<span class="cm"> * +-------+-------+-------+-------+-------+--------+</span>
<span class="cm"> *                    \                      /</span>
<span class="cm"> *                     --------&lt;-POP---------</span>
<span class="cm"> *</span>
<span class="cm"> * where B is a virtual ematch referencing to sequence starting with B1.</span>
<span class="cm"> *</span>
<span class="cm"> * ==========================================================================</span>
<span class="cm"> *</span>
<span class="cm"> * How to write an ematch in 60 seconds</span>
<span class="cm"> * ------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> *   1) Provide a matcher function:</span>
<span class="cm"> *      static int my_match(struct sk_buff *skb, struct tcf_ematch *m,</span>
<span class="cm"> *                          struct tcf_pkt_info *info)</span>
<span class="cm"> *      {</span>
<span class="cm"> *      	struct mydata *d = (struct mydata *) m-&gt;data;</span>
<span class="cm"> *</span>
<span class="cm"> *      	if (...matching goes here...)</span>
<span class="cm"> *      		return 1;</span>
<span class="cm"> *      	else</span>
<span class="cm"> *      		return 0;</span>
<span class="cm"> *      }</span>
<span class="cm"> *</span>
<span class="cm"> *   2) Fill out a struct tcf_ematch_ops:</span>
<span class="cm"> *      static struct tcf_ematch_ops my_ops = {</span>
<span class="cm"> *      	.kind = unique id,</span>
<span class="cm"> *      	.datalen = sizeof(struct mydata),</span>
<span class="cm"> *      	.match = my_match,</span>
<span class="cm"> *      	.owner = THIS_MODULE,</span>
<span class="cm"> *      };</span>
<span class="cm"> *</span>
<span class="cm"> *   3) Register/Unregister your ematch:</span>
<span class="cm"> *      static int __init init_my_ematch(void)</span>
<span class="cm"> *      {</span>
<span class="cm"> *      	return tcf_em_register(&amp;my_ops);</span>
<span class="cm"> *      }</span>
<span class="cm"> *</span>
<span class="cm"> *      static void __exit exit_my_ematch(void)</span>
<span class="cm"> *      {</span>
<span class="cm"> *      	tcf_em_unregister(&amp;my_ops);</span>
<span class="cm"> *      }</span>
<span class="cm"> *</span>
<span class="cm"> *      module_init(init_my_ematch);</span>
<span class="cm"> *      module_exit(exit_my_ematch);</span>
<span class="cm"> *</span>
<span class="cm"> *   4) By now you should have two more seconds left, barely enough to</span>
<span class="cm"> *      open up a beer to watch the compilation going.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;net/pkt_cls.h&gt;</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">ematch_ops</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">ematch_mod_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tcf_ematch_ops</span> <span class="o">*</span><span class="nf">tcf_em_lookup</span><span class="p">(</span><span class="n">u16</span> <span class="n">kind</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tcf_ematch_ops</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ematch_mod_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ematch_ops</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kind</span> <span class="o">==</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
				<span class="n">e</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ematch_mod_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">e</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ematch_mod_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tcf_em_register - register an extended match</span>
<span class="cm"> *</span>
<span class="cm"> * @ops: ematch operations lookup table</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called by ematches to announce their presence.</span>
<span class="cm"> * The given @ops must have kind set to a unique identifier and the</span>
<span class="cm"> * callback match() must be implemented. All other callbacks are optional</span>
<span class="cm"> * and a fallback implementation is used instead.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EEXISTS if an ematch of the same kind has already registered.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tcf_em_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcf_ematch_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcf_ematch_ops</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ematch_mod_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ematch_ops</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">==</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ematch_ops</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">errout:</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ematch_mod_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcf_em_register</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcf_em_unregister - unregster and extended match</span>
<span class="cm"> *</span>
<span class="cm"> * @ops: ematch operations lookup table</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called by ematches to announce their disappearance</span>
<span class="cm"> * for examples when the module gets unloaded. The @ops parameter must be</span>
<span class="cm"> * the same as the one used for registration.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -ENOENT if no matching ematch was found.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcf_em_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcf_ematch_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ematch_mod_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ematch_mod_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcf_em_unregister</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tcf_ematch</span> <span class="o">*</span><span class="nf">tcf_em_get_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcf_ematch_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span>
						  <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">matches</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcf_em_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcf_proto</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">tcf_ematch_tree_hdr</span> <span class="o">*</span><span class="n">tree_hdr</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">tcf_ematch</span> <span class="o">*</span><span class="n">em</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcf_ematch_hdr</span> <span class="o">*</span><span class="n">em_hdr</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">nla</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">data_len</span> <span class="o">=</span> <span class="n">nla_len</span><span class="p">(</span><span class="n">nla</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">em_hdr</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">em_hdr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">em_hdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TCF_EM_REL_VALID</span><span class="p">(</span><span class="n">em_hdr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">em_hdr</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">==</span> <span class="n">TCF_EM_CONTAINER</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Special ematch called &quot;container&quot;, carries an index</span>
<span class="cm">		 * referencing an external ematch sequence.</span>
<span class="cm">		 */</span>
		<span class="n">u32</span> <span class="n">ref</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="o">&gt;=</span> <span class="n">tree_hdr</span><span class="o">-&gt;</span><span class="n">nmatches</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

		<span class="cm">/* We do not allow backward jumps to avoid loops and jumps</span>
<span class="cm">		 * to our own position are of course illegal.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>


		<span class="n">em</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Note: This lookup will increase the module refcnt</span>
<span class="cm">		 * of the ematch module referenced. In case of a failure,</span>
<span class="cm">		 * a destroy function is called by the underlying layer</span>
<span class="cm">		 * which automatically releases the reference again, therefore</span>
<span class="cm">		 * the module MUST not be given back under any circumstances</span>
<span class="cm">		 * here. Be aware, the destroy function assumes that the</span>
<span class="cm">		 * module is held if the ops field is non zero.</span>
<span class="cm">		 */</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">tcf_em_lookup</span><span class="p">(</span><span class="n">em_hdr</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MODULES</span>
			<span class="n">__rtnl_unlock</span><span class="p">();</span>
			<span class="n">request_module</span><span class="p">(</span><span class="s">&quot;ematch-kind-%u&quot;</span><span class="p">,</span> <span class="n">em_hdr</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">);</span>
			<span class="n">rtnl_lock</span><span class="p">();</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">tcf_em_lookup</span><span class="p">(</span><span class="n">em_hdr</span><span class="o">-&gt;</span><span class="n">kind</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* We dropped the RTNL mutex in order to</span>
<span class="cm">				 * perform the module load. Tell the caller</span>
<span class="cm">				 * to replay the request.</span>
<span class="cm">				 */</span>
				<span class="n">module_put</span><span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* ematch module provides expected length of data, so we</span>
<span class="cm">		 * can do a basic sanity check.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">datalen</span> <span class="o">&amp;&amp;</span> <span class="n">data_len</span> <span class="o">&lt;</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">datalen</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">change</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">change</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_len</span><span class="p">,</span> <span class="n">em</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ematch module doesn&#39;t provide an own change</span>
<span class="cm">			 * procedure and expects us to allocate and copy</span>
<span class="cm">			 * the ematch data.</span>
<span class="cm">			 *</span>
<span class="cm">			 * TCF_EM_SIMPLE may be specified stating that the</span>
<span class="cm">			 * data only consists of a u32 integer and the module</span>
<span class="cm">			 * does not expected a memory reference but rather</span>
<span class="cm">			 * the value carried.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">em_hdr</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TCF_EM_SIMPLE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
				<span class="n">em</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="n">kmemdup</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">em</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">v</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">em</span><span class="o">-&gt;</span><span class="n">matchid</span> <span class="o">=</span> <span class="n">em_hdr</span><span class="o">-&gt;</span><span class="n">matchid</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">em_hdr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">datalen</span> <span class="o">=</span> <span class="n">data_len</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">errout:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nla_policy</span> <span class="n">em_policy</span><span class="p">[</span><span class="n">TCA_EMATCH_TREE_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">TCA_EMATCH_TREE_HDR</span><span class="p">]</span>	<span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcf_ematch_tree_hdr</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">[</span><span class="n">TCA_EMATCH_TREE_LIST</span><span class="p">]</span>	<span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">NLA_NESTED</span> <span class="p">},</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * tcf_em_tree_validate - validate ematch config TLV and build ematch tree</span>
<span class="cm"> *</span>
<span class="cm"> * @tp: classifier kind handle</span>
<span class="cm"> * @nla: ematch tree configuration TLV</span>
<span class="cm"> * @tree: destination ematch tree variable to store the resulting</span>
<span class="cm"> *        ematch tree.</span>
<span class="cm"> *</span>
<span class="cm"> * This function validates the given configuration TLV @nla and builds an</span>
<span class="cm"> * ematch tree in @tree. The resulting tree must later be copied into</span>
<span class="cm"> * the private classifier data using tcf_em_tree_change(). You MUST NOT</span>
<span class="cm"> * provide the ematch tree variable of the private classifier data directly,</span>
<span class="cm"> * the changes would not be locked properly.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a negative error code if the configuration TLV contains errors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tcf_em_tree_validate</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcf_proto</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">nla</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">tcf_ematch_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">list_len</span><span class="p">,</span> <span class="n">matches_len</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">tb</span><span class="p">[</span><span class="n">TCA_EMATCH_TREE_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">rt_match</span><span class="p">,</span> <span class="o">*</span><span class="n">rt_hdr</span><span class="p">,</span> <span class="o">*</span><span class="n">rt_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcf_ematch_tree_hdr</span> <span class="o">*</span><span class="n">tree_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcf_ematch</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tree</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nla</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nla_parse_nested</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">TCA_EMATCH_TREE_MAX</span><span class="p">,</span> <span class="n">nla</span><span class="p">,</span> <span class="n">em_policy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">rt_hdr</span> <span class="o">=</span> <span class="n">tb</span><span class="p">[</span><span class="n">TCA_EMATCH_TREE_HDR</span><span class="p">];</span>
	<span class="n">rt_list</span> <span class="o">=</span> <span class="n">tb</span><span class="p">[</span><span class="n">TCA_EMATCH_TREE_LIST</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_hdr</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">rt_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

	<span class="n">tree_hdr</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">rt_hdr</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">tree_hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tree_hdr</span><span class="p">));</span>

	<span class="n">rt_match</span> <span class="o">=</span> <span class="n">nla_data</span><span class="p">(</span><span class="n">rt_list</span><span class="p">);</span>
	<span class="n">list_len</span> <span class="o">=</span> <span class="n">nla_len</span><span class="p">(</span><span class="n">rt_list</span><span class="p">);</span>
	<span class="n">matches_len</span> <span class="o">=</span> <span class="n">tree_hdr</span><span class="o">-&gt;</span><span class="n">nmatches</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">em</span><span class="p">);</span>

	<span class="n">tree</span><span class="o">-&gt;</span><span class="n">matches</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">matches_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">matches</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">errout</span><span class="p">;</span>

	<span class="cm">/* We do not use nla_parse_nested here because the maximum</span>
<span class="cm">	 * number of attributes is unknown. This saves us the allocation</span>
<span class="cm">	 * for a tb buffer which would serve no purpose at all.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The array of rt attributes is parsed in the order as they are</span>
<span class="cm">	 * provided, their type must be incremental from 1 to n. Even</span>
<span class="cm">	 * if it does not serve any real purpose, a failure of sticking</span>
<span class="cm">	 * to this policy will result in parsing failure.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nla_ok</span><span class="p">(</span><span class="n">rt_match</span><span class="p">,</span> <span class="n">list_len</span><span class="p">);</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rt_match</span><span class="o">-&gt;</span><span class="n">nla_type</span> <span class="o">!=</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">errout_abort</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">tree_hdr</span><span class="o">-&gt;</span><span class="n">nmatches</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">errout_abort</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nla_len</span><span class="p">(</span><span class="n">rt_match</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcf_ematch_hdr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">errout_abort</span><span class="p">;</span>

		<span class="n">em</span> <span class="o">=</span> <span class="n">tcf_em_get_match</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">tcf_em_validate</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tree_hdr</span><span class="p">,</span> <span class="n">em</span><span class="p">,</span> <span class="n">rt_match</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">errout_abort</span><span class="p">;</span>

		<span class="n">rt_match</span> <span class="o">=</span> <span class="n">nla_next</span><span class="p">(</span><span class="n">rt_match</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list_len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check if the number of matches provided by userspace actually</span>
<span class="cm">	 * complies with the array of matches. The number was used for</span>
<span class="cm">	 * the validation of references and a mismatch could lead to</span>
<span class="cm">	 * undefined references during the matching process.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="n">tree_hdr</span><span class="o">-&gt;</span><span class="n">nmatches</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">errout_abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">errout:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">errout_abort:</span>
	<span class="n">tcf_em_tree_destroy</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tree</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcf_em_tree_validate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcf_em_tree_destroy - destroy an ematch tree</span>
<span class="cm"> *</span>
<span class="cm"> * @tp: classifier kind handle</span>
<span class="cm"> * @tree: ematch tree to be deleted</span>
<span class="cm"> *</span>
<span class="cm"> * This functions destroys an ematch tree previously created by</span>
<span class="cm"> * tcf_em_tree_validate()/tcf_em_tree_change(). You must ensure that</span>
<span class="cm"> * the ematch tree is not in use before calling this function.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tcf_em_tree_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcf_proto</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcf_ematch_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">matches</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nmatches</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">tcf_ematch</span> <span class="o">*</span><span class="n">em</span> <span class="o">=</span> <span class="n">tcf_em_get_match</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">)</span>
				<span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">em</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcf_em_is_simple</span><span class="p">(</span><span class="n">em</span><span class="p">))</span>
				<span class="n">kfree</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
			<span class="n">module_put</span><span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tree</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nmatches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">matches</span><span class="p">);</span>
	<span class="n">tree</span><span class="o">-&gt;</span><span class="n">matches</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcf_em_tree_destroy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * tcf_em_tree_dump - dump ematch tree into a rtnl message</span>
<span class="cm"> *</span>
<span class="cm"> * @skb: skb holding the rtnl message</span>
<span class="cm"> * @t: ematch tree to be dumped</span>
<span class="cm"> * @tlv: TLV type to be used to encapsulate the tree</span>
<span class="cm"> *</span>
<span class="cm"> * This function dumps a ematch tree into a rtnl message. It is valid to</span>
<span class="cm"> * call this function while the ematch tree is in use.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -1 if the skb tailroom is insufficient.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tcf_em_tree_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcf_ematch_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tlv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">top_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">list_start</span><span class="p">;</span>

	<span class="n">top_start</span> <span class="o">=</span> <span class="n">nla_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">tlv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">top_start</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TCA_EMATCH_TREE_HDR</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>

	<span class="n">list_start</span> <span class="o">=</span> <span class="n">nla_nest_start</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">TCA_EMATCH_TREE_LIST</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_start</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>

	<span class="n">tail</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nmatches</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="n">match_start</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nlattr</span> <span class="o">*</span><span class="p">)</span><span class="n">tail</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">tcf_ematch</span> <span class="o">*</span><span class="n">em</span> <span class="o">=</span> <span class="n">tcf_em_get_match</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">tcf_ematch_hdr</span> <span class="n">em_hdr</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">?</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">kind</span> <span class="o">:</span> <span class="n">TCF_EM_CONTAINER</span><span class="p">,</span>
			<span class="p">.</span><span class="n">matchid</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">matchid</span><span class="p">,</span>
			<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span>
		<span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nla_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">em_hdr</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">em_hdr</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">em</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nla_put_failure</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcf_em_is_container</span><span class="p">(</span><span class="n">em</span><span class="p">)</span> <span class="o">||</span> <span class="n">tcf_em_is_simple</span><span class="p">(</span><span class="n">em</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">u</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">nla_put_nohdr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">datalen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">nla_put_nohdr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">datalen</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

		<span class="n">tail</span> <span class="o">=</span> <span class="n">skb_tail_pointer</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="n">match_start</span><span class="o">-&gt;</span><span class="n">nla_len</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">-</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">match_start</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nla_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">list_start</span><span class="p">);</span>
	<span class="n">nla_nest_end</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">top_start</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nla_put_failure:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcf_em_tree_dump</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tcf_em_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcf_ematch</span> <span class="o">*</span><span class="n">em</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">tcf_pkt_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">em</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tcf_em_is_inverted</span><span class="p">(</span><span class="n">em</span><span class="p">)</span> <span class="o">?</span> <span class="o">!</span><span class="n">r</span> <span class="o">:</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Do not use this function directly, use tcf_em_tree_match instead */</span>
<span class="kt">int</span> <span class="nf">__tcf_em_tree_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tcf_ematch_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">tcf_pkt_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">stackp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">match_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcf_ematch</span> <span class="o">*</span><span class="n">cur_match</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stack</span><span class="p">[</span><span class="n">CONFIG_NET_EMATCH_STACK</span><span class="p">];</span>

<span class="nl">proceed:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">match_idx</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">nmatches</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur_match</span> <span class="o">=</span> <span class="n">tcf_em_get_match</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">match_idx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcf_em_is_container</span><span class="p">(</span><span class="n">cur_match</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">stackp</span> <span class="o">&gt;=</span> <span class="n">CONFIG_NET_EMATCH_STACK</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">stack_overflow</span><span class="p">;</span>

			<span class="n">stack</span><span class="p">[</span><span class="n">stackp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_idx</span><span class="p">;</span>
			<span class="n">match_idx</span> <span class="o">=</span> <span class="n">cur_match</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">proceed</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">tcf_em_match</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">cur_match</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcf_em_early_end</span><span class="p">(</span><span class="n">cur_match</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">match_idx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">pop_stack:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stackp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">match_idx</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">--</span><span class="n">stackp</span><span class="p">];</span>
		<span class="n">cur_match</span> <span class="o">=</span> <span class="n">tcf_em_get_match</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">match_idx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcf_em_early_end</span><span class="p">(</span><span class="n">cur_match</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">pop_stack</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">match_idx</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">proceed</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>

<span class="nl">stack_overflow:</span>
	<span class="n">net_warn_ratelimited</span><span class="p">(</span><span class="s">&quot;tc ematch: local stack overflow, increase NET_EMATCH_STACK</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__tcf_em_tree_match</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
