<!DOCTYPE html>
<html><head><title>joekychen/linux » net › unix › garbage.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>garbage.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * NET3:	Garbage Collector For AF_UNIX sockets</span>
<span class="cm"> *</span>
<span class="cm"> * Garbage Collector:</span>
<span class="cm"> *	Copyright (C) Barak A. Pearlmutter.</span>
<span class="cm"> *	Released under the GPL version 2 or later.</span>
<span class="cm"> *</span>
<span class="cm"> * Chopped about by Alan Cox 22/3/96 to make it fit the AF_UNIX socket problem.</span>
<span class="cm"> * If it doesn&#39;t work blame me, it worked when Barak sent it.</span>
<span class="cm"> *</span>
<span class="cm"> * Assumptions:</span>
<span class="cm"> *</span>
<span class="cm"> *  - object w/ a bit</span>
<span class="cm"> *  - free list</span>
<span class="cm"> *</span>
<span class="cm"> * Current optimizations:</span>
<span class="cm"> *</span>
<span class="cm"> *  - explicit stack instead of recursion</span>
<span class="cm"> *  - tail recurse on first born instead of immediate push/pop</span>
<span class="cm"> *  - we gather the stuff that should not be killed into tree</span>
<span class="cm"> *    and stack is just a path from root to the current pointer.</span>
<span class="cm"> *</span>
<span class="cm"> *  Future optimizations:</span>
<span class="cm"> *</span>
<span class="cm"> *  - don&#39;t just push entire root set; process in place</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	as published by the Free Software Foundation; either version</span>
<span class="cm"> *	2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  Fixes:</span>
<span class="cm"> *	Alan Cox	07 Sept	1997	Vmalloc internal stack as needed.</span>
<span class="cm"> *					Cope with changing max_files.</span>
<span class="cm"> *	Al Viro		11 Oct 1998</span>
<span class="cm"> *		Graph may have cycles. That is, we can send the descriptor</span>
<span class="cm"> *		of foo to bar and vice versa. Current code chokes on that.</span>
<span class="cm"> *		Fix: move SCM_RIGHTS ones into the separate list and then</span>
<span class="cm"> *		skb_free() them all instead of doing explicit fput&#39;s.</span>
<span class="cm"> *		Another problem: since fput() may block somebody may</span>
<span class="cm"> *		create a new unix_socket when we are in the middle of sweep</span>
<span class="cm"> *		phase. Fix: revert the logic wrt MARKED. Mark everything</span>
<span class="cm"> *		upon the beginning and unmark non-junk ones.</span>
<span class="cm"> *</span>
<span class="cm"> *		[12 Oct 1998] AAARGH! New code purges all SCM_RIGHTS</span>
<span class="cm"> *		sent to connect()&#39;ed but still not accept()&#39;ed sockets.</span>
<span class="cm"> *		Fixed. Old code had slightly different problem here:</span>
<span class="cm"> *		extra fput() in situation when we passed the descriptor via</span>
<span class="cm"> *		such socket and closed it (descriptor). That would happen on</span>
<span class="cm"> *		each unix_gc() until the accept(). Since the struct file in</span>
<span class="cm"> *		question would go to the free list and might be reused...</span>
<span class="cm"> *		That might be the reason of random oopses on filp_close()</span>
<span class="cm"> *		in unrelated processes.</span>
<span class="cm"> *</span>
<span class="cm"> *	AV		28 Feb 1999</span>
<span class="cm"> *		Kill the explicit allocation of stack. Now we keep the tree</span>
<span class="cm"> *		with root in dummy + pointer (gc_current) to one of the nodes.</span>
<span class="cm"> *		Stack is represented as path from gc_current to dummy. Unmark</span>
<span class="cm"> *		now means &quot;add to tree&quot;. Push == &quot;make it a son of gc_current&quot;.</span>
<span class="cm"> *		Pop == &quot;move gc_current to parent&quot;. We keep only pointers to</span>
<span class="cm"> *		parents (-&gt;gc_tree).</span>
<span class="cm"> *	AV		1 Mar 1999</span>
<span class="cm"> *		Damn. Added missing check for -&gt;dead in listen queues scanning.</span>
<span class="cm"> *</span>
<span class="cm"> *	Miklos Szeredi 25 Jun 2007</span>
<span class="cm"> *		Reimplement with a cycle collecting algorithm. This should</span>
<span class="cm"> *		solve several problems with the previous code, like being racy</span>
<span class="cm"> *		wrt receive and holding up unrelated socket operations.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/un.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>

<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/af_unix.h&gt;</span>
<span class="cp">#include &lt;net/scm.h&gt;</span>
<span class="cp">#include &lt;net/tcp_states.h&gt;</span>

<span class="cm">/* Internal data structures and random procedures: */</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">gc_inflight_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">gc_candidates</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">unix_gc_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">unix_gc_wait</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unix_tot_inflight</span><span class="p">;</span>


<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">unix_get_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">u_sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Socket ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISSOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_PATH</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span> <span class="o">=</span> <span class="n">SOCKET_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	PF_UNIX ?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">family</span> <span class="o">==</span> <span class="n">PF_UNIX</span><span class="p">)</span>
			<span class="n">u_sock</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">u_sock</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Keep the number of times in flight count for the file</span>
<span class="cm"> *	descriptor if it is for an AF_UNIX socket.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">unix_inflight</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">unix_get_socket</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_gc_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_long_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">));</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_inflight_list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">unix_tot_inflight</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_gc_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unix_notinflight</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">unix_get_socket</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_gc_lock</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_long_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">))</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">unix_tot_inflight</span><span class="o">--</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_gc_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scan_inflight</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="p">),</span>
			  <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">hitlist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">skb_queue_walk_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Do we have file descriptors ?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bool</span> <span class="n">hit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 *	Process the descriptors of this socket</span>
<span class="cm">			 */</span>
			<span class="kt">int</span> <span class="n">nfd</span> <span class="o">=</span> <span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">file</span> <span class="o">**</span><span class="n">fp</span> <span class="o">=</span> <span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">nfd</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 *	Get the socket the fd matches</span>
<span class="cm">				 *	if it indeed does so</span>
<span class="cm">				 */</span>
				<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">unix_get_socket</span><span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="o">++</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

					<span class="cm">/*</span>
<span class="cm">					 * Ignore non-candidates, they could</span>
<span class="cm">					 * have been added to the queues after</span>
<span class="cm">					 * starting the garbage collection</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">gc_candidate</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">hit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
						<span class="n">func</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hit</span> <span class="o">&amp;&amp;</span> <span class="n">hitlist</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
				<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="n">hitlist</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scan_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="p">),</span>
			  <span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="o">*</span><span class="n">hitlist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
		<span class="n">scan_inflight</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">hitlist</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>
		<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">embryos</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * For a listening socket collect the queued embryos</span>
<span class="cm">		 * and perform a scan on them as well.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">skb_queue_walk_safe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * An embryo cannot be in-flight, so it&#39;s safe</span>
<span class="cm">			 * to use the list link.</span>
<span class="cm">			 */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">));</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">embryos</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">embryos</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">embryos</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">unix_sock</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
			<span class="n">scan_inflight</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">hitlist</span><span class="p">);</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dec_inflight</span><span class="p">(</span><span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">usk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usk</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inc_inflight</span><span class="p">(</span><span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">usk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usk</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inc_inflight_move_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this still might be part of a cycle, move it to the end</span>
<span class="cm">	 * of the list, so that it&#39;s checked even if it was already</span>
<span class="cm">	 * passed over</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">gc_maybe_cycle</span><span class="p">)</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_candidates</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">gc_in_progress</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="cp">#define UNIX_INFLIGHT_TRIGGER_GC 16000</span>

<span class="kt">void</span> <span class="nf">wait_for_unix_gc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If number of inflight sockets is insane,</span>
<span class="cm">	 * force a garbage collect right now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unix_tot_inflight</span> <span class="o">&gt;</span> <span class="n">UNIX_INFLIGHT_TRIGGER_GC</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">gc_in_progress</span><span class="p">)</span>
		<span class="n">unix_gc</span><span class="p">();</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">unix_gc_wait</span><span class="p">,</span> <span class="n">gc_in_progress</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* The external entry point: unix_gc() */</span>
<span class="kt">void</span> <span class="nf">unix_gc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff_head</span> <span class="n">hitlist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cursor</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">not_cycle_list</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_gc_lock</span><span class="p">);</span>

	<span class="cm">/* Avoid a recursive GC. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gc_in_progress</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">gc_in_progress</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * First, select candidates for garbage collection.  Only</span>
<span class="cm">	 * in-flight sockets are considered, and from those only ones</span>
<span class="cm">	 * which don&#39;t have any external reference.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Holding unix_gc_lock will protect these candidates from</span>
<span class="cm">	 * being detached, and hence from gaining an external</span>
<span class="cm">	 * reference.  Since there are no possible receivers, all</span>
<span class="cm">	 * buffers currently on the candidates&#39; queues stay there</span>
<span class="cm">	 * during the garbage collection.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We also know that no new candidate can be added onto the</span>
<span class="cm">	 * receive queues.  Other, non candidate sockets _can_ be</span>
<span class="cm">	 * added to queue, so we must make sure only to touch</span>
<span class="cm">	 * candidates.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_inflight_list</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">total_refs</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">inflight_refs</span><span class="p">;</span>

		<span class="n">total_refs</span> <span class="o">=</span> <span class="n">file_count</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">.</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
		<span class="n">inflight_refs</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">inflight_refs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">total_refs</span> <span class="o">&lt;</span> <span class="n">inflight_refs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_refs</span> <span class="o">==</span> <span class="n">inflight_refs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_candidates</span><span class="p">);</span>
			<span class="n">u</span><span class="o">-&gt;</span><span class="n">gc_candidate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">u</span><span class="o">-&gt;</span><span class="n">gc_maybe_cycle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now remove all internal in-flight reference to children of</span>
<span class="cm">	 * the candidates.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_candidates</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
		<span class="n">scan_children</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">dec_inflight</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Restore the references for children of all candidates,</span>
<span class="cm">	 * which have remaining references.  Do this recursively, so</span>
<span class="cm">	 * only those remain, which form cyclic references.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Use a &quot;cursor&quot; link, to make the list traversal safe, even</span>
<span class="cm">	 * though elements might be moved about.</span>
<span class="cm">	 */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_candidates</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cursor</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">gc_candidates</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cursor</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">unix_sock</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>

		<span class="cm">/* Move cursor to after the current position. */</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">not_cycle_list</span><span class="p">);</span>
			<span class="n">u</span><span class="o">-&gt;</span><span class="n">gc_maybe_cycle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">scan_children</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">inc_inflight_move_tail</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * not_cycle_list contains those sockets which do not make up a</span>
<span class="cm">	 * cycle.  Restore these to the inflight list.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">not_cycle_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">not_cycle_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">unix_sock</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">u</span><span class="o">-&gt;</span><span class="n">gc_candidate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_inflight_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now gc_candidates contains only garbage.  Restore original</span>
<span class="cm">	 * inflight counters for these as well, and remove the skbuffs</span>
<span class="cm">	 * which are creating the cycle(s).</span>
<span class="cm">	 */</span>
	<span class="n">skb_queue_head_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hitlist</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gc_candidates</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
	<span class="n">scan_children</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="n">inc_inflight</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hitlist</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_gc_lock</span><span class="p">);</span>

	<span class="cm">/* Here we are. Hitlist is filled. Die. */</span>
	<span class="n">__skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hitlist</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_gc_lock</span><span class="p">);</span>

	<span class="cm">/* All candidates should have been detached by now. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gc_candidates</span><span class="p">));</span>
	<span class="n">gc_in_progress</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_gc_wait</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_gc_lock</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
