<!DOCTYPE html>
<html><head><title>joekychen/linux » net › unix › af_unix.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>af_unix.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * NET4:	Implementation of BSD Unix domain sockets.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors:	Alan Cox, &lt;alan@lxorguk.ukuu.org.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *		This program is free software; you can redistribute it and/or</span>
<span class="cm"> *		modify it under the terms of the GNU General Public License</span>
<span class="cm"> *		as published by the Free Software Foundation; either version</span>
<span class="cm"> *		2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * Fixes:</span>
<span class="cm"> *		Linus Torvalds	:	Assorted bug cures.</span>
<span class="cm"> *		Niibe Yutaka	:	async I/O support.</span>
<span class="cm"> *		Carsten Paeth	:	PF_UNIX check, address fixes.</span>
<span class="cm"> *		Alan Cox	:	Limit size of allocated blocks.</span>
<span class="cm"> *		Alan Cox	:	Fixed the stupid socketpair bug.</span>
<span class="cm"> *		Alan Cox	:	BSD compatibility fine tuning.</span>
<span class="cm"> *		Alan Cox	:	Fixed a bug in connect when interrupted.</span>
<span class="cm"> *		Alan Cox	:	Sorted out a proper draft version of</span>
<span class="cm"> *					file descriptor passing hacked up from</span>
<span class="cm"> *					Mike Shaver&#39;s work.</span>
<span class="cm"> *		Marty Leisner	:	Fixes to fd passing</span>
<span class="cm"> *		Nick Nevin	:	recvmsg bugfix.</span>
<span class="cm"> *		Alan Cox	:	Started proper garbage collector</span>
<span class="cm"> *		Heiko EiBfeldt	:	Missing verify_area check</span>
<span class="cm"> *		Alan Cox	:	Started POSIXisms</span>
<span class="cm"> *		Andreas Schwab	:	Replace inode by dentry for proper</span>
<span class="cm"> *					reference counting</span>
<span class="cm"> *		Kirk Petersen	:	Made this a module</span>
<span class="cm"> *	    Christoph Rohland	:	Elegant non-blocking accept/connect algorithm.</span>
<span class="cm"> *					Lots of bug fixes.</span>
<span class="cm"> *	     Alexey Kuznetosv	:	Repaired (I hope) bugs introduces</span>
<span class="cm"> *					by above two patches.</span>
<span class="cm"> *	     Andrea Arcangeli	:	If possible we block in connect(2)</span>
<span class="cm"> *					if the max backlog of the listen socket</span>
<span class="cm"> *					is been reached. This won&#39;t break</span>
<span class="cm"> *					old apps and it will avoid huge amount</span>
<span class="cm"> *					of socks hashed (this for unix_gc()</span>
<span class="cm"> *					performances reasons).</span>
<span class="cm"> *					Security fix that limits the max</span>
<span class="cm"> *					number of socks to 2*max_files and</span>
<span class="cm"> *					the number of skb queueable in the</span>
<span class="cm"> *					dgram receiver.</span>
<span class="cm"> *		Artur Skawina   :	Hash function optimizations</span>
<span class="cm"> *	     Alexey Kuznetsov   :	Full scale SMP. Lot of bugs are introduced 8)</span>
<span class="cm"> *	      Malcolm Beattie   :	Set peercred for socketpair</span>
<span class="cm"> *	     Michal Ostrowski   :       Module initialization cleanup.</span>
<span class="cm"> *	     Arnaldo C. Melo	:	Remove MOD_{INC,DEC}_USE_COUNT,</span>
<span class="cm"> *	     				the core infrastructure is doing that</span>
<span class="cm"> *	     				for all net proto families now (2.5.69+)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Known differences from reference BSD that was tested:</span>
<span class="cm"> *</span>
<span class="cm"> *	[TO FIX]</span>
<span class="cm"> *	ECONNREFUSED is not returned from one end of a connected() socket to the</span>
<span class="cm"> *		other the moment one end closes.</span>
<span class="cm"> *	fstat() doesn&#39;t return st_dev=0, and give the blksize as high water mark</span>
<span class="cm"> *		and a fake inode identifier (nor the BSD first socket fstat twice bug).</span>
<span class="cm"> *	[NOT TO FIX]</span>
<span class="cm"> *	accept() returns a path name even if the connecting socket has closed</span>
<span class="cm"> *		in the meantime (BSD loses the path and gives up).</span>
<span class="cm"> *	accept() returns 0 length path for an unbound connector. BSD returns 16</span>
<span class="cm"> *		and a null first byte in the path (but not for gethost/peername - BSD bug ??)</span>
<span class="cm"> *	socketpair(...SOCK_RAW..) doesn&#39;t panic the kernel.</span>
<span class="cm"> *	BSD af_unix apparently has connect forgetting to block properly.</span>
<span class="cm"> *		(need to check this with the POSIX spec in detail)</span>
<span class="cm"> *</span>
<span class="cm"> * Differences from 2.0.0-11-... (ANK)</span>
<span class="cm"> *	Bug fixes and improvements.</span>
<span class="cm"> *		- client shutdown killed server socket.</span>
<span class="cm"> *		- removed all useless cli/sti pairs.</span>
<span class="cm"> *</span>
<span class="cm"> *	Semantic changes/extensions.</span>
<span class="cm"> *		- generic control message passing.</span>
<span class="cm"> *		- SCM_CREDENTIALS control message.</span>
<span class="cm"> *		- &quot;Abstract&quot; (not FS based) socket bindings.</span>
<span class="cm"> *		  Abstract names are sequences of bytes (not zero terminated)</span>
<span class="cm"> *		  started by 0, so that this name space does not intersect</span>
<span class="cm"> *		  with BSD names.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/dcache.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/un.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/termios.h&gt;</span>
<span class="cp">#include &lt;linux/sockios.h&gt;</span>
<span class="cp">#include &lt;linux/net.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/netdevice.h&gt;</span>
<span class="cp">#include &lt;net/net_namespace.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/tcp_states.h&gt;</span>
<span class="cp">#include &lt;net/af_unix.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;net/scm.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/rtnetlink.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;net/checksum.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>

<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">unix_socket_table</span><span class="p">[</span><span class="n">UNIX_HASH_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unix_socket_table</span><span class="p">);</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">unix_table_lock</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unix_table_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">atomic_long_t</span> <span class="n">unix_nr_socks</span><span class="p">;</span>

<span class="cp">#define unix_sockets_unbound	(&amp;unix_socket_table[UNIX_HASH_SIZE])</span>

<span class="cp">#define UNIX_ABSTRACT(sk)	(unix_sk(sk)-&gt;addr-&gt;hash != UNIX_HASH_SIZE)</span>

<span class="cp">#ifdef CONFIG_SECURITY_NETWORK</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unix_get_secdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">scm_cookie</span> <span class="o">*</span><span class="n">scm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">UNIXSID</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">secid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unix_set_secdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">scm_cookie</span> <span class="o">*</span><span class="n">scm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scm</span><span class="o">-&gt;</span><span class="n">secid</span> <span class="o">=</span> <span class="o">*</span><span class="n">UNIXSID</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unix_get_secdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">scm_cookie</span> <span class="o">*</span><span class="n">scm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unix_set_secdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">scm_cookie</span> <span class="o">*</span><span class="n">scm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SECURITY_NETWORK */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  SMP locking strategy:</span>
<span class="cm"> *    hash table is protected with spinlock unix_table_lock</span>
<span class="cm"> *    each socket state is protected by separate spin lock.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">unix_hash_fold</span><span class="p">(</span><span class="n">__wsum</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">__force</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">^=</span> <span class="n">hash</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">;</span>
	<span class="n">hash</span> <span class="o">^=</span> <span class="n">hash</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hash</span><span class="o">&amp;</span><span class="p">(</span><span class="n">UNIX_HASH_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define unix_peer(sk) (unix_sk(sk)-&gt;peer)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">unix_our_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">osk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unix_peer</span><span class="p">(</span><span class="n">osk</span><span class="p">)</span> <span class="o">==</span> <span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">unix_may_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">osk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unix_peer</span><span class="p">(</span><span class="n">osk</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">unix_our_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">osk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">unix_recvq_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="k">const</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">skb_queue_len</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">unix_peer_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">peer</span><span class="p">;</span>

	<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">peer</span> <span class="o">=</span> <span class="n">unix_peer</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="p">)</span>
		<span class="n">sock_hold</span><span class="p">(</span><span class="n">peer</span><span class="p">);</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">peer</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unix_peer_get</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unix_release_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">unix_address</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Check unix socket name:</span>
<span class="cm"> *		- should be not zero length.</span>
<span class="cm"> *	        - if started by not zero, should be NULL terminated (FS object)</span>
<span class="cm"> *		- if started by zero, it is abstract name.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_mkname</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sunaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">hashp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sunaddr</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sunaddr</span> <span class="o">||</span> <span class="n">sunaddr</span><span class="o">-&gt;</span><span class="n">sun_family</span> <span class="o">!=</span> <span class="n">AF_UNIX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sunaddr</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This may look like an off by one error but it is a bit more</span>
<span class="cm">		 * subtle. 108 is the longest valid AF_UNIX path for a binding.</span>
<span class="cm">		 * sun_path[108] doesn&#39;t as such exist.  However in kernel space</span>
<span class="cm">		 * we are guaranteed that it is a valid memory location in our</span>
<span class="cm">		 * kernel address buffer.</span>
<span class="cm">		 */</span>
		<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sunaddr</span><span class="p">)[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">sunaddr</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">hashp</span> <span class="o">=</span> <span class="n">unix_hash_fold</span><span class="p">(</span><span class="n">csum_partial</span><span class="p">(</span><span class="n">sunaddr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__unix_remove_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sk_del_node_init</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__unix_insert_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sk_unhashed</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="n">sk_add_node</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unix_remove_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
	<span class="n">__unix_remove_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unix_insert_socket</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
	<span class="n">__unix_insert_socket</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">__unix_find_socket_byname</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sunname</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">sk_for_each</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unix_socket_table</span><span class="p">[</span><span class="n">hash</span> <span class="o">^</span> <span class="n">type</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">net_eq</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">net</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">len</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sunname</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">unix_find_socket_byname</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sunname</span><span class="p">,</span>
						   <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
						   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">__unix_find_socket_byname</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunname</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span>
		<span class="n">sock_hold</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">unix_find_socket_byinode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
	<span class="n">sk_for_each</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span>
		    <span class="o">&amp;</span><span class="n">unix_socket_table</span><span class="p">[</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UNIX_HASH_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span> <span class="o">&amp;&amp;</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sock_hold</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">found:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">unix_writable</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unix_write_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unix_writable</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">wq</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wq_has_sleeper</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span>
			<span class="n">wake_up_interruptible_sync_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span>
				<span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span> <span class="o">|</span> <span class="n">POLLWRBAND</span><span class="p">);</span>
		<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_SPACE</span><span class="p">,</span> <span class="n">POLL_OUT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* When dgram socket disconnects (or changes its peer), we clear its receive</span>
<span class="cm"> * queue of packets arrived from previous peer. First, it allows to do</span>
<span class="cm"> * flow control based only on wmem_alloc; second, sk connected to peer</span>
<span class="cm"> * may receive messages only from that peer. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unix_dgram_disconnected</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="n">wake_up_interruptible_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">peer_wait</span><span class="p">);</span>

		<span class="cm">/* If one link of bidirectional dgram pipe is disconnected,</span>
<span class="cm">		 * we signal error. Messages are lost. Do not make this,</span>
<span class="cm">		 * when peer was not connected to us.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unix_peer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">ECONNRESET</span><span class="p">;</span>
			<span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_error_report</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unix_sock_destructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">skb_queue_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wmem_alloc</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sk_unhashed</span><span class="p">(</span><span class="n">sk</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Attempt to release alive unix socket: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="n">unix_release_addr</span><span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>

	<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_nr_socks</span><span class="p">);</span>
	<span class="n">local_bh_disable</span><span class="p">();</span>
	<span class="n">sock_prot_inuse_add</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">local_bh_enable</span><span class="p">();</span>
<span class="cp">#ifdef UNIX_REFCNT_DEBUG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;UNIX %p is destroyed, %ld are still alive.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span>
		<span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_nr_socks</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_release_sock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">embrion</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">skpair</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">state</span><span class="p">;</span>

	<span class="n">unix_remove_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Clear state */</span>
	<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sock_orphan</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">=</span> <span class="n">SHUTDOWN_MASK</span><span class="p">;</span>
	<span class="n">path</span>	     <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">;</span>
	<span class="n">u</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">TCP_CLOSE</span><span class="p">;</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">wake_up_interruptible_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">peer_wait</span><span class="p">);</span>

	<span class="n">skpair</span> <span class="o">=</span> <span class="n">unix_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skpair</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">skpair</span><span class="p">);</span>
			<span class="cm">/* No more writes */</span>
			<span class="n">skpair</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">=</span> <span class="n">SHUTDOWN_MASK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)</span> <span class="o">||</span> <span class="n">embrion</span><span class="p">)</span>
				<span class="n">skpair</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">ECONNRESET</span><span class="p">;</span>
			<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">skpair</span><span class="p">);</span>
			<span class="n">skpair</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">skpair</span><span class="p">);</span>
			<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">skpair</span><span class="p">,</span> <span class="n">SOCK_WAKE_WAITD</span><span class="p">,</span> <span class="n">POLL_HUP</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">skpair</span><span class="p">);</span> <span class="cm">/* It may now die */</span>
		<span class="n">unix_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Try to flush out this socket. Throw out buffers at least */</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
			<span class="n">unix_release_sock</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* passed fds are erased in the kfree_skb hook	      */</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">)</span>
		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* ---- Socket is dead now and most probably destroyed ---- */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fixme: BSD difference: In BSD all sockets connected to use get</span>
<span class="cm">	 *	  ECONNRESET and we die on the spot. In Linux we behave</span>
<span class="cm">	 *	  like files and pipes do and wait for the last</span>
<span class="cm">	 *	  dereference.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Can&#39;t we simply set sock-&gt;err?</span>
<span class="cm">	 *</span>
<span class="cm">	 *	  What the above comment does talk about? --ANK(980817)</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unix_tot_inflight</span><span class="p">)</span>
		<span class="n">unix_gc</span><span class="p">();</span>		<span class="cm">/* Garbage collect fds */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_peercred</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_cred</span><span class="p">)</span>
		<span class="n">put_cred</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_cred</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_pid</span>  <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">task_tgid</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_cred</span> <span class="o">=</span> <span class="n">get_current_cred</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_peercred</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">peersk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_cred</span><span class="p">)</span>
		<span class="n">put_cred</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_cred</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_pid</span>  <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">peersk</span><span class="o">-&gt;</span><span class="n">sk_peer_pid</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peer_cred</span> <span class="o">=</span> <span class="n">get_cred</span><span class="p">(</span><span class="n">peersk</span><span class="o">-&gt;</span><span class="n">sk_peer_cred</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_listen</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">old_pid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">old_cred</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SOCK_STREAM</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>	<span class="cm">/* Only stream/seqpacket sockets accept */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>	<span class="cm">/* No listens on an unbound socket */</span>
	<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_CLOSE</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">backlog</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span><span class="p">)</span>
		<span class="n">wake_up_interruptible_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">peer_wait</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span>	<span class="o">=</span> <span class="n">backlog</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>		<span class="o">=</span> <span class="n">TCP_LISTEN</span><span class="p">;</span>
	<span class="cm">/* set credentials so connect can copy them */</span>
	<span class="n">init_peercred</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">put_pid</span><span class="p">(</span><span class="n">old_pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_cred</span><span class="p">)</span>
		<span class="n">put_cred</span><span class="p">(</span><span class="n">old_cred</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_stream_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">addr_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_socketpair</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_getname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unix_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">unix_dgram_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
				    <span class="n">poll_table</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_stream_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_stream_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_dgram_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_dgram_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_dgram_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">,</span>
			      <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_seqpacket_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">unix_seqpacket_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unix_set_peek_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_peek_off</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">unix_stream_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>	<span class="n">PF_UNIX</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">unix_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span> <span class="o">=</span>		<span class="n">unix_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span> <span class="o">=</span>	<span class="n">unix_stream_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span> <span class="o">=</span>	<span class="n">unix_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span> <span class="o">=</span>	<span class="n">unix_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span> <span class="o">=</span>	<span class="n">unix_getname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span>		<span class="n">unix_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">unix_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listen</span> <span class="o">=</span>	<span class="n">unix_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span>	<span class="n">unix_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span> <span class="o">=</span>	<span class="n">sock_no_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span> <span class="o">=</span>	<span class="n">sock_no_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span> <span class="o">=</span>	<span class="n">unix_stream_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span> <span class="o">=</span>	<span class="n">unix_stream_recvmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span> <span class="o">=</span>	<span class="n">sock_no_sendpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_peek_off</span> <span class="o">=</span>	<span class="n">unix_set_peek_off</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">unix_dgram_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>	<span class="n">PF_UNIX</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">unix_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span> <span class="o">=</span>		<span class="n">unix_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span> <span class="o">=</span>	<span class="n">unix_dgram_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span> <span class="o">=</span>	<span class="n">unix_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span> <span class="o">=</span>	<span class="n">sock_no_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span> <span class="o">=</span>	<span class="n">unix_getname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span>		<span class="n">unix_dgram_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">unix_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listen</span> <span class="o">=</span>	<span class="n">sock_no_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span>	<span class="n">unix_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span> <span class="o">=</span>	<span class="n">sock_no_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span> <span class="o">=</span>	<span class="n">sock_no_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span> <span class="o">=</span>	<span class="n">unix_dgram_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span> <span class="o">=</span>	<span class="n">unix_dgram_recvmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span> <span class="o">=</span>	<span class="n">sock_no_sendpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_peek_off</span> <span class="o">=</span>	<span class="n">unix_set_peek_off</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span> <span class="n">unix_seqpacket_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span>	<span class="n">PF_UNIX</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span>	<span class="n">unix_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bind</span> <span class="o">=</span>		<span class="n">unix_bind</span><span class="p">,</span>
	<span class="p">.</span><span class="n">connect</span> <span class="o">=</span>	<span class="n">unix_stream_connect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">socketpair</span> <span class="o">=</span>	<span class="n">unix_socketpair</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accept</span> <span class="o">=</span>	<span class="n">unix_accept</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getname</span> <span class="o">=</span>	<span class="n">unix_getname</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span>		<span class="n">unix_dgram_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ioctl</span> <span class="o">=</span>	<span class="n">unix_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listen</span> <span class="o">=</span>	<span class="n">unix_listen</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span>	<span class="n">unix_shutdown</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setsockopt</span> <span class="o">=</span>	<span class="n">sock_no_setsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getsockopt</span> <span class="o">=</span>	<span class="n">sock_no_getsockopt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendmsg</span> <span class="o">=</span>	<span class="n">unix_seqpacket_sendmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">recvmsg</span> <span class="o">=</span>	<span class="n">unix_seqpacket_recvmsg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span>		<span class="n">sock_no_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sendpage</span> <span class="o">=</span>	<span class="n">sock_no_sendpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_peek_off</span> <span class="o">=</span>	<span class="n">unix_set_peek_off</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proto</span> <span class="n">unix_proto</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;UNIX&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">obj_size</span>		<span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">unix_sock</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * AF_UNIX sockets do not interact with hardware, hence they</span>
<span class="cm"> * dont trigger interrupts - so it&#39;s safe for them to have</span>
<span class="cm"> * bh-unsafe locking for their sk_receive_queue.lock. Split off</span>
<span class="cm"> * this special lock-class by reinitializing the spinlock key:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">af_unix_sk_receive_queue_lock_key</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">unix_create1</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>

	<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_nr_socks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_nr_socks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">get_max_files</span><span class="p">())</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sk</span> <span class="o">=</span> <span class="n">sk_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">PF_UNIX</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unix_proto</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">sock_init_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">lockdep_set_class</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">af_unix_sk_receive_queue_lock_key</span><span class="p">);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_space</span>	<span class="o">=</span> <span class="n">unix_write_space</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_max_ack_backlog</span>	<span class="o">=</span> <span class="n">net</span><span class="o">-&gt;</span><span class="n">unx</span><span class="p">.</span><span class="n">sysctl_max_dgram_qlen</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span>		<span class="o">=</span> <span class="n">unix_sock_destructor</span><span class="p">;</span>
	<span class="n">u</span>	  <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">atomic_long_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">inflight</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span> <span class="cm">/* single task reading lock */</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">peer_wait</span><span class="p">);</span>
	<span class="n">unix_insert_socket</span><span class="p">(</span><span class="n">unix_sockets_unbound</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_nr_socks</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">local_bh_disable</span><span class="p">();</span>
		<span class="n">sock_prot_inuse_add</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">local_bh_enable</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">protocol</span> <span class="o">&amp;&amp;</span> <span class="n">protocol</span> <span class="o">!=</span> <span class="n">PF_UNIX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTONOSUPPORT</span><span class="p">;</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_UNCONNECTED</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SOCK_STREAM</span>:
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">unix_stream_ops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Believe it or not BSD has AF_UNIX, SOCK_RAW though</span>
<span class="cm">		 *	nothing uses it.</span>
<span class="cm">		 */</span>
	<span class="k">case</span> <span class="n">SOCK_RAW</span>:
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">SOCK_DGRAM</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_DGRAM</span>:
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">unix_dgram_ops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SOCK_SEQPACKET</span>:
		<span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">unix_seqpacket_ops</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ESOCKTNOSUPPORT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">unix_create1</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">unix_release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_autobind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">static</span> <span class="n">u32</span> <span class="n">ordernum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unix_address</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">sun_family</span> <span class="o">=</span> <span class="n">AF_UNIX</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%05x&quot;</span><span class="p">,</span> <span class="n">ordernum</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">);</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">unix_hash_fold</span><span class="p">(</span><span class="n">csum_partial</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
	<span class="n">ordernum</span> <span class="o">=</span> <span class="p">(</span><span class="n">ordernum</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xFFFFF</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__unix_find_socket_byname</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
				      <span class="n">addr</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * __unix_find_socket_byname() may take long time if many names</span>
<span class="cm">		 * are already in use.</span>
<span class="cm">		 */</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="cm">/* Give up if all names seems to be in use. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retries</span><span class="o">++</span> <span class="o">==</span> <span class="mh">0xFFFFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">^=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">;</span>

	<span class="n">__unix_remove_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">__unix_insert_socket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_socket_table</span><span class="p">[</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">],</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">unix_find_other</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sunname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sunname</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">kern_path</span><span class="p">(</span><span class="n">sunname</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="p">,</span> <span class="n">LOOKUP_FOLLOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">MAY_WRITE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">put_fail</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISSOCK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">put_fail</span><span class="p">;</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">unix_find_socket_byinode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">u</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">put_fail</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
			<span class="n">touch_atime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

		<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPROTOTYPE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sock_put</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">unix_find_socket_byname</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunname</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span>
				<span class="n">touch_atime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_sk</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">u</span><span class="p">;</span>

<span class="nl">put_fail:</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_bind</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sunaddr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="p">)</span><span class="n">uaddr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sun_path</span> <span class="o">=</span> <span class="n">sunaddr</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unix_address</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sunaddr</span><span class="o">-&gt;</span><span class="n">sun_family</span> <span class="o">!=</span> <span class="n">AF_UNIX</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr_len</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">unix_autobind</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">unix_mkname</span><span class="p">(</span><span class="n">sunaddr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">addr_len</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">addr</span><span class="p">)</span><span class="o">+</span><span class="n">addr_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sunaddr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">);</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">addr_len</span><span class="p">;</span>
	<span class="n">addr</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">^</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sun_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">umode_t</span> <span class="n">mode</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get the parent directory, calculate the hash for last</span>
<span class="cm">		 * component.</span>
<span class="cm">		 */</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">kern_path_create</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span> <span class="n">sun_path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_mknod_parent</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * All right, let&#39;s create it.</span>
<span class="cm">		 */</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">S_IFSOCK</span> <span class="o">|</span>
		       <span class="p">(</span><span class="n">SOCK_INODE</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">current_umask</span><span class="p">());</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_mknod_dput</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">security_path_mknod</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_mknod_drop_write</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">vfs_mknod</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out_mknod_drop_write:</span>
		<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_mknod_dput</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">path</span><span class="p">.</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>

		<span class="n">addr</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">UNIX_HASH_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sun_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__unix_find_socket_byname</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunaddr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span>
					      <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">,</span> <span class="n">hash</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">unix_release_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">unix_socket_table</span><span class="p">[</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">unix_socket_table</span><span class="p">[</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">UNIX_HASH_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)];</span>
		<span class="n">u</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__unix_remove_socket</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">__unix_insert_socket</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
<span class="nl">out_up:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">out_mknod_dput:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">path_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">path</span><span class="p">);</span>
<span class="nl">out_mknod_parent:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EADDRINUSE</span><span class="p">;</span>
	<span class="n">unix_release_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_up</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unix_state_double_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sk1</span> <span class="o">==</span> <span class="n">sk2</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">sk2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk1</span> <span class="o">&lt;</span> <span class="n">sk2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk1</span><span class="p">);</span>
		<span class="n">unix_state_lock_nested</span><span class="p">(</span><span class="n">sk2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk2</span><span class="p">);</span>
		<span class="n">unix_state_lock_nested</span><span class="p">(</span><span class="n">sk1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unix_state_double_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sk1</span> <span class="o">==</span> <span class="n">sk2</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">sk2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk1</span><span class="p">);</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_dgram_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">alen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sunaddr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">AF_UNSPEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">unix_mkname</span><span class="p">(</span><span class="n">sunaddr</span><span class="p">,</span> <span class="n">alen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">alen</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_PASSCRED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">err</span> <span class="o">=</span> <span class="n">unix_autobind</span><span class="p">(</span><span class="n">sock</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">restart:</span>
		<span class="n">other</span> <span class="o">=</span> <span class="n">unix_find_other</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunaddr</span><span class="p">,</span> <span class="n">alen</span><span class="p">,</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">other</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">unix_state_double_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>

		<span class="cm">/* Apparently VFS overslept socket death. Retry. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">unix_state_double_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
			<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unix_may_send</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">security_unix_may_send</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">,</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	1003.1g breaking connected state with AF_UNSPEC</span>
<span class="cm">		 */</span>
		<span class="n">other</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">unix_state_double_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If it was connected, reconnect.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unix_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">old_peer</span> <span class="o">=</span> <span class="n">unix_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">unix_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span>
		<span class="n">unix_state_double_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="o">!=</span> <span class="n">old_peer</span><span class="p">)</span>
			<span class="n">unix_dgram_disconnected</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">old_peer</span><span class="p">);</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">old_peer</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">unix_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span>
		<span class="n">unix_state_double_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">unix_state_double_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">unix_wait_for_peer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sched</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">prepare_to_wait_exclusive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">peer_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

	<span class="n">sched</span> <span class="o">=</span> <span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">unix_recvq_full</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>

	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sched</span><span class="p">)</span>
		<span class="n">timeo</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>

	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">peer_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">timeo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_stream_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">addr_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sunaddr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="p">)</span><span class="n">uaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">*</span><span class="n">newu</span><span class="p">,</span> <span class="o">*</span><span class="n">otheru</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">newsk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">st</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">unix_mkname</span><span class="p">(</span><span class="n">sunaddr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">addr_len</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_PASSCRED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">err</span> <span class="o">=</span> <span class="n">unix_autobind</span><span class="p">(</span><span class="n">sock</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>

	<span class="cm">/* First of all allocate resources.</span>
<span class="cm">	   If we will make it after state is locked,</span>
<span class="cm">	   we will have to recheck all again in any case.</span>
<span class="cm">	 */</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* create new sock for complete connection */</span>
	<span class="n">newsk</span> <span class="o">=</span> <span class="n">unix_create1</span><span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsk</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Allocate skb for sending to listening sock */</span>
	<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_wmalloc</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="cm">/*  Find listening sock. */</span>
	<span class="n">other</span> <span class="o">=</span> <span class="n">unix_find_other</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunaddr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">other</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Latch state of peer */</span>
	<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>

	<span class="cm">/* Apparently VFS overslept socket death. Retry. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unix_recvq_full</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

		<span class="n">timeo</span> <span class="o">=</span> <span class="n">unix_wait_for_peer</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">timeo</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Latch our state.</span>

<span class="cm">	   It is tricky place. We need to grab our state lock and cannot</span>
<span class="cm">	   drop lock on peer. It is dangerous because deadlock is</span>
<span class="cm">	   possible. Connect to self case and simultaneous</span>
<span class="cm">	   attempt to connect are eliminated by checking socket</span>
<span class="cm">	   state. other is TCP_LISTEN, if sk is TCP_LISTEN we</span>
<span class="cm">	   check this before attempt to grab lock.</span>

<span class="cm">	   Well, and we have to recheck the state after socket locked.</span>
<span class="cm">	 */</span>
	<span class="n">st</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">TCP_CLOSE</span>:
		<span class="cm">/* This is ok... continue with connect */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">TCP_ESTABLISHED</span>:
		<span class="cm">/* Socket is already connected */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">unix_state_lock_nested</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">st</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">security_unix_stream_connect</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">newsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The way is open! Fastly set all the necessary fields... */</span>

	<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">unix_peer</span><span class="p">(</span><span class="n">newsk</span><span class="p">)</span>	<span class="o">=</span> <span class="n">sk</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_state</span>		<span class="o">=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">;</span>
	<span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_type</span>		<span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">;</span>
	<span class="n">init_peercred</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
	<span class="n">newu</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>
	<span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">newsk</span><span class="o">-&gt;</span><span class="n">sk_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newu</span><span class="o">-&gt;</span><span class="n">peer_wq</span><span class="p">);</span>
	<span class="n">otheru</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>

	<span class="cm">/* copy address information from listening to new sock*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">otheru</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">otheru</span><span class="o">-&gt;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
		<span class="n">newu</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">otheru</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">otheru</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">.</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">otheru</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="n">newu</span><span class="o">-&gt;</span><span class="n">path</span> <span class="o">=</span> <span class="n">otheru</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Set credentials */</span>
	<span class="n">copy_peercred</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>

	<span class="n">sock</span><span class="o">-&gt;</span><span class="n">state</span>	<span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span>	<span class="o">=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">;</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="n">newsk</span><span class="p">);</span>

	<span class="n">smp_mb__after_atomic_inc</span><span class="p">();</span>	<span class="cm">/* sock_hold() does an atomic_inc() */</span>
	<span class="n">unix_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span>	<span class="o">=</span> <span class="n">newsk</span><span class="p">;</span>

	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* take ten and and send info to listening sock */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">)</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsk</span><span class="p">)</span>
		<span class="n">unix_release_sock</span><span class="p">(</span><span class="n">newsk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">)</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_socketpair</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">socka</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sockb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">ska</span> <span class="o">=</span> <span class="n">socka</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">sockb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="cm">/* Join our sockets back to back */</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="n">ska</span><span class="p">);</span>
	<span class="n">sock_hold</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">unix_peer</span><span class="p">(</span><span class="n">ska</span><span class="p">)</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="n">unix_peer</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span> <span class="o">=</span> <span class="n">ska</span><span class="p">;</span>
	<span class="n">init_peercred</span><span class="p">(</span><span class="n">ska</span><span class="p">);</span>
	<span class="n">init_peercred</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ska</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_DGRAM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ska</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">;</span>
		<span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">;</span>
		<span class="n">socka</span><span class="o">-&gt;</span><span class="n">state</span>  <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>
		<span class="n">sockb</span><span class="o">-&gt;</span><span class="n">state</span>  <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SOCK_STREAM</span> <span class="o">&amp;&amp;</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* If socket state is TCP_LISTEN it cannot change (for now...),</span>
<span class="cm">	 * so that no locks are necessary.</span>
<span class="cm">	 */</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_recv_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="o">&amp;</span><span class="n">O_NONBLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This means receive shutdown. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tsk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="n">skb_free_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">peer_wait</span><span class="p">);</span>

	<span class="cm">/* attach accepted sock to socket */</span>
	<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">newsock</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SS_CONNECTED</span><span class="p">;</span>
	<span class="n">sock_graft</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">newsock</span><span class="p">);</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_getname</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">uaddr_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">peer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span><span class="p">;</span>
	<span class="n">DECLARE_SOCKADDR</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="p">,</span> <span class="n">sunaddr</span><span class="p">,</span> <span class="n">uaddr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">peer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sk</span> <span class="o">=</span> <span class="n">unix_peer_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sock_hold</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sunaddr</span><span class="o">-&gt;</span><span class="n">sun_family</span> <span class="o">=</span> <span class="n">AF_UNIX</span><span class="p">;</span>
		<span class="n">sunaddr</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">uaddr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">unix_address</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>

		<span class="o">*</span><span class="n">uaddr_len</span> <span class="o">=</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">sunaddr</span><span class="p">,</span> <span class="n">addr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">uaddr_len</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unix_detach_fds</span><span class="p">(</span><span class="k">struct</span> <span class="n">scm_cookie</span> <span class="o">*</span><span class="n">scm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">=</span> <span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="p">;</span>
	<span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">unix_notinflight</span><span class="p">(</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unix_destruct_scm</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scm_cookie</span> <span class="n">scm</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scm</span><span class="p">));</span>
	<span class="n">scm</span><span class="p">.</span><span class="n">pid</span>  <span class="o">=</span> <span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">;</span>
	<span class="n">scm</span><span class="p">.</span><span class="n">cred</span> <span class="o">=</span> <span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">cred</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="p">)</span>
		<span class="n">unix_detach_fds</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scm</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* Alas, it calls VFS */</span>
	<span class="cm">/* So fscking what? fput() had been SMP-safe since the last Summer */</span>
	<span class="n">scm_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scm</span><span class="p">);</span>
	<span class="n">sock_wfree</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define MAX_RECURSION_LEVEL 4</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_attach_fds</span><span class="p">(</span><span class="k">struct</span> <span class="n">scm_cookie</span> <span class="o">*</span><span class="n">scm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">max_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unix_sock_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">unix_get_socket</span><span class="p">(</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unix_sock_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">max_level</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_level</span><span class="p">,</span>
					<span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">recursion_level</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">max_level</span> <span class="o">&gt;</span> <span class="n">MAX_RECURSION_LEVEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ETOOMANYREFS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Need to duplicate file references for the sake of garbage</span>
<span class="cm">	 * collection.  Otherwise a socket in the fps might become a</span>
<span class="cm">	 * candidate for GC while the skb is not yet queued.</span>
<span class="cm">	 */</span>
	<span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span> <span class="o">=</span> <span class="n">scm_fp_dup</span><span class="p">(</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unix_sock_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
			<span class="n">unix_inflight</span><span class="p">(</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">max_level</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_scm_to_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">scm_cookie</span> <span class="o">*</span><span class="n">scm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="n">bool</span> <span class="n">send_fds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span>  <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">)</span>
		<span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">cred</span> <span class="o">=</span> <span class="n">get_cred</span><span class="p">(</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">&amp;&amp;</span> <span class="n">send_fds</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">unix_attach_fds</span><span class="p">(</span><span class="n">scm</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">destructor</span> <span class="o">=</span> <span class="n">unix_destruct_scm</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Some apps rely on write() giving SCM_CREDENTIALS</span>
<span class="cm"> * We include credentials if source or destination socket</span>
<span class="cm"> * asserted SOCK_PASSCRED.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">maybe_add_creds</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">cred</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_PASSCRED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_socket</span> <span class="o">||</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_PASSCRED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span>  <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">task_tgid</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>
		<span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">cred</span> <span class="o">=</span> <span class="n">get_current_cred</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Send AF_UNIX data.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_dgram_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="o">*</span><span class="n">siocb</span> <span class="o">=</span> <span class="n">kiocb_to_siocb</span><span class="p">(</span><span class="n">kiocb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span> <span class="o">=</span> <span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sunaddr</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* fake GCC */</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scm_cookie</span> <span class="n">tmp_scm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">data_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">)</span>
		<span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp_scm</span><span class="p">;</span>
	<span class="n">wait_for_unix_gc</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">scm_send</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="o">&amp;</span><span class="n">MSG_OOB</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">unix_mkname</span><span class="p">(</span><span class="n">sunaddr</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">namelen</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sunaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="n">other</span> <span class="o">=</span> <span class="n">unix_peer_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">other</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">SOCK_PASSCRED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span>
	    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">err</span> <span class="o">=</span> <span class="n">unix_autobind</span><span class="p">(</span><span class="n">sock</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">SKB_MAX_ALLOC</span><span class="p">)</span>
		<span class="n">data_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span>
				 <span class="n">len</span> <span class="o">-</span> <span class="n">SKB_MAX_ALLOC</span><span class="p">,</span>
				 <span class="n">MAX_SKB_FRAGS</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_alloc_send_pskb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">data_len</span><span class="p">,</span> <span class="n">data_len</span><span class="p">,</span>
				   <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">unix_scm_to_skb</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="n">max_level</span> <span class="o">=</span> <span class="n">err</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">unix_get_secdata</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">data_len</span><span class="p">);</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">skb_copy_datagram_from_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_sndtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>

<span class="nl">restart:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNRESET</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sunaddr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="n">other</span> <span class="o">=</span> <span class="n">unix_find_other</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sunaddr</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">,</span>
					<span class="n">hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk_filter</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Toss the packet but do not return any error to the sender */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unix_may_send</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Check with 1003.1g - what should</span>
<span class="cm">		 *	datagram error</span>
<span class="cm">		 */</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unix_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unix_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

			<span class="n">unix_dgram_disconnected</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
			<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECONNREFUSED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">other</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">!=</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">security_unix_may_send</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">,</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unix_peer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sk</span> <span class="o">&amp;&amp;</span> <span class="n">unix_recvq_full</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">timeo</span> <span class="o">=</span> <span class="n">unix_wait_for_peer</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">timeo</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMP</span><span class="p">))</span>
		<span class="n">__net_timestamp</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">maybe_add_creds</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
	<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_level</span> <span class="o">&gt;</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">recursion_level</span><span class="p">)</span>
		<span class="n">unix_sk</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">recursion_level</span> <span class="o">=</span> <span class="n">max_level</span><span class="p">;</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="n">scm_destroy</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">)</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="n">scm_destroy</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_stream_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="o">*</span><span class="n">siocb</span> <span class="o">=</span> <span class="n">kiocb_to_siocb</span><span class="p">(</span><span class="n">kiocb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scm_cookie</span> <span class="n">tmp_scm</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fds_sent</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_level</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">)</span>
		<span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp_scm</span><span class="p">;</span>
	<span class="n">wait_for_unix_gc</span><span class="p">();</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">scm_send</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="o">&amp;</span><span class="n">MSG_OOB</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_ESTABLISHED</span> <span class="o">?</span> <span class="o">-</span><span class="n">EISCONN</span> <span class="o">:</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="n">other</span> <span class="o">=</span> <span class="n">unix_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">other</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">pipe_err</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sent</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *	Optimisation for the fact that under 0.01% of X</span>
<span class="cm">		 *	messages typically need breaking up.</span>
<span class="cm">		 */</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">len</span><span class="o">-</span><span class="n">sent</span><span class="p">;</span>

		<span class="cm">/* Keep two messages in the pipe so it schedules better */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">64</span><span class="p">))</span>
			<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sndbuf</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">64</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">SKB_MAX_ALLOC</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">SKB_MAX_ALLOC</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	Grab a buffer</span>
<span class="cm">		 */</span>

		<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_alloc_send_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="o">&amp;</span><span class="n">MSG_DONTWAIT</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *	If you pass two values to the sock_alloc_send_skb</span>
<span class="cm">		 *	it tries to grab the large buffer with GFP_NOFS</span>
<span class="cm">		 *	(which can fail easily), and if it fails grab the</span>
<span class="cm">		 *	fallback size buffer which is under a page and will</span>
<span class="cm">		 *	succeed. [Alan]</span>
<span class="cm">		 */</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">skb_tailroom</span><span class="p">(</span><span class="n">skb</span><span class="p">));</span>


		<span class="cm">/* Only send the fds in the first buffer */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">unix_scm_to_skb</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">!</span><span class="n">fds_sent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">max_level</span> <span class="o">=</span> <span class="n">err</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">fds_sent</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">memcpy_fromiovec</span><span class="p">(</span><span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">pipe_err_free</span><span class="p">;</span>

		<span class="n">maybe_add_creds</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
		<span class="n">skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max_level</span> <span class="o">&gt;</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">recursion_level</span><span class="p">)</span>
			<span class="n">unix_sk</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">recursion_level</span> <span class="o">=</span> <span class="n">max_level</span><span class="p">;</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">sent</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scm_destroy</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">);</span>
	<span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sent</span><span class="p">;</span>

<span class="nl">pipe_err_free:</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="nl">pipe_err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sent</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span><span class="o">&amp;</span><span class="n">MSG_NOSIGNAL</span><span class="p">))</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">scm_destroy</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">);</span>
	<span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sent</span> <span class="o">?</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_seqpacket_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">kiocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span><span class="p">)</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">unix_dgram_sendmsg</span><span class="p">(</span><span class="n">kiocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_seqpacket_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">unix_dgram_recvmsg</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unix_copy_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">,</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_dgram_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="o">*</span><span class="n">siocb</span> <span class="o">=</span> <span class="n">kiocb_to_siocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scm_cookie</span> <span class="n">tmp_scm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">noblock</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">peeked</span><span class="p">,</span> <span class="n">skip</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="o">&amp;</span><span class="n">MSG_OOB</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">sock_rcvtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">noblock</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skip</span> <span class="o">=</span> <span class="n">sk_peek_offset</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">__skb_recv_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">peeked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skip</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="cm">/* Signal EOF on disconnected non-blocking SEQPACKET socket. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_SEQPACKET</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wake_up_interruptible_sync_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">peer_wait</span><span class="p">,</span>
					<span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span> <span class="o">|</span> <span class="n">POLLWRBAND</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">)</span>
		<span class="n">unix_copy_addr</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skip</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skip</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skip</span><span class="p">)</span>
		<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_flags</span> <span class="o">|=</span> <span class="n">MSG_TRUNC</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">skb_copy_datagram_iovec</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skip</span><span class="p">,</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_RCVTSTAMP</span><span class="p">))</span>
		<span class="n">__sock_recv_timestamp</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp_scm</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_scm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp_scm</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">scm_set_cred</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span> <span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">,</span> <span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">cred</span><span class="p">);</span>
	<span class="n">unix_set_secdata</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="p">)</span>
			<span class="n">unix_detach_fds</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="n">sk_peek_offset_bwd</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* It is questionable: on PEEK we could:</span>
<span class="cm">		   - do not return fds - good, but too simple 8)</span>
<span class="cm">		   - return fds, and do not return them on read (old strategy,</span>
<span class="cm">		     apparently wrong)</span>
<span class="cm">		   - clone fds (I chose it for now, it is the most universal</span>
<span class="cm">		     solution)</span>

<span class="cm">		   POSIX 1003.1g does not actually define this clearly</span>
<span class="cm">		   at all. POSIX 1003.1g doesn&#39;t define a lot of things</span>
<span class="cm">		   clearly however!</span>

<span class="cm">		*/</span>

		<span class="n">sk_peek_offset_fwd</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="p">)</span>
			<span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">=</span> <span class="n">scm_fp_dup</span><span class="p">(</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_TRUNC</span><span class="p">)</span> <span class="o">?</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skip</span> <span class="o">:</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">scm_recv</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">out_free:</span>
	<span class="n">skb_free_datagram</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Sleep until data has arrive. But check for races..</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">unix_stream_data_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">timeo</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_WAITDATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">timeo</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
		<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_WAITDATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">finish_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">timeo</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_stream_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock_iocb</span> <span class="o">*</span><span class="n">siocb</span> <span class="o">=</span> <span class="n">kiocb_to_siocb</span><span class="p">(</span><span class="n">iocb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scm_cookie</span> <span class="n">tmp_scm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr_un</span> <span class="o">*</span><span class="n">sunaddr</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">check_creds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">target</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">timeo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skip</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="o">&amp;</span><span class="n">MSG_OOB</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">target</span> <span class="o">=</span> <span class="n">sock_rcvlowat</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="o">&amp;</span><span class="n">MSG_WAITALL</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">timeo</span> <span class="o">=</span> <span class="n">sock_rcvtimeo</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="o">&amp;</span><span class="n">MSG_DONTWAIT</span><span class="p">);</span>

	<span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Lock the socket to prevent queue disordering</span>
<span class="cm">	 * while sleeps in memcpy_tomsg</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp_scm</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_scm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp_scm</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">skip</span> <span class="o">=</span> <span class="n">sk_peek_offset</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

		<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
<span class="nl">again:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unix_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">recursion_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 *	POSIX 1003.1g mandates this order.</span>
<span class="cm">			 */</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">sock_error</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

			<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timeo</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span>

			<span class="n">timeo</span> <span class="o">=</span> <span class="n">unix_stream_data_wait</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">timeo</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
			    <span class="o">||</span>  <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">sock_intr_errno</span><span class="p">(</span><span class="n">timeo</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">continue</span><span class="p">;</span>
 <span class="nl">unlock:</span>
			<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skip</span> <span class="o">&gt;=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skip</span> <span class="o">-=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek_next</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">check_creds</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Never glue messages from different writers */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span>  <span class="o">!=</span> <span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">cred</span> <span class="o">!=</span> <span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Copy credentials */</span>
			<span class="n">scm_set_cred</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span> <span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">pid</span><span class="p">,</span> <span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">cred</span><span class="p">);</span>
			<span class="n">check_creds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Copy address just once */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sunaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unix_copy_addr</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">sunaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">chunk</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">skip</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcpy_toiovec</span><span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_iov</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">skip</span><span class="p">,</span> <span class="n">chunk</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">copied</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">copied</span> <span class="o">+=</span> <span class="n">chunk</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">-=</span> <span class="n">chunk</span><span class="p">;</span>

		<span class="cm">/* Mark read part of skb as used */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MSG_PEEK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

			<span class="n">sk_peek_offset_bwd</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="p">)</span>
				<span class="n">unix_detach_fds</span><span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">skb_unlink</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
			<span class="n">consume_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* It is questionable, see note in unix_dgram_recvmsg.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="p">)</span>
				<span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">=</span> <span class="n">scm_fp_dup</span><span class="p">(</span><span class="n">UNIXCB</span><span class="p">(</span><span class="n">skb</span><span class="p">).</span><span class="n">fp</span><span class="p">);</span>

			<span class="n">sk_peek_offset_fwd</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">chunk</span><span class="p">);</span>

			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">readlock</span><span class="p">);</span>
	<span class="n">scm_recv</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">siocb</span><span class="o">-&gt;</span><span class="n">scm</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">copied</span> <span class="o">?</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">other</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">RCV_SHUTDOWN</span><span class="o">|</span><span class="n">SEND_SHUTDOWN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">|=</span> <span class="n">mode</span><span class="p">;</span>
	<span class="n">other</span> <span class="o">=</span> <span class="n">unix_peer</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">)</span>
		<span class="n">sock_hold</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_SEQPACKET</span><span class="p">))</span> <span class="p">{</span>

		<span class="kt">int</span> <span class="n">peer_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">&amp;</span><span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
			<span class="n">peer_mode</span> <span class="o">|=</span> <span class="n">SEND_SHUTDOWN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">&amp;</span><span class="n">SEND_SHUTDOWN</span><span class="p">)</span>
			<span class="n">peer_mode</span> <span class="o">|=</span> <span class="n">RCV_SHUTDOWN</span><span class="p">;</span>
		<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">|=</span> <span class="n">peer_mode</span><span class="p">;</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="n">other</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">peer_mode</span> <span class="o">==</span> <span class="n">SHUTDOWN_MASK</span><span class="p">)</span>
			<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SOCK_WAKE_WAITD</span><span class="p">,</span> <span class="n">POLL_HUP</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">peer_mode</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
			<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SOCK_WAKE_WAITD</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">)</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">unix_inq_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span> <span class="o">||</span>
	    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb_queue_walk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">)</span>
			<span class="n">amount</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="p">)</span>
			<span class="n">amount</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">amount</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unix_inq_len</span><span class="p">);</span>

<span class="kt">long</span> <span class="nf">unix_outq_len</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sk_wmem_alloc_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unix_outq_len</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SIOCOUTQ</span>:
		<span class="n">amount</span> <span class="o">=</span> <span class="n">unix_outq_len</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SIOCINQ</span>:
		<span class="n">amount</span> <span class="o">=</span> <span class="n">unix_inq_len</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">amount</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">put_user</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">unix_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">sock_poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* exceptional events? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLERR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">==</span> <span class="n">SHUTDOWN_MASK</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLRDHUP</span> <span class="o">|</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="cm">/* readable? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="cm">/* Connection-based need to check for termination and startup */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_STREAM</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we set writable also when the other side has shut down the</span>
<span class="cm">	 * connection. This prevents stuck sockets.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unix_writable</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span> <span class="o">|</span> <span class="n">POLLWRBAND</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">unix_dgram_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
				    <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="n">writable</span><span class="p">;</span>

	<span class="n">sock_poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* exceptional events? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">||</span> <span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_error_queue</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLERR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLRDHUP</span> <span class="o">|</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">==</span> <span class="n">SHUTDOWN_MASK</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>

	<span class="cm">/* readable? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb_queue_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">))</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>

	<span class="cm">/* Connection-based need to check for termination and startup */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_type</span> <span class="o">==</span> <span class="n">SOCK_SEQPACKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_CLOSE</span><span class="p">)</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>
		<span class="cm">/* connection hasn&#39;t started yet? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_SYN_SENT</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* No write status requested, avoid expensive OUT tests. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">poll_requested_events</span><span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">POLLWRBAND</span><span class="o">|</span><span class="n">POLLWRNORM</span><span class="o">|</span><span class="n">POLLOUT</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>

	<span class="n">writable</span> <span class="o">=</span> <span class="n">unix_writable</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">other</span> <span class="o">=</span> <span class="n">unix_peer_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unix_peer</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sock_poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unix_sk</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">peer_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unix_recvq_full</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
				<span class="n">writable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sock_put</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">writable</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span> <span class="o">|</span> <span class="n">POLLWRBAND</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">SOCK_ASYNC_NOSPACE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_socket</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">first_unix_socket</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">UNIX_HASH_SIZE</span><span class="p">;</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_socket_table</span><span class="p">[</span><span class="o">*</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">return</span> <span class="n">__sk_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_socket_table</span><span class="p">[</span><span class="o">*</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">next_unix_socket</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">sk_next</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="cm">/* More in this chain? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
	<span class="cm">/* Look for next non-empty chain. */</span>
	<span class="k">for</span> <span class="p">((</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">UNIX_HASH_SIZE</span><span class="p">;</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hlist_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_socket_table</span><span class="p">[</span><span class="o">*</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">return</span> <span class="n">__sk_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_socket_table</span><span class="p">[</span><span class="o">*</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">unix_iter_state</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_net_private</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="nf">unix_seq_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">unix_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">first_unix_socket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">);</span> <span class="n">s</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">next_unix_socket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="n">seq_file_net</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">==</span> <span class="n">pos</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
		<span class="o">++</span><span class="n">off</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">unix_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">unix_table_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">pos</span> <span class="o">?</span> <span class="n">unix_seq_idx</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">SEQ_START_TOKEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">unix_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">unix_iter_state</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="n">sk</span> <span class="o">=</span> <span class="n">first_unix_socket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sk</span> <span class="o">=</span> <span class="n">next_unix_socket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sk</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">sock_net</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">!=</span> <span class="n">seq_file_net</span><span class="p">(</span><span class="n">seq</span><span class="p">)))</span>
		<span class="n">sk</span> <span class="o">=</span> <span class="n">next_unix_socket</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sk</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unix_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">unix_table_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_table_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_seq_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;Num       RefCount Protocol Flags    Type St &quot;</span>
			 <span class="s">&quot;Inode Path</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">unix_sock</span> <span class="o">*</span><span class="n">u</span> <span class="o">=</span> <span class="n">unix_sk</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">unix_state_lock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;%pK: %08X %08X %08X %04X %02X %5lu&quot;</span><span class="p">,</span>
			<span class="n">s</span><span class="p">,</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sk_refcnt</span><span class="p">),</span>
			<span class="mi">0</span><span class="p">,</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_LISTEN</span> <span class="o">?</span> <span class="n">__SO_ACCEPTCON</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sk_type</span><span class="p">,</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">sk_socket</span> <span class="o">?</span>
			<span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_ESTABLISHED</span> <span class="o">?</span> <span class="n">SS_CONNECTED</span> <span class="o">:</span> <span class="n">SS_UNCONNECTED</span><span class="p">)</span> <span class="o">:</span>
			<span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_ESTABLISHED</span> <span class="o">?</span> <span class="n">SS_CONNECTING</span> <span class="o">:</span> <span class="n">SS_DISCONNECTING</span><span class="p">),</span>
			<span class="n">sock_i_ino</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>

			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">short</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">UNIX_ABSTRACT</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
				<span class="n">len</span><span class="o">--</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;@&#39;</span><span class="p">);</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">u</span><span class="o">-&gt;</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">sun_path</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">unix_state_unlock</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="n">seq_putc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">unix_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>  <span class="o">=</span> <span class="n">unix_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>   <span class="o">=</span> <span class="n">unix_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>   <span class="o">=</span> <span class="n">unix_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>   <span class="o">=</span> <span class="n">unix_seq_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unix_seq_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open_net</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unix_seq_ops</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">unix_iter_state</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">unix_seq_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">unix_seq_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release_net</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">net_proto_family</span> <span class="n">unix_family_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">family</span> <span class="o">=</span> <span class="n">PF_UNIX</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">unix_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span>	<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">__net_init</span> <span class="nf">unix_net_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">net</span><span class="o">-&gt;</span><span class="n">unx</span><span class="p">.</span><span class="n">sysctl_max_dgram_qlen</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unix_sysctl_register</span><span class="p">(</span><span class="n">net</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">proc_net_fops_create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;unix&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unix_seq_fops</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unix_sysctl_unregister</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__net_exit</span> <span class="nf">unix_net_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unix_sysctl_unregister</span><span class="p">(</span><span class="n">net</span><span class="p">);</span>
	<span class="n">proc_net_remove</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="s">&quot;unix&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pernet_operations</span> <span class="n">unix_net_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">unix_net_init</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exit</span> <span class="o">=</span> <span class="n">unix_net_exit</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">af_unix_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">dummy_skb</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">unix_skb_parms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dummy_skb</span><span class="o">-&gt;</span><span class="n">cb</span><span class="p">));</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">proto_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_proto</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;%s: Cannot create unix_sock SLAB cache!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sock_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_family_ops</span><span class="p">);</span>
	<span class="n">register_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_net_ops</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">af_unix_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sock_unregister</span><span class="p">(</span><span class="n">PF_UNIX</span><span class="p">);</span>
	<span class="n">proto_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_proto</span><span class="p">);</span>
	<span class="n">unregister_pernet_subsys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unix_net_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Earlier than device_initcall() so that other drivers invoking</span>
<span class="cm">   request_module() don&#39;t end up in a loop when modprobe tries</span>
<span class="cm">   to use a UNIX socket. But later than subsys_initcall() because</span>
<span class="cm">   we depend on stuff initialised there */</span>
<span class="n">fs_initcall</span><span class="p">(</span><span class="n">af_unix_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">af_unix_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_NETPROTO</span><span class="p">(</span><span class="n">PF_UNIX</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
