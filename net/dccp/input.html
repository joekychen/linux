<!DOCTYPE html>
<html><head><title>joekychen/linux » net › dccp › input.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>input.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  net/dccp/input.c</span>
<span class="cm"> *</span>
<span class="cm"> *  An implementation of the DCCP protocol</span>
<span class="cm"> *  Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	as published by the Free Software Foundation; either version</span>
<span class="cm"> *	2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/dccp.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;net/sock.h&gt;</span>

<span class="cp">#include &quot;ackvec.h&quot;</span>
<span class="cp">#include &quot;ccid.h&quot;</span>
<span class="cp">#include &quot;dccp.h&quot;</span>

<span class="cm">/* rate-limit for syncs in reply to sequence-invalid packets; RFC 4340, 7.5.4 */</span>
<span class="kt">int</span> <span class="n">sysctl_dccp_sync_ratelimit</span>	<span class="n">__read_mostly</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dccp_enqueue_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dccp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccph_doff</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">skb_set_owner_r</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dccp_fin</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * On receiving Close/CloseReq, both RD/WR shutdown are performed.</span>
<span class="cm">	 * RFC 4340, 8.3 says that we MAY send further Data/DataAcks after</span>
<span class="cm">	 * receiving the closing segment, but there is no guarantee that such</span>
<span class="cm">	 * data will be processed at all.</span>
<span class="cm">	 */</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">=</span> <span class="n">SHUTDOWN_MASK</span><span class="p">;</span>
	<span class="n">sock_set_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DONE</span><span class="p">);</span>
	<span class="n">dccp_enqueue_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dccp_rcv_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We ignore Close when received in one of the following states:</span>
<span class="cm">	 *  - CLOSED		(may be a late or duplicate packet)</span>
<span class="cm">	 *  - PASSIVE_CLOSEREQ	(the peer has sent a CloseReq earlier)</span>
<span class="cm">	 *  - RESPOND		(already handled by dccp_check_req)</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">DCCP_CLOSING</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Simultaneous-close: receiving a Close after sending one. This</span>
<span class="cm">		 * can happen if both client and server perform active-close and</span>
<span class="cm">		 * will result in an endless ping-pong of crossing and retrans-</span>
<span class="cm">		 * mitted Close packets, which only terminates when one of the</span>
<span class="cm">		 * nodes times out (min. 64 seconds). Quicker convergence can be</span>
<span class="cm">		 * achieved when one of the nodes acts as tie-breaker.</span>
<span class="cm">		 * This is ok as both ends are done with data transfer and each</span>
<span class="cm">		 * end is just waiting for the other to acknowledge termination.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccps_role</span> <span class="o">!=</span> <span class="n">DCCP_ROLE_CLIENT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">DCCP_REQUESTING</span>:
	<span class="k">case</span> <span class="n">DCCP_ACTIVE_CLOSEREQ</span>:
		<span class="n">dccp_send_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">DCCP_RESET_CODE_CLOSED</span><span class="p">);</span>
		<span class="n">dccp_done</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_OPEN</span>:
	<span class="k">case</span> <span class="n">DCCP_PARTOPEN</span>:
		<span class="cm">/* Give waiting application a chance to read pending data */</span>
		<span class="n">queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dccp_fin</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">dccp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">DCCP_PASSIVE_CLOSE</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">DCCP_PASSIVE_CLOSE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Retransmitted Close: we have already enqueued the first one.</span>
<span class="cm">		 */</span>
		<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_WAITD</span><span class="p">,</span> <span class="n">POLL_HUP</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">queued</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dccp_rcv_closereq</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *   Step 7: Check for unexpected packet types</span>
<span class="cm">	 *      If (S.is_server and P.type == CloseReq)</span>
<span class="cm">	 *	  Send Sync packet acknowledging P.seqno</span>
<span class="cm">	 *	  Drop packet and return</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccps_role</span> <span class="o">!=</span> <span class="n">DCCP_ROLE_CLIENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dccp_send_sync</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span><span class="p">,</span> <span class="n">DCCP_PKT_SYNC</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">queued</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Step 13: process relevant Client states &lt; CLOSEREQ */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DCCP_REQUESTING</span>:
		<span class="n">dccp_send_close</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">dccp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">DCCP_CLOSING</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_OPEN</span>:
	<span class="k">case</span> <span class="n">DCCP_PARTOPEN</span>:
		<span class="cm">/* Give waiting application a chance to read pending data */</span>
		<span class="n">queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dccp_fin</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">dccp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">DCCP_PASSIVE_CLOSEREQ</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">DCCP_PASSIVE_CLOSEREQ</span>:
		<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_WAITD</span><span class="p">,</span> <span class="n">POLL_HUP</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">queued</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u16</span> <span class="nf">dccp_reset_code_convert</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u16</span> <span class="n">error_code</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">DCCP_RESET_CODE_CLOSED</span><span class="p">]</span>	     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* normal termination */</span>
	<span class="p">[</span><span class="n">DCCP_RESET_CODE_UNSPECIFIED</span><span class="p">]</span>	     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* nothing known */</span>
	<span class="p">[</span><span class="n">DCCP_RESET_CODE_ABORTED</span><span class="p">]</span>	     <span class="o">=</span> <span class="n">ECONNRESET</span><span class="p">,</span>

	<span class="p">[</span><span class="n">DCCP_RESET_CODE_NO_CONNECTION</span><span class="p">]</span>	     <span class="o">=</span> <span class="n">ECONNREFUSED</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DCCP_RESET_CODE_CONNECTION_REFUSED</span><span class="p">]</span> <span class="o">=</span> <span class="n">ECONNREFUSED</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DCCP_RESET_CODE_TOO_BUSY</span><span class="p">]</span>	     <span class="o">=</span> <span class="n">EUSERS</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DCCP_RESET_CODE_AGGRESSION_PENALTY</span><span class="p">]</span> <span class="o">=</span> <span class="n">EDQUOT</span><span class="p">,</span>

	<span class="p">[</span><span class="n">DCCP_RESET_CODE_PACKET_ERROR</span><span class="p">]</span>	     <span class="o">=</span> <span class="n">ENOMSG</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DCCP_RESET_CODE_BAD_INIT_COOKIE</span><span class="p">]</span>    <span class="o">=</span> <span class="n">EBADR</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DCCP_RESET_CODE_BAD_SERVICE_CODE</span><span class="p">]</span>   <span class="o">=</span> <span class="n">EBADRQC</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DCCP_RESET_CODE_OPTION_ERROR</span><span class="p">]</span>	     <span class="o">=</span> <span class="n">EILSEQ</span><span class="p">,</span>
	<span class="p">[</span><span class="n">DCCP_RESET_CODE_MANDATORY_ERROR</span><span class="p">]</span>    <span class="o">=</span> <span class="n">EOPNOTSUPP</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">code</span> <span class="o">&gt;=</span> <span class="n">DCCP_MAX_RESET_CODES</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">error_code</span><span class="p">[</span><span class="n">code</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dccp_rcv_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">err</span> <span class="o">=</span> <span class="n">dccp_reset_code_convert</span><span class="p">(</span><span class="n">dccp_hdr_reset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccph_reset_code</span><span class="p">);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* Queue the equivalent of TCP fin so that dccp_recvmsg exits the loop */</span>
	<span class="n">dccp_fin</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span>
		<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_IO</span><span class="p">,</span> <span class="n">POLL_ERR</span><span class="p">);</span>
	<span class="n">dccp_time_wait</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">DCCP_TIME_WAIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dccp_handle_ackvec_processing</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dccp_ackvec</span> <span class="o">*</span><span class="n">av</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccps_hc_rx_ackvec</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_ack_seq</span> <span class="o">!=</span> <span class="n">DCCP_PKT_WITHOUT_ACK_SEQ</span><span class="p">)</span>
		<span class="n">dccp_ackvec_clear_state</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_ack_seq</span><span class="p">);</span>
	<span class="n">dccp_ackvec_input</span><span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dccp_deliver_input_to_ccids</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t deliver to RX CCID when node has shut down read end. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">RCV_SHUTDOWN</span><span class="p">))</span>
		<span class="n">ccid_hc_rx_packet_recv</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_hc_rx_ccid</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Until the TX queue has been drained, we can not honour SHUT_WR, since</span>
<span class="cm">	 * we need received feedback as input to adjust congestion control.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">.</span><span class="n">qlen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_shutdown</span> <span class="o">&amp;</span> <span class="n">SEND_SHUTDOWN</span><span class="p">))</span>
		<span class="n">ccid_hc_tx_packet_recv</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_hc_tx_ccid</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dccp_check_seqno</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">dccp_hdr</span> <span class="o">*</span><span class="n">dh</span> <span class="o">=</span> <span class="n">dccp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">lswl</span><span class="p">,</span> <span class="n">lawl</span><span class="p">,</span> <span class="n">seqno</span> <span class="o">=</span> <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span><span class="p">,</span>
			<span class="n">ackno</span> <span class="o">=</span> <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_ack_seq</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *   Step 5: Prepare sequence numbers for Sync</span>
<span class="cm">	 *     If P.type == Sync or P.type == SyncAck,</span>
<span class="cm">	 *	  If S.AWL &lt;= P.ackno &lt;= S.AWH and P.seqno &gt;= S.SWL,</span>
<span class="cm">	 *	     / * P is valid, so update sequence number variables</span>
<span class="cm">	 *		 accordingly.  After this update, P will pass the tests</span>
<span class="cm">	 *		 in Step 6.  A SyncAck is generated if necessary in</span>
<span class="cm">	 *		 Step 15 * /</span>
<span class="cm">	 *	     Update S.GSR, S.SWL, S.SWH</span>
<span class="cm">	 *	  Otherwise,</span>
<span class="cm">	 *	     Drop packet and return</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_SYNC</span> <span class="o">||</span>
	    <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_SYNCACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">between48</span><span class="p">(</span><span class="n">ackno</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_awl</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_awh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">dccp_delta_seqno</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_swl</span><span class="p">,</span> <span class="n">seqno</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dccp_update_gsr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *   Step 6: Check sequence numbers</span>
<span class="cm">	 *      Let LSWL = S.SWL and LAWL = S.AWL</span>
<span class="cm">	 *      If P.type == CloseReq or P.type == Close or P.type == Reset,</span>
<span class="cm">	 *	  LSWL := S.GSR + 1, LAWL := S.GAR</span>
<span class="cm">	 *      If LSWL &lt;= P.seqno &lt;= S.SWH</span>
<span class="cm">	 *	     and (P.ackno does not exist or LAWL &lt;= P.ackno &lt;= S.AWH),</span>
<span class="cm">	 *	  Update S.GSR, S.SWL, S.SWH</span>
<span class="cm">	 *	  If P.type != Sync,</span>
<span class="cm">	 *	     Update S.GAR</span>
<span class="cm">	 */</span>
	<span class="n">lswl</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_swl</span><span class="p">;</span>
	<span class="n">lawl</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_awl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_CLOSEREQ</span> <span class="o">||</span>
	    <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_CLOSE</span> <span class="o">||</span>
	    <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lswl</span> <span class="o">=</span> <span class="n">ADD48</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_gsr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">lawl</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_gar</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">between48</span><span class="p">(</span><span class="n">seqno</span><span class="p">,</span> <span class="n">lswl</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_swh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ackno</span> <span class="o">==</span> <span class="n">DCCP_PKT_WITHOUT_ACK_SEQ</span> <span class="o">||</span>
	     <span class="n">between48</span><span class="p">(</span><span class="n">ackno</span><span class="p">,</span> <span class="n">lawl</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_awh</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dccp_update_gsr</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seqno</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">!=</span> <span class="n">DCCP_PKT_SYNC</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ackno</span> <span class="o">!=</span> <span class="n">DCCP_PKT_WITHOUT_ACK_SEQ</span> <span class="o">&amp;&amp;</span>
		    <span class="n">after48</span><span class="p">(</span><span class="n">ackno</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_gar</span><span class="p">))</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_gar</span> <span class="o">=</span> <span class="n">ackno</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 *   Step 6: Check sequence numbers</span>
<span class="cm">		 *      Otherwise,</span>
<span class="cm">		 *         If P.type == Reset,</span>
<span class="cm">		 *            Send Sync packet acknowledging S.GSR</span>
<span class="cm">		 *         Otherwise,</span>
<span class="cm">		 *            Send Sync packet acknowledging P.seqno</span>
<span class="cm">		 *      Drop packet and return</span>
<span class="cm">		 *</span>
<span class="cm">		 *   These Syncs are rate-limited as per RFC 4340, 7.5.4:</span>
<span class="cm">		 *   at most 1 / (dccp_sync_rate_limit * HZ) Syncs per second.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_rate_last</span> <span class="o">+</span>
				      <span class="n">sysctl_dccp_sync_ratelimit</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">DCCP_WARN</span><span class="p">(</span><span class="s">&quot;Step 6 failed for %s packet, &quot;</span>
			  <span class="s">&quot;(LSWL(%llu) &lt;= P.seqno(%llu) &lt;= S.SWH(%llu)) and &quot;</span>
			  <span class="s">&quot;(P.ackno %s or LAWL(%llu) &lt;= P.ackno(%llu) &lt;= S.AWH(%llu), &quot;</span>
			  <span class="s">&quot;sending SYNC...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  <span class="n">dccp_packet_name</span><span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span><span class="p">),</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">lswl</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">seqno</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_swh</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">ackno</span> <span class="o">==</span> <span class="n">DCCP_PKT_WITHOUT_ACK_SEQ</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;doesn&#39;t exist&quot;</span>
							      <span class="o">:</span> <span class="s">&quot;exists&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">lawl</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ackno</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_awh</span><span class="p">);</span>

		<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_rate_last</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_RESET</span><span class="p">)</span>
			<span class="n">seqno</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_gsr</span><span class="p">;</span>
		<span class="n">dccp_send_sync</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">seqno</span><span class="p">,</span> <span class="n">DCCP_PKT_SYNC</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dccp_rcv_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">dccp_hdr</span> <span class="o">*</span><span class="n">dh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dccp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccph_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DCCP_PKT_DATAACK</span>:
	<span class="k">case</span> <span class="n">DCCP_PKT_DATA</span>:
		<span class="cm">/*</span>
<span class="cm">		 * FIXME: schedule DATA_DROPPED (RFC 4340, 11.7.2) if and when</span>
<span class="cm">		 * - sk_shutdown == RCV_SHUTDOWN, use Code 1, &quot;Not Listening&quot;</span>
<span class="cm">		 * - sk_receive_queue is full, use Code 2, &quot;Receive Buffer&quot;</span>
<span class="cm">		 */</span>
		<span class="n">dccp_enqueue_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_PKT_ACK</span>:
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_PKT_RESET</span>:
		<span class="cm">/*</span>
<span class="cm">		 *  Step 9: Process Reset</span>
<span class="cm">		 *	If P.type == Reset,</span>
<span class="cm">		 *		Tear down connection</span>
<span class="cm">		 *		S.state := TIMEWAIT</span>
<span class="cm">		 *		Set TIMEWAIT timer</span>
<span class="cm">		 *		Drop packet and return</span>
<span class="cm">		 */</span>
		<span class="n">dccp_rcv_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_PKT_CLOSEREQ</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dccp_rcv_closereq</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_PKT_CLOSE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dccp_rcv_close</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_PKT_REQUEST</span>:
		<span class="cm">/* Step 7</span>
<span class="cm">		 *   or (S.is_server and P.type == Response)</span>
<span class="cm">		 *   or (S.is_client and P.type == Request)</span>
<span class="cm">		 *   or (S.state &gt;= OPEN and P.type == Request</span>
<span class="cm">		 *	and P.seqno &gt;= S.OSR)</span>
<span class="cm">		 *    or (S.state &gt;= OPEN and P.type == Response</span>
<span class="cm">		 *	and P.seqno &gt;= S.OSR)</span>
<span class="cm">		 *    or (S.state == RESPOND and P.type == Data),</span>
<span class="cm">		 *  Send Sync packet acknowledging P.seqno</span>
<span class="cm">		 *  Drop packet and return</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_role</span> <span class="o">!=</span> <span class="n">DCCP_ROLE_LISTEN</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">send_sync</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">check_seq</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_PKT_RESPONSE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_role</span> <span class="o">!=</span> <span class="n">DCCP_ROLE_CLIENT</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">send_sync</span><span class="p">;</span>
<span class="nl">check_seq:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dccp_delta_seqno</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_osr</span><span class="p">,</span>
				     <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">send_sync:</span>
			<span class="n">dccp_send_sync</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span><span class="p">,</span>
				       <span class="n">DCCP_PKT_SYNC</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_PKT_SYNC</span>:
		<span class="n">dccp_send_sync</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span><span class="p">,</span>
			       <span class="n">DCCP_PKT_SYNCACK</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * From RFC 4340, sec. 5.7</span>
<span class="cm">		 *</span>
<span class="cm">		 * As with DCCP-Ack packets, DCCP-Sync and DCCP-SyncAck packets</span>
<span class="cm">		 * MAY have non-zero-length application data areas, whose</span>
<span class="cm">		 * contents receivers MUST ignore.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DCCP_INC_STATS_BH</span><span class="p">(</span><span class="n">DCCP_MIB_INERRS</span><span class="p">);</span>
<span class="nl">discard:</span>
	<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dccp_rcv_established</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			 <span class="k">const</span> <span class="k">struct</span> <span class="n">dccp_hdr</span> <span class="o">*</span><span class="n">dh</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dccp_check_seqno</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dccp_parse_options</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dccp_handle_ackvec_processing</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="n">dccp_deliver_input_to_ccids</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__dccp_rcv_established</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="nl">discard:</span>
	<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dccp_rcv_established</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dccp_rcv_request_sent_state_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
					       <span class="k">const</span> <span class="k">struct</span> <span class="n">dccp_hdr</span> <span class="o">*</span><span class="n">dh</span><span class="p">,</span>
					       <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Step 4: Prepare sequence numbers in REQUEST</span>
<span class="cm">	 *     If S.state == REQUEST,</span>
<span class="cm">	 *	  If (P.type == Response or P.type == Reset)</span>
<span class="cm">	 *		and S.AWL &lt;= P.ackno &lt;= S.AWH,</span>
<span class="cm">	 *	     / * Set sequence number variables corresponding to the</span>
<span class="cm">	 *		other endpoint, so P will pass the tests in Step 6 * /</span>
<span class="cm">	 *	     Set S.GSR, S.ISR, S.SWL, S.SWH</span>
<span class="cm">	 *	     / * Response processing continues in Step 10; Reset</span>
<span class="cm">	 *		processing continues in Step 9 * /</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_RESPONSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="kt">long</span> <span class="n">tstamp</span> <span class="o">=</span> <span class="n">dccp_timestamp</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">between48</span><span class="p">(</span><span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_ack_seq</span><span class="p">,</span>
			       <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_awl</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_awh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dccp_pr_debug</span><span class="p">(</span><span class="s">&quot;invalid ackno: S.AWL=%llu, &quot;</span>
				      <span class="s">&quot;P.ackno=%llu, S.AWH=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_awl</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_ack_seq</span><span class="p">,</span>
				      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_awh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_invalid_packet</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If option processing (Step 8) failed, return 1 here so that</span>
<span class="cm">		 * dccp_v4_do_rcv() sends a Reset. The Reset code depends on</span>
<span class="cm">		 * the option type and is set in dccp_parse_options().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dccp_parse_options</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Obtain usec RTT sample from SYN exchange (used by TFRC). */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_options_received</span><span class="p">.</span><span class="n">dccpor_timestamp_echo</span><span class="p">))</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_syn_rtt</span> <span class="o">=</span> <span class="n">dccp_sample_rtt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">tstamp</span> <span class="o">-</span>
			    <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_options_received</span><span class="p">.</span><span class="n">dccpor_timestamp_echo</span><span class="p">));</span>

		<span class="cm">/* Stop the REQUEST timer */</span>
		<span class="n">inet_csk_clear_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_RETRANS</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">kfree_skb</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span><span class="p">);</span>
		<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Set ISR, GSR from packet. ISS was set in dccp_v{4,6}_connect</span>
<span class="cm">		 * and GSS in dccp_transmit_skb(). Setting AWL/AWH and SWL/SWH</span>
<span class="cm">		 * is done as part of activating the feature values below, since</span>
<span class="cm">		 * these settings depend on the local/remote Sequence Window</span>
<span class="cm">		 * features, which were undefined or not confirmed until now.</span>
<span class="cm">		 */</span>
		<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_gsr</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_isr</span> <span class="o">=</span> <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span><span class="p">;</span>

		<span class="n">dccp_sync_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_pmtu_cookie</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *    Step 10: Process REQUEST state (second part)</span>
<span class="cm">		 *       If S.state == REQUEST,</span>
<span class="cm">		 *	  / * If we get here, P is a valid Response from the</span>
<span class="cm">		 *	      server (see Step 4), and we should move to</span>
<span class="cm">		 *	      PARTOPEN state. PARTOPEN means send an Ack,</span>
<span class="cm">		 *	      don&#39;t send Data packets, retransmit Acks</span>
<span class="cm">		 *	      periodically, and always include any Init Cookie</span>
<span class="cm">		 *	      from the Response * /</span>
<span class="cm">		 *	  S.state := PARTOPEN</span>
<span class="cm">		 *	  Set PARTOPEN timer</span>
<span class="cm">		 *	  Continue with S.state == PARTOPEN</span>
<span class="cm">		 *	  / * Step 12 will send the Ack completing the</span>
<span class="cm">		 *	      three-way handshake * /</span>
<span class="cm">		 */</span>
		<span class="n">dccp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">DCCP_PARTOPEN</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If feature negotiation was successful, activate features now;</span>
<span class="cm">		 * an activation failure means that this host could not activate</span>
<span class="cm">		 * one ore more features (e.g. insufficient memory), which would</span>
<span class="cm">		 * leave at least one feature in an undefined state.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dccp_feat_activate_values</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_featneg</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unable_to_proceed</span><span class="p">;</span>

		<span class="cm">/* Make sure socket is routed, for correct metrics. */</span>
		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">rebuild_header</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DEAD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_IO</span><span class="p">,</span> <span class="n">POLL_OUT</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_pending</span> <span class="o">||</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">pingpong</span> <span class="o">||</span>
		    <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_accept_queue</span><span class="p">.</span><span class="n">rskq_defer_accept</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Save one ACK. Data will be ready after</span>
<span class="cm">			 * several ticks, if write_pending is set.</span>
<span class="cm">			 *</span>
<span class="cm">			 * It may be deleted, but with this feature tcpdumps</span>
<span class="cm">			 * look so _wonderfully_ clever, that I was not able</span>
<span class="cm">			 * to stand against the temptation 8)     --ANK</span>
<span class="cm">			 */</span>
			<span class="cm">/*</span>
<span class="cm">			 * OK, in DCCP we can as well do a similar trick, its</span>
<span class="cm">			 * even in the draft, but there is no need for us to</span>
<span class="cm">			 * schedule an ack here, as dccp_sendmsg does this for</span>
<span class="cm">			 * us, also stated in the draft. -acme</span>
<span class="cm">			 */</span>
			<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dccp_send_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_invalid_packet:</span>
	<span class="cm">/* dccp_v4_do_rcv will send a reset */</span>
	<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_reset_code</span> <span class="o">=</span> <span class="n">DCCP_RESET_CODE_PACKET_ERROR</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">unable_to_proceed:</span>
	<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_reset_code</span> <span class="o">=</span> <span class="n">DCCP_RESET_CODE_ABORTED</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We mark this socket as no longer usable, so that the loop in</span>
<span class="cm">	 * dccp_sendmsg() terminates and the application gets notified.</span>
<span class="cm">	 */</span>
	<span class="n">dccp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">DCCP_CLOSED</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="n">ECOMM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dccp_rcv_respond_partopen_state_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
						   <span class="k">const</span> <span class="k">struct</span> <span class="n">dccp_hdr</span> <span class="o">*</span><span class="n">dh</span><span class="p">,</span>
						   <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">sample</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_options_received</span><span class="p">.</span><span class="n">dccpor_timestamp_echo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DCCP_PKT_RESET</span>:
		<span class="n">inet_csk_clear_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_DACK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_PKT_DATA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">DCCP_RESPOND</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_PKT_DATAACK</span>:
	<span class="k">case</span> <span class="n">DCCP_PKT_ACK</span>:
		<span class="cm">/*</span>
<span class="cm">		 * FIXME: we should be reseting the PARTOPEN (DELACK) timer</span>
<span class="cm">		 * here but only if we haven&#39;t used the DELACK timer for</span>
<span class="cm">		 * something else, like sending a delayed ack for a TIMESTAMP</span>
<span class="cm">		 * echo, etc, for now were not clearing it, sending an extra</span>
<span class="cm">		 * ACK when there is nothing else to do in DELACK is not a big</span>
<span class="cm">		 * deal after all.</span>
<span class="cm">		 */</span>

		<span class="cm">/* Stop the PARTOPEN timer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">DCCP_PARTOPEN</span><span class="p">)</span>
			<span class="n">inet_csk_clear_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_DACK</span><span class="p">);</span>

		<span class="cm">/* Obtain usec RTT sample from SYN exchange (used by TFRC). */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sample</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">long</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">dccp_timestamp</span><span class="p">()</span> <span class="o">-</span> <span class="n">sample</span><span class="p">;</span>

			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_syn_rtt</span> <span class="o">=</span> <span class="n">dccp_sample_rtt</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">delta</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_osr</span> <span class="o">=</span> <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span><span class="p">;</span>
		<span class="n">dccp_set_state</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">DCCP_OPEN</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_DATAACK</span> <span class="o">||</span>
		    <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_DATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__dccp_rcv_established</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* packet was queued</span>
<span class="cm">				       (by __dccp_rcv_established) */</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">queued</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dccp_rcv_state_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">dccp_hdr</span> <span class="o">*</span><span class="n">dh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dccp_skb_cb</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">old_state</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Step 3: Process LISTEN state</span>
<span class="cm">	 *</span>
<span class="cm">	 *     If S.state == LISTEN,</span>
<span class="cm">	 *	 If P.type == Request or P contains a valid Init Cookie option,</span>
<span class="cm">	 *	      (* Must scan the packet&#39;s options to check for Init</span>
<span class="cm">	 *		 Cookies.  Only Init Cookies are processed here,</span>
<span class="cm">	 *		 however; other options are processed in Step 8.  This</span>
<span class="cm">	 *		 scan need only be performed if the endpoint uses Init</span>
<span class="cm">	 *		 Cookies *)</span>
<span class="cm">	 *	      (* Generate a new socket and switch to that socket *)</span>
<span class="cm">	 *	      Set S := new socket for this port pair</span>
<span class="cm">	 *	      S.state = RESPOND</span>
<span class="cm">	 *	      Choose S.ISS (initial seqno) or set from Init Cookies</span>
<span class="cm">	 *	      Initialize S.GAR := S.ISS</span>
<span class="cm">	 *	      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init</span>
<span class="cm">	 *	      Cookies Continue with S.state == RESPOND</span>
<span class="cm">	 *	      (* A Response packet will be generated in Step 11 *)</span>
<span class="cm">	 *	 Otherwise,</span>
<span class="cm">	 *	      Generate Reset(No Connection) unless P.type == Reset</span>
<span class="cm">	 *	      Drop packet and return</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">DCCP_LISTEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_REQUEST</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">conn_request</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span>
								    <span class="n">skb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_RESET</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

		<span class="cm">/* Caller (dccp_v4_do_rcv) will send Reset */</span>
		<span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_reset_code</span> <span class="o">=</span> <span class="n">DCCP_RESET_CODE_NO_CONNECTION</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">DCCP_CLOSED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_reset_code</span> <span class="o">=</span> <span class="n">DCCP_RESET_CODE_NO_CONNECTION</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Step 6: Check sequence numbers (omitted in LISTEN/REQUEST state) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">DCCP_REQUESTING</span> <span class="o">&amp;&amp;</span> <span class="n">dccp_check_seqno</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *   Step 7: Check for unexpected packet types</span>
<span class="cm">	 *      If (S.is_server and P.type == Response)</span>
<span class="cm">	 *	    or (S.is_client and P.type == Request)</span>
<span class="cm">	 *	    or (S.state == RESPOND and P.type == Data),</span>
<span class="cm">	 *	  Send Sync packet acknowledging P.seqno</span>
<span class="cm">	 *	  Drop packet and return</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_role</span> <span class="o">!=</span> <span class="n">DCCP_ROLE_CLIENT</span> <span class="o">&amp;&amp;</span>
	     <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_RESPONSE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_role</span> <span class="o">==</span> <span class="n">DCCP_ROLE_CLIENT</span> <span class="o">&amp;&amp;</span>
	     <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_REQUEST</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">DCCP_RESPOND</span> <span class="o">&amp;&amp;</span> <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_DATA</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dccp_send_sync</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span><span class="p">,</span> <span class="n">DCCP_PKT_SYNC</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*  Step 8: Process options */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dccp_parse_options</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Step 9: Process Reset</span>
<span class="cm">	 *	If P.type == Reset,</span>
<span class="cm">	 *		Tear down connection</span>
<span class="cm">	 *		S.state := TIMEWAIT</span>
<span class="cm">	 *		Set TIMEWAIT timer</span>
<span class="cm">	 *		Drop packet and return</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_RESET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dccp_rcv_reset</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_CLOSEREQ</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Step 13 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dccp_rcv_closereq</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_CLOSE</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* Step 14 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dccp_rcv_close</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DCCP_REQUESTING</span>:
		<span class="n">queued</span> <span class="o">=</span> <span class="n">dccp_rcv_request_sent_state_process</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">queued</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">queued</span><span class="p">;</span>

		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">DCCP_PARTOPEN</span>:
		<span class="cm">/* Step 8: if using Ack Vectors, mark packet acknowledgeable */</span>
		<span class="n">dccp_handle_ackvec_processing</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="n">dccp_deliver_input_to_ccids</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">DCCP_RESPOND</span>:
		<span class="n">queued</span> <span class="o">=</span> <span class="n">dccp_rcv_respond_partopen_state_process</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span>
								 <span class="n">dh</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_ACK</span> <span class="o">||</span>
	    <span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_DATAACK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">old_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DCCP_PARTOPEN</span>:
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state_change</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_IO</span><span class="p">,</span> <span class="n">POLL_OUT</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span> <span class="o">==</span> <span class="n">DCCP_PKT_SYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dccp_send_sync</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span><span class="p">,</span> <span class="n">DCCP_PKT_SYNCACK</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">discard</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queued</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">discard:</span>
		<span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dccp_rcv_state_process</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  dccp_sample_rtt  -  Validate and finalise computation of RTT sample</span>
<span class="cm"> *  @delta:	number of microseconds between packet and acknowledgment</span>
<span class="cm"> *  The routine is kept generic to work in different contexts. It should be</span>
<span class="cm"> *  called immediately when the ACK used for the RTT sample arrives.</span>
<span class="cm"> */</span>
<span class="n">u32</span> <span class="nf">dccp_sample_rtt</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* dccpor_elapsed_time is either zeroed out or set and &gt; 0 */</span>
	<span class="n">delta</span> <span class="o">-=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccps_options_received</span><span class="p">.</span><span class="n">dccpor_elapsed_time</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DCCP_WARN</span><span class="p">(</span><span class="s">&quot;unusable RTT sample %ld, using min</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DCCP_SANE_RTT_MIN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">DCCP_SANE_RTT_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DCCP_WARN</span><span class="p">(</span><span class="s">&quot;RTT sample %ld too large, using max</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">DCCP_SANE_RTT_MAX</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">delta</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
