<!DOCTYPE html>
<html><head><title>joekychen/linux » net › dccp › output.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>output.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  net/dccp/output.c</span>
<span class="cm"> *</span>
<span class="cm"> *  An implementation of the DCCP protocol</span>
<span class="cm"> *  Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *	This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	as published by the Free Software Foundation; either version</span>
<span class="cm"> *	2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/dccp.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/skbuff.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;net/inet_sock.h&gt;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>

<span class="cp">#include &quot;ackvec.h&quot;</span>
<span class="cp">#include &quot;ccid.h&quot;</span>
<span class="cp">#include &quot;dccp.h&quot;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dccp_event_ack_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inet_csk_clear_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_DACK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* enqueue @skb on sk_send_head for retransmission, return clone to send now */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">dccp_skb_entail</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">skb_set_owner_w</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">=</span> <span class="n">skb</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span><span class="p">,</span> <span class="n">gfp_any</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * All SKB&#39;s seen here are completely headerless. It is our</span>
<span class="cm"> * job to build the DCCP header, and pass the packet down to</span>
<span class="cm"> * IP so it can do the same plus pass the packet off to the</span>
<span class="cm"> * device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dccp_transmit_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">skb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inet_sock</span> <span class="o">*</span><span class="n">inet</span> <span class="o">=</span> <span class="n">inet_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">dccp_skb_cb</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">dccp_hdr</span> <span class="o">*</span><span class="n">dh</span><span class="p">;</span>
		<span class="cm">/* XXX For now we&#39;re using only 48 bits sequence numbers */</span>
		<span class="k">const</span> <span class="n">u32</span> <span class="n">dccp_header_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dh</span><span class="p">)</span> <span class="o">+</span>
					     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dccp_hdr_ext</span><span class="p">)</span> <span class="o">+</span>
					  <span class="n">dccp_packet_hdr_len</span><span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_type</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">set_ack</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ackno</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_gsr</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Increment GSS here already in case the option code needs it.</span>
<span class="cm">		 * Update GSS for real only if option processing below succeeds.</span>
<span class="cm">		 */</span>
		<span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span> <span class="o">=</span> <span class="n">ADD48</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_gss</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DCCP_PKT_DATA</span>:
			<span class="n">set_ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">DCCP_PKT_DATAACK</span>:
		<span class="k">case</span> <span class="n">DCCP_PKT_RESET</span>:
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DCCP_PKT_REQUEST</span>:
			<span class="n">set_ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* Use ISS on the first (non-retransmitted) Request. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_iss</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>

		<span class="k">case</span> <span class="n">DCCP_PKT_SYNC</span>:
		<span class="k">case</span> <span class="n">DCCP_PKT_SYNCACK</span>:
			<span class="n">ackno</span> <span class="o">=</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_ack_seq</span><span class="p">;</span>
			<span class="cm">/* fall through */</span>
		<span class="nl">default:</span>
			<span class="cm">/*</span>
<span class="cm">			 * Set owner/destructor: some skbs are allocated via</span>
<span class="cm">			 * alloc_skb (e.g. when retransmission may happen).</span>
<span class="cm">			 * Only Data, DataAck, and Reset packets should come</span>
<span class="cm">			 * through here with skb-&gt;sk set.</span>
<span class="cm">			 */</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">skb_set_owner_w</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dccp_insert_options</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="cm">/* Build DCCP header and checksum it. */</span>
		<span class="n">dh</span> <span class="o">=</span> <span class="n">dccp_zeroed_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dccp_header_size</span><span class="p">);</span>
		<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span>	<span class="o">=</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_type</span><span class="p">;</span>
		<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_sport</span>	<span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_sport</span><span class="p">;</span>
		<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_dport</span>	<span class="o">=</span> <span class="n">inet</span><span class="o">-&gt;</span><span class="n">inet_dport</span><span class="p">;</span>
		<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_doff</span>	<span class="o">=</span> <span class="p">(</span><span class="n">dccp_header_size</span> <span class="o">+</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_opt_len</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_ccval</span>	<span class="o">=</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_ccval</span><span class="p">;</span>
		<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_cscov</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_pcslen</span><span class="p">;</span>
		<span class="cm">/* XXX For now we&#39;re using only 48 bits sequence numbers */</span>
		<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_x</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">dccp_update_gss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span><span class="p">);</span>
		<span class="n">dccp_hdr_set_seq</span><span class="p">(</span><span class="n">dh</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_gss</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set_ack</span><span class="p">)</span>
			<span class="n">dccp_hdr_set_ack</span><span class="p">(</span><span class="n">dccp_hdr_ack_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">ackno</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DCCP_PKT_REQUEST</span>:
			<span class="n">dccp_hdr_request</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccph_req_service</span> <span class="o">=</span>
							<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_service</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Limit Ack window to ISS &lt;= P.ackno &lt;= GSS, so that</span>
<span class="cm">			 * only Responses to Requests we sent are considered.</span>
<span class="cm">			 */</span>
			<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_awl</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_iss</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DCCP_PKT_RESET</span>:
			<span class="n">dccp_hdr_reset</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccph_reset_code</span> <span class="o">=</span>
							<span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_reset_code</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">send_check</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">set_ack</span><span class="p">)</span>
			<span class="n">dccp_event_ack_sent</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

		<span class="n">DCCP_INC_STATS</span><span class="p">(</span><span class="n">DCCP_MIB_OUTSEGS</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">queue_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inet</span><span class="o">-&gt;</span><span class="n">cork</span><span class="p">.</span><span class="n">fl</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">net_xmit_eval</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dccp_determine_ccmps  -  Find out about CCID-specific packet-size limits</span>
<span class="cm"> * We only consider the HC-sender CCID for setting the CCMPS (RFC 4340, 14.),</span>
<span class="cm"> * since the RX CCID is restricted to feedback packets (Acks), which are small</span>
<span class="cm"> * in comparison with the data traffic. A value of 0 means &quot;no current CCMPS&quot;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">dccp_determine_ccmps</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ccid</span> <span class="o">*</span><span class="n">tx_ccid</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_hc_tx_ccid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tx_ccid</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">tx_ccid</span><span class="o">-&gt;</span><span class="n">ccid_ops</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tx_ccid</span><span class="o">-&gt;</span><span class="n">ccid_ops</span><span class="o">-&gt;</span><span class="n">ccid_ccmps</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">dccp_sync_mss</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pmtu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">ccmps</span> <span class="o">=</span> <span class="n">dccp_determine_ccmps</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">cur_mps</span> <span class="o">=</span> <span class="n">ccmps</span> <span class="o">?</span> <span class="n">min</span><span class="p">(</span><span class="n">pmtu</span><span class="p">,</span> <span class="n">ccmps</span><span class="p">)</span> <span class="o">:</span> <span class="n">pmtu</span><span class="p">;</span>

	<span class="cm">/* Account for header lengths and IPv4/v6 option overhead */</span>
	<span class="n">cur_mps</span> <span class="o">-=</span> <span class="p">(</span><span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">net_header_len</span> <span class="o">+</span> <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_ext_hdr_len</span> <span class="o">+</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dccp_hdr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dccp_hdr_ext</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Leave enough headroom for common DCCP header options.</span>
<span class="cm">	 * This only considers options which may appear on DCCP-Data packets, as</span>
<span class="cm">	 * per table 3 in RFC 4340, 5.8. When running out of space for other</span>
<span class="cm">	 * options (eg. Ack Vector which can take up to 255 bytes), it is better</span>
<span class="cm">	 * to schedule a separate Ack. Thus we leave headroom for the following:</span>
<span class="cm">	 *  - 1 byte for Slow Receiver (11.6)</span>
<span class="cm">	 *  - 6 bytes for Timestamp (13.1)</span>
<span class="cm">	 *  - 10 bytes for Timestamp Echo (13.3)</span>
<span class="cm">	 *  - 8 bytes for NDP count (7.7, when activated)</span>
<span class="cm">	 *  - 6 bytes for Data Checksum (9.3)</span>
<span class="cm">	 *  - %DCCPAV_MIN_OPTLEN bytes for Ack Vector size (11.4, when enabled)</span>
<span class="cm">	 */</span>
	<span class="n">cur_mps</span> <span class="o">-=</span> <span class="n">roundup</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_send_ndp_count</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">+</span>
			   <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_hc_rx_ackvec</span> <span class="o">?</span> <span class="n">DCCPAV_MIN_OPTLEN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* And store cached results */</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_pmtu_cookie</span> <span class="o">=</span> <span class="n">pmtu</span><span class="p">;</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_mss_cache</span> <span class="o">=</span> <span class="n">cur_mps</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cur_mps</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dccp_sync_mss</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">dccp_write_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">socket_wq</span> <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">wq</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_wq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq_has_sleeper</span><span class="p">(</span><span class="n">wq</span><span class="p">))</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="cm">/* Should agree with poll, otherwise some programs break */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sock_writeable</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
		<span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_SPACE</span><span class="p">,</span> <span class="n">POLL_OUT</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dccp_wait_for_ccid  -  Await CCID send permission</span>
<span class="cm"> * @sk:    socket to wait for</span>
<span class="cm"> * @delay: timeout in jiffies</span>
<span class="cm"> * This is used by CCIDs which need to delay the send time in process context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dccp_wait_for_ccid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">remaining</span><span class="p">;</span>

	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_pending</span><span class="o">++</span><span class="p">;</span>
	<span class="n">release_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">remaining</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">delay</span><span class="p">);</span>

	<span class="n">lock_sock</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_pending</span><span class="o">--</span><span class="p">;</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">sk_sleep</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">||</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">remaining</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dccp_xmit_packet  -  Send data packet under control of CCID</span>
<span class="cm"> * Transmits next-queued payload and informs CCID to account for the packet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dccp_xmit_packet</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">dccp_qpolicy_pop</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">DCCP_PARTOPEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">u32</span> <span class="n">cur_mps</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_mss_cache</span> <span class="o">-</span> <span class="n">DCCP_FEATNEG_OVERHEAD</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * See 8.1.5 - Handshake Completion.</span>
<span class="cm">		 *</span>
<span class="cm">		 * For robustness we resend Confirm options until the client has</span>
<span class="cm">		 * entered OPEN. During the initial feature negotiation, the MPS</span>
<span class="cm">		 * is smaller than usual, reduced by the Change/Confirm options.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_featneg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">cur_mps</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DCCP_WARN</span><span class="p">(</span><span class="s">&quot;Payload too large (%d) for featneg.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">dccp_send_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">dccp_feat_list_purge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_featneg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">inet_csk_schedule_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
		<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_DACK</span><span class="p">,</span>
					      <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">,</span>
					      <span class="n">DCCP_RTO_MAX</span><span class="p">);</span>
		<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_type</span> <span class="o">=</span> <span class="n">DCCP_PKT_DATAACK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dccp_ack_pending</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_type</span> <span class="o">=</span> <span class="n">DCCP_PKT_DATAACK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_type</span> <span class="o">=</span> <span class="n">DCCP_PKT_DATA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dccp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">dccp_pr_debug</span><span class="p">(</span><span class="s">&quot;transmit_skb() returned err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Register this one as sent even if an error occurred. To the remote</span>
<span class="cm">	 * end a local packet drop is indistinguishable from network loss, i.e.</span>
<span class="cm">	 * any local drop will eventually be reported via receiver feedback.</span>
<span class="cm">	 */</span>
	<span class="n">ccid_hc_tx_packet_sent</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_hc_tx_ccid</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the CCID needs to transfer additional header options out-of-band</span>
<span class="cm">	 * (e.g. Ack Vectors or feature-negotiation options), it activates this</span>
<span class="cm">	 * flag to schedule a Sync. The Sync will automatically incorporate all</span>
<span class="cm">	 * currently pending header options, thus clearing the backlog.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_sync_scheduled</span><span class="p">)</span>
		<span class="n">dccp_send_sync</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_gsr</span><span class="p">,</span> <span class="n">DCCP_PKT_SYNC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dccp_flush_write_queue  -  Drain queue at end of connection</span>
<span class="cm"> * Since dccp_sendmsg queues packets without waiting for them to be sent, it may</span>
<span class="cm"> * happen that the TX queue is not empty at the end of a connection. We give the</span>
<span class="cm"> * HC-sender CCID a grace period of up to @time_budget jiffies. If this function</span>
<span class="cm"> * returns with a non-empty write queue, it will be purged later.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dccp_flush_write_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">time_budget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">delay</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">time_budget</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">skb</span> <span class="o">=</span> <span class="n">skb_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ccid_hc_tx_send_packet</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_hc_tx_ccid</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ccid_packet_dequeue_eval</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CCID_PACKET_WILL_DEQUEUE_LATER</span>:
			<span class="cm">/*</span>
<span class="cm">			 * If the CCID determines when to send, the next sending</span>
<span class="cm">			 * time is unknown or the CCID may not even send again</span>
<span class="cm">			 * (e.g. remote host crashes or lost Ack packets).</span>
<span class="cm">			 */</span>
			<span class="n">DCCP_WARN</span><span class="p">(</span><span class="s">&quot;CCID did not manage to send all packets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CCID_PACKET_DELAY</span>:
			<span class="n">delay</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">delay</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">time_budget</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">dccp_wait_for_ccid</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="o">*</span><span class="n">time_budget</span> <span class="o">-=</span> <span class="p">(</span><span class="n">delay</span> <span class="o">-</span> <span class="n">rc</span><span class="p">);</span>
			<span class="cm">/* check again if we can send now */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CCID_PACKET_SEND_AT_ONCE</span>:
			<span class="n">dccp_xmit_packet</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CCID_PACKET_ERR</span>:
			<span class="n">skb_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_write_queue</span><span class="p">);</span>
			<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
			<span class="n">dccp_pr_debug</span><span class="p">(</span><span class="s">&quot;packet discarded due to err=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dccp_write_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">skb</span> <span class="o">=</span> <span class="n">dccp_qpolicy_top</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">ccid_hc_tx_send_packet</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_hc_tx_ccid</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">ccid_packet_dequeue_eval</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CCID_PACKET_WILL_DEQUEUE_LATER</span>:
			<span class="k">return</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CCID_PACKET_DELAY</span>:
			<span class="n">sk_reset_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_xmit_timer</span><span class="p">,</span>
				       <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">rc</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CCID_PACKET_SEND_AT_ONCE</span>:
			<span class="n">dccp_xmit_packet</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CCID_PACKET_ERR</span>:
			<span class="n">dccp_qpolicy_drop</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
			<span class="n">dccp_pr_debug</span><span class="p">(</span><span class="s">&quot;packet discarded due to err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dccp_retransmit_skb  -  Retransmit Request, Close, or CloseReq packets</span>
<span class="cm"> * There are only four retransmittable packet types in DCCP:</span>
<span class="cm"> * - Request  in client-REQUEST  state (sec. 8.1.1),</span>
<span class="cm"> * - CloseReq in server-CLOSEREQ state (sec. 8.3),</span>
<span class="cm"> * - Close    in   node-CLOSING  state (sec. 8.3),</span>
<span class="cm"> * - Acks in client-PARTOPEN state (sec. 8.1.5, handled by dccp_delack_timer()).</span>
<span class="cm"> * This function expects sk-&gt;sk_send_head to contain the original skb.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dccp_retransmit_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">rebuild_header</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EHOSTUNREACH</span><span class="p">;</span> <span class="cm">/* Routing failure or similar. */</span>

	<span class="cm">/* this count is used to distinguish original and retransmitted skb */</span>
	<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dccp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb_clone</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_send_head</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">dccp_make_response</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">request_sock</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dccp_hdr</span> <span class="o">*</span><span class="n">dh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dccp_request_sock</span> <span class="o">*</span><span class="n">dreq</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">dccp_header_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dccp_hdr</span><span class="p">)</span> <span class="o">+</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dccp_hdr_ext</span><span class="p">)</span> <span class="o">+</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dccp_hdr_response</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">sock_wmalloc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					   <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Reserve space for headers. */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">);</span>

	<span class="n">skb_dst_set</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dst_clone</span><span class="p">(</span><span class="n">dst</span><span class="p">));</span>

	<span class="n">dreq</span> <span class="o">=</span> <span class="n">dccp_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">acked</span><span class="p">)</span>	<span class="cm">/* increase GSS upon retransmission */</span>
		<span class="n">dccp_inc_seqno</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dreq</span><span class="o">-&gt;</span><span class="n">dreq_gss</span><span class="p">);</span>
	<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_type</span> <span class="o">=</span> <span class="n">DCCP_PKT_RESPONSE</span><span class="p">;</span>
	<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span>  <span class="o">=</span> <span class="n">dreq</span><span class="o">-&gt;</span><span class="n">dreq_gss</span><span class="p">;</span>

	<span class="cm">/* Resolve feature dependencies resulting from choice of CCID */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dccp_feat_server_ccid_dependencies</span><span class="p">(</span><span class="n">dreq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">response_failed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dccp_insert_options_rsk</span><span class="p">(</span><span class="n">dreq</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">response_failed</span><span class="p">;</span>

	<span class="cm">/* Build and checksum header */</span>
	<span class="n">dh</span> <span class="o">=</span> <span class="n">dccp_zeroed_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dccp_header_size</span><span class="p">);</span>

	<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_sport</span>	<span class="o">=</span> <span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">loc_port</span><span class="p">;</span>
	<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_dport</span>	<span class="o">=</span> <span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rmt_port</span><span class="p">;</span>
	<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_doff</span>	<span class="o">=</span> <span class="p">(</span><span class="n">dccp_header_size</span> <span class="o">+</span>
			   <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_opt_len</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span>	<span class="o">=</span> <span class="n">DCCP_PKT_RESPONSE</span><span class="p">;</span>
	<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_x</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">dccp_hdr_set_seq</span><span class="p">(</span><span class="n">dh</span><span class="p">,</span> <span class="n">dreq</span><span class="o">-&gt;</span><span class="n">dreq_gss</span><span class="p">);</span>
	<span class="n">dccp_hdr_set_ack</span><span class="p">(</span><span class="n">dccp_hdr_ack_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">dreq</span><span class="o">-&gt;</span><span class="n">dreq_gsr</span><span class="p">);</span>
	<span class="n">dccp_hdr_response</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccph_resp_service</span> <span class="o">=</span> <span class="n">dreq</span><span class="o">-&gt;</span><span class="n">dreq_service</span><span class="p">;</span>

	<span class="n">dccp_csum_outgoing</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

	<span class="cm">/* We use `acked&#39; to remember that a Response was already sent. */</span>
	<span class="n">inet_rsk</span><span class="p">(</span><span class="n">req</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">acked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">DCCP_INC_STATS</span><span class="p">(</span><span class="n">DCCP_MIB_OUTSEGS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="nl">response_failed:</span>
	<span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dccp_make_response</span><span class="p">);</span>

<span class="cm">/* answer offending packet in @rcv_skb with Reset from control socket @ctl */</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="nf">dccp_ctl_make_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rcv_skb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dccp_hdr</span> <span class="o">*</span><span class="n">rxdh</span> <span class="o">=</span> <span class="n">dccp_hdr</span><span class="p">(</span><span class="n">rcv_skb</span><span class="p">),</span> <span class="o">*</span><span class="n">dh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dccp_skb_cb</span> <span class="o">*</span><span class="n">dcb</span> <span class="o">=</span> <span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">rcv_skb</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">dccp_hdr_reset_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dccp_hdr</span><span class="p">)</span> <span class="o">+</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dccp_hdr_ext</span><span class="p">)</span> <span class="o">+</span>
				       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dccp_hdr_reset</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dccp_hdr_reset</span> <span class="o">*</span><span class="n">dhr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">);</span>

	<span class="cm">/* Swap the send and the receive. */</span>
	<span class="n">dh</span> <span class="o">=</span> <span class="n">dccp_zeroed_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dccp_hdr_reset_len</span><span class="p">);</span>
	<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_type</span>	<span class="o">=</span> <span class="n">DCCP_PKT_RESET</span><span class="p">;</span>
	<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_sport</span>	<span class="o">=</span> <span class="n">rxdh</span><span class="o">-&gt;</span><span class="n">dccph_dport</span><span class="p">;</span>
	<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_dport</span>	<span class="o">=</span> <span class="n">rxdh</span><span class="o">-&gt;</span><span class="n">dccph_sport</span><span class="p">;</span>
	<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_doff</span>	<span class="o">=</span> <span class="n">dccp_hdr_reset_len</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">dh</span><span class="o">-&gt;</span><span class="n">dccph_x</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dhr</span> <span class="o">=</span> <span class="n">dccp_hdr_reset</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="n">dhr</span><span class="o">-&gt;</span><span class="n">dccph_reset_code</span> <span class="o">=</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_reset_code</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_reset_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DCCP_RESET_CODE_PACKET_ERROR</span>:
		<span class="n">dhr</span><span class="o">-&gt;</span><span class="n">dccph_reset_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rxdh</span><span class="o">-&gt;</span><span class="n">dccph_type</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DCCP_RESET_CODE_OPTION_ERROR</span>:	<span class="cm">/* fall through */</span>
	<span class="k">case</span> <span class="n">DCCP_RESET_CODE_MANDATORY_ERROR</span>:
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dhr</span><span class="o">-&gt;</span><span class="n">dccph_reset_data</span><span class="p">,</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_reset_data</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * From RFC 4340, 8.3.1:</span>
<span class="cm">	 *   If P.ackno exists, set R.seqno := P.ackno + 1.</span>
<span class="cm">	 *   Else set R.seqno := 0.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_ack_seq</span> <span class="o">!=</span> <span class="n">DCCP_PKT_WITHOUT_ACK_SEQ</span><span class="p">)</span>
		<span class="n">dccp_hdr_set_seq</span><span class="p">(</span><span class="n">dh</span><span class="p">,</span> <span class="n">ADD48</span><span class="p">(</span><span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_ack_seq</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">dccp_hdr_set_ack</span><span class="p">(</span><span class="n">dccp_hdr_ack_bits</span><span class="p">(</span><span class="n">skb</span><span class="p">),</span> <span class="n">dcb</span><span class="o">-&gt;</span><span class="n">dccpd_seq</span><span class="p">);</span>

	<span class="n">dccp_csum_outgoing</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">skb</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dccp_ctl_make_reset</span><span class="p">);</span>

<span class="cm">/* send Reset on established socket, to close or abort the connection */</span>
<span class="kt">int</span> <span class="nf">dccp_send_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">enum</span> <span class="n">dccp_reset_codes</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * FIXME: what if rebuild_header fails?</span>
<span class="cm">	 * Should we be doing a rebuild_header here?</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_af_ops</span><span class="o">-&gt;</span><span class="n">rebuild_header</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">sock_wmalloc</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="cm">/* Reserve space for headers and prepare control bits. */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">);</span>
	<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_type</span>	   <span class="o">=</span> <span class="n">DCCP_PKT_RESET</span><span class="p">;</span>
	<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_reset_code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dccp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Do all connect socket setups that can be done AF independent.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dccp_connect</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dst_entry</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">__sk_dst_get</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inet_connection_sock</span> <span class="o">*</span><span class="n">icsk</span> <span class="o">=</span> <span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>

	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sock_reset_flag</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_DONE</span><span class="p">);</span>

	<span class="n">dccp_sync_mss</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dst_mtu</span><span class="p">(</span><span class="n">dst</span><span class="p">));</span>

	<span class="cm">/* do not connect if feature negotiation setup fails */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dccp_feat_finalise_settings</span><span class="p">(</span><span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">;</span>

	<span class="cm">/* Initialise GAR as per 8.5; AWL/AWH are set in dccp_transmit_skb() */</span>
	<span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_gar</span> <span class="o">=</span> <span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_iss</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="cm">/* Reserve space for headers. */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">);</span>

	<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_type</span> <span class="o">=</span> <span class="n">DCCP_PKT_REQUEST</span><span class="p">;</span>

	<span class="n">dccp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">dccp_skb_entail</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">));</span>
	<span class="n">DCCP_INC_STATS</span><span class="p">(</span><span class="n">DCCP_MIB_ACTIVEOPENS</span><span class="p">);</span>

	<span class="cm">/* Timer for repeating the REQUEST until an answer. */</span>
	<span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_retransmits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_RETRANS</span><span class="p">,</span>
				  <span class="n">icsk</span><span class="o">-&gt;</span><span class="n">icsk_rto</span><span class="p">,</span> <span class="n">DCCP_RTO_MAX</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dccp_connect</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">dccp_send_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If we have been reset, we may not send again. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">DCCP_CLOSED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">,</span>
						<span class="n">GFP_ATOMIC</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inet_csk_schedule_ack</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
			<span class="n">inet_csk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">icsk_ack</span><span class="p">.</span><span class="n">ato</span> <span class="o">=</span> <span class="n">TCP_ATO_MIN</span><span class="p">;</span>
			<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_DACK</span><span class="p">,</span>
						  <span class="n">TCP_DELACK_MAX</span><span class="p">,</span>
						  <span class="n">DCCP_RTO_MAX</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Reserve space for headers */</span>
		<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">);</span>
		<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_type</span> <span class="o">=</span> <span class="n">DCCP_PKT_ACK</span><span class="p">;</span>
		<span class="n">dccp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dccp_send_ack</span><span class="p">);</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/* FIXME: Is this still necessary (11.3) - currently nowhere used by DCCP. */</span>
<span class="c">void dccp_send_delayed_ack(struct sock *sk)</span>
<span class="c">{</span>
<span class="c">	struct inet_connection_sock *icsk = inet_csk(sk);</span>
<span class="c">	/*</span>
<span class="c">	 * FIXME: tune this timer. elapsed time fixes the skew, so no problem</span>
<span class="c">	 * with using 2s, and active senders also piggyback the ACK into a</span>
<span class="c">	 * DATAACK packet, so this is really for quiescent senders.</span>
<span class="c">	 */</span>
<span class="c">	unsigned long timeout = jiffies + 2 * HZ;</span>

<span class="c">	/* Use new timeout only if there wasn&#39;t a older one earlier. */</span>
<span class="c">	if (icsk-&gt;icsk_ack.pending &amp; ICSK_ACK_TIMER) {</span>
<span class="c">		/* If delack timer was blocked or is about to expire,</span>
<span class="c">		 * send ACK now.</span>
<span class="c">		 *</span>
<span class="c">		 * FIXME: check the &quot;about to expire&quot; part</span>
<span class="c">		 */</span>
<span class="c">		if (icsk-&gt;icsk_ack.blocked) {</span>
<span class="c">			dccp_send_ack(sk);</span>
<span class="c">			return;</span>
<span class="c">		}</span>

<span class="c">		if (!time_before(timeout, icsk-&gt;icsk_ack.timeout))</span>
<span class="c">			timeout = icsk-&gt;icsk_ack.timeout;</span>
<span class="c">	}</span>
<span class="c">	icsk-&gt;icsk_ack.pending |= ICSK_ACK_SCHED | ICSK_ACK_TIMER;</span>
<span class="c">	icsk-&gt;icsk_ack.timeout = timeout;</span>
<span class="c">	sk_reset_timer(sk, &amp;icsk-&gt;icsk_delack_timer, timeout);</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">dccp_send_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="n">u64</span> <span class="n">ackno</span><span class="p">,</span>
		    <span class="k">const</span> <span class="k">enum</span> <span class="n">dccp_pkt_type</span> <span class="n">pkt_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We are not putting this on the write queue, so</span>
<span class="cm">	 * dccp_transmit_skb() will set the ownership to this</span>
<span class="cm">	 * sock.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME: how to make sure the sync is sent? */</span>
		<span class="n">DCCP_CRIT</span><span class="p">(</span><span class="s">&quot;could not send %s&quot;</span><span class="p">,</span> <span class="n">dccp_packet_name</span><span class="p">(</span><span class="n">pkt_type</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reserve space for headers and prepare control bits. */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">);</span>
	<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_type</span> <span class="o">=</span> <span class="n">pkt_type</span><span class="p">;</span>
	<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_ack_seq</span> <span class="o">=</span> <span class="n">ackno</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clear the flag in case the Sync was scheduled for out-of-band data,</span>
<span class="cm">	 * such as carrying a long Ack Vector.</span>
<span class="cm">	 */</span>
	<span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccps_sync_scheduled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dccp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dccp_send_sync</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Send a DCCP_PKT_CLOSE/CLOSEREQ. The caller locks the socket for us. This</span>
<span class="cm"> * cannot be allowed to fail queueing a DCCP_PKT_CLOSE/CLOSEREQ frame under</span>
<span class="cm"> * any circumstances.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">dccp_send_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">active</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dccp_sock</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">dccp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">gfp_t</span> <span class="n">prio</span> <span class="o">=</span> <span class="n">active</span> <span class="o">?</span> <span class="n">GFP_KERNEL</span> <span class="o">:</span> <span class="n">GFP_ATOMIC</span><span class="p">;</span>

	<span class="n">skb</span> <span class="o">=</span> <span class="n">alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">,</span> <span class="n">prio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">skb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Reserve space for headers and prepare control bits. */</span>
	<span class="n">skb_reserve</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">max_header</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_role</span> <span class="o">==</span> <span class="n">DCCP_ROLE_SERVER</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dccps_server_timewait</span><span class="p">)</span>
		<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_type</span> <span class="o">=</span> <span class="n">DCCP_PKT_CLOSEREQ</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">DCCP_SKB_CB</span><span class="p">(</span><span class="n">skb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dccpd_type</span> <span class="o">=</span> <span class="n">DCCP_PKT_CLOSE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">skb</span> <span class="o">=</span> <span class="n">dccp_skb_entail</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Retransmission timer for active-close: RFC 4340, 8.3 requires</span>
<span class="cm">		 * to retransmit the Close/CloseReq until the CLOSING/CLOSEREQ</span>
<span class="cm">		 * state can be left. The initial timeout is 2 RTTs.</span>
<span class="cm">		 * Since RTT measurement is done by the CCIDs, there is no easy</span>
<span class="cm">		 * way to get an RTT sample. The fallback RTT from RFC 4340, 3.4</span>
<span class="cm">		 * is too low (200ms); we use a high value to avoid unnecessary</span>
<span class="cm">		 * retransmissions when the link RTT is &gt; 0.2 seconds.</span>
<span class="cm">		 * FIXME: Let main module sample RTTs and use that instead.</span>
<span class="cm">		 */</span>
		<span class="n">inet_csk_reset_xmit_timer</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">ICSK_TIME_RETRANS</span><span class="p">,</span>
					  <span class="n">DCCP_TIMEOUT_INIT</span><span class="p">,</span> <span class="n">DCCP_RTO_MAX</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">dccp_transmit_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
