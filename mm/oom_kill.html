<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › oom_kill.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>oom_kill.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/mm/oom_kill.c</span>
<span class="cm"> * </span>
<span class="cm"> *  Copyright (C)  1998,2000  Rik van Riel</span>
<span class="cm"> *	Thanks go out to Claus Fischer for some serious inspiration and</span>
<span class="cm"> *	for goading me into coding this file...</span>
<span class="cm"> *  Copyright (C)  2010  Google, Inc.</span>
<span class="cm"> *	Rewritten by David Rientjes</span>
<span class="cm"> *</span>
<span class="cm"> *  The routines in this file are used to kill a process when</span>
<span class="cm"> *  we&#39;re seriously out of memory. This gets called from __alloc_pages()</span>
<span class="cm"> *  in mm/page_alloc.c when we really run out of memory.</span>
<span class="cm"> *</span>
<span class="cm"> *  Since we won&#39;t call these routines often (on a well-configured</span>
<span class="cm"> *  machine) this file will double as a &#39;coding guide&#39; and a signpost</span>
<span class="cm"> *  for newbie kernel hackers. It features several pointers to major</span>
<span class="cm"> *  kernel subsystems and hints as to where to find out what things do.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/oom.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/timex.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>
<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/ptrace.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/ftrace.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/oom.h&gt;</span>

<span class="kt">int</span> <span class="n">sysctl_panic_on_oom</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_oom_kill_allocating_task</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_oom_dump_tasks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">zone_scan_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * compare_swap_oom_score_adj() - compare and swap current&#39;s oom_score_adj</span>
<span class="cm"> * @old_val: old oom_score_adj for compare</span>
<span class="cm"> * @new_val: new oom_score_adj for swap</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the oom_score_adj value for current to @new_val iff its present value is</span>
<span class="cm"> * @old_val.  Usually used to reinstate a previous value to prevent racing with</span>
<span class="cm"> * userspacing tuning the value in the interim.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">compare_swap_oom_score_adj</span><span class="p">(</span><span class="kt">int</span> <span class="n">old_val</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sighand</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span> <span class="o">==</span> <span class="n">old_val</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
	<span class="n">trace_oom_score_adj_update</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * test_set_oom_score_adj() - set current&#39;s oom_score_adj and return old value</span>
<span class="cm"> * @new_val: new oom_score_adj value</span>
<span class="cm"> *</span>
<span class="cm"> * Sets the oom_score_adj value for current to @new_val with proper</span>
<span class="cm"> * synchronization and returns the old value.  Usually used to temporarily</span>
<span class="cm"> * set a value, save the old value in the caller, and then reinstate it later.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">test_set_oom_score_adj</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sighand</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_val</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>
	<span class="n">old_val</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
	<span class="n">trace_oom_score_adj_update</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">old_val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="cm">/**</span>
<span class="cm"> * has_intersects_mems_allowed() - check task eligiblity for kill</span>
<span class="cm"> * @tsk: task struct of which task to consider</span>
<span class="cm"> * @mask: nodemask passed to page allocator for mempolicy ooms</span>
<span class="cm"> *</span>
<span class="cm"> * Task eligibility is determined by whether or not a candidate task, @tsk,</span>
<span class="cm"> * shares the same mempolicy nodes as current if it is bound by such a policy</span>
<span class="cm"> * and whether or not it has the same set of allowed cpuset nodes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">has_intersects_mems_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">tsk</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If this is a mempolicy constrained oom, tsk&#39;s</span>
<span class="cm">			 * cpuset is irrelevant.  Only return true if its</span>
<span class="cm">			 * mempolicy intersects current, otherwise it may be</span>
<span class="cm">			 * needlessly killed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mempolicy_nodemask_intersects</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mask</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is not a mempolicy constrained oom, so only</span>
<span class="cm">			 * check the mems of tsk&#39;s cpuset.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpuset_mems_allowed_intersects</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">tsk</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">tsk</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">has_intersects_mems_allowed</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The process p may have detached its own -&gt;mm while exiting or through</span>
<span class="cm"> * use_mm(), but one or more of its subthreads may still have a valid</span>
<span class="cm"> * pointer.  Return p, or any of its subthreads with a valid -&gt;mm, with</span>
<span class="cm"> * task_lock() held.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">find_lock_task_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">task_lock</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">t</span><span class="p">;</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* return true if the task is not adequate as candidate victim task. */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">oom_unkillable_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_global_init</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_KTHREAD</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* When mem_cgroup_out_of_memory() and p is not member of the group */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">task_in_mem_cgroup</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">memcg</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* p may not have freeable memory in nodemask */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_intersects_mems_allowed</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * oom_badness - heuristic function to determine which candidate task to kill</span>
<span class="cm"> * @p: task struct of which task we should calculate</span>
<span class="cm"> * @totalpages: total present RAM allowed for page allocation</span>
<span class="cm"> *</span>
<span class="cm"> * The heuristic for determining which task to kill is made to be as simple and</span>
<span class="cm"> * predictable as possible.  The goal is to return the highest value for the</span>
<span class="cm"> * task consuming the most memory to avoid subsequent oom failures.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">oom_badness</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
			  <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">totalpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">points</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">adj</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oom_unkillable_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">find_lock_task_mm</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">adj</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adj</span> <span class="o">==</span> <span class="n">OOM_SCORE_ADJ_MIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The baseline for the badness score is the proportion of RAM that each</span>
<span class="cm">	 * task&#39;s rss, pagetable and swap space use.</span>
<span class="cm">	 */</span>
	<span class="n">points</span> <span class="o">=</span> <span class="n">get_mm_rss</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">nr_ptes</span> <span class="o">+</span>
		 <span class="n">get_mm_counter</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_SWAPENTS</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Root processes get 3% bonus, just like the __vm_enough_memory()</span>
<span class="cm">	 * implementation used by LSMs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">has_capability_noaudit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="n">adj</span> <span class="o">-=</span> <span class="mi">30</span><span class="p">;</span>

	<span class="cm">/* Normalize to oom_score_adj units */</span>
	<span class="n">adj</span> <span class="o">*=</span> <span class="n">totalpages</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">points</span> <span class="o">+=</span> <span class="n">adj</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Never return 0 for an eligible task regardless of the root bonus and</span>
<span class="cm">	 * oom_score_adj (oom_score_adj can&#39;t be OOM_SCORE_ADJ_MIN here).</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">points</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">points</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine the type of allocation constraint.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">oom_constraint</span> <span class="nf">constrained_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">totalpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">zone_type</span> <span class="n">high_zoneidx</span> <span class="o">=</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">cpuset_limited</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="cm">/* Default to all available memory */</span>
	<span class="o">*</span><span class="n">totalpages</span> <span class="o">=</span> <span class="n">totalram_pages</span> <span class="o">+</span> <span class="n">total_swap_pages</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zonelist</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CONSTRAINT_NONE</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Reach here only when __GFP_NOFAIL is used. So, we should avoid</span>
<span class="cm">	 * to kill current.We have to random task kill in this case.</span>
<span class="cm">	 * Hopefully, CONSTRAINT_THISNODE...but no way to handle it, now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_THISNODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CONSTRAINT_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is not a __GFP_THISNODE allocation, so a truncated nodemask in</span>
<span class="cm">	 * the page allocator means a mempolicy is in effect.  Cpuset policy</span>
<span class="cm">	 * is enforced in get_page_from_freelist().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nodemask</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nodes_subset</span><span class="p">(</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">],</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">totalpages</span> <span class="o">=</span> <span class="n">total_swap_pages</span><span class="p">;</span>
		<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span>
			<span class="o">*</span><span class="n">totalpages</span> <span class="o">+=</span> <span class="n">node_spanned_pages</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">CONSTRAINT_MEMORY_POLICY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check this allocation failure is caused by cpuset&#39;s wall function */</span>
	<span class="n">for_each_zone_zonelist_nodemask</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span>
			<span class="n">high_zoneidx</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cpuset_zone_allowed_softwall</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">))</span>
			<span class="n">cpuset_limited</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuset_limited</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">totalpages</span> <span class="o">=</span> <span class="n">total_swap_pages</span><span class="p">;</span>
		<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">cpuset_current_mems_allowed</span><span class="p">)</span>
			<span class="o">*</span><span class="n">totalpages</span> <span class="o">+=</span> <span class="n">node_spanned_pages</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">CONSTRAINT_CPUSET</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">CONSTRAINT_NONE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">oom_constraint</span> <span class="nf">constrained_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">totalpages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">totalpages</span> <span class="o">=</span> <span class="n">totalram_pages</span> <span class="o">+</span> <span class="n">total_swap_pages</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">CONSTRAINT_NONE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Simple selection loop. We chose the process with the highest</span>
<span class="cm"> * number of &#39;points&#39;. We expect the caller will lock the tasklist.</span>
<span class="cm"> *</span>
<span class="cm"> * (not docbooked, we don&#39;t want this one cluttering up the manual)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">select_bad_process</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ppoints</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">totalpages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
		<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force_kill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">chosen</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">chosen_points</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">do_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">points</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">exit_state</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oom_unkillable_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This task already has access to memory reserves and is</span>
<span class="cm">		 * being killed. Don&#39;t allow any other task access to the</span>
<span class="cm">		 * memory reserve.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note: this may have a chance of deadlock if it gets</span>
<span class="cm">		 * blocked waiting for another task which itself is waiting</span>
<span class="cm">		 * for memory. Is there a better alternative?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_tsk_thread_flag</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TIF_MEMDIE</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">frozen</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
				<span class="n">__thaw_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">force_kill</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="mi">1UL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If p is the current task and is in the process of</span>
<span class="cm">			 * releasing memory, we allow the &quot;kill&quot; to set</span>
<span class="cm">			 * TIF_MEMDIE, which will allow it to gain access to</span>
<span class="cm">			 * memory reserves.  Otherwise, it may stall forever.</span>
<span class="cm">			 *</span>
<span class="cm">			 * The loop isn&#39;t broken here, however, in case other</span>
<span class="cm">			 * threads are found to have already been oom killed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">chosen</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
				<span class="n">chosen_points</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">force_kill</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If this task is not being ptraced on exit,</span>
<span class="cm">				 * then wait for it to finish before killing</span>
<span class="cm">				 * some other task unnecessarily.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">ptrace</span> <span class="o">&amp;</span> <span class="n">PT_TRACE_EXIT</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="mi">1UL</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">points</span> <span class="o">=</span> <span class="n">oom_badness</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">,</span> <span class="n">totalpages</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">points</span> <span class="o">&gt;</span> <span class="n">chosen_points</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chosen</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="n">chosen_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ppoints</span> <span class="o">=</span> <span class="n">chosen_points</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">totalpages</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">chosen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dump_tasks - dump current memory state of all system tasks</span>
<span class="cm"> * @memcg: current&#39;s memory controller, if constrained</span>
<span class="cm"> * @nodemask: nodemask passed to page allocator for mempolicy ooms</span>
<span class="cm"> *</span>
<span class="cm"> * Dumps the current memory state of all eligible tasks.  Tasks not in the same</span>
<span class="cm"> * memcg, not in the same cpuset, or bound to a disjoint set of mempolicy nodes</span>
<span class="cm"> * are not shown.</span>
<span class="cm"> * State information includes task&#39;s pid, uid, tgid, vm size, rss, cpu, oom_adj</span>
<span class="cm"> * value, oom_score_adj value, and name.</span>
<span class="cm"> *</span>
<span class="cm"> * Call with tasklist_lock read-locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_tasks</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;[ pid ]   uid  tgid total_vm      rss cpu oom_adj oom_score_adj name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">for_each_process</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oom_unkillable_task</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">task</span> <span class="o">=</span> <span class="n">find_lock_task_mm</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This is a kthread or all of p&#39;s threads have already</span>
<span class="cm">			 * detached their mm&#39;s.  There&#39;s no need to report</span>
<span class="cm">			 * them; they can&#39;t be oom killed anyway.</span>
<span class="cm">			 */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;[%5d] %5d %5d %8lu %8lu %3u     %3d         %5d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">from_kuid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_user_ns</span><span class="p">,</span> <span class="n">task_uid</span><span class="p">(</span><span class="n">task</span><span class="p">)),</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span><span class="p">,</span> <span class="n">get_mm_rss</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">),</span>
			<span class="n">task_cpu</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_adj</span><span class="p">,</span>
			<span class="n">task</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">task_lock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;%s invoked oom-killer: gfp_mask=0x%x, order=%d, &quot;</span>
		<span class="s">&quot;oom_adj=%d, oom_score_adj=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_adj</span><span class="p">,</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span><span class="p">);</span>
	<span class="n">cpuset_print_task_mems_allowed</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
	<span class="n">mem_cgroup_print_oom_info</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">show_mem</span><span class="p">(</span><span class="n">SHOW_MEM_FILTER_NODES</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_oom_dump_tasks</span><span class="p">)</span>
		<span class="n">dump_tasks</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define K(x) ((x) &lt;&lt; (PAGE_SHIFT-10))</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">oom_kill_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">points</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">totalpages</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">victim</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">victim_points</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_RATELIMIT_STATE</span><span class="p">(</span><span class="n">oom_rs</span><span class="p">,</span> <span class="n">DEFAULT_RATELIMIT_INTERVAL</span><span class="p">,</span>
					      <span class="n">DEFAULT_RATELIMIT_BURST</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the task is already exiting, don&#39;t alarm the sysadmin or kill</span>
<span class="cm">	 * its children or threads, just set TIF_MEMDIE so it can die quickly</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_EXITING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_tsk_thread_flag</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TIF_MEMDIE</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oom_rs</span><span class="p">))</span>
		<span class="n">dump_header</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">);</span>

	<span class="n">task_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Kill process %d (%s) score %d or sacrifice child</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">message</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">points</span><span class="p">);</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If any of p&#39;s children has a different mm and is eligible for kill,</span>
<span class="cm">	 * the one with the highest oom_badness() score is sacrificed for its</span>
<span class="cm">	 * parent.  This attempts to lose the minimal amount of work done while</span>
<span class="cm">	 * still freeing memory.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">,</span> <span class="n">sibling</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">child_points</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * oom_badness() returns 0 if the thread is unkillable</span>
<span class="cm">			 */</span>
			<span class="n">child_points</span> <span class="o">=</span> <span class="n">oom_badness</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">,</span>
								<span class="n">totalpages</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">child_points</span> <span class="o">&gt;</span> <span class="n">victim_points</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">victim</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
				<span class="n">victim_points</span> <span class="o">=</span> <span class="n">child_points</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="n">while_each_thread</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

	<span class="n">victim</span> <span class="o">=</span> <span class="n">find_lock_task_mm</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* mm cannot safely be dereferenced after task_unlock(victim) */</span>
	<span class="n">mm</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">victim</span><span class="p">),</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">K</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span><span class="p">),</span>
		<span class="n">K</span><span class="p">(</span><span class="n">get_mm_counter</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">)),</span>
		<span class="n">K</span><span class="p">(</span><span class="n">get_mm_counter</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_FILEPAGES</span><span class="p">)));</span>
	<span class="n">task_unlock</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Kill all user processes sharing victim-&gt;mm in other thread groups, if</span>
<span class="cm">	 * any.  They don&#39;t get access to memory reserves, though, to avoid</span>
<span class="cm">	 * depletion of all memory.  This prevents mm-&gt;mmap_sem livelock when an</span>
<span class="cm">	 * oom killed thread cannot exit because it requires the semaphore and</span>
<span class="cm">	 * its contended by another thread trying to allocate memory itself.</span>
<span class="cm">	 * That thread will now get access to memory reserves since it has a</span>
<span class="cm">	 * pending fatal signal.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_process</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">mm</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">same_thread_group</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">victim</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_KTHREAD</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">oom_score_adj</span> <span class="o">==</span> <span class="n">OOM_SCORE_ADJ_MIN</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">task_lock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>	<span class="cm">/* Protect -&gt;comm from prctl() */</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Kill process %d (%s) sharing same memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">task_pid_nr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
			<span class="n">task_unlock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">do_send_sig_info</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">SEND_SIG_FORCED</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">set_tsk_thread_flag</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">TIF_MEMDIE</span><span class="p">);</span>
	<span class="n">do_send_sig_info</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">SEND_SIG_FORCED</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#undef K</span>

<span class="cm">/*</span>
<span class="cm"> * Determines whether the kernel must panic because of the panic_on_oom sysctl.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_panic_on_oom</span><span class="p">(</span><span class="k">enum</span> <span class="n">oom_constraint</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">sysctl_panic_on_oom</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_panic_on_oom</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * panic_on_oom == 1 only affects CONSTRAINT_NONE, the kernel</span>
<span class="cm">		 * does not panic for cpuset, mempolicy, or memcg allocation</span>
<span class="cm">		 * failures.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">constraint</span> <span class="o">!=</span> <span class="n">CONSTRAINT_NONE</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">dump_header</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Out of memory: %s panic_on_oom is enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">sysctl_panic_on_oom</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">?</span> <span class="s">&quot;compulsory&quot;</span> <span class="o">:</span> <span class="s">&quot;system-wide&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR</span>
<span class="kt">void</span> <span class="nf">mem_cgroup_out_of_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">points</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If current has a pending SIGKILL, then automatically select it.  The</span>
<span class="cm">	 * goal is to allow it to allocate so that it may quickly exit and free</span>
<span class="cm">	 * its memory.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_MEMDIE</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">check_panic_on_oom</span><span class="p">(</span><span class="n">CONSTRAINT_MEMCG</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="n">mem_cgroup_get_limit</span><span class="p">(</span><span class="n">memcg</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span> <span class="o">?</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">select_bad_process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">points</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1UL</span><span class="p">)</span>
		<span class="n">oom_kill_process</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="s">&quot;Memory cgroup out of memory&quot;</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">BLOCKING_NOTIFIER_HEAD</span><span class="p">(</span><span class="n">oom_notify_list</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">register_oom_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oom_notify_list</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">register_oom_notifier</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">unregister_oom_notifier</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blocking_notifier_chain_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oom_notify_list</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unregister_oom_notifier</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Try to acquire the OOM killer lock for the zones in zonelist.  Returns zero</span>
<span class="cm"> * if a parallel OOM killing is already taking place that includes a zone in</span>
<span class="cm"> * the zonelist.  Otherwise, locks all zones in the zonelist and returns 1.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">try_set_zonelist_oom</span><span class="p">(</span><span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone_scan_lock</span><span class="p">);</span>
	<span class="n">for_each_zone_zonelist</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zone_is_oom_locked</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">for_each_zone_zonelist</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Lock each zone in the zonelist under zone_scan_lock so a</span>
<span class="cm">		 * parallel invocation of try_set_zonelist_oom() doesn&#39;t succeed</span>
<span class="cm">		 * when it shouldn&#39;t.</span>
<span class="cm">		 */</span>
		<span class="n">zone_set_flag</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">ZONE_OOM_LOCKED</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone_scan_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clears the ZONE_OOM_LOCKED flag for all zones in the zonelist so that failed</span>
<span class="cm"> * allocation attempts with zonelists containing them may now recall the OOM</span>
<span class="cm"> * killer, if necessary.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">clear_zonelist_oom</span><span class="p">(</span><span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone_scan_lock</span><span class="p">);</span>
	<span class="n">for_each_zone_zonelist</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">zone_clear_flag</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">ZONE_OOM_LOCKED</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone_scan_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to acquire the oom killer lock for all system zones.  Returns zero if a</span>
<span class="cm"> * parallel oom killing is taking place, otherwise locks all zones and returns</span>
<span class="cm"> * non-zero.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_set_system_oom</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone_scan_lock</span><span class="p">);</span>
	<span class="n">for_each_populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zone_is_oom_locked</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="n">for_each_populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span>
		<span class="n">zone_set_flag</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">ZONE_OOM_LOCKED</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone_scan_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clears ZONE_OOM_LOCKED for all system zones so that failed allocation</span>
<span class="cm"> * attempts or page faults may now recall the oom killer, if necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_system_oom</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone_scan_lock</span><span class="p">);</span>
	<span class="n">for_each_populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span>
		<span class="n">zone_clear_flag</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">ZONE_OOM_LOCKED</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone_scan_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * out_of_memory - kill the &quot;best&quot; process when we run out of memory</span>
<span class="cm"> * @zonelist: zonelist pointer</span>
<span class="cm"> * @gfp_mask: memory allocation flags</span>
<span class="cm"> * @order: amount of memory being requested as a power of 2</span>
<span class="cm"> * @nodemask: nodemask passed to page allocator</span>
<span class="cm"> * @force_kill: true if a task must be killed, even if others are exiting</span>
<span class="cm"> *</span>
<span class="cm"> * If we run out of memory, we have the choice between either</span>
<span class="cm"> * killing a random task (bad), letting the system crash (worse)</span>
<span class="cm"> * OR try to be smart about which process to kill. Note that we</span>
<span class="cm"> * don&#39;t have to be perfect here, we just have to be good.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">out_of_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force_kill</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">mpol_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">totalpages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">points</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">oom_constraint</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">CONSTRAINT_NONE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">killed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">blocking_notifier_call_chain</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oom_notify_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">freed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Got some memory back in the last second. */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If current has a pending SIGKILL, then automatically select it.  The</span>
<span class="cm">	 * goal is to allow it to allocate so that it may quickly exit and free</span>
<span class="cm">	 * its memory.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_thread_flag</span><span class="p">(</span><span class="n">TIF_MEMDIE</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if there were limitations on the allocation (only relevant for</span>
<span class="cm">	 * NUMA) that may require different handling.</span>
<span class="cm">	 */</span>
	<span class="n">constraint</span> <span class="o">=</span> <span class="n">constrained_alloc</span><span class="p">(</span><span class="n">zonelist</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">totalpages</span><span class="p">);</span>
	<span class="n">mpol_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">constraint</span> <span class="o">==</span> <span class="n">CONSTRAINT_MEMORY_POLICY</span><span class="p">)</span> <span class="o">?</span> <span class="n">nodemask</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">check_panic_on_oom</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">mpol_mask</span><span class="p">);</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_oom_kill_allocating_task</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">oom_unkillable_task</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oom_kill_process</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">totalpages</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="n">nodemask</span><span class="p">,</span>
				 <span class="s">&quot;Out of memory (oom_kill_allocating_task)&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">select_bad_process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">points</span><span class="p">,</span> <span class="n">totalpages</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mpol_mask</span><span class="p">,</span>
			       <span class="n">force_kill</span><span class="p">);</span>
	<span class="cm">/* Found nothing?!?! Either we hang forever, or we panic. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dump_header</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mpol_mask</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Out of memory and no killable processes...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1UL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">oom_kill_process</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">totalpages</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				 <span class="n">nodemask</span><span class="p">,</span> <span class="s">&quot;Out of memory&quot;</span><span class="p">);</span>
		<span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklist_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Give &quot;p&quot; a good chance of killing itself before we</span>
<span class="cm">	 * retry to allocate memory unless &quot;p&quot; is current</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">killed</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_MEMDIE</span><span class="p">))</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The pagefault handler calls here because it is out of memory, so kill a</span>
<span class="cm"> * memory-hogging task.  If a populated zone has ZONE_OOM_LOCKED set, a parallel</span>
<span class="cm"> * oom killing is already in progress so do nothing.  If a task is found with</span>
<span class="cm"> * TIF_MEMDIE set, it has been killed so do nothing and allow it to exit.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pagefault_out_of_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">try_set_system_oom</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">out_of_memory</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">clear_system_oom</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_MEMDIE</span><span class="p">))</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
