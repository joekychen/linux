<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › ksm.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>ksm.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Memory merging support.</span>
<span class="cm"> *</span>
<span class="cm"> * This code enables dynamic sharing of identical pages found in different</span>
<span class="cm"> * memory areas, even if they are not shared by fork()</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008-2009 Red Hat, Inc.</span>
<span class="cm"> * Authors:</span>
<span class="cm"> *	Izik Eidus</span>
<span class="cm"> *	Andrea Arcangeli</span>
<span class="cm"> *	Chris Wright</span>
<span class="cm"> *	Hugh Dickins</span>
<span class="cm"> *</span>
<span class="cm"> * This work is licensed under the terms of the GNU GPL, version 2.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/jhash.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/memory.h&gt;</span>
<span class="cp">#include &lt;linux/mmu_notifier.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/ksm.h&gt;</span>
<span class="cp">#include &lt;linux/hash.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/oom.h&gt;</span>

<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * A few notes about the KSM scanning process,</span>
<span class="cm"> * to make it easier to understand the data structures below:</span>
<span class="cm"> *</span>
<span class="cm"> * In order to reduce excessive scanning, KSM sorts the memory pages by their</span>
<span class="cm"> * contents into a data structure that holds pointers to the pages&#39; locations.</span>
<span class="cm"> *</span>
<span class="cm"> * Since the contents of the pages may change at any moment, KSM cannot just</span>
<span class="cm"> * insert the pages into a normal sorted tree and expect it to find anything.</span>
<span class="cm"> * Therefore KSM uses two data structures - the stable and the unstable tree.</span>
<span class="cm"> *</span>
<span class="cm"> * The stable tree holds pointers to all the merged pages (ksm pages), sorted</span>
<span class="cm"> * by their contents.  Because each such page is write-protected, searching on</span>
<span class="cm"> * this tree is fully assured to be working (except when pages are unmapped),</span>
<span class="cm"> * and therefore this tree is called the stable tree.</span>
<span class="cm"> *</span>
<span class="cm"> * In addition to the stable tree, KSM uses a second data structure called the</span>
<span class="cm"> * unstable tree: this tree holds pointers to pages which have been found to</span>
<span class="cm"> * be &quot;unchanged for a period of time&quot;.  The unstable tree sorts these pages</span>
<span class="cm"> * by their contents, but since they are not write-protected, KSM cannot rely</span>
<span class="cm"> * upon the unstable tree to work correctly - the unstable tree is liable to</span>
<span class="cm"> * be corrupted as its contents are modified, and so it is called unstable.</span>
<span class="cm"> *</span>
<span class="cm"> * KSM solves this problem by several techniques:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) The unstable tree is flushed every time KSM completes scanning all</span>
<span class="cm"> *    memory areas, and then the tree is rebuilt again from the beginning.</span>
<span class="cm"> * 2) KSM will only insert into the unstable tree, pages whose hash value</span>
<span class="cm"> *    has not changed since the previous scan of all memory areas.</span>
<span class="cm"> * 3) The unstable tree is a RedBlack Tree - so its balancing is based on the</span>
<span class="cm"> *    colors of the nodes and not on their contents, assuring that even when</span>
<span class="cm"> *    the tree gets &quot;corrupted&quot; it won&#39;t get out of balance, so scanning time</span>
<span class="cm"> *    remains the same (also, searching and inserting nodes in an rbtree uses</span>
<span class="cm"> *    the same algorithm, so we have no overhead when we flush and rebuild).</span>
<span class="cm"> * 4) KSM never flushes the stable tree, which means that even if it were to</span>
<span class="cm"> *    take 10 attempts to find a page in the unstable tree, once it is found,</span>
<span class="cm"> *    it is secured in the stable tree.  (When we scan a new page, we first</span>
<span class="cm"> *    compare it against the stable tree, and then against the unstable tree.)</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * struct mm_slot - ksm information per mm that is being scanned</span>
<span class="cm"> * @link: link to the mm_slots hash list</span>
<span class="cm"> * @mm_list: link into the mm_slots list, rooted in ksm_mm_head</span>
<span class="cm"> * @rmap_list: head for this mm_slot&#39;s singly-linked list of rmap_items</span>
<span class="cm"> * @mm: the mm that this information is valid for</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mm_slot</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">mm_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ksm_scan - cursor for scanning</span>
<span class="cm"> * @mm_slot: the current mm_slot we are scanning</span>
<span class="cm"> * @address: the next address inside that to be scanned</span>
<span class="cm"> * @rmap_list: link to the next rmap to be scanned in the rmap_list</span>
<span class="cm"> * @seqnr: count of completed full scans (needed when removing unstable node)</span>
<span class="cm"> *</span>
<span class="cm"> * There is only the one ksm_scan instance of this cursor structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ksm_scan</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">**</span><span class="n">rmap_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seqnr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct stable_node - node of the stable rbtree</span>
<span class="cm"> * @node: rb node of this ksm page in the stable tree</span>
<span class="cm"> * @hlist: hlist head of rmap_items using this ksm page</span>
<span class="cm"> * @kpfn: page frame number of this ksm page</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">stable_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">hlist</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kpfn</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct rmap_item - reverse mapping item for virtual addresses</span>
<span class="cm"> * @rmap_list: next rmap_item in mm_slot&#39;s singly-linked rmap_list</span>
<span class="cm"> * @anon_vma: pointer to anon_vma for this mm,address, when in stable tree</span>
<span class="cm"> * @mm: the memory structure this rmap_item is pointing into</span>
<span class="cm"> * @address: the virtual address this rmap_item tracks (+ flags in low bits)</span>
<span class="cm"> * @oldchecksum: previous checksum of the page at that virtual address</span>
<span class="cm"> * @node: rb node of this rmap_item in the unstable tree</span>
<span class="cm"> * @head: pointer to stable_node heading this list in the stable tree</span>
<span class="cm"> * @hlist: link into hlist of rmap_items hanging off that stable_node</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">rmap_item</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">;</span>	<span class="cm">/* when stable */</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>		<span class="cm">/* + low bits used for flags below */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oldchecksum</span><span class="p">;</span>	<span class="cm">/* when unstable */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">node</span><span class="p">;</span>	<span class="cm">/* when node of unstable tree */</span>
		<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* when listed from stable tree */</span>
			<span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hlist</span><span class="p">;</span>
		<span class="p">};</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="cp">#define SEQNR_MASK	0x0ff	</span><span class="cm">/* low bits of unstable tree seqnr */</span><span class="cp"></span>
<span class="cp">#define UNSTABLE_FLAG	0x100	</span><span class="cm">/* is a node of the unstable tree */</span><span class="cp"></span>
<span class="cp">#define STABLE_FLAG	0x200	</span><span class="cm">/* is listed from the stable tree */</span><span class="cp"></span>

<span class="cm">/* The stable and unstable tree heads */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">root_stable_tree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">root_unstable_tree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>

<span class="cp">#define MM_SLOTS_HASH_SHIFT 10</span>
<span class="cp">#define MM_SLOTS_HASH_HEADS (1 &lt;&lt; MM_SLOTS_HASH_SHIFT)</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">mm_slots_hash</span><span class="p">[</span><span class="n">MM_SLOTS_HASH_HEADS</span><span class="p">];</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mm_slot</span> <span class="n">ksm_mm_head</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mm_list</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">ksm_mm_head</span><span class="p">.</span><span class="n">mm_list</span><span class="p">),</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ksm_scan</span> <span class="n">ksm_scan</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">mm_slot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ksm_mm_head</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">rmap_item_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">stable_node_cache</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">mm_slot_cache</span><span class="p">;</span>

<span class="cm">/* The number of nodes in the stable tree */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ksm_pages_shared</span><span class="p">;</span>

<span class="cm">/* The number of page slots additionally sharing those nodes */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ksm_pages_sharing</span><span class="p">;</span>

<span class="cm">/* The number of nodes in the unstable tree */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ksm_pages_unshared</span><span class="p">;</span>

<span class="cm">/* The number of rmap_items in use: to calculate pages_volatile */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ksm_rmap_items</span><span class="p">;</span>

<span class="cm">/* Number of pages ksmd should scan in one batch */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ksm_thread_pages_to_scan</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="cm">/* Milliseconds ksmd should sleep between batches */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ksm_thread_sleep_millisecs</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="cp">#define KSM_RUN_STOP	0</span>
<span class="cp">#define KSM_RUN_MERGE	1</span>
<span class="cp">#define KSM_RUN_UNMERGE	2</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ksm_run</span> <span class="o">=</span> <span class="n">KSM_RUN_STOP</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">ksm_thread_wait</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">ksm_thread_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>

<span class="cp">#define KSM_KMEM_CACHE(__struct, __flags) kmem_cache_create(&quot;ksm_&quot;#__struct,\</span>
<span class="cp">		sizeof(struct __struct), __alignof__(struct __struct),\</span>
<span class="cp">		(__flags), NULL)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ksm_slab_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rmap_item_cache</span> <span class="o">=</span> <span class="n">KSM_KMEM_CACHE</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmap_item_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">stable_node_cache</span> <span class="o">=</span> <span class="n">KSM_KMEM_CACHE</span><span class="p">(</span><span class="n">stable_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stable_node_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free1</span><span class="p">;</span>

	<span class="n">mm_slot_cache</span> <span class="o">=</span> <span class="n">KSM_KMEM_CACHE</span><span class="p">(</span><span class="n">mm_slot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_slot_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free2</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free2:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">stable_node_cache</span><span class="p">);</span>
<span class="nl">out_free1:</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">rmap_item_cache</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">ksm_slab_free</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">mm_slot_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">stable_node_cache</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">rmap_item_cache</span><span class="p">);</span>
	<span class="n">mm_slot_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="nf">alloc_rmap_item</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">;</span>

	<span class="n">rmap_item</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">rmap_item_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="p">)</span>
		<span class="n">ksm_rmap_items</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rmap_item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_rmap_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ksm_rmap_items</span><span class="o">--</span><span class="p">;</span>
	<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* debug safety */</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">rmap_item_cache</span><span class="p">,</span> <span class="n">rmap_item</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="nf">alloc_stable_node</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">stable_node_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_stable_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">stable_node_cache</span><span class="p">,</span> <span class="n">stable_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="nf">alloc_mm_slot</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_slot_cache</span><span class="p">)</span>	<span class="cm">/* initialization failed */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">mm_slot_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_mm_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">mm_slot_cache</span><span class="p">,</span> <span class="n">mm_slot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="nf">get_mm_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">bucket</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm_slots_hash</span><span class="p">[</span><span class="n">hash_ptr</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_SLOTS_HASH_SHIFT</span><span class="p">)];</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">mm_slot</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">==</span> <span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">mm_slot</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_to_mm_slots_hash</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">bucket</span><span class="p">;</span>

	<span class="n">bucket</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm_slots_hash</span><span class="p">[</span><span class="n">hash_ptr</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_SLOTS_HASH_SHIFT</span><span class="p">)];</span>
	<span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">bucket</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">in_stable_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">STABLE_FLAG</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * ksmd, and unmerge_and_remove_all_rmap_items(), must not touch an mm&#39;s</span>
<span class="cm"> * page tables after it has passed through ksm_exit() - which, if necessary,</span>
<span class="cm"> * takes mmap_sem briefly to serialize against them.  ksm_exit() does not set</span>
<span class="cm"> * a special flag: they can just back out as soon as mm_users goes to zero.</span>
<span class="cm"> * ksm_test_exit() is used throughout to make this test for exit: in some</span>
<span class="cm"> * places for correctness, in some places just to avoid unnecessary work.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">ksm_test_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We use break_ksm to break COW on a ksm page: it&#39;s a stripped down</span>
<span class="cm"> *</span>
<span class="cm"> *	if (get_user_pages(current, mm, addr, 1, 1, 1, &amp;page, NULL) == 1)</span>
<span class="cm"> *		put_page(page);</span>
<span class="cm"> *</span>
<span class="cm"> * but taking great care only to touch a ksm page, in a VM_MERGEABLE vma,</span>
<span class="cm"> * in case the application has unmapped and remapped mm,addr meanwhile.</span>
<span class="cm"> * Could a ksm page appear anywhere else?  Actually yes, in a VM_PFNMAP</span>
<span class="cm"> * mmap of /dev/mem or /dev/kmem, where we would not want to touch it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">break_ksm</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">follow_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">FOLL_GET</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">handle_mm_fault</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
							<span class="n">FAULT_FLAG_WRITE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_WRITE</span><span class="p">;</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_FAULT_WRITE</span> <span class="o">|</span> <span class="n">VM_FAULT_SIGBUS</span> <span class="o">|</span> <span class="n">VM_FAULT_OOM</span><span class="p">)));</span>
	<span class="cm">/*</span>
<span class="cm">	 * We must loop because handle_mm_fault() may back out if there&#39;s</span>
<span class="cm">	 * any difficulty e.g. if pte accessed bit gets updated concurrently.</span>
<span class="cm">	 *</span>
<span class="cm">	 * VM_FAULT_WRITE is what we have been hoping for: it indicates that</span>
<span class="cm">	 * COW has been broken, even if the vma does not permit VM_WRITE;</span>
<span class="cm">	 * but note that a concurrent fault might break PageKsm for us.</span>
<span class="cm">	 *</span>
<span class="cm">	 * VM_FAULT_SIGBUS could occur if we race with truncation of the</span>
<span class="cm">	 * backing file, which also invalidates anonymous pages: that&#39;s</span>
<span class="cm">	 * okay, that truncation will have unmapped the PageKsm for us.</span>
<span class="cm">	 *</span>
<span class="cm">	 * VM_FAULT_OOM: at the time of writing (late July 2009), setting</span>
<span class="cm">	 * aside mem_cgroup limits, VM_FAULT_OOM would only be set if the</span>
<span class="cm">	 * current task has TIF_MEMDIE set, and will be OOM killed on return</span>
<span class="cm">	 * to user; and ksmd, having no mm, would never be chosen for that.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But if the mm is in a limited mem_cgroup, then the fault may fail</span>
<span class="cm">	 * with VM_FAULT_OOM even if the current task is not TIF_MEMDIE; and</span>
<span class="cm">	 * even ksmd can fail in this way - though it&#39;s usually breaking ksm</span>
<span class="cm">	 * just to undo a merge it made a moment before, so unlikely to oom.</span>
<span class="cm">	 *</span>
<span class="cm">	 * That&#39;s a pity: we might therefore have more kernel pages allocated</span>
<span class="cm">	 * than we&#39;re counting as nodes in the stable tree; but ksm_do_scan</span>
<span class="cm">	 * will retry to break_cow on each pass, so should recover the page</span>
<span class="cm">	 * in due course.  The important thing is to not let VM_MERGEABLE</span>
<span class="cm">	 * be cleared while any such pages might remain in the area.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_OOM</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">find_mergeable_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ksm_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MERGEABLE</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">break_cow</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is not an accident that whenever we want to break COW</span>
<span class="cm">	 * to undo, we also need to drop a reference to the anon_vma.</span>
<span class="cm">	 */</span>
	<span class="n">put_anon_vma</span><span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_mergeable_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
		<span class="n">break_ksm</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">page_trans_compound_anon</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageTransCompound</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">compound_trans_head</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * head may actually be splitted and freed from under</span>
<span class="cm">		 * us but it&#39;s ok here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">head</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">head</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">get_mergeable_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_mergeable_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">follow_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">FOLL_GET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">page_trans_compound_anon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">flush_anon_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>		<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_node_from_stable_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">hlist</span><span class="p">;</span>

	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">,</span> <span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">.</span><span class="n">next</span><span class="p">)</span>
			<span class="n">ksm_pages_sharing</span><span class="o">--</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ksm_pages_shared</span><span class="o">--</span><span class="p">;</span>
		<span class="n">put_anon_vma</span><span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_stable_tree</span><span class="p">);</span>
	<span class="n">free_stable_node</span><span class="p">(</span><span class="n">stable_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get_ksm_page: checks if the page indicated by the stable node</span>
<span class="cm"> * is still its ksm page, despite having held no reference to it.</span>
<span class="cm"> * In which case we can trust the content of the page, and it</span>
<span class="cm"> * returns the gotten page; but if the page has now been zapped,</span>
<span class="cm"> * remove the stale node from the stable tree and return NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * You would expect the stable_node to hold a reference to the ksm page.</span>
<span class="cm"> * But if it increments the page&#39;s count, swapping out has to wait for</span>
<span class="cm"> * ksmd to come around again before it can free the page, which may take</span>
<span class="cm"> * seconds or even minutes: much too unresponsive.  So instead we use a</span>
<span class="cm"> * &quot;keyhole reference&quot;: access to the ksm page from the stable node peeps</span>
<span class="cm"> * out through its keyhole to see if that page still holds the right key,</span>
<span class="cm"> * pointing back to this stable node.  This relies on freeing a PageAnon</span>
<span class="cm"> * page to reset its page-&gt;mapping to NULL, and relies on no other use of</span>
<span class="cm"> * a page to put something that might look like our key in page-&gt;mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * include/linux/pagemap.h page_cache_get_speculative() is a good reference,</span>
<span class="cm"> * but this is different - made simpler by ksm_thread_mutex being held, but</span>
<span class="cm"> * interesting for assuming that no other use of the struct page could ever</span>
<span class="cm"> * put our expected_mapping into page-&gt;mapping (or a field of the union which</span>
<span class="cm"> * coincides with page-&gt;mapping).  The RCU calls are not for KSM at all, but</span>
<span class="cm"> * to keep the page_count protocol described with page_cache_get_speculative.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: it is possible that get_ksm_page() will return NULL one moment,</span>
<span class="cm"> * then page the next, if the page is in between page_freeze_refs() and</span>
<span class="cm"> * page_unfreeze_refs(): this shouldn&#39;t be a problem anywhere, the page</span>
<span class="cm"> * is on its way to being freed; but it is an anomaly to bear in mind.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">get_ksm_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">expected_mapping</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">kpfn</span><span class="p">);</span>
	<span class="n">expected_mapping</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">stable_node</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">PAGE_MAPPING_ANON</span> <span class="o">|</span> <span class="n">PAGE_MAPPING_KSM</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">expected_mapping</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">stale</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_page_unless_zero</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">stale</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">expected_mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">stale</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="nl">stale:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">remove_node_from_stable_tree</span><span class="p">(</span><span class="n">stable_node</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Removing rmap_item from stable or unstable tree.</span>
<span class="cm"> * This function will clean the information from the stable/unstable tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_rmap_item_from_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">STABLE_FLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="n">stable_node</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">get_ksm_page</span><span class="p">(</span><span class="n">stable_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
			<span class="n">ksm_pages_sharing</span><span class="o">--</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ksm_pages_shared</span><span class="o">--</span><span class="p">;</span>

		<span class="n">put_anon_vma</span><span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">UNSTABLE_FLAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">age</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Usually ksmd can and must skip the rb_erase, because</span>
<span class="cm">		 * root_unstable_tree was already reset to RB_ROOT.</span>
<span class="cm">		 * But be careful when an mm is exiting: do the rb_erase</span>
<span class="cm">		 * if this rmap_item was inserted by this scan, rather</span>
<span class="cm">		 * than left over from before.</span>
<span class="cm">		 */</span>
		<span class="n">age</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">ksm_scan</span><span class="p">.</span><span class="n">seqnr</span> <span class="o">-</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">age</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">age</span><span class="p">)</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_unstable_tree</span><span class="p">);</span>

		<span class="n">ksm_pages_unshared</span><span class="o">--</span><span class="p">;</span>
		<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&amp;=</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">cond_resched</span><span class="p">();</span>		<span class="cm">/* we&#39;re called from many long loops */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_trailing_rmap_items</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">**</span><span class="n">rmap_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">rmap_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span> <span class="o">=</span> <span class="o">*</span><span class="n">rmap_list</span><span class="p">;</span>
		<span class="o">*</span><span class="n">rmap_list</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">rmap_list</span><span class="p">;</span>
		<span class="n">remove_rmap_item_from_tree</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">);</span>
		<span class="n">free_rmap_item</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Though it&#39;s very tempting to unmerge in_stable_tree(rmap_item)s rather</span>
<span class="cm"> * than check every pte of a given vma, the locking doesn&#39;t quite work for</span>
<span class="cm"> * that - an rmap_item is assigned to the stable tree after inserting ksm</span>
<span class="cm"> * page and upping mmap_sem.  Nor does it fit with the way we skip dup&#39;ing</span>
<span class="cm"> * rmap_items from parent to child at fork time (so as not to waste time</span>
<span class="cm"> * if exit comes before the next scan reaches it).</span>
<span class="cm"> *</span>
<span class="cm"> * Similarly, although we&#39;d like to remove rmap_items (so updating counts</span>
<span class="cm"> * and freeing memory) when unmerging an area, it&#39;s easier to leave that</span>
<span class="cm"> * to the next pass of ksmd - consider, for example, how ksmd might be</span>
<span class="cm"> * in cmp_and_merge_page on one of the rmap_items we would be removing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">unmerge_ksm_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">err</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ksm_test_exit</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">break_ksm</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="cm">/*</span>
<span class="cm"> * Only called through the sysfs control interface:</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">unmerge_and_remove_all_rmap_items</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>
	<span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">ksm_mm_head</span><span class="p">.</span><span class="n">mm_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">mm_slot</span><span class="p">,</span> <span class="n">mm_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">mm_slot</span> <span class="o">=</span> <span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span><span class="p">;</span>
			<span class="n">mm_slot</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ksm_mm_head</span><span class="p">;</span> <span class="n">mm_slot</span> <span class="o">=</span> <span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mm</span> <span class="o">=</span> <span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ksm_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MERGEABLE</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">unmerge_ksm_pages</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span>
						<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">remove_trailing_rmap_items</span><span class="p">(</span><span class="n">mm_slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">rmap_list</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>
		<span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">mm_slot</span><span class="p">,</span> <span class="n">mm_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ksm_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>

			<span class="n">free_mm_slot</span><span class="p">(</span><span class="n">mm_slot</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">MMF_VM_MERGEABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
			<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>
			<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ksm_scan</span><span class="p">.</span><span class="n">seqnr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>
	<span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ksm_mm_head</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSFS */</span><span class="cp"></span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">calc_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="n">jhash2</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">17</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">checksum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">memcmp_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">addr1</span><span class="p">,</span> <span class="o">*</span><span class="n">addr2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">addr1</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page1</span><span class="p">);</span>
	<span class="n">addr2</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page2</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">addr1</span><span class="p">,</span> <span class="n">addr2</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">addr2</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">addr1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pages_identical</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">memcmp_pages</span><span class="p">(</span><span class="n">page1</span><span class="p">,</span> <span class="n">page2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_protect_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			      <span class="n">pte_t</span> <span class="o">*</span><span class="n">orig_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">swapped</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">page_address_in_vma</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageTransCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">ptep</span> <span class="o">=</span> <span class="n">page_check_address</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pte_write</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">)</span> <span class="o">||</span> <span class="n">pte_dirty</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>

		<span class="n">swapped</span> <span class="o">=</span> <span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">flush_cache_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ok this is tricky, when get_user_pages_fast() run it doesn&#39;t</span>
<span class="cm">		 * take any lock, therefore the check that we are going to make</span>
<span class="cm">		 * with the pagecount against the mapcount is racey and</span>
<span class="cm">		 * O_DIRECT can happen right after the check.</span>
<span class="cm">		 * So we clear the pte and flush the tlb before the check</span>
<span class="cm">		 * this assure us that no O_DIRECT can happen after the check</span>
<span class="cm">		 * or in the middle of the check.</span>
<span class="cm">		 */</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">ptep_clear_flush</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check that no O_DIRECT or similar I/O is in progress on the</span>
<span class="cm">		 * page</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">swapped</span> <span class="o">!=</span> <span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">set_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_dirty</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
			<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkclean</span><span class="p">(</span><span class="n">pte_wrprotect</span><span class="p">(</span><span class="n">entry</span><span class="p">));</span>
		<span class="n">set_pte_at_notify</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">orig_pte</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * replace_page - replace page in vma by new ksm page</span>
<span class="cm"> * @vma:      vma that holds the pte pointing to page</span>
<span class="cm"> * @page:     the page we are replacing by kpage</span>
<span class="cm"> * @kpage:    the ksm page we replace page by</span>
<span class="cm"> * @orig_pte: the original value of the pte</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -EFAULT on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">replace_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">kpage</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">orig_pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">page_address_in_vma</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pud_present</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pmd_trans_huge</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmd_present</span><span class="p">(</span><span class="o">*</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ptep</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">get_page</span><span class="p">(</span><span class="n">kpage</span><span class="p">);</span>
	<span class="n">page_add_anon_rmap</span><span class="p">(</span><span class="n">kpage</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="n">flush_cache_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_pfn</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">));</span>
	<span class="n">ptep_clear_flush</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
	<span class="n">set_pte_at_notify</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">kpage</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">));</span>

	<span class="n">page_remove_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">try_to_free_swap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">page_trans_compound_anon_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">transhuge_head</span> <span class="o">=</span> <span class="n">page_trans_compound_anon</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transhuge_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Get the reference on the head to split it. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_page_unless_zero</span><span class="p">(</span><span class="n">transhuge_head</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Recheck we got the reference while the head</span>
<span class="cm">			 * was still anonymous.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">transhuge_head</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">split_huge_page</span><span class="p">(</span><span class="n">transhuge_head</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="cm">/*</span>
<span class="cm">				 * Retry later if split_huge_page run</span>
<span class="cm">				 * from under us.</span>
<span class="cm">				 */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">transhuge_head</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* Retry later if split_huge_page run from under us. */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * try_to_merge_one_page - take two pages and merge them into one</span>
<span class="cm"> * @vma: the vma that holds the pte pointing to page</span>
<span class="cm"> * @page: the PageAnon page that we want to replace with kpage</span>
<span class="cm"> * @kpage: the PageKsm page that we want to map instead of page,</span>
<span class="cm"> *         or NULL the first time when we want to use page as kpage.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if the pages were merged, -EFAULT otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_merge_one_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">kpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">orig_pte</span> <span class="o">=</span> <span class="n">__pte</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">kpage</span><span class="p">)</span>			<span class="cm">/* ksm page forked */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MERGEABLE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageTransCompound</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">page_trans_compound_anon_split</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageTransCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need the page lock to read a stable PageSwapCache in</span>
<span class="cm">	 * write_protect_page().  We use trylock_page() instead of</span>
<span class="cm">	 * lock_page() because we don&#39;t want to wait here - we</span>
<span class="cm">	 * prefer to continue scanning and merging different pages,</span>
<span class="cm">	 * then come back to this page when it is unlocked.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this anonymous page is mapped only here, its pte may need</span>
<span class="cm">	 * to be write-protected.  If it&#39;s mapped elsewhere, all of its</span>
<span class="cm">	 * ptes are necessarily already write-protected.  But in either</span>
<span class="cm">	 * case, we need to lock and check page_count is not raised.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write_protect_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">orig_pte</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kpage</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * While we hold page lock, upgrade page from</span>
<span class="cm">			 * PageAnon+anon_vma to PageKsm+NULL stable_node:</span>
<span class="cm">			 * stable_tree_insert() will update stable_node.</span>
<span class="cm">			 */</span>
			<span class="n">set_page_stable_node</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pages_identical</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">kpage</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">replace_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">kpage</span><span class="p">,</span> <span class="n">orig_pte</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_LOCKED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">kpage</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">munlock_vma_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageMlocked</span><span class="p">(</span><span class="n">kpage</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">lock_page</span><span class="p">(</span><span class="n">kpage</span><span class="p">);</span>
			<span class="n">mlock_vma_page</span><span class="p">(</span><span class="n">kpage</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">kpage</span><span class="p">;</span>		<span class="cm">/* for final unlock */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * try_to_merge_with_ksm_page - like try_to_merge_two_pages,</span>
<span class="cm"> * but no new kernel page is allocated: kpage must already be a ksm page.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if the pages were merged, -EFAULT otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">try_to_merge_with_ksm_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">kpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ksm_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">try_to_merge_one_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">kpage</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Must get reference to anon_vma while still holding mmap_sem */</span>
	<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
	<span class="n">get_anon_vma</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * try_to_merge_two_pages - take two identical pages and prepare them</span>
<span class="cm"> * to be merged into one page.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the kpage if we successfully merged two identical</span>
<span class="cm"> * pages into one ksm page, NULL otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function upgrades page to ksm page: if one of the pages</span>
<span class="cm"> * is already a ksm page, try_to_merge_with_ksm_page should be used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">try_to_merge_two_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">tree_rmap_item</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">tree_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">try_to_merge_with_ksm_page</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">try_to_merge_with_ksm_page</span><span class="p">(</span><span class="n">tree_rmap_item</span><span class="p">,</span>
							<span class="n">tree_page</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If that fails, we have a ksm page with only one pte</span>
<span class="cm">		 * pointing to it: so break it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">break_cow</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * stable_tree_search - search for page inside the stable tree</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks if there is a page inside the stable tree</span>
<span class="cm"> * with identical content to the page that we are scanning right now.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the stable tree node of identical content if found,</span>
<span class="cm"> * NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">stable_tree_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">root_stable_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">;</span>

	<span class="n">stable_node</span> <span class="o">=</span> <span class="n">page_stable_node</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stable_node</span><span class="p">)</span> <span class="p">{</span>			<span class="cm">/* ksm page forked */</span>
		<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">tree_page</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">stable_node</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stable_node</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">tree_page</span> <span class="o">=</span> <span class="n">get_ksm_page</span><span class="p">(</span><span class="n">stable_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tree_page</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">memcmp_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tree_page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">tree_page</span><span class="p">);</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">tree_page</span><span class="p">);</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="n">tree_page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * stable_tree_insert - insert rmap_item pointing to new ksm page</span>
<span class="cm"> * into the stable tree.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the stable tree node just allocated on success,</span>
<span class="cm"> * NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="nf">stable_tree_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">kpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root_stable_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">tree_page</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">stable_node</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stable_node</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">tree_page</span> <span class="o">=</span> <span class="n">get_ksm_page</span><span class="p">(</span><span class="n">stable_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tree_page</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">memcmp_pages</span><span class="p">(</span><span class="n">kpage</span><span class="p">,</span> <span class="n">tree_page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">tree_page</span><span class="p">);</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * It is not a bug that stable_tree_search() didn&#39;t</span>
<span class="cm">			 * find this node: because at that time our page was</span>
<span class="cm">			 * not yet write-protected, so may have changed since.</span>
<span class="cm">			 */</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">stable_node</span> <span class="o">=</span> <span class="n">alloc_stable_node</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stable_node</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_stable_tree</span><span class="p">);</span>

	<span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>

	<span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">kpfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">kpage</span><span class="p">);</span>
	<span class="n">set_page_stable_node</span><span class="p">(</span><span class="n">kpage</span><span class="p">,</span> <span class="n">stable_node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">stable_node</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * unstable_tree_search_insert - search for identical page,</span>
<span class="cm"> * else insert rmap_item into the unstable tree.</span>
<span class="cm"> *</span>
<span class="cm"> * This function searches for a page in the unstable tree identical to the</span>
<span class="cm"> * page currently being scanned; and if no identical page is found in the</span>
<span class="cm"> * tree, we insert rmap_item as a new object into the unstable tree.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns pointer to rmap_item found to be identical</span>
<span class="cm"> * to the currently scanned page, NULL otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does both searching and inserting, because they share</span>
<span class="cm"> * the same walking algorithm in an rbtree.</span>
<span class="cm"> */</span>
<span class="k">static</span>
<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="nf">unstable_tree_search_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">tree_pagep</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root_unstable_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">tree_rmap_item</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">tree_page</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">tree_rmap_item</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rmap_item</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">tree_page</span> <span class="o">=</span> <span class="n">get_mergeable_page</span><span class="p">(</span><span class="n">tree_rmap_item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">tree_page</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t substitute a ksm page for a forked page.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">tree_page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">tree_page</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">memcmp_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tree_page</span><span class="p">);</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">tree_page</span><span class="p">);</span>
			<span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">tree_page</span><span class="p">);</span>
			<span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">tree_pagep</span> <span class="o">=</span> <span class="n">tree_page</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">tree_rmap_item</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">|=</span> <span class="n">UNSTABLE_FLAG</span><span class="p">;</span>
	<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ksm_scan</span><span class="p">.</span><span class="n">seqnr</span> <span class="o">&amp;</span> <span class="n">SEQNR_MASK</span><span class="p">);</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_unstable_tree</span><span class="p">);</span>

	<span class="n">ksm_pages_unshared</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * stable_tree_append - add another rmap_item to the linked list of</span>
<span class="cm"> * rmap_items hanging off a given node of the stable tree, all sharing</span>
<span class="cm"> * the same ksm page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">stable_tree_append</span><span class="p">(</span><span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">stable_node</span><span class="p">;</span>
	<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">|=</span> <span class="n">STABLE_FLAG</span><span class="p">;</span>
	<span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">.</span><span class="n">next</span><span class="p">)</span>
		<span class="n">ksm_pages_sharing</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ksm_pages_shared</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cmp_and_merge_page - first see if page can be merged into the stable tree;</span>
<span class="cm"> * if not, compare checksum to previous and if it&#39;s the same, see if page can</span>
<span class="cm"> * be inserted into the unstable tree, or merged with a page already there and</span>
<span class="cm"> * both transferred to the stable tree.</span>
<span class="cm"> *</span>
<span class="cm"> * @page: the page that we are searching identical page to.</span>
<span class="cm"> * @rmap_item: the reverse mapping into the virtual address of this page</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cmp_and_merge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">tree_rmap_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">tree_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">kpage</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">checksum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">remove_rmap_item_from_tree</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">);</span>

	<span class="cm">/* We first start with searching the page inside the stable tree */</span>
	<span class="n">kpage</span> <span class="o">=</span> <span class="n">stable_tree_search</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kpage</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">try_to_merge_with_ksm_page</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">kpage</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The page was successfully merged:</span>
<span class="cm">			 * add its rmap_item to the stable tree.</span>
<span class="cm">			 */</span>
			<span class="n">lock_page</span><span class="p">(</span><span class="n">kpage</span><span class="p">);</span>
			<span class="n">stable_tree_append</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">,</span> <span class="n">page_stable_node</span><span class="p">(</span><span class="n">kpage</span><span class="p">));</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">kpage</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">kpage</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the hash value of the page has changed from the last time</span>
<span class="cm">	 * we calculated it, this page is changing frequently: therefore we</span>
<span class="cm">	 * don&#39;t want to insert it in the unstable tree, and we don&#39;t want</span>
<span class="cm">	 * to waste our time searching for something identical to it there.</span>
<span class="cm">	 */</span>
	<span class="n">checksum</span> <span class="o">=</span> <span class="n">calc_checksum</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">oldchecksum</span> <span class="o">!=</span> <span class="n">checksum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">oldchecksum</span> <span class="o">=</span> <span class="n">checksum</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tree_rmap_item</span> <span class="o">=</span>
		<span class="n">unstable_tree_search_insert</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tree_page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tree_rmap_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kpage</span> <span class="o">=</span> <span class="n">try_to_merge_two_pages</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
						<span class="n">tree_rmap_item</span><span class="p">,</span> <span class="n">tree_page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">tree_page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * As soon as we merge this page, we want to remove the</span>
<span class="cm">		 * rmap_item of the page we have merged with from the unstable</span>
<span class="cm">		 * tree, and insert it instead as new node in the stable tree.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kpage</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">remove_rmap_item_from_tree</span><span class="p">(</span><span class="n">tree_rmap_item</span><span class="p">);</span>

			<span class="n">lock_page</span><span class="p">(</span><span class="n">kpage</span><span class="p">);</span>
			<span class="n">stable_node</span> <span class="o">=</span> <span class="n">stable_tree_insert</span><span class="p">(</span><span class="n">kpage</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stable_node</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">stable_tree_append</span><span class="p">(</span><span class="n">tree_rmap_item</span><span class="p">,</span> <span class="n">stable_node</span><span class="p">);</span>
				<span class="n">stable_tree_append</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">,</span> <span class="n">stable_node</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">kpage</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If we fail to insert the page into the stable tree,</span>
<span class="cm">			 * we will have 2 virtual addresses that are pointing</span>
<span class="cm">			 * to a ksm page left outside the stable tree,</span>
<span class="cm">			 * in which case we need to break_cow on both.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stable_node</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">break_cow</span><span class="p">(</span><span class="n">tree_rmap_item</span><span class="p">);</span>
				<span class="n">break_cow</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="nf">get_next_rmap_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">**</span><span class="n">rmap_list</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">rmap_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rmap_item</span> <span class="o">=</span> <span class="o">*</span><span class="n">rmap_list</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rmap_item</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="o">*</span><span class="n">rmap_list</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">rmap_list</span><span class="p">;</span>
		<span class="n">remove_rmap_item_from_tree</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">);</span>
		<span class="n">free_rmap_item</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rmap_item</span> <span class="o">=</span> <span class="n">alloc_rmap_item</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* It has already been zeroed */</span>
		<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
		<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">rmap_list</span> <span class="o">=</span> <span class="o">*</span><span class="n">rmap_list</span><span class="p">;</span>
		<span class="o">*</span><span class="n">rmap_list</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rmap_item</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="nf">scan_get_next_rmap_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mm_head</span><span class="p">.</span><span class="n">mm_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ksm_mm_head</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * A number of pages can hang around indefinitely on per-cpu</span>
<span class="cm">		 * pagevecs, raised page count preventing write_protect_page</span>
<span class="cm">		 * from merging them.  Though it doesn&#39;t really matter much,</span>
<span class="cm">		 * it is puzzling to see some stuck in pages_volatile until</span>
<span class="cm">		 * other activity jostles them out, and they also prevented</span>
<span class="cm">		 * LTP&#39;s KSM test from succeeding deterministically; so drain</span>
<span class="cm">		 * them here (here rather than on entry to ksm_do_scan(),</span>
<span class="cm">		 * so we don&#39;t IPI too often when pages_to_scan is set low).</span>
<span class="cm">		 */</span>
		<span class="n">lru_add_drain_all</span><span class="p">();</span>

		<span class="n">root_unstable_tree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_slot</span><span class="p">,</span> <span class="n">mm_list</span><span class="p">);</span>
		<span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Although we tested list_empty() above, a racing __ksm_exit</span>
<span class="cm">		 * of the last mm on the list may have removed it since then.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ksm_mm_head</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">next_mm:</span>
		<span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ksm_scan</span><span class="p">.</span><span class="n">rmap_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">rmap_list</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">slot</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ksm_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MERGEABLE</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
			<span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span>
			<span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ksm_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">follow_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="n">FOLL_GET</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="o">*</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
				<span class="n">cond_resched</span><span class="p">();</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="o">*</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">page_trans_compound_anon</span><span class="p">(</span><span class="o">*</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">flush_anon_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>
				<span class="n">flush_dcache_page</span><span class="p">(</span><span class="o">*</span><span class="n">page</span><span class="p">);</span>
				<span class="n">rmap_item</span> <span class="o">=</span> <span class="n">get_next_rmap_item</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span>
					<span class="n">ksm_scan</span><span class="p">.</span><span class="n">rmap_list</span><span class="p">,</span> <span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ksm_scan</span><span class="p">.</span><span class="n">rmap_list</span> <span class="o">=</span>
							<span class="o">&amp;</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">rmap_list</span><span class="p">;</span>
					<span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">put_page</span><span class="p">(</span><span class="o">*</span><span class="n">page</span><span class="p">);</span>
				<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">rmap_item</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">put_page</span><span class="p">(</span><span class="o">*</span><span class="n">page</span><span class="p">);</span>
			<span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ksm_test_exit</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ksm_scan</span><span class="p">.</span><span class="n">rmap_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">rmap_list</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Nuke all the rmap_items that are above this current rmap:</span>
<span class="cm">	 * because there were no VM_MERGEABLE vmas with such addresses.</span>
<span class="cm">	 */</span>
	<span class="n">remove_trailing_rmap_items</span><span class="p">(</span><span class="n">slot</span><span class="p">,</span> <span class="n">ksm_scan</span><span class="p">.</span><span class="n">rmap_list</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>
	<span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">mm_slot</span><span class="p">,</span> <span class="n">mm_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ksm_scan</span><span class="p">.</span><span class="n">address</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;ve completed a full scan of all vmas, holding mmap_sem</span>
<span class="cm">		 * throughout, and found no VM_MERGEABLE: so do the same as</span>
<span class="cm">		 * __ksm_exit does to remove this mm from all our lists now.</span>
<span class="cm">		 * This applies either when cleaning up after __ksm_exit</span>
<span class="cm">		 * (but beware: we can reach here even before __ksm_exit),</span>
<span class="cm">		 * or when all VM_MERGEABLE areas have been unmapped (and</span>
<span class="cm">		 * mmap_sem then protects against race with MADV_MERGEABLE).</span>
<span class="cm">		 */</span>
		<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>

		<span class="n">free_mm_slot</span><span class="p">(</span><span class="n">slot</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">MMF_VM_MERGEABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Repeat until we&#39;ve completed scanning the whole list */</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ksm_mm_head</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">next_mm</span><span class="p">;</span>

	<span class="n">ksm_scan</span><span class="p">.</span><span class="n">seqnr</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ksm_do_scan  - the ksm scanner main worker function.</span>
<span class="cm"> * @scan_npages - number of pages we want to scan before we return.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ksm_do_scan</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scan_npages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">scan_npages</span><span class="o">--</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">freezing</span><span class="p">(</span><span class="n">current</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">rmap_item</span> <span class="o">=</span> <span class="n">scan_get_next_rmap_item</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rmap_item</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">in_stable_tree</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">))</span>
			<span class="n">cmp_and_merge_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">rmap_item</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ksmd_should_run</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ksm_run</span> <span class="o">&amp;</span> <span class="n">KSM_RUN_MERGE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mm_head</span><span class="p">.</span><span class="n">mm_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ksm_scan_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">nothing</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_freezable</span><span class="p">();</span>
	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_thread_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ksmd_should_run</span><span class="p">())</span>
			<span class="n">ksm_do_scan</span><span class="p">(</span><span class="n">ksm_thread_pages_to_scan</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_thread_mutex</span><span class="p">);</span>

		<span class="n">try_to_freeze</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ksmd_should_run</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">schedule_timeout_interruptible</span><span class="p">(</span>
				<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">ksm_thread_sleep_millisecs</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">wait_event_freezable</span><span class="p">(</span><span class="n">ksm_thread_wait</span><span class="p">,</span>
				<span class="n">ksmd_should_run</span><span class="p">()</span> <span class="o">||</span> <span class="n">kthread_should_stop</span><span class="p">());</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ksm_madvise</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">advice</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">advice</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MADV_MERGEABLE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Be somewhat over-protective for now!</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_MERGEABLE</span> <span class="o">|</span> <span class="n">VM_SHARED</span>  <span class="o">|</span> <span class="n">VM_MAYSHARE</span>   <span class="o">|</span>
				 <span class="n">VM_PFNMAP</span>    <span class="o">|</span> <span class="n">VM_IO</span>      <span class="o">|</span> <span class="n">VM_DONTEXPAND</span> <span class="o">|</span>
				 <span class="n">VM_RESERVED</span>  <span class="o">|</span> <span class="n">VM_HUGETLB</span> <span class="o">|</span> <span class="n">VM_INSERTPAGE</span> <span class="o">|</span>
				 <span class="n">VM_NONLINEAR</span> <span class="o">|</span> <span class="n">VM_MIXEDMAP</span> <span class="o">|</span> <span class="n">VM_SAO</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* just ignore the advice */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">MMF_VM_MERGEABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">__ksm_enter</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_MERGEABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MADV_UNMERGEABLE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MERGEABLE</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* just ignore the advice */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">unmerge_ksm_pages</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_MERGEABLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__ksm_enter</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">needs_wakeup</span><span class="p">;</span>

	<span class="n">mm_slot</span> <span class="o">=</span> <span class="n">alloc_mm_slot</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_slot</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Check ksm_run too?  Would need tighter locking */</span>
	<span class="n">needs_wakeup</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mm_head</span><span class="p">.</span><span class="n">mm_list</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>
	<span class="n">insert_to_mm_slots_hash</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">mm_slot</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Insert just behind the scanning cursor, to let the area settle</span>
<span class="cm">	 * down a little; when fork is followed by immediate exec, we don&#39;t</span>
<span class="cm">	 * want ksmd to waste time setting up and tearing down an rmap_list.</span>
<span class="cm">	 */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">MMF_VM_MERGEABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">needs_wakeup</span><span class="p">)</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_thread_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__ksm_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_slot</span> <span class="o">*</span><span class="n">mm_slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">easy_to_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This process is exiting: if it&#39;s straightforward (as is the</span>
<span class="cm">	 * case when ksmd was never running), free mm_slot immediately.</span>
<span class="cm">	 * But if it&#39;s at the cursor or has rmap_items linked to it, use</span>
<span class="cm">	 * mmap_sem to synchronize with any break_cows before pagetables</span>
<span class="cm">	 * are freed, and leave the mm_slot on the list for ksmd to free.</span>
<span class="cm">	 * Beware: ksm may already have noticed it exiting and freed the slot.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>
	<span class="n">mm_slot</span> <span class="o">=</span> <span class="n">get_mm_slot</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm_slot</span> <span class="o">&amp;&amp;</span> <span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span> <span class="o">!=</span> <span class="n">mm_slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">rmap_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hlist_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">);</span>
			<span class="n">easy_to_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">ksm_scan</span><span class="p">.</span><span class="n">mm_slot</span><span class="o">-&gt;</span><span class="n">mm_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_mmlist_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">easy_to_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_mm_slot</span><span class="p">(</span><span class="n">mm_slot</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">MMF_VM_MERGEABLE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">mmdrop</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mm_slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">ksm_does_need_to_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">new_page</span><span class="p">;</span>

	<span class="n">new_page</span> <span class="o">=</span> <span class="n">alloc_page_vma</span><span class="p">(</span><span class="n">GFP_HIGHUSER_MOVABLE</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">copy_user_highpage</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>

		<span class="n">SetPageDirty</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
		<span class="n">__SetPageUptodate</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
		<span class="n">SetPageSwapBacked</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
		<span class="n">__set_page_locked</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page_evictable</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">vma</span><span class="p">))</span>
			<span class="n">lru_cache_add_lru</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">LRU_ACTIVE_ANON</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">add_page_to_unevictable_list</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">new_page</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">page_referenced_ksm</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">hlist</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mapcount</span> <span class="o">=</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">referenced</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">search_new_forks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">stable_node</span> <span class="o">=</span> <span class="n">page_stable_node</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stable_node</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">,</span> <span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">vmac</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

		<span class="n">anon_vma_lock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vmac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">same_anon_vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">vmac</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">||</span>
			    <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Initially we examine only the vma which covers this</span>
<span class="cm">			 * rmap_item; but later, if there is still work to do,</span>
<span class="cm">			 * we examine covering vmas in other mms: in case they</span>
<span class="cm">			 * were forked from the original since ksmd passed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">)</span> <span class="o">==</span> <span class="n">search_new_forks</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mm_match_cgroup</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">memcg</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">referenced</span> <span class="o">+=</span> <span class="n">page_referenced_one</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span>
				<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapcount</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">search_new_forks</span> <span class="o">||</span> <span class="o">!</span><span class="n">mapcount</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapcount</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">search_new_forks</span><span class="o">++</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">referenced</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">try_to_unmap_ksm</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">enum</span> <span class="n">ttu_flags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">hlist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_AGAIN</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">search_new_forks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">stable_node</span> <span class="o">=</span> <span class="n">page_stable_node</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stable_node</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SWAP_FAIL</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">,</span> <span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">vmac</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

		<span class="n">anon_vma_lock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vmac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">same_anon_vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">vmac</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">||</span>
			    <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Initially we examine only the vma which covers this</span>
<span class="cm">			 * rmap_item; but later, if there is still work to do,</span>
<span class="cm">			 * we examine covering vmas in other mms: in case they</span>
<span class="cm">			 * were forked from the original since ksmd passed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">)</span> <span class="o">==</span> <span class="n">search_new_forks</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_unmap_one</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span>
					<span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">SWAP_AGAIN</span> <span class="o">||</span> <span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">search_new_forks</span><span class="o">++</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MIGRATION</span>
<span class="kt">int</span> <span class="nf">rmap_walk_ksm</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rmap_one</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">hlist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rmap_item</span> <span class="o">*</span><span class="n">rmap_item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SWAP_AGAIN</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">search_new_forks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">stable_node</span> <span class="o">=</span> <span class="n">page_stable_node</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stable_node</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">rmap_item</span><span class="p">,</span> <span class="n">hlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="p">,</span> <span class="n">hlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span> <span class="o">=</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">anon_vma</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="o">*</span><span class="n">vmac</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

		<span class="n">anon_vma_lock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vmac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anon_vma</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">same_anon_vma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">vmac</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">||</span>
			    <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Initially we examine only the vma which covers this</span>
<span class="cm">			 * rmap_item; but later, if there is still work to do,</span>
<span class="cm">			 * we examine covering vmas in other mms: in case they</span>
<span class="cm">			 * were forked from the original since ksmd passed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">mm</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">)</span> <span class="o">==</span> <span class="n">search_new_forks</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">rmap_one</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">rmap_item</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">SWAP_AGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">anon_vma_unlock</span><span class="p">(</span><span class="n">anon_vma</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">search_new_forks</span><span class="o">++</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ksm_migrate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">newpage</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">oldpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">oldpage</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">newpage</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">newpage</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">oldpage</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">);</span>

	<span class="n">stable_node</span> <span class="o">=</span> <span class="n">page_stable_node</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stable_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">kpfn</span> <span class="o">!=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">oldpage</span><span class="p">));</span>
		<span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">kpfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MIGRATION */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_MEMORY_HOTREMOVE</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="nf">ksm_check_stable_tree</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_stable_tree</span><span class="p">);</span> <span class="n">node</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">;</span>

		<span class="n">stable_node</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stable_node</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">kpfn</span> <span class="o">&gt;=</span> <span class="n">start_pfn</span> <span class="o">&amp;&amp;</span>
		    <span class="n">stable_node</span><span class="o">-&gt;</span><span class="n">kpfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">stable_node</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ksm_memory_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memory_notify</span> <span class="o">*</span><span class="n">mn</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">stable_node</span> <span class="o">*</span><span class="n">stable_node</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEM_GOING_OFFLINE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Keep it very simple for now: just lock out ksmd and</span>
<span class="cm">		 * MADV_UNMERGEABLE while any memory is going offline.</span>
<span class="cm">		 * mutex_lock_nested() is necessary because lockdep was alarmed</span>
<span class="cm">		 * that here we take ksm_thread_mutex inside notifier chain</span>
<span class="cm">		 * mutex, and later take notifier chain mutex inside</span>
<span class="cm">		 * ksm_thread_mutex to unlock it.   But that&#39;s safe because both</span>
<span class="cm">		 * are inside mem_hotplug_mutex.</span>
<span class="cm">		 */</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_thread_mutex</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MEM_OFFLINE</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Most of the work is done by page migration; but there might</span>
<span class="cm">		 * be a few stable_nodes left over, still pointing to struct</span>
<span class="cm">		 * pages which have been offlined: prune those from the tree.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">stable_node</span> <span class="o">=</span> <span class="n">ksm_check_stable_tree</span><span class="p">(</span><span class="n">mn</span><span class="o">-&gt;</span><span class="n">start_pfn</span><span class="p">,</span>
					<span class="n">mn</span><span class="o">-&gt;</span><span class="n">start_pfn</span> <span class="o">+</span> <span class="n">mn</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">remove_node_from_stable_tree</span><span class="p">(</span><span class="n">stable_node</span><span class="p">);</span>
		<span class="cm">/* fallthrough */</span>

	<span class="k">case</span> <span class="n">MEM_CANCEL_OFFLINE</span>:
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_thread_mutex</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_MEMORY_HOTREMOVE */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="cm">/*</span>
<span class="cm"> * This all compiles without CONFIG_SYSFS, but is a waste of space.</span>
<span class="cm"> */</span>

<span class="cp">#define KSM_ATTR_RO(_name) \</span>
<span class="cp">	static struct kobj_attribute _name##_attr = __ATTR_RO(_name)</span>
<span class="cp">#define KSM_ATTR(_name) \</span>
<span class="cp">	static struct kobj_attribute _name##_attr = \</span>
<span class="cp">		__ATTR(_name, 0644, _name##_show, _name##_store)</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sleep_millisecs_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ksm_thread_sleep_millisecs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sleep_millisecs_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msecs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msecs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">msecs</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ksm_thread_sleep_millisecs</span> <span class="o">=</span> <span class="n">msecs</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">KSM_ATTR</span><span class="p">(</span><span class="n">sleep_millisecs</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pages_to_scan_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ksm_thread_pages_to_scan</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pages_to_scan_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ksm_thread_pages_to_scan</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">KSM_ATTR</span><span class="p">(</span><span class="n">pages_to_scan</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">run_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ksm_run</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">run_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">||</span> <span class="n">flags</span> <span class="o">&gt;</span> <span class="n">UINT_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&gt;</span> <span class="n">KSM_RUN_UNMERGE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * KSM_RUN_MERGE sets ksmd running, and 0 stops it running.</span>
<span class="cm">	 * KSM_RUN_UNMERGE stops it running and unmerges all rmap_items,</span>
<span class="cm">	 * breaking COW to free the pages_shared (but leaves mm_slots</span>
<span class="cm">	 * on the list for when ksmd may be set running again).</span>
<span class="cm">	 */</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_thread_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ksm_run</span> <span class="o">!=</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ksm_run</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KSM_RUN_UNMERGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">oom_score_adj</span><span class="p">;</span>

			<span class="n">oom_score_adj</span> <span class="o">=</span> <span class="n">test_set_oom_score_adj</span><span class="p">(</span><span class="n">OOM_SCORE_ADJ_MAX</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">unmerge_and_remove_all_rmap_items</span><span class="p">();</span>
			<span class="n">compare_swap_oom_score_adj</span><span class="p">(</span><span class="n">OOM_SCORE_ADJ_MAX</span><span class="p">,</span>
								<span class="n">oom_score_adj</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ksm_run</span> <span class="o">=</span> <span class="n">KSM_RUN_STOP</span><span class="p">;</span>
				<span class="n">count</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_thread_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">KSM_RUN_MERGE</span><span class="p">)</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksm_thread_wait</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">KSM_ATTR</span><span class="p">(</span><span class="n">run</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pages_shared_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ksm_pages_shared</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">KSM_ATTR_RO</span><span class="p">(</span><span class="n">pages_shared</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pages_sharing_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ksm_pages_sharing</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">KSM_ATTR_RO</span><span class="p">(</span><span class="n">pages_sharing</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pages_unshared_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ksm_pages_unshared</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">KSM_ATTR_RO</span><span class="p">(</span><span class="n">pages_unshared</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">pages_volatile_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ksm_pages_volatile</span><span class="p">;</span>

	<span class="n">ksm_pages_volatile</span> <span class="o">=</span> <span class="n">ksm_rmap_items</span> <span class="o">-</span> <span class="n">ksm_pages_shared</span>
				<span class="o">-</span> <span class="n">ksm_pages_sharing</span> <span class="o">-</span> <span class="n">ksm_pages_unshared</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * It was not worth any locking to calculate that statistic,</span>
<span class="cm">	 * but it might therefore sometimes be negative: conceal that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ksm_pages_volatile</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ksm_pages_volatile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ksm_pages_volatile</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">KSM_ATTR_RO</span><span class="p">(</span><span class="n">pages_volatile</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">full_scans_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ksm_scan</span><span class="p">.</span><span class="n">seqnr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">KSM_ATTR_RO</span><span class="p">(</span><span class="n">full_scans</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">ksm_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">sleep_millisecs_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pages_to_scan_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">run_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pages_shared_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pages_sharing_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pages_unshared_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">pages_volatile_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">full_scans_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">ksm_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">ksm_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ksm&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSFS */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ksm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">ksm_thread</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ksm_slab_init</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ksm_thread</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">ksm_scan_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;ksmd&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ksm_thread</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ksm: creating kthread failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ksm_thread</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="n">mm_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ksm_attr_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ksm: register sysfs failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">ksm_thread</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">ksm_run</span> <span class="o">=</span> <span class="n">KSM_RUN_MERGE</span><span class="p">;</span>	<span class="cm">/* no way for user to start it */</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSFS */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_MEMORY_HOTREMOVE</span>
	<span class="cm">/*</span>
<span class="cm">	 * Choose a high priority since the callback takes ksm_thread_mutex:</span>
<span class="cm">	 * later callbacks could only be taking locks which nest within that.</span>
<span class="cm">	 */</span>
	<span class="n">hotplug_memory_notifier</span><span class="p">(</span><span class="n">ksm_memory_callback</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="n">ksm_slab_free</span><span class="p">();</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">ksm_init</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
