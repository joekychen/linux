<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › slub.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>slub.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * SLUB: A slab allocator that limits cache line use instead of queuing</span>
<span class="cm"> * objects in per cpu and per node lists.</span>
<span class="cm"> *</span>
<span class="cm"> * The allocator synchronizes using per slab locks or atomic operatios</span>
<span class="cm"> * and only uses a centralized lock to manage a pool of partial slabs.</span>
<span class="cm"> *</span>
<span class="cm"> * (C) 2007 SGI, Christoph Lameter</span>
<span class="cm"> * (C) 2011 Linux Foundation, Christoph Lameter</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt; </span><span class="cm">/* struct reclaim_state */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/bit_spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/kmemcheck.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/debugobjects.h&gt;</span>
<span class="cp">#include &lt;linux/kallsyms.h&gt;</span>
<span class="cp">#include &lt;linux/memory.h&gt;</span>
<span class="cp">#include &lt;linux/math64.h&gt;</span>
<span class="cp">#include &lt;linux/fault-inject.h&gt;</span>
<span class="cp">#include &lt;linux/stacktrace.h&gt;</span>
<span class="cp">#include &lt;linux/prefetch.h&gt;</span>

<span class="cp">#include &lt;trace/events/kmem.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Lock order:</span>
<span class="cm"> *   1. slub_lock (Global Semaphore)</span>
<span class="cm"> *   2. node-&gt;list_lock</span>
<span class="cm"> *   3. slab_lock(page) (Only on some arches and for debugging)</span>
<span class="cm"> *</span>
<span class="cm"> *   slub_lock</span>
<span class="cm"> *</span>
<span class="cm"> *   The role of the slub_lock is to protect the list of all the slabs</span>
<span class="cm"> *   and to synchronize major metadata changes to slab cache structures.</span>
<span class="cm"> *</span>
<span class="cm"> *   The slab_lock is only used for debugging and on arches that do not</span>
<span class="cm"> *   have the ability to do a cmpxchg_double. It only protects the second</span>
<span class="cm"> *   double word in the page struct. Meaning</span>
<span class="cm"> *	A. page-&gt;freelist	-&gt; List of object free in a page</span>
<span class="cm"> *	B. page-&gt;counters	-&gt; Counters of objects</span>
<span class="cm"> *	C. page-&gt;frozen		-&gt; frozen state</span>
<span class="cm"> *</span>
<span class="cm"> *   If a slab is frozen then it is exempt from list management. It is not</span>
<span class="cm"> *   on any list. The processor that froze the slab is the one who can</span>
<span class="cm"> *   perform list operations on the page. Other processors may put objects</span>
<span class="cm"> *   onto the freelist but the processor that froze the slab is the only</span>
<span class="cm"> *   one that can retrieve the objects from the page&#39;s freelist.</span>
<span class="cm"> *</span>
<span class="cm"> *   The list_lock protects the partial and full list on each node and</span>
<span class="cm"> *   the partial slab counter. If taken then no new slabs may be added or</span>
<span class="cm"> *   removed from the lists nor make the number of partial slabs be modified.</span>
<span class="cm"> *   (Note that the total number of slabs is an atomic value that may be</span>
<span class="cm"> *   modified without taking the list lock).</span>
<span class="cm"> *</span>
<span class="cm"> *   The list_lock is a centralized lock and thus we avoid taking it as</span>
<span class="cm"> *   much as possible. As long as SLUB does not have to handle partial</span>
<span class="cm"> *   slabs, operations can continue without any centralized lock. F.e.</span>
<span class="cm"> *   allocating a long series of objects that fill up slabs does not require</span>
<span class="cm"> *   the list lock.</span>
<span class="cm"> *   Interrupts are disabled during allocation and deallocation in order to</span>
<span class="cm"> *   make the slab allocator safe to use in the context of an irq. In addition</span>
<span class="cm"> *   interrupts are disabled to ensure that the processor does not change</span>
<span class="cm"> *   while handling per_cpu slabs, due to kernel preemption.</span>
<span class="cm"> *</span>
<span class="cm"> * SLUB assigns one slab for allocation to each processor.</span>
<span class="cm"> * Allocations only occur from these slabs called cpu slabs.</span>
<span class="cm"> *</span>
<span class="cm"> * Slabs with free elements are kept on a partial list and during regular</span>
<span class="cm"> * operations no list for full slabs is used. If an object in a full slab is</span>
<span class="cm"> * freed then the slab will show up again on the partial lists.</span>
<span class="cm"> * We track full slabs for debugging purposes though because otherwise we</span>
<span class="cm"> * cannot scan all objects.</span>
<span class="cm"> *</span>
<span class="cm"> * Slabs are freed when they become empty. Teardown and setup is</span>
<span class="cm"> * minimal so we rely on the page allocators per cpu caches for</span>
<span class="cm"> * fast frees and allocs.</span>
<span class="cm"> *</span>
<span class="cm"> * Overloading of page flags that are otherwise used for LRU management.</span>
<span class="cm"> *</span>
<span class="cm"> * PageActive 		The slab is frozen and exempt from list processing.</span>
<span class="cm"> * 			This means that the slab is dedicated to a purpose</span>
<span class="cm"> * 			such as satisfying allocations for a specific</span>
<span class="cm"> * 			processor. Objects may be freed in the slab while</span>
<span class="cm"> * 			it is frozen but slab_free will then skip the usual</span>
<span class="cm"> * 			list operations. It is up to the processor holding</span>
<span class="cm"> * 			the slab to integrate the slab into the slab lists</span>
<span class="cm"> * 			when the slab is no longer needed.</span>
<span class="cm"> *</span>
<span class="cm"> * 			One use of this flag is to mark slabs that are</span>
<span class="cm"> * 			used for allocations. Then such a slab becomes a cpu</span>
<span class="cm"> * 			slab. The cpu slab may be equipped with an additional</span>
<span class="cm"> * 			freelist that allows lockless access to</span>
<span class="cm"> * 			free objects in addition to the regular freelist</span>
<span class="cm"> * 			that requires the slab lock.</span>
<span class="cm"> *</span>
<span class="cm"> * PageError		Slab requires special handling due to debug</span>
<span class="cm"> * 			options set. This moves	slab handling out of</span>
<span class="cm"> * 			the fast path and disables lockless freelists.</span>
<span class="cm"> */</span>

<span class="cp">#define SLAB_DEBUG_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \</span>
<span class="cp">		SLAB_TRACE | SLAB_DEBUG_FREE)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kmem_cache_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
	<span class="k">return</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DEBUG_FLAGS</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Issues still to be resolved:</span>
<span class="cm"> *</span>
<span class="cm"> * - Support PAGE_ALLOC_DEBUG. Should be easy to do.</span>
<span class="cm"> *</span>
<span class="cm"> * - Variable sizing of the per node arrays</span>
<span class="cm"> */</span>

<span class="cm">/* Enable to test recovery from slab corruption on boot */</span>
<span class="cp">#undef SLUB_RESILIENCY_TEST</span>

<span class="cm">/* Enable to log cmpxchg failures */</span>
<span class="cp">#undef SLUB_DEBUG_CMPXCHG</span>

<span class="cm">/*</span>
<span class="cm"> * Mininum number of partial slabs. These will be left on the partial</span>
<span class="cm"> * lists even if they are empty. kmem_cache_shrink may reclaim them.</span>
<span class="cm"> */</span>
<span class="cp">#define MIN_PARTIAL 5</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum number of desirable partial slabs.</span>
<span class="cm"> * The existence of more partial slabs makes kmem_cache_shrink</span>
<span class="cm"> * sort the partial list by the number of objects in the.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_PARTIAL 10</span>

<span class="cp">#define DEBUG_DEFAULT_FLAGS (SLAB_DEBUG_FREE | SLAB_RED_ZONE | \</span>
<span class="cp">				SLAB_POISON | SLAB_STORE_USER)</span>

<span class="cm">/*</span>
<span class="cm"> * Debugging flags that require metadata to be stored in the slab.  These get</span>
<span class="cm"> * disabled when slub_debug=O is used and a cache&#39;s min order increases with</span>
<span class="cm"> * metadata.</span>
<span class="cm"> */</span>
<span class="cp">#define DEBUG_METADATA_FLAGS (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER)</span>

<span class="cm">/*</span>
<span class="cm"> * Set of flags that will prevent slab merging</span>
<span class="cm"> */</span>
<span class="cp">#define SLUB_NEVER_MERGE (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | \</span>
<span class="cp">		SLAB_TRACE | SLAB_DESTROY_BY_RCU | SLAB_NOLEAKTRACE | \</span>
<span class="cp">		SLAB_FAILSLAB)</span>

<span class="cp">#define SLUB_MERGE_SAME (SLAB_DEBUG_FREE | SLAB_RECLAIM_ACCOUNT | \</span>
<span class="cp">		SLAB_CACHE_DMA | SLAB_NOTRACK)</span>

<span class="cp">#define OO_SHIFT	16</span>
<span class="cp">#define OO_MASK		((1 &lt;&lt; OO_SHIFT) - 1)</span>
<span class="cp">#define MAX_OBJS_PER_PAGE	32767 </span><span class="cm">/* since page.objects is u15 */</span><span class="cp"></span>

<span class="cm">/* Internal SLUB flags */</span>
<span class="cp">#define __OBJECT_POISON		0x80000000UL </span><span class="cm">/* Poison object */</span><span class="cp"></span>
<span class="cp">#define __CMPXCHG_DOUBLE	0x40000000UL </span><span class="cm">/* Use cmpxchg_double */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">kmem_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">slab_notifier</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">DOWN</span><span class="p">,</span>		<span class="cm">/* No slab functionality available */</span>
	<span class="n">PARTIAL</span><span class="p">,</span>	<span class="cm">/* Kmem_cache_node works */</span>
	<span class="n">UP</span><span class="p">,</span>		<span class="cm">/* Everything works but does not show up in sysfs */</span>
	<span class="n">SYSFS</span>		<span class="cm">/* Sysfs up */</span>
<span class="p">}</span> <span class="n">slab_state</span> <span class="o">=</span> <span class="n">DOWN</span><span class="p">;</span>

<span class="cm">/* A list of all slab caches on the system */</span>
<span class="k">static</span> <span class="n">DECLARE_RWSEM</span><span class="p">(</span><span class="n">slub_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">slab_caches</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Tracking user of a slab.</span>
<span class="cm"> */</span>
<span class="cp">#define TRACK_ADDRS_COUNT 16</span>
<span class="k">struct</span> <span class="n">track</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>	<span class="cm">/* Called from address */</span>
<span class="cp">#ifdef CONFIG_STACKTRACE</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addrs</span><span class="p">[</span><span class="n">TRACK_ADDRS_COUNT</span><span class="p">];</span>	<span class="cm">/* Called from address */</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>		<span class="cm">/* Was running on cpu */</span>
	<span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>		<span class="cm">/* Pid context */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">when</span><span class="p">;</span>	<span class="cm">/* When did the operation occur */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">track_item</span> <span class="p">{</span> <span class="n">TRACK_ALLOC</span><span class="p">,</span> <span class="n">TRACK_FREE</span> <span class="p">};</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sysfs_slab_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sysfs_slab_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sysfs_slab_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysfs_slab_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sysfs_slab_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
							<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sysfs_slab_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">stat</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">enum</span> <span class="n">stat_item</span> <span class="n">si</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SLUB_STATS</span>
	<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">[</span><span class="n">si</span><span class="p">]);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/********************************************************************</span>
<span class="cm"> * 			Core slab cache functions</span>
<span class="cm"> *******************************************************************/</span>

<span class="kt">int</span> <span class="nf">slab_is_available</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">slab_state</span> <span class="o">&gt;=</span> <span class="n">UP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="nf">get_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Verify that a pointer has an address that is valid within a slab page */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_valid_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">&lt;</span> <span class="n">base</span> <span class="o">||</span> <span class="n">object</span> <span class="o">&gt;=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span> <span class="o">*</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">object</span> <span class="o">-</span> <span class="n">base</span><span class="p">)</span> <span class="o">%</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">get_freepointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)(</span><span class="n">object</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prefetch_freepointer</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prefetch</span><span class="p">(</span><span class="n">object</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">get_freepointer_safe</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_PAGEALLOC</span>
	<span class="n">probe_kernel_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)(</span><span class="n">object</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="cp">#else</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_freepointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)(</span><span class="n">object</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Loop over all objects in a slab */</span>
<span class="cp">#define for_each_object(__p, __s, __addr, __objects) \</span>
<span class="cp">	for (__p = (__addr); __p &lt; (__addr) + (__objects) * (__s)-&gt;size;\</span>
<span class="cp">			__p += (__s)-&gt;size)</span>

<span class="cm">/* Determine object index from a given position */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">slab_index</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">addr</span><span class="p">)</span> <span class="o">/</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">slab_ksize</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
	<span class="cm">/*</span>
<span class="cm">	 * Debugging requires use of the padding between object</span>
<span class="cm">	 * and whatever may come after it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SLAB_RED_ZONE</span> <span class="o">|</span> <span class="n">SLAB_POISON</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">;</span>

<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we have the need to store the freelist pointer</span>
<span class="cm">	 * back there or track user information then we can</span>
<span class="cm">	 * only use the space before that information.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SLAB_DESTROY_BY_RCU</span> <span class="o">|</span> <span class="n">SLAB_STORE_USER</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Else we can use all the padding etc for the allocation</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">order_objects</span><span class="p">(</span><span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="n">reserved</span><span class="p">)</span> <span class="o">/</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="nf">oo_make</span><span class="p">(</span><span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">(</span><span class="n">order</span> <span class="o">&lt;&lt;</span> <span class="n">OO_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">order_objects</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">reserved</span><span class="p">)</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">oo_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">OO_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">oo_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">OO_MASK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Per slab locking using the pagelock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">slab_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bit_spin_lock</span><span class="p">(</span><span class="n">PG_locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">slab_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__bit_spin_unlock</span><span class="p">(</span><span class="n">PG_locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Interrupts must be disabled (for the fallback code to work right) */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">__cmpxchg_double_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">freelist_old</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters_old</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">freelist_new</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters_new</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
<span class="cp">#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span>
<span class="cp">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__CMPXCHG_DOUBLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg_double</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">,</span>
			<span class="n">freelist_old</span><span class="p">,</span> <span class="n">counters_old</span><span class="p">,</span>
			<span class="n">freelist_new</span><span class="p">,</span> <span class="n">counters_new</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
	<span class="p">{</span>
		<span class="n">slab_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">==</span> <span class="n">freelist_old</span> <span class="o">&amp;&amp;</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">==</span> <span class="n">counters_old</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">freelist_new</span><span class="p">;</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">=</span> <span class="n">counters_new</span><span class="p">;</span>
			<span class="n">slab_unlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">slab_unlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CMPXCHG_DOUBLE_FAIL</span><span class="p">);</span>

<span class="cp">#ifdef SLUB_DEBUG_CMPXCHG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s %s: cmpxchg double redo &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">cmpxchg_double_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">freelist_old</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters_old</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">freelist_new</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters_new</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span>
<span class="cp">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__CMPXCHG_DOUBLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg_double</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">,</span>
			<span class="n">freelist_old</span><span class="p">,</span> <span class="n">counters_old</span><span class="p">,</span>
			<span class="n">freelist_new</span><span class="p">,</span> <span class="n">counters_new</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">slab_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">==</span> <span class="n">freelist_old</span> <span class="o">&amp;&amp;</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">==</span> <span class="n">counters_old</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">freelist_new</span><span class="p">;</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span> <span class="o">=</span> <span class="n">counters_new</span><span class="p">;</span>
			<span class="n">slab_unlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">slab_unlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CMPXCHG_DOUBLE_FAIL</span><span class="p">);</span>

<span class="cp">#ifdef SLUB_DEBUG_CMPXCHG</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s %s: cmpxchg double redo &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * Determine a map of object in use on a page.</span>
<span class="cm"> *</span>
<span class="cm"> * Node listlock must be held to guarantee that the page does</span>
<span class="cm"> * not vanish from under us.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">slab_index</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">addr</span><span class="p">),</span> <span class="n">map</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Debug settings:</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG_ON</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">slub_debug</span> <span class="o">=</span> <span class="n">DEBUG_DEFAULT_FLAGS</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">slub_debug</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">slub_debug_slabs</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">disable_higher_order_debug</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Object debugging</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_section</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">print_hex_dump</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">DUMP_PREFIX_ADDRESS</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
			<span class="n">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">track</span> <span class="o">*</span><span class="nf">get_track</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
	<span class="k">enum</span> <span class="n">track_item</span> <span class="n">alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">track</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">object</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">object</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">p</span> <span class="o">+</span> <span class="n">alloc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_track</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">track_item</span> <span class="n">alloc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">track</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">get_track</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">alloc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_STACKTRACE</span>
		<span class="k">struct</span> <span class="n">stack_trace</span> <span class="n">trace</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">trace</span><span class="p">.</span><span class="n">max_entries</span> <span class="o">=</span> <span class="n">TRACK_ADDRS_COUNT</span><span class="p">;</span>
		<span class="n">trace</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">;</span>
		<span class="n">trace</span><span class="p">.</span><span class="n">skip</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">save_stack_trace</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trace</span><span class="p">);</span>

		<span class="cm">/* See rant in lockdep.c */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">trace</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ULONG_MAX</span><span class="p">)</span>
			<span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span><span class="o">--</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">trace</span><span class="p">.</span><span class="n">nr_entries</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TRACK_ADDRS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">when</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">track</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_tracking</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">set_track</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">TRACK_FREE</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
	<span class="n">set_track</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">TRACK_ALLOC</span><span class="p">,</span> <span class="mi">0UL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_track</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">track</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;INFO: %s in %pS age=%lu cpu=%u pid=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">when</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_STACKTRACE</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TRACK_ADDRS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">%pS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">else</span>
				<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_tracking</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">print_track</span><span class="p">(</span><span class="s">&quot;Allocated&quot;</span><span class="p">,</span> <span class="n">get_track</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">TRACK_ALLOC</span><span class="p">));</span>
	<span class="n">print_track</span><span class="p">(</span><span class="s">&quot;Freed&quot;</span><span class="p">,</span> <span class="n">get_track</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">TRACK_FREE</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_page_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;INFO: Slab 0x%p objects=%u used=%u fp=0x%p flags=0x%04lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">page</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_bug</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">vsnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;========================================&quot;</span>
			<span class="s">&quot;=====================================</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;BUG %s (%s): %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">print_tainted</span><span class="p">(),</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;----------------------------------------&quot;</span>
			<span class="s">&quot;-------------------------------------</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_fix</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">vsnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FIX %s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_trailer</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">off</span><span class="p">;</span>	<span class="cm">/* Offset of last byte */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">print_tracking</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

	<span class="n">print_page_info</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;INFO: Object 0x%p @offset=%tu fp=0x%p</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">p</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="n">addr</span><span class="p">,</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">addr</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">print_section</span><span class="p">(</span><span class="s">&quot;Bytes b4 &quot;</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

	<span class="n">print_section</span><span class="p">(</span><span class="s">&quot;Object &quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">,</span>
				<span class="n">PAGE_SIZE</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span>
		<span class="n">print_section</span><span class="p">(</span><span class="s">&quot;Redzone &quot;</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">,</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">off</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">track</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">!=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
		<span class="cm">/* Beginning of the filler is the free pointer */</span>
		<span class="n">print_section</span><span class="p">(</span><span class="s">&quot;Padding &quot;</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">off</span><span class="p">);</span>

	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">object_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">slab_bug</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
	<span class="n">print_trailer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">vsnprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="n">slab_bug</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">print_page_info</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">dump_stack</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">object</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__OBJECT_POISON</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">POISON_FREE</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">POISON_END</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">restore_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> <span class="n">u8</span> <span class="n">data</span><span class="p">,</span>
						<span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">slab_fix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;Restoring 0x%p-0x%p=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">to</span> <span class="o">-</span> <span class="n">from</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_bytes_and_report</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">what</span><span class="p">,</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">fault</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="n">fault</span> <span class="o">=</span> <span class="n">memchr_inv</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fault</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">fault</span> <span class="o">&amp;&amp;</span> <span class="n">end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span>
		<span class="n">end</span><span class="o">--</span><span class="p">;</span>

	<span class="n">slab_bug</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%s overwritten&quot;</span><span class="p">,</span> <span class="n">what</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;INFO: 0x%p-0x%p. First byte 0x%x instead of 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">fault</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fault</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">print_trailer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>

	<span class="n">restore_bytes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">fault</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Object layout:</span>
<span class="cm"> *</span>
<span class="cm"> * object address</span>
<span class="cm"> * 	Bytes of the object to be managed.</span>
<span class="cm"> * 	If the freepointer may overlay the object then the free</span>
<span class="cm"> * 	pointer is the first word of the object.</span>
<span class="cm"> *</span>
<span class="cm"> * 	Poisoning uses 0x6b (POISON_FREE) and the last byte is</span>
<span class="cm"> * 	0xa5 (POISON_END)</span>
<span class="cm"> *</span>
<span class="cm"> * object + s-&gt;objsize</span>
<span class="cm"> * 	Padding to reach word boundary. This is also used for Redzoning.</span>
<span class="cm"> * 	Padding is extended by another word if Redzoning is enabled and</span>
<span class="cm"> * 	objsize == inuse.</span>
<span class="cm"> *</span>
<span class="cm"> * 	We fill with 0xbb (RED_INACTIVE) for inactive objects and with</span>
<span class="cm"> * 	0xcc (RED_ACTIVE) for objects in use.</span>
<span class="cm"> *</span>
<span class="cm"> * object + s-&gt;inuse</span>
<span class="cm"> * 	Meta data starts here.</span>
<span class="cm"> *</span>
<span class="cm"> * 	A. Free pointer (if we cannot overwrite object on free)</span>
<span class="cm"> * 	B. Tracking data for SLAB_STORE_USER</span>
<span class="cm"> * 	C. Padding to reach required alignment boundary or at mininum</span>
<span class="cm"> * 		one word if debugging is on to be able to detect writes</span>
<span class="cm"> * 		before the word boundary.</span>
<span class="cm"> *</span>
<span class="cm"> *	Padding is done using 0x5a (POISON_INUSE)</span>
<span class="cm"> *</span>
<span class="cm"> * object + s-&gt;size</span>
<span class="cm"> * 	Nothing is used beyond s-&gt;size.</span>
<span class="cm"> *</span>
<span class="cm"> * If slabcaches are merged then the objsize and inuse boundaries are mostly</span>
<span class="cm"> * ignored. And therefore no slab options that rely on these boundaries</span>
<span class="cm"> * may be used with merged slabcaches.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_pad_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">;</span>	<span class="cm">/* The end of info */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span>
		<span class="cm">/* Freepointer is placed after the object. */</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span>
		<span class="cm">/* We also have user information there */</span>
		<span class="n">off</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">track</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">off</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">check_bytes_and_report</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&quot;Object padding&quot;</span><span class="p">,</span>
				<span class="n">p</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">POISON_INUSE</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">off</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check the pad bytes at the end of a slab page */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">slab_pad_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">fault</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remainder</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">remainder</span> <span class="o">=</span> <span class="n">length</span> <span class="o">%</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remainder</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">fault</span> <span class="o">=</span> <span class="n">memchr_inv</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">POISON_INUSE</span><span class="p">,</span> <span class="n">remainder</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fault</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">fault</span> <span class="o">&amp;&amp;</span> <span class="n">end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">POISON_INUSE</span><span class="p">)</span>
		<span class="n">end</span><span class="o">--</span><span class="p">;</span>

	<span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">&quot;Padding overwritten. 0x%p-0x%p&quot;</span><span class="p">,</span> <span class="n">fault</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">print_section</span><span class="p">(</span><span class="s">&quot;Padding &quot;</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">remainder</span><span class="p">);</span>

	<span class="n">restore_bytes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;slab padding&quot;</span><span class="p">,</span> <span class="n">POISON_INUSE</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">object</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">endobject</span> <span class="o">=</span> <span class="n">object</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_bytes_and_report</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="s">&quot;Redzone&quot;</span><span class="p">,</span>
			<span class="n">endobject</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">check_bytes_and_report</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&quot;Alignment padding&quot;</span><span class="p">,</span>
				<span class="n">endobject</span><span class="p">,</span> <span class="n">POISON_INUSE</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">SLUB_RED_ACTIVE</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__OBJECT_POISON</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="o">!</span><span class="n">check_bytes_and_report</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&quot;Poison&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
					<span class="n">POISON_FREE</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
			 <span class="o">!</span><span class="n">check_bytes_and_report</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&quot;Poison&quot;</span><span class="p">,</span>
				<span class="n">p</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">POISON_END</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * check_pad_bytes cleans up on its own.</span>
<span class="cm">		 */</span>
		<span class="n">check_pad_bytes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">==</span> <span class="n">SLUB_RED_ACTIVE</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Object and freepointer overlap. Cannot check</span>
<span class="cm">		 * freepointer while object is allocated.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Check free pointer validity */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_valid_pointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">object_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="s">&quot;Freepointer corrupt&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * No choice but to zap it and thus lose the remainder</span>
<span class="cm">		 * of the free objects in this slab. May cause</span>
<span class="cm">		 * another error because the object count is now wrong.</span>
<span class="cm">		 */</span>
		<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">maxobj</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">&quot;Not a valid slab page&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">maxobj</span> <span class="o">=</span> <span class="n">order_objects</span><span class="p">(</span><span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span> <span class="o">&gt;</span> <span class="n">maxobj</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">&quot;objects %u &gt; max %u&quot;</span><span class="p">,</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">,</span> <span class="n">maxobj</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">&gt;</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">&quot;inuse %u &gt; max %u&quot;</span><span class="p">,</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Slab_pad_check fixes things up after itself */</span>
	<span class="n">slab_pad_check</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if a certain object on a page is on the freelist. Must hold the</span>
<span class="cm"> * slab lock to guarantee that the chains are in a consistent state.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">on_freelist</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">search</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_objects</span><span class="p">;</span>

	<span class="n">fp</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">fp</span> <span class="o">&amp;&amp;</span> <span class="n">nr</span> <span class="o">&lt;=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="n">search</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_valid_pointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">object_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span>
					<span class="s">&quot;Freechain corrupt&quot;</span><span class="p">);</span>
				<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">&quot;Freepointer corrupt&quot;</span><span class="p">);</span>
				<span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">;</span>
				<span class="n">slab_fix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;Freelist cleared&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">object</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
		<span class="n">nr</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">max_objects</span> <span class="o">=</span> <span class="n">order_objects</span><span class="p">(</span><span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_objects</span> <span class="o">&gt;</span> <span class="n">MAX_OBJS_PER_PAGE</span><span class="p">)</span>
		<span class="n">max_objects</span> <span class="o">=</span> <span class="n">MAX_OBJS_PER_PAGE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span> <span class="o">!=</span> <span class="n">max_objects</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">&quot;Wrong number of objects. Found %d but &quot;</span>
			<span class="s">&quot;should be %d&quot;</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">,</span> <span class="n">max_objects</span><span class="p">);</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span> <span class="o">=</span> <span class="n">max_objects</span><span class="p">;</span>
		<span class="n">slab_fix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;Number of objects adjusted.&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">!=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span> <span class="o">-</span> <span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">&quot;Wrong object count. Counter is %d but &quot;</span>
			<span class="s">&quot;counted were %d&quot;</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span> <span class="o">-</span> <span class="n">nr</span><span class="p">);</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span> <span class="o">-</span> <span class="n">nr</span><span class="p">;</span>
		<span class="n">slab_fix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;Object count adjusted.&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">search</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
								<span class="kt">int</span> <span class="n">alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_TRACE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;TRACE %s %s 0x%p inuse=%d fp=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">alloc</span> <span class="o">?</span> <span class="s">&quot;alloc&quot;</span> <span class="o">:</span> <span class="s">&quot;free&quot;</span><span class="p">,</span>
			<span class="n">object</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">,</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc</span><span class="p">)</span>
			<span class="n">print_section</span><span class="p">(</span><span class="s">&quot;Object &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">);</span>

		<span class="n">dump_stack</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hooks for other subsystems that check memory allocations. In a typical</span>
<span class="cm"> * production configuration these hooks all should produce no code at all.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">slab_pre_alloc_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">gfp_allowed_mask</span><span class="p">;</span>
	<span class="n">lockdep_trace_alloc</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">should_failslab</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">slab_post_alloc_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">gfp_allowed_mask</span><span class="p">;</span>
	<span class="n">kmemcheck_slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">slab_ksize</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
	<span class="n">kmemleak_alloc_recursive</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">slab_free_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmemleak_free_recursive</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Trouble is that we may no longer disable interupts in the fast path</span>
<span class="cm">	 * So in order to make the debug calls that expect irqs to be</span>
<span class="cm">	 * disabled we need to disable interrupts temporarily.</span>
<span class="cm">	 */</span>
<span class="cp">#if defined(CONFIG_KMEMCHECK) || defined(CONFIG_LOCKDEP)</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">kmemcheck_slab_free</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">);</span>
		<span class="n">debug_check_no_locks_freed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DEBUG_OBJECTS</span><span class="p">))</span>
		<span class="n">debug_check_no_obj_freed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tracking of fully allocated slabs for debugging purposes.</span>
<span class="cm"> *</span>
<span class="cm"> * list_lock must be held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * list_lock must be held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Tracking of the number of slabs for debugging purposes */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">slabs_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_slabs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">node_nr_slabs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_slabs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_slabs_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">objects</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * May be called early in order to allocate a slab for the</span>
<span class="cm">	 * kmem_cache_node structure. Solve the chicken-egg</span>
<span class="cm">	 * dilemma by deferring the increment of the count during</span>
<span class="cm">	 * bootstrap (see early_kmem_cache_node_alloc).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_long_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_slabs</span><span class="p">);</span>
		<span class="n">atomic_long_add</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">total_objects</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dec_slabs_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">objects</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_slabs</span><span class="p">);</span>
	<span class="n">atomic_long_sub</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">total_objects</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Object debug checks for alloc/free paths */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_object_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
								<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SLAB_STORE_USER</span><span class="o">|</span><span class="n">SLAB_RED_ZONE</span><span class="o">|</span><span class="n">__OBJECT_POISON</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">init_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">SLUB_RED_INACTIVE</span><span class="p">);</span>
	<span class="n">init_tracking</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">alloc_debug_processing</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_valid_pointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">object_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="s">&quot;Freelist Pointer check fails&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">SLUB_RED_INACTIVE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

	<span class="cm">/* Success perform special debug activities for allocs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span>
		<span class="n">set_track</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">TRACK_ALLOC</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">trace</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">init_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">SLUB_RED_ACTIVE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this is a slab page then lets do the best we can</span>
<span class="cm">		 * to avoid issues in the future. Marking all objects</span>
<span class="cm">		 * as used avoids touching the remaining objects.</span>
<span class="cm">		 */</span>
		<span class="n">slab_fix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;Marking all objects used&quot;</span><span class="p">);</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">;</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">free_debug_processing</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">slab_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_valid_pointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">&quot;Invalid object pointer 0x%p&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">on_freelist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">object_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="s">&quot;Object already free&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">SLUB_RED_ACTIVE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">&quot;Attempt to free object(0x%p) &quot;</span>
				<span class="s">&quot;outside of slab&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;SLUB &lt;none&gt;: no slab for object 0x%p.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">object</span><span class="p">);</span>
			<span class="n">dump_stack</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">object_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span>
					<span class="s">&quot;page slab pointer corrupt.&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span>
		<span class="n">set_track</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">TRACK_FREE</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">trace</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">init_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">SLUB_RED_INACTIVE</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">slab_unlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">slab_fix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;Object at 0x%p not freed&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_slub_debug</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">slub_debug</span> <span class="o">=</span> <span class="n">DEBUG_DEFAULT_FLAGS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;=&#39;</span> <span class="o">||</span> <span class="o">!*</span><span class="n">str</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * No options specified. Switch on full debugging.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * No options but restriction on slabs. This means full</span>
<span class="cm">		 * debugging for slabs matching a pattern.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">check_slabs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tolower</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;o&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Avoid enabling debugging on caches if its minimum order</span>
<span class="cm">		 * would increase as a result.</span>
<span class="cm">		 */</span>
		<span class="n">disable_higher_order_debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">slub_debug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Switch off all debugging measures.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine which debug features should be switched on</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">str</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">str</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span><span class="p">;</span> <span class="n">str</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">tolower</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;f&#39;</span>:
			<span class="n">slub_debug</span> <span class="o">|=</span> <span class="n">SLAB_DEBUG_FREE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;z&#39;</span>:
			<span class="n">slub_debug</span> <span class="o">|=</span> <span class="n">SLAB_RED_ZONE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;p&#39;</span>:
			<span class="n">slub_debug</span> <span class="o">|=</span> <span class="n">SLAB_POISON</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;u&#39;</span>:
			<span class="n">slub_debug</span> <span class="o">|=</span> <span class="n">SLAB_STORE_USER</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;t&#39;</span>:
			<span class="n">slub_debug</span> <span class="o">|=</span> <span class="n">SLAB_TRACE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">&#39;a&#39;</span>:
			<span class="n">slub_debug</span> <span class="o">|=</span> <span class="n">SLAB_FAILSLAB</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;slub_debug option &#39;%c&#39; &quot;</span>
				<span class="s">&quot;unknown. skipped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">check_slabs:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
		<span class="n">slub_debug_slabs</span> <span class="o">=</span> <span class="n">str</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;slub_debug&quot;</span><span class="p">,</span> <span class="n">setup_slub_debug</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kmem_cache_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">objsize</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Enable debugging if selected on the kernel commandline.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slub_debug</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">slub_debug_slabs</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">slub_debug_slabs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">slub_debug_slabs</span><span class="p">))))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">slub_debug</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setup_object_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">alloc_debug_processing</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">free_debug_processing</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">slab_pad_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
			<span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">check_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">u8</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">remove_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">kmem_cache_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">objsize</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define slub_debug 0</span>

<span class="cp">#define disable_higher_order_debug 0</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">slabs_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
							<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">node_nr_slabs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
							<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">inc_slabs_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
							<span class="kt">int</span> <span class="n">objects</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dec_slabs_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
							<span class="kt">int</span> <span class="n">objects</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">slab_pre_alloc_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
							<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">slab_post_alloc_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">slab_free_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SLUB_DEBUG */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Slab allocation and freeing</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_slab_page</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="n">oo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">oo_order</span><span class="p">(</span><span class="n">oo</span><span class="p">);</span>

	<span class="n">flags</span> <span class="o">|=</span> <span class="n">__GFP_NOTRACK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">alloc_pages_exact_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">allocate_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_order_objects</span> <span class="n">oo</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">oo</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">alloc_gfp</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">gfp_allowed_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span>
		<span class="n">local_irq_enable</span><span class="p">();</span>

	<span class="n">flags</span> <span class="o">|=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">allocflags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let the initial higher-order allocation fail under memory pressure</span>
<span class="cm">	 * so we fall-back to the minimum order allocation.</span>
<span class="cm">	 */</span>
	<span class="n">alloc_gfp</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_NOFAIL</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_slab_page</span><span class="p">(</span><span class="n">alloc_gfp</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">oo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">oo</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allocation may have failed due to fragmentation.</span>
<span class="cm">		 * Try a lower order alloc if possible</span>
<span class="cm">		 */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_slab_page</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">oo</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
			<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ORDER_FALLBACK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)</span>
		<span class="n">local_irq_disable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kmemcheck_enabled</span>
		<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SLAB_NOTRACK</span> <span class="o">|</span> <span class="n">DEBUG_DEFAULT_FLAGS</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">oo_order</span><span class="p">(</span><span class="n">oo</span><span class="p">);</span>

		<span class="n">kmemcheck_alloc_shadow</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">oo_order</span><span class="p">(</span><span class="n">oo</span><span class="p">),</span> <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Objects from caches that have a constructor don&#39;t get</span>
<span class="cm">		 * cleared when they&#39;re allocated, so we need to do it here.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">)</span>
			<span class="n">kmemcheck_mark_uninitialized_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">kmemcheck_mark_unallocated_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span> <span class="o">=</span> <span class="n">oo_objects</span><span class="p">(</span><span class="n">oo</span><span class="p">);</span>
	<span class="n">mod_zone_page_state</span><span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
		<span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">NR_SLAB_RECLAIMABLE</span> <span class="o">:</span> <span class="n">NR_SLAB_UNRECLAIMABLE</span><span class="p">,</span>
		<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">oo_order</span><span class="p">(</span><span class="n">oo</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">setup_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">setup_object_debug</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">))</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">new_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GFP_SLAB_BUG_MASK</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">allocate_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
		<span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">GFP_RECLAIM_MASK</span> <span class="o">|</span> <span class="n">GFP_CONSTRAINT_MASK</span><span class="p">),</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">inc_slabs_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">);</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">__SetPageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">))</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">POISON_INUSE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">last</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">for_each_object</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">setup_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
		<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">setup_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">;</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__free_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="n">slab_pad_check</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">for_each_object</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
						<span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">)</span>
			<span class="n">check_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">SLUB_RED_INACTIVE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kmemcheck_free_shadow</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">mod_zone_page_state</span><span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
		<span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">NR_SLAB_RECLAIMABLE</span> <span class="o">:</span> <span class="n">NR_SLAB_UNRECLAIMABLE</span><span class="p">,</span>
		<span class="o">-</span><span class="n">pages</span><span class="p">);</span>

	<span class="n">__ClearPageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">reset_page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">reclaim_state</span><span class="o">-&gt;</span><span class="n">reclaimed_slab</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define need_reserve_slab_rcu						\</span>
<span class="cp">	(sizeof(((struct page *)NULL)-&gt;lru) &lt; sizeof(struct rcu_head))</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">rcu_free_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_reserve_slab_rcu</span><span class="p">)</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">((</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">)</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>

	<span class="n">__free_slab</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">need_reserve_slab_rcu</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">;</span>

			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">));</span>
			<span class="n">head</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * RCU free overloads the RCU head over the LRU</span>
<span class="cm">			 */</span>
			<span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">call_rcu</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">rcu_free_slab</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">__free_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">discard_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dec_slabs_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">);</span>
	<span class="n">free_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Management of partially allocated slabs.</span>
<span class="cm"> *</span>
<span class="cm"> * list_lock must be held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail</span> <span class="o">==</span> <span class="n">DEACTIVATE_TO_TAIL</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * list_lock must be held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">remove_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Lock slab, remove from the partial list and put the object into the</span>
<span class="cm"> * per cpu freelist.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a list of objects or NULL if it fails.</span>
<span class="cm"> *</span>
<span class="cm"> * Must hold list_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">acquire_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">freelist</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="n">new</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Zap the freelist and set the frozen bit.</span>
<span class="cm">	 * The old freelist is the list of objects for the</span>
<span class="cm">	 * per cpu allocation list.</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">freelist</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
		<span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
		<span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">counters</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">;</span>
			<span class="n">new</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">new</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">freelist</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">frozen</span><span class="p">);</span>
		<span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">__cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
			<span class="n">freelist</span><span class="p">,</span> <span class="n">counters</span><span class="p">,</span>
			<span class="n">new</span><span class="p">.</span><span class="n">freelist</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
			<span class="s">&quot;lock and freeze&quot;</span><span class="p">));</span>

	<span class="n">remove_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">freelist</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">put_cpu_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">drain</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Try to allocate a partial slab from a specific node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">get_partial_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">page2</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Racy check. If we mistakenly see no partial slabs then we</span>
<span class="cm">	 * just allocate an empty slab. If we mistakenly try to get a</span>
<span class="cm">	 * partial slab and there is none available then get_partials()</span>
<span class="cm">	 * will return NULL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span> <span class="o">||</span> <span class="o">!</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">page2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">acquire_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">available</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ALLOC_FROM_PARTIAL</span><span class="p">);</span>
			<span class="n">object</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
			<span class="n">available</span> <span class="o">=</span>  <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span> <span class="o">-</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">available</span> <span class="o">=</span> <span class="n">put_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CPU_PARTIAL_NODE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">||</span> <span class="n">available</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">object</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a page from somewhere. Search in increasing NUMA distances.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">get_any_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">zone_type</span> <span class="n">high_zoneidx</span> <span class="o">=</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpuset_mems_cookie</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The defrag ratio allows a configuration of the tradeoffs between</span>
<span class="cm">	 * inter node defragmentation and node local allocations. A lower</span>
<span class="cm">	 * defrag_ratio increases the tendency to do local allocations</span>
<span class="cm">	 * instead of attempting to obtain partial slabs from other nodes.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the defrag_ratio is set to 0 then kmalloc() always</span>
<span class="cm">	 * returns node local objects. If the ratio is higher then kmalloc()</span>
<span class="cm">	 * may return off node objects because partial slabs are obtained</span>
<span class="cm">	 * from other nodes and filled up.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If /sys/kernel/slab/xx/defrag_ratio is set to 100 (which makes</span>
<span class="cm">	 * defrag_ratio = 1000) then every (well almost) allocation will</span>
<span class="cm">	 * first attempt to defrag slab caches on other nodes. This means</span>
<span class="cm">	 * scanning over all nodes to look for partial slabs which may be</span>
<span class="cm">	 * expensive if we do it every time we are trying to find a slab</span>
<span class="cm">	 * with available objects.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">remote_node_defrag_ratio</span> <span class="o">||</span>
			<span class="n">get_cycles</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1024</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">remote_node_defrag_ratio</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">cpuset_mems_cookie</span> <span class="o">=</span> <span class="n">get_mems_allowed</span><span class="p">();</span>
		<span class="n">zonelist</span> <span class="o">=</span> <span class="n">node_zonelist</span><span class="p">(</span><span class="n">slab_node</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mempolicy</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">for_each_zone_zonelist</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span> <span class="n">high_zoneidx</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

			<span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">zone_to_nid</span><span class="p">(</span><span class="n">zone</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">cpuset_zone_allowed_hardwall</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">min_partial</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">object</span> <span class="o">=</span> <span class="n">get_partial_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * Return the object even if</span>
<span class="cm">					 * put_mems_allowed indicated that</span>
<span class="cm">					 * the cpuset mems_allowed was</span>
<span class="cm">					 * updated in parallel. It&#39;s a</span>
<span class="cm">					 * harmless race between the alloc</span>
<span class="cm">					 * and the cpuset update.</span>
<span class="cm">					 */</span>
					<span class="n">put_mems_allowed</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">object</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">put_mems_allowed</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get a partial page, lock it and return it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">get_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">searchnode</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span> <span class="o">?</span> <span class="n">numa_node_id</span><span class="p">()</span> <span class="o">:</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">get_partial_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">searchnode</span><span class="p">),</span> <span class="n">c</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">object</span> <span class="o">||</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">object</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">get_any_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PREEMPT</span>
<span class="cm">/*</span>
<span class="cm"> * Calculate the next globally unique transaction for disambiguiation</span>
<span class="cm"> * during cmpxchg. The transactions start with the cpu number and are then</span>
<span class="cm"> * incremented by CONFIG_NR_CPUS.</span>
<span class="cm"> */</span>
<span class="cp">#define TID_STEP  roundup_pow_of_two(CONFIG_NR_CPUS)</span>
<span class="cp">#else</span>
<span class="cm">/*</span>
<span class="cm"> * No preemption supported therefore also no need to check for</span>
<span class="cm"> * different cpus.</span>
<span class="cm"> */</span>
<span class="cp">#define TID_STEP 1</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">next_tid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tid</span> <span class="o">+</span> <span class="n">TID_STEP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">tid_to_cpu</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tid</span> <span class="o">%</span> <span class="n">TID_STEP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">tid_to_event</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tid</span> <span class="o">/</span> <span class="n">TID_STEP</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">init_tid</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">cpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">note_cmpxchg_failure</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tid</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef SLUB_DEBUG_CMPXCHG</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">actual_tid</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s %s: cmpxchg redo &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PREEMPT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid_to_cpu</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span> <span class="o">!=</span> <span class="n">tid_to_cpu</span><span class="p">(</span><span class="n">actual_tid</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;due to cpu change %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tid_to_cpu</span><span class="p">(</span><span class="n">tid</span><span class="p">),</span> <span class="n">tid_to_cpu</span><span class="p">(</span><span class="n">actual_tid</span><span class="p">));</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tid_to_event</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span> <span class="o">!=</span> <span class="n">tid_to_event</span><span class="p">(</span><span class="n">actual_tid</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;due to cpu running other code. Event %ld-&gt;%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tid_to_event</span><span class="p">(</span><span class="n">tid</span><span class="p">),</span> <span class="n">tid_to_event</span><span class="p">(</span><span class="n">actual_tid</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;for unknown reason: actual=%lx was=%lx target=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">actual_tid</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">next_tid</span><span class="p">(</span><span class="n">tid</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CMPXCHG_DOUBLE_CPU_FAIL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_kmem_cache_cpus</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">init_tid</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the cpu slab</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">deactivate_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">slab_modes</span> <span class="p">{</span> <span class="n">M_NONE</span><span class="p">,</span> <span class="n">M_PARTIAL</span><span class="p">,</span> <span class="n">M_FULL</span><span class="p">,</span> <span class="n">M_FREE</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">slab_modes</span> <span class="n">l</span> <span class="o">=</span> <span class="n">M_NONE</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">M_NONE</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">freelist</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">nextfree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">DEACTIVATE_TO_HEAD</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="n">new</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="n">old</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DEACTIVATE_REMOTE_FREES</span><span class="p">);</span>
		<span class="n">tail</span> <span class="o">=</span> <span class="n">DEACTIVATE_TO_TAIL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">next_tid</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">freelist</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stage one: Free all available per cpu objects back</span>
<span class="cm">	 * to the page freelist while it is still frozen. Leave the</span>
<span class="cm">	 * last one.</span>
<span class="cm">	 *</span>
<span class="cm">	 * There is no need to take the list-&gt;lock because the page</span>
<span class="cm">	 * is still frozen.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">freelist</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nextfree</span> <span class="o">=</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">freelist</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">prior</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">prior</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
			<span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
			<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">freelist</span><span class="p">,</span> <span class="n">prior</span><span class="p">);</span>
			<span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">counters</span><span class="p">;</span>
			<span class="n">new</span><span class="p">.</span><span class="n">inuse</span><span class="o">--</span><span class="p">;</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">frozen</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">__cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
			<span class="n">prior</span><span class="p">,</span> <span class="n">counters</span><span class="p">,</span>
			<span class="n">freelist</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
			<span class="s">&quot;drain percpu freelist&quot;</span><span class="p">));</span>

		<span class="n">freelist</span> <span class="o">=</span> <span class="n">nextfree</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stage two: Ensure that the page is unfrozen while the</span>
<span class="cm">	 * list presence reflects the actual number of objects</span>
<span class="cm">	 * during unfreeze.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We setup the list membership and then perform a cmpxchg</span>
<span class="cm">	 * with the count. If there is a mismatch then the page</span>
<span class="cm">	 * is not unfrozen but the page is on the wrong list.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Then we restart the process which may have to remove</span>
<span class="cm">	 * the page from the list that we just put it on again</span>
<span class="cm">	 * because the number of objects in the slab may have</span>
<span class="cm">	 * changed.</span>
<span class="cm">	 */</span>
<span class="nl">redo:</span>

	<span class="n">old</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
	<span class="n">old</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">old</span><span class="p">.</span><span class="n">frozen</span><span class="p">);</span>

	<span class="cm">/* Determine target state of the slab */</span>
	<span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">old</span><span class="p">.</span><span class="n">counters</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freelist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new</span><span class="p">.</span><span class="n">inuse</span><span class="o">--</span><span class="p">;</span>
		<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">freelist</span><span class="p">,</span> <span class="n">old</span><span class="p">.</span><span class="n">freelist</span><span class="p">);</span>
		<span class="n">new</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">freelist</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">new</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">old</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>

	<span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">min_partial</span><span class="p">)</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">M_FREE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">freelist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">M_PARTIAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Taking the spinlock removes the possiblity</span>
<span class="cm">			 * that acquire_slab() will see a slab page that</span>
<span class="cm">			 * is frozen</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">M_FULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * This also ensures that the scanning of full</span>
<span class="cm">			 * slabs from diagnostic functions will not see</span>
<span class="cm">			 * any frozen slabs.</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">M_PARTIAL</span><span class="p">)</span>

			<span class="n">remove_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">M_FULL</span><span class="p">)</span>

			<span class="n">remove_full</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">M_PARTIAL</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">add_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>
			<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">M_FULL</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DEACTIVATE_FULL</span><span class="p">);</span>
			<span class="n">add_full</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
				<span class="n">old</span><span class="p">.</span><span class="n">freelist</span><span class="p">,</span> <span class="n">old</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
				<span class="n">new</span><span class="p">.</span><span class="n">freelist</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
				<span class="s">&quot;unfreezing slab&quot;</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">M_FREE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DEACTIVATE_EMPTY</span><span class="p">);</span>
		<span class="n">discard_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_SLAB</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Unfreeze all the cpu partial slabs */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">unfreeze_partials</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">discard_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">page</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">slab_modes</span> <span class="p">{</span> <span class="n">M_PARTIAL</span><span class="p">,</span> <span class="n">M_FREE</span> <span class="p">};</span>
		<span class="k">enum</span> <span class="n">slab_modes</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="n">new</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="n">old</span><span class="p">;</span>

		<span class="n">c</span><span class="o">-&gt;</span><span class="n">partial</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">M_FREE</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>

			<span class="n">old</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
			<span class="n">old</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">old</span><span class="p">.</span><span class="n">frozen</span><span class="p">);</span>

			<span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">old</span><span class="p">.</span><span class="n">counters</span><span class="p">;</span>
			<span class="n">new</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">old</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>

			<span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span> <span class="o">||</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">min_partial</span><span class="p">))</span>
				<span class="n">m</span> <span class="o">=</span> <span class="n">M_FREE</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n2</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
							<span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

				<span class="n">m</span> <span class="o">=</span> <span class="n">M_PARTIAL</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">n2</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
						<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

					<span class="n">n</span> <span class="o">=</span> <span class="n">n2</span><span class="p">;</span>
					<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">M_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">remove_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
					<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_REMOVE_PARTIAL</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">add_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
						<span class="n">DEACTIVATE_TO_TAIL</span><span class="p">);</span>
					<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_ADD_PARTIAL</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">l</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
				<span class="n">old</span><span class="p">.</span><span class="n">freelist</span><span class="p">,</span> <span class="n">old</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
				<span class="n">new</span><span class="p">.</span><span class="n">freelist</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
				<span class="s">&quot;unfreezing slab&quot;</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">M_FREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">discard_page</span><span class="p">;</span>
			<span class="n">discard_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">discard_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">discard_page</span><span class="p">;</span>
		<span class="n">discard_page</span> <span class="o">=</span> <span class="n">discard_page</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DEACTIVATE_EMPTY</span><span class="p">);</span>
		<span class="n">discard_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_SLAB</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Put a page that was just frozen (in __slab_free) into a partial page</span>
<span class="cm"> * slot if available. This is done without interrupts disabled and without</span>
<span class="cm"> * preemption disabled. The cmpxchg is racy and may put the partial page</span>
<span class="cm"> * onto a random cpus partial slot.</span>
<span class="cm"> *</span>
<span class="cm"> * If we did not find a slot then simply move all the partials to the</span>
<span class="cm"> * per node partial list.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">put_cpu_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">drain</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">oldpage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pobjects</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pobjects</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">oldpage</span> <span class="o">=</span> <span class="n">this_cpu_read</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">oldpage</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pobjects</span> <span class="o">=</span> <span class="n">oldpage</span><span class="o">-&gt;</span><span class="n">pobjects</span><span class="p">;</span>
			<span class="n">pages</span> <span class="o">=</span> <span class="n">oldpage</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">drain</span> <span class="o">&amp;&amp;</span> <span class="n">pobjects</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_partial</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * partial array is full. Move the existing</span>
<span class="cm">				 * set to the per node partial list.</span>
<span class="cm">				 */</span>
				<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">unfreeze_partials</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
				<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
				<span class="n">pobjects</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CPU_PARTIAL_DRAIN</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">pages</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pobjects</span> <span class="o">+=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span> <span class="o">-</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">;</span>

		<span class="n">page</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">pobjects</span> <span class="o">=</span> <span class="n">pobjects</span><span class="p">;</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">oldpage</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">this_cpu_cmpxchg</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">,</span> <span class="n">oldpage</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">oldpage</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pobjects</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">flush_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CPUSLAB_FLUSH</span><span class="p">);</span>
	<span class="n">deactivate_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Flush cpu slab.</span>
<span class="cm"> *</span>
<span class="cm"> * Called from IPI handler with interrupts disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__flush_cpu_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span>
			<span class="n">flush_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

		<span class="n">unfreeze_partials</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_cpu_slab</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

	<span class="n">__flush_cpu_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">smp_processor_id</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">has_cpu_slab</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">||</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">flush_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">on_each_cpu_cond</span><span class="p">(</span><span class="n">has_cpu_slab</span><span class="p">,</span> <span class="n">flush_cpu_slab</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if the objects in a per cpu structure fit numa</span>
<span class="cm"> * locality expectations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">node_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">NUMA_NO_NODE</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">count_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span> <span class="o">-</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">count_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span>
					<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">get_count</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span>
		<span class="n">x</span> <span class="o">+=</span> <span class="n">get_count</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">node_nr_objs</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
	<span class="k">return</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">total_objects</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span>
<span class="nf">slab_out_of_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		<span class="s">&quot;SLUB: Unable to allocate memory on node %d (gfp=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">nid</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;  cache: %s, object size: %d, buffer size: %d, &quot;</span>
		<span class="s">&quot;default order: %d, min order: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">,</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">oo_order</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">oo</span><span class="p">),</span> <span class="n">oo_order</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oo_order</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">get_order</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;  %s debugging increased min order, use &quot;</span>
		       <span class="s">&quot;slub_debug=O to disable.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_slabs</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_objs</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_free</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">nr_free</span>  <span class="o">=</span> <span class="n">count_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">count_free</span><span class="p">);</span>
		<span class="n">nr_slabs</span> <span class="o">=</span> <span class="n">node_nr_slabs</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">nr_objs</span>  <span class="o">=</span> <span class="n">node_nr_objs</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;  node %d: slabs: %ld, objs: %ld, free: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">node</span><span class="p">,</span> <span class="n">nr_slabs</span><span class="p">,</span> <span class="n">nr_objs</span><span class="p">,</span> <span class="n">nr_free</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">new_slab_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">**</span><span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">new_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span>
			<span class="n">flush_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * No other reference to the page yet so we can</span>
<span class="cm">		 * muck around with it freely without cmpxchg</span>
<span class="cm">		 */</span>
		<span class="n">object</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
		<span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ALLOC_SLAB</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">object</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check the page-&gt;freelist of a page and either transfer the freelist to the per cpu freelist</span>
<span class="cm"> * or deactivate the page.</span>
<span class="cm"> *</span>
<span class="cm"> * The page is still frozen if the return value is not NULL.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function returns NULL then the page has been unfrozen.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">get_freelist</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">freelist</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">freelist</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
		<span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
		<span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">counters</span><span class="p">;</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">frozen</span><span class="p">);</span>

		<span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">;</span>
		<span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="n">freelist</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
		<span class="n">freelist</span><span class="p">,</span> <span class="n">counters</span><span class="p">,</span>
		<span class="nb">NULL</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
		<span class="s">&quot;get_freelist&quot;</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">freelist</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Slow path. The lockless freelist is empty or we need to perform</span>
<span class="cm"> * debugging duties.</span>
<span class="cm"> *</span>
<span class="cm"> * Processing is still very fast if new objects have been freed to the</span>
<span class="cm"> * regular freelist. In that case we simply take over the regular freelist</span>
<span class="cm"> * as the lockless freelist and zap the regular freelist.</span>
<span class="cm"> *</span>
<span class="cm"> * If that is not working then we fall back to the partial lists. We take the</span>
<span class="cm"> * first element of the freelist as the object to allocate now and move the</span>
<span class="cm"> * rest of the freelist to the lockless freelist.</span>
<span class="cm"> *</span>
<span class="cm"> * And if we were unable to get a new slab from the partial slab lists then</span>
<span class="cm"> * we need to allocate a new slab. This is the slowest path since it involves</span>
<span class="cm"> * a call to the page allocator and the setup of a new slab.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">__slab_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">object</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_PREEMPT</span>
	<span class="cm">/*</span>
<span class="cm">	 * We may have been preempted and rescheduled on a different</span>
<span class="cm">	 * cpu before disabling interrupts. Need to reload cpu area</span>
<span class="cm">	 * pointer.</span>
<span class="cm">	 */</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">this_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">new_slab</span><span class="p">;</span>
<span class="nl">redo:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">node_match</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ALLOC_NODE_MISMATCH</span><span class="p">);</span>
		<span class="n">deactivate_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">new_slab</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* must check again c-&gt;freelist in case of cpu migration or IRQ */</span>
	<span class="n">object</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">object</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">load_freelist</span><span class="p">;</span>

	<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ALLOC_SLOWPATH</span><span class="p">);</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">get_freelist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DEACTIVATE_BYPASS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">new_slab</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ALLOC_REFILL</span><span class="p">);</span>

<span class="nl">load_freelist:</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">next_tid</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">object</span><span class="p">;</span>

<span class="nl">new_slab:</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">partial</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CPU_PARTIAL_ALLOC</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Then do expensive stuff like retrieving pages from the partial lists */</span>
	<span class="n">object</span> <span class="o">=</span> <span class="n">get_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">object</span> <span class="o">=</span> <span class="n">new_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gfpflags</span> <span class="o">&amp;</span> <span class="n">__GFP_NOWARN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">printk_ratelimit</span><span class="p">())</span>
				<span class="n">slab_out_of_memory</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">load_freelist</span><span class="p">;</span>

	<span class="cm">/* Only entered in the debug case */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_debug_processing</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">new_slab</span><span class="p">;</span>	<span class="cm">/* Slab failed checks. Next slab needed */</span>

	<span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
	<span class="n">deactivate_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">object</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Inlined fastpath so that allocation functions (kmalloc, kmem_cache_alloc)</span>
<span class="cm"> * have the fastpath folded into their functions. So no function call</span>
<span class="cm"> * overhead for requests that can be satisfied on the fastpath.</span>
<span class="cm"> *</span>
<span class="cm"> * The fastpath works by first checking if the lockless freelist can be used.</span>
<span class="cm"> * If not then __slab_alloc is called for slow processing.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise we can simply pick the next object from the lockless free list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">slab_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		<span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slab_pre_alloc_hook</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">redo:</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must read kmem_cache cpu data via this cpu ptr. Preemption is</span>
<span class="cm">	 * enabled. We may switch back and forth between cpus while</span>
<span class="cm">	 * reading from one cpu area. That does not matter as long</span>
<span class="cm">	 * as we end up on the original cpu again when doing the cmpxchg.</span>
<span class="cm">	 */</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The transaction ids are globally unique per cpu and per operation on</span>
<span class="cm">	 * a per cpu queue. Thus they can be guarantee that the cmpxchg_double</span>
<span class="cm">	 * occurs on the right processor and that there was no operation on the</span>
<span class="cm">	 * linked list in between.</span>
<span class="cm">	 */</span>
	<span class="n">tid</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">;</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">object</span> <span class="o">||</span> <span class="o">!</span><span class="n">node_match</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="p">)))</span>

		<span class="n">object</span> <span class="o">=</span> <span class="n">__slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">next_object</span> <span class="o">=</span> <span class="n">get_freepointer_safe</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The cmpxchg will only match if there was no additional</span>
<span class="cm">		 * operation and if we are on the right processor.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The cmpxchg does the following atomically (without lock semantics!)</span>
<span class="cm">		 * 1. Relocate first pointer to the current per cpu area.</span>
<span class="cm">		 * 2. Verify that tid and freelist have not been changed</span>
<span class="cm">		 * 3. If they were not changed replace tid and freelist</span>
<span class="cm">		 *</span>
<span class="cm">		 * Since this is without lock semantics the protection is only against</span>
<span class="cm">		 * code executing on this cpu *not* from access by other cpus.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">this_cpu_cmpxchg_double</span><span class="p">(</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">,</span>
				<span class="n">object</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span>
				<span class="n">next_object</span><span class="p">,</span> <span class="n">next_tid</span><span class="p">(</span><span class="n">tid</span><span class="p">))))</span> <span class="p">{</span>

			<span class="n">note_cmpxchg_failure</span><span class="p">(</span><span class="s">&quot;slab_alloc&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prefetch_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">next_object</span><span class="p">);</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ALLOC_FASTPATH</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">gfpflags</span> <span class="o">&amp;</span> <span class="n">__GFP_ZERO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">object</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">);</span>

	<span class="n">slab_post_alloc_hook</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">object</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">kmem_cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">trace_kmem_cache_alloc</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_alloc</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TRACING</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">kmem_cache_alloc_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
	<span class="n">trace_kmalloc</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_alloc_trace</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">kmalloc_order_trace</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">kmalloc_order</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="n">trace_kmalloc</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmalloc_order_trace</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">kmem_cache_alloc_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">trace_kmem_cache_alloc_node</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
				    <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_alloc_node</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_TRACING</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">kmem_cache_alloc_node_trace</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				    <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">trace_kmalloc_node</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
			   <span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_alloc_node_trace</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Slow patch handling. This may still be called frequently since objects</span>
<span class="cm"> * have a longer lifetime than the cpu slabs in most processing loads.</span>
<span class="cm"> *</span>
<span class="cm"> * So we still attempt to reduce cache line usage. Just take the slab</span>
<span class="cm"> * lock and free the item. If there is no additional partial page</span>
<span class="cm"> * handling required then we can return immediately.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__slab_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">prior</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">object</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">was_frozen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">inuse</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="n">new</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counters</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_SLOWPATH</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">free_debug_processing</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">addr</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">prior</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
		<span class="n">counters</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">counters</span><span class="p">;</span>
		<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">prior</span><span class="p">);</span>
		<span class="n">new</span><span class="p">.</span><span class="n">counters</span> <span class="o">=</span> <span class="n">counters</span><span class="p">;</span>
		<span class="n">was_frozen</span> <span class="o">=</span> <span class="n">new</span><span class="p">.</span><span class="n">frozen</span><span class="p">;</span>
		<span class="n">new</span><span class="p">.</span><span class="n">inuse</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">new</span><span class="p">.</span><span class="n">inuse</span> <span class="o">||</span> <span class="o">!</span><span class="n">prior</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_frozen</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">prior</span><span class="p">)</span>

				<span class="cm">/*</span>
<span class="cm">				 * Slab was on no list before and will be partially empty</span>
<span class="cm">				 * We can defer the list move and instead freeze it.</span>
<span class="cm">				 */</span>
				<span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">else</span> <span class="p">{</span> <span class="cm">/* Needs to be taken off a list */</span>

	                        <span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
				<span class="cm">/*</span>
<span class="cm">				 * Speculatively acquire the list_lock.</span>
<span class="cm">				 * If the cmpxchg does not succeed then we may</span>
<span class="cm">				 * drop the list_lock without any processing.</span>
<span class="cm">				 *</span>
<span class="cm">				 * Otherwise the list_lock will synchronize with</span>
<span class="cm">				 * other processors updating the list of slabs.</span>
<span class="cm">				 */</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">inuse</span> <span class="o">=</span> <span class="n">new</span><span class="p">.</span><span class="n">inuse</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">cmpxchg_double_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
		<span class="n">prior</span><span class="p">,</span> <span class="n">counters</span><span class="p">,</span>
		<span class="n">object</span><span class="p">,</span> <span class="n">new</span><span class="p">.</span><span class="n">counters</span><span class="p">,</span>
		<span class="s">&quot;__slab_free&quot;</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we just froze the page then put it onto the</span>
<span class="cm">		 * per cpu partial list.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">.</span><span class="n">frozen</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">was_frozen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_cpu_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">CPU_PARTIAL_FREE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * The list lock was not taken therefore no list</span>
<span class="cm">		 * activity can be necessary.</span>
<span class="cm">		 */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">was_frozen</span><span class="p">)</span>
                        <span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_FROZEN</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * was_frozen may have been set after we acquired the list_lock in</span>
<span class="cm">	 * an earlier loop. So we need to check it here again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">was_frozen</span><span class="p">)</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_FROZEN</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">inuse</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">min_partial</span><span class="p">))</span>
                        <span class="k">goto</span> <span class="n">slab_empty</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Objects left in the slab. If it was not on the partial list before</span>
<span class="cm">		 * then add it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">prior</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">remove_full</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="n">add_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">DEACTIVATE_TO_TAIL</span><span class="p">);</span>
			<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_ADD_PARTIAL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">slab_empty:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prior</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Slab on the partial list.</span>
<span class="cm">		 */</span>
		<span class="n">remove_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_REMOVE_PARTIAL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Slab must be on the full list */</span>
		<span class="n">remove_full</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_SLAB</span><span class="p">);</span>
	<span class="n">discard_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Fastpath with forced inlining to produce a kfree and kmem_cache_free that</span>
<span class="cm"> * can perform fastpath freeing without additional function calls.</span>
<span class="cm"> *</span>
<span class="cm"> * The fastpath is only possible if we are freeing to the current cpu slab</span>
<span class="cm"> * of this processor. This typically the case if we have just allocated</span>
<span class="cm"> * the item before.</span>
<span class="cm"> *</span>
<span class="cm"> * If fastpath is not possible then fall back to __slab_free where we deal</span>
<span class="cm"> * with all sorts of special processing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">slab_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">object</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tid</span><span class="p">;</span>

	<span class="n">slab_free_hook</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

<span class="nl">redo:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Determine the currently cpus per cpu slab.</span>
<span class="cm">	 * The cpu may change afterward. However that does not matter since</span>
<span class="cm">	 * data is retrieved via this pointer. If we are on the same cpu</span>
<span class="cm">	 * during the cmpxchg then the free will succedd.</span>
<span class="cm">	 */</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">__this_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>

	<span class="n">tid</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">;</span>
	<span class="n">barrier</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_freepointer</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">this_cpu_cmpxchg_double</span><span class="p">(</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">,</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span>
				<span class="n">object</span><span class="p">,</span> <span class="n">next_tid</span><span class="p">(</span><span class="n">tid</span><span class="p">))))</span> <span class="p">{</span>

			<span class="n">note_cmpxchg_failure</span><span class="p">(</span><span class="s">&quot;slab_free&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">redo</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">stat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FREE_FASTPATH</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">__slab_free</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kmem_cache_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

	<span class="n">slab_free</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">trace_kmem_cache_free</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_free</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Object placement in a slab is made very easy because we always start at</span>
<span class="cm"> * offset 0. If we tune the size of the object to the alignment then we can</span>
<span class="cm"> * get the required alignment by putting one properly sized object after</span>
<span class="cm"> * another.</span>
<span class="cm"> *</span>
<span class="cm"> * Notice that the allocation order determines the sizes of the per cpu</span>
<span class="cm"> * caches. Each processor has always one slab available for allocations.</span>
<span class="cm"> * Increasing the allocation order reduces the number of times that slabs</span>
<span class="cm"> * must be moved on and off the partial lists and is therefore a factor in</span>
<span class="cm"> * locking overhead.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Mininum / Maximum order of slab pages. This influences locking overhead</span>
<span class="cm"> * and slab fragmentation. A higher order reduces the number of partial slabs</span>
<span class="cm"> * and increases the number of allocations possible without having to</span>
<span class="cm"> * take the list_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">slub_min_order</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">slub_max_order</span> <span class="o">=</span> <span class="n">PAGE_ALLOC_COSTLY_ORDER</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">slub_min_objects</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Merge control. If this is set then no merging of slab caches will occur.</span>
<span class="cm"> * (Could be removed. This was introduced to pacify the merge skeptics.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">slub_nomerge</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the order of allocation given an slab object size.</span>
<span class="cm"> *</span>
<span class="cm"> * The order of allocation has significant impact on performance and other</span>
<span class="cm"> * system components. Generally order 0 allocations should be preferred since</span>
<span class="cm"> * order 0 does not cause fragmentation in the page allocator. Larger objects</span>
<span class="cm"> * be problematic to put into order 0 slabs because there may be too much</span>
<span class="cm"> * unused space left. We go to a higher order if more than 1/16th of the slab</span>
<span class="cm"> * would be wasted.</span>
<span class="cm"> *</span>
<span class="cm"> * In order to reach satisfactory performance we must ensure that a minimum</span>
<span class="cm"> * number of objects is in one slab. Otherwise we may generate too much</span>
<span class="cm"> * activity on the partial lists which requires taking the list_lock. This is</span>
<span class="cm"> * less a concern for large slabs though which are rarely used.</span>
<span class="cm"> *</span>
<span class="cm"> * slub_max_order specifies the order where we begin to stop considering the</span>
<span class="cm"> * number of objects in a slab as critical. If we reach slub_max_order then</span>
<span class="cm"> * we try to keep the page order as low as possible. So we accept more waste</span>
<span class="cm"> * of space in favor of a small page order.</span>
<span class="cm"> *</span>
<span class="cm"> * Higher order allocations also allow the placement of more objects in a</span>
<span class="cm"> * slab and thereby reduce object handling overhead. If the user has</span>
<span class="cm"> * requested a higher mininum order then we start with that one instead of</span>
<span class="cm"> * the smallest order which will fit the object.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">slab_order</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_objects</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">max_order</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fract_leftover</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_order</span> <span class="o">=</span> <span class="n">slub_min_order</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">order_objects</span><span class="p">(</span><span class="n">min_order</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">reserved</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_OBJS_PER_PAGE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">MAX_OBJS_PER_PAGE</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">order</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">min_order</span><span class="p">,</span>
				<span class="n">fls</span><span class="p">(</span><span class="n">min_objects</span> <span class="o">*</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
			<span class="n">order</span> <span class="o">&lt;=</span> <span class="n">max_order</span><span class="p">;</span> <span class="n">order</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slab_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">slab_size</span> <span class="o">&lt;</span> <span class="n">min_objects</span> <span class="o">*</span> <span class="n">size</span> <span class="o">+</span> <span class="n">reserved</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">rem</span> <span class="o">=</span> <span class="p">(</span><span class="n">slab_size</span> <span class="o">-</span> <span class="n">reserved</span><span class="p">)</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&lt;=</span> <span class="n">slab_size</span> <span class="o">/</span> <span class="n">fract_leftover</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">calculate_order</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_objects</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fraction</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_objects</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attempt to find best configuration for a slab. This</span>
<span class="cm">	 * works by first attempting to generate a layout with</span>
<span class="cm">	 * the best configuration and backing off gradually.</span>
<span class="cm">	 *</span>
<span class="cm">	 * First we reduce the acceptable waste in a slab. Then</span>
<span class="cm">	 * we reduce the minimum objects required in a slab.</span>
<span class="cm">	 */</span>
	<span class="n">min_objects</span> <span class="o">=</span> <span class="n">slub_min_objects</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">min_objects</span><span class="p">)</span>
		<span class="n">min_objects</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="n">fls</span><span class="p">(</span><span class="n">nr_cpu_ids</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">max_objects</span> <span class="o">=</span> <span class="n">order_objects</span><span class="p">(</span><span class="n">slub_max_order</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">reserved</span><span class="p">);</span>
	<span class="n">min_objects</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min_objects</span><span class="p">,</span> <span class="n">max_objects</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">min_objects</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fraction</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">fraction</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">order</span> <span class="o">=</span> <span class="n">slab_order</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">min_objects</span><span class="p">,</span>
					<span class="n">slub_max_order</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">reserved</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;=</span> <span class="n">slub_max_order</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
			<span class="n">fraction</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">min_objects</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We were unable to place multiple objects in a slab. Now</span>
<span class="cm">	 * lets see if we can place a single object there.</span>
<span class="cm">	 */</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">slab_order</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">slub_max_order</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reserved</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;=</span> <span class="n">slub_max_order</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">order</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Doh this slab cannot be placed using slub_max_order.</span>
<span class="cm">	 */</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">slab_order</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MAX_ORDER</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reserved</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">order</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Figure out what the alignment of the objects will be.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">calculate_alignment</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the user wants hardware cache aligned objects then follow that</span>
<span class="cm">	 * suggestion if the object is sufficiently large.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The hardware cache alignment cannot override the specified</span>
<span class="cm">	 * alignment though. If that is greater then use it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ralign</span> <span class="o">=</span> <span class="n">cache_line_size</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">ralign</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">ralign</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">align</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">align</span><span class="p">,</span> <span class="n">ralign</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">align</span> <span class="o">&lt;</span> <span class="n">ARCH_SLAB_MINALIGN</span><span class="p">)</span>
		<span class="n">align</span> <span class="o">=</span> <span class="n">ARCH_SLAB_MINALIGN</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">align</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">init_kmem_cache_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
	<span class="n">atomic_long_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_slabs</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_long_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">total_objects</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">alloc_kmem_cache_cpus</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">PERCPU_DYNAMIC_EARLY_SIZE</span> <span class="o">&lt;</span>
			<span class="n">SLUB_PAGE_SHIFT</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_cpu</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must align to double word boundary for the double cmpxchg</span>
<span class="cm">	 * instructions to work; see __pcpu_double_call_return_bool().</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span> <span class="o">=</span> <span class="n">__alloc_percpu</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_cpu</span><span class="p">),</span>
				     <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">init_kmem_cache_cpus</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">kmem_cache_node</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * No kmalloc_node yet so do it by hand. We know that this is the first</span>
<span class="cm"> * slab on the node for this slabcache. There are no concurrent accesses</span>
<span class="cm"> * possible.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function only works on the kmalloc_node_cache</span>
<span class="cm"> * when allocating for the kmalloc_node_cache. This is used for bootstrapping</span>
<span class="cm"> * memory on a fresh node that has no slab structures yet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">early_kmem_cache_node_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_node</span><span class="p">));</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">new_slab</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SLUB: Unable to allocate memory from &quot;</span>
				<span class="s">&quot;node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SLUB: Allocating a useless per node structure &quot;</span>
				<span class="s">&quot;in order to be able to continue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">);</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">get_freepointer</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">kmem_cache_node</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
	<span class="n">init_object</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">SLUB_RED_ACTIVE</span><span class="p">);</span>
	<span class="n">init_tracking</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">init_kmem_cache_node</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="n">inc_slabs_node</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">);</span>

	<span class="n">add_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">DEACTIVATE_TO_HEAD</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_kmem_cache_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_kmem_cache_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">slab_state</span> <span class="o">==</span> <span class="n">DOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">early_kmem_cache_node_alloc</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">kmem_cache_alloc_node</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span>
						<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_kmem_cache_nodes</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">init_kmem_cache_node</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_min_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">&lt;</span> <span class="n">MIN_PARTIAL</span><span class="p">)</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">MIN_PARTIAL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">&gt;</span> <span class="n">MAX_PARTIAL</span><span class="p">)</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">MAX_PARTIAL</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">min_partial</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * calculate_sizes() determines the order and the distribution of data within</span>
<span class="cm"> * a slab object.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">calculate_sizes</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">forced_order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">align</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Round up object size to the next word boundary. We can only</span>
<span class="cm">	 * place the free pointer at word boundaries and this determines</span>
<span class="cm">	 * the possible location of the free pointer.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
	<span class="cm">/*</span>
<span class="cm">	 * Determine if we can poison the object itself. If the user of</span>
<span class="cm">	 * the slab may touch the object after free or before allocation</span>
<span class="cm">	 * then we should never poison the object itself.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">__OBJECT_POISON</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__OBJECT_POISON</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * If we are Redzoning then check if there is some space between the</span>
<span class="cm">	 * end of the object and the free pointer. If not then add an</span>
<span class="cm">	 * additional word to have some bytes to store Redzone information.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">==</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">)</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * With that we have determined the number of bytes in actual use</span>
<span class="cm">	 * by the object. This is the potential offset to the free pointer.</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SLAB_DESTROY_BY_RCU</span> <span class="o">|</span> <span class="n">SLAB_POISON</span><span class="p">))</span> <span class="o">||</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Relocate free pointer after the object if it is not</span>
<span class="cm">		 * permitted to overwrite the first word of the object on</span>
<span class="cm">		 * kmem_cache_free.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This is the case if we do RCU, have a constructor or</span>
<span class="cm">		 * destructor or are poisoning the objects.</span>
<span class="cm">		 */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Need to store information about allocs and frees after</span>
<span class="cm">		 * the object.</span>
<span class="cm">		 */</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">track</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Add some empty padding so that we can catch</span>
<span class="cm">		 * overwrites from earlier objects rather than let</span>
<span class="cm">		 * tracking information or the free pointer be</span>
<span class="cm">		 * corrupted if a user writes before the start</span>
<span class="cm">		 * of the object.</span>
<span class="cm">		 */</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine the alignment based on various parameters that the</span>
<span class="cm">	 * user specified and the dynamic determination of cache line size</span>
<span class="cm">	 * on bootup.</span>
<span class="cm">	 */</span>
	<span class="n">align</span> <span class="o">=</span> <span class="n">calculate_alignment</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">align</span> <span class="o">=</span> <span class="n">align</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SLUB stores one object immediately after another beginning from</span>
<span class="cm">	 * offset 0. In order to align the objects we have to simply size</span>
<span class="cm">	 * each object to conform to the alignment.</span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">forced_order</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">order</span> <span class="o">=</span> <span class="n">forced_order</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">order</span> <span class="o">=</span> <span class="n">calculate_order</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">allocflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">order</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">allocflags</span> <span class="o">|=</span> <span class="n">__GFP_COMP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_CACHE_DMA</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">allocflags</span> <span class="o">|=</span> <span class="n">SLUB_DMA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">allocflags</span> <span class="o">|=</span> <span class="n">__GFP_RECLAIMABLE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine the number of objects per slab</span>
<span class="cm">	 */</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">oo</span> <span class="o">=</span> <span class="n">oo_make</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">min</span> <span class="o">=</span> <span class="n">oo_make</span><span class="p">(</span><span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oo_objects</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">oo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">oo_objects</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">))</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">oo</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">!!</span><span class="n">oo_objects</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">oo</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">kmem_cache_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kmem_size</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">ctor</span> <span class="o">=</span> <span class="n">ctor</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">align</span> <span class="o">=</span> <span class="n">align</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">kmem_cache_flags</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ctor</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_reserve_slab_rcu</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">))</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">calculate_sizes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disable_higher_order_debug</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Disable debugging flags that store metadata if the min slab</span>
<span class="cm">		 * order increased.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_order</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">get_order</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DEBUG_METADATA_FLAGS</span><span class="p">;</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">calculate_sizes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span>
<span class="cp">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">system_has_cmpxchg_double</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DEBUG_FLAGS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* Enable fast mode */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">__CMPXCHG_DOUBLE</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * The larger the object size is, the more pages we want on the partial</span>
<span class="cm">	 * list to avoid pounding the page allocator excessively.</span>
<span class="cm">	 */</span>
	<span class="n">set_min_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * cpu_partial determined the maximum number of objects kept in the</span>
<span class="cm">	 * per cpu partial lists of a processor.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Per cpu partial lists mainly contain slabs that just have one</span>
<span class="cm">	 * object freed. If they are used for allocation then they can be</span>
<span class="cm">	 * filled up again with minimal effort. The slab will never hit the</span>
<span class="cm">	 * per node partial lists and therefore no locking will be required.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This setting also determines</span>
<span class="cm">	 *</span>
<span class="cm">	 * A) The number of objects from per cpu partial slabs dumped to the</span>
<span class="cm">	 *    per node list when we reach the limit.</span>
<span class="cm">	 * B) The number of objects in cpu partial slabs to extract from the</span>
<span class="cm">	 *    per node list when we run out of per cpu objects. We only fetch 50%</span>
<span class="cm">	 *    to keep some capacity around for frees.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">256</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">remote_node_defrag_ratio</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init_kmem_cache_nodes</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_kmem_cache_cpus</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">free_kmem_cache_nodes</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_PANIC</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Cannot create slab %s size=%lu realsize=%u &quot;</span>
			<span class="s">&quot;order=%u offset=%u flags=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">oo_order</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">oo</span><span class="p">),</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine the size of a slab object</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">kmem_cache_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_size</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">list_slab_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
							<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">)</span> <span class="o">*</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">slab_err</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">);</span>
	<span class="n">slab_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">get_map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
	<span class="n">for_each_object</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">slab_index</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">addr</span><span class="p">),</span> <span class="n">map</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;INFO: Object 0x%p @offset=%tu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">p</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="n">addr</span><span class="p">);</span>
			<span class="n">print_tracking</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">slab_unlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Attempt to free all partial slabs on a node.</span>
<span class="cm"> * This is called from kmem_cache_close(). We must be the last thread</span>
<span class="cm"> * using the cache and therefore we do not need to lock anymore.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_partial</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">remove_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="n">discard_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">list_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
				<span class="s">&quot;Objects remaining on kmem_cache_close()&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Release all resources used by a slab cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kmem_cache_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">flush_all</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">free_percpu</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">);</span>
	<span class="cm">/* Attempt to free all objects */</span>
	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="n">free_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span> <span class="o">||</span> <span class="n">slabs_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">free_kmem_cache_nodes</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Close a cache and release the kmem_cache structure</span>
<span class="cm"> * (must be used for caches created using kmem_cache_create)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">kmem_cache_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_close</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SLUB %s: %s called for cache that &quot;</span>
				<span class="s">&quot;still has objects.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">dump_stack</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">)</span>
			<span class="n">rcu_barrier</span><span class="p">();</span>
		<span class="n">sysfs_slab_remove</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_destroy</span><span class="p">);</span>

<span class="cm">/********************************************************************</span>
<span class="cm"> *		Kmalloc subsystem</span>
<span class="cm"> *******************************************************************/</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">SLUB_PAGE_SHIFT</span><span class="p">];</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">kmem_cache</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">kmalloc_dma_caches</span><span class="p">[</span><span class="n">SLUB_PAGE_SHIFT</span><span class="p">];</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_slub_min_order</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slub_min_order</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;slub_min_order=&quot;</span><span class="p">,</span> <span class="n">setup_slub_min_order</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_slub_max_order</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slub_max_order</span><span class="p">);</span>
	<span class="n">slub_max_order</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">slub_max_order</span><span class="p">,</span> <span class="n">MAX_ORDER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;slub_max_order=&quot;</span><span class="p">,</span> <span class="n">setup_slub_max_order</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_slub_min_objects</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_option</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slub_min_objects</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;slub_min_objects=&quot;</span><span class="p">,</span> <span class="n">setup_slub_min_objects</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">setup_slub_nomerge</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">slub_nomerge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;slub_nomerge&quot;</span><span class="p">,</span> <span class="n">setup_slub_nomerge</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">__init</span> <span class="nf">create_kmalloc_cache</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This function is called with IRQs disabled during early-boot on</span>
<span class="cm">	 * single CPU so there&#39;s no need to take slub_lock here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kmem_cache_open</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ARCH_KMALLOC_MINALIGN</span><span class="p">,</span>
								<span class="n">flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">panic</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>

<span class="nl">panic:</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Creation of kmalloc slab %s size=%d failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Conversion table for small slabs sizes / 8 to the index in the</span>
<span class="cm"> * kmalloc array. This is necessary for slabs &lt; 192 since we have non power</span>
<span class="cm"> * of two cache sizes there. The size of larger slabs can be determined using</span>
<span class="cm"> * fls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s8</span> <span class="n">size_index</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mi">3</span><span class="p">,</span>	<span class="cm">/* 8 */</span>
	<span class="mi">4</span><span class="p">,</span>	<span class="cm">/* 16 */</span>
	<span class="mi">5</span><span class="p">,</span>	<span class="cm">/* 24 */</span>
	<span class="mi">5</span><span class="p">,</span>	<span class="cm">/* 32 */</span>
	<span class="mi">6</span><span class="p">,</span>	<span class="cm">/* 40 */</span>
	<span class="mi">6</span><span class="p">,</span>	<span class="cm">/* 48 */</span>
	<span class="mi">6</span><span class="p">,</span>	<span class="cm">/* 56 */</span>
	<span class="mi">6</span><span class="p">,</span>	<span class="cm">/* 64 */</span>
	<span class="mi">1</span><span class="p">,</span>	<span class="cm">/* 72 */</span>
	<span class="mi">1</span><span class="p">,</span>	<span class="cm">/* 80 */</span>
	<span class="mi">1</span><span class="p">,</span>	<span class="cm">/* 88 */</span>
	<span class="mi">1</span><span class="p">,</span>	<span class="cm">/* 96 */</span>
	<span class="mi">7</span><span class="p">,</span>	<span class="cm">/* 104 */</span>
	<span class="mi">7</span><span class="p">,</span>	<span class="cm">/* 112 */</span>
	<span class="mi">7</span><span class="p">,</span>	<span class="cm">/* 120 */</span>
	<span class="mi">7</span><span class="p">,</span>	<span class="cm">/* 128 */</span>
	<span class="mi">2</span><span class="p">,</span>	<span class="cm">/* 136 */</span>
	<span class="mi">2</span><span class="p">,</span>	<span class="cm">/* 144 */</span>
	<span class="mi">2</span><span class="p">,</span>	<span class="cm">/* 152 */</span>
	<span class="mi">2</span><span class="p">,</span>	<span class="cm">/* 160 */</span>
	<span class="mi">2</span><span class="p">,</span>	<span class="cm">/* 168 */</span>
	<span class="mi">2</span><span class="p">,</span>	<span class="cm">/* 176 */</span>
	<span class="mi">2</span><span class="p">,</span>	<span class="cm">/* 184 */</span>
	<span class="mi">2</span>	<span class="cm">/* 192 */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">size_index_elem</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="nf">get_slab</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">192</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ZERO_SIZE_PTR</span><span class="p">;</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">size_index</span><span class="p">[</span><span class="n">size_index_elem</span><span class="p">(</span><span class="n">size</span><span class="p">)];</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLUB_DMA</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">kmalloc_dma_caches</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">__kmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">SLUB_MAX_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">kmalloc_large</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">get_slab</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">s</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">trace_kmalloc</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__kmalloc</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">kmalloc_large_node</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">|=</span> <span class="n">__GFP_COMP</span> <span class="o">|</span> <span class="n">__GFP_NOTRACK</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">kmemleak_alloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">__kmalloc_node</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">SLUB_MAX_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kmalloc_large_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="n">trace_kmalloc_node</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
				   <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">),</span>
				   <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">get_slab</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">s</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>

	<span class="n">trace_kmalloc_node</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__kmalloc_node</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">size_t</span> <span class="nf">ksize</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">object</span> <span class="o">==</span> <span class="n">ZERO_SIZE_PTR</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">slab_ksize</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">ksize</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
<span class="n">bool</span> <span class="nf">verify_mem_not_deleted</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* maybe it was from stack? */</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">slab_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">on_freelist</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">object_err</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="s">&quot;Object is on free-list&quot;</span><span class="p">);</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rv</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">slab_unlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">verify_mem_not_deleted</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">kfree</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">object</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>

	<span class="n">trace_kfree</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">kmemleak_free</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">slab_free</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kfree</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * kmem_cache_shrink removes empty slabs from the partial lists and sorts</span>
<span class="cm"> * the remaining slabs by the number of items in use. The slabs with the</span>
<span class="cm"> * most items in use come first. New allocations will then fill those up</span>
<span class="cm"> * and thus they can be removed from the partial lists.</span>
<span class="cm"> *</span>
<span class="cm"> * The slabs with the least items are placed last. This results in them</span>
<span class="cm"> * being allocated from last increasing the chance that the last objects</span>
<span class="cm"> * are freed in them.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">kmem_cache_shrink</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">objects</span> <span class="o">=</span> <span class="n">oo_objects</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">slabs_by_inuse</span> <span class="o">=</span>
		<span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span><span class="p">)</span> <span class="o">*</span> <span class="n">objects</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slabs_by_inuse</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">flush_all</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">objects</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">slabs_by_inuse</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Build lists indexed by the items in use in each slab.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note that concurrent frees may occur while we hold the</span>
<span class="cm">		 * list_lock. page-&gt;inuse here is the upper limit.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">slabs_by_inuse</span> <span class="o">+</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">)</span>
				<span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Rebuild the partial list with the slabs filled up most</span>
<span class="cm">		 * first and the least used slabs at the end.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">objects</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
			<span class="n">list_splice</span><span class="p">(</span><span class="n">slabs_by_inuse</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* Release empty slabs */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">slabs_by_inuse</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span>
			<span class="n">discard_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">slabs_by_inuse</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_shrink</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_MEMORY_HOTPLUG)</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">slab_mem_going_offline_callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">kmem_cache_shrink</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">slab_mem_offline_callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memory_notify</span> <span class="o">*</span><span class="n">marg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offline_node</span><span class="p">;</span>

	<span class="n">offline_node</span> <span class="o">=</span> <span class="n">marg</span><span class="o">-&gt;</span><span class="n">status_change_nid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the node still has available memory. we need kmem_cache_node</span>
<span class="cm">	 * for it yet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offline_node</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offline_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * if n-&gt;nr_slabs &gt; 0, slabs still exist on the node</span>
<span class="cm">			 * that is going down. We were unable to free them,</span>
<span class="cm">			 * and offline_pages() function shouldn&#39;t call this</span>
<span class="cm">			 * callback. So, we must fail.</span>
<span class="cm">			 */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">slabs_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offline_node</span><span class="p">));</span>

			<span class="n">s</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="n">offline_node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">slab_mem_going_online_callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memory_notify</span> <span class="o">*</span><span class="n">marg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">marg</span><span class="o">-&gt;</span><span class="n">status_change_nid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the node&#39;s memory is already available, then kmem_cache_node is</span>
<span class="cm">	 * already created. Nothing to do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are bringing a node online. No memory is available yet. We must</span>
<span class="cm">	 * allocate a kmem_cache_node structure in order to bring the node</span>
<span class="cm">	 * online.</span>
<span class="cm">	 */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * XXX: kmem_cache_alloc_node will fallback to other nodes</span>
<span class="cm">		 *      since memory is not yet available from the node that</span>
<span class="cm">		 *      is brought up.</span>
<span class="cm">		 */</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">init_kmem_cache_node</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">slab_memory_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEM_GOING_ONLINE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">slab_mem_going_online_callback</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MEM_GOING_OFFLINE</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">slab_mem_going_offline_callback</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MEM_OFFLINE</span>:
	<span class="k">case</span> <span class="n">MEM_CANCEL_ONLINE</span>:
		<span class="n">slab_mem_offline_callback</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MEM_ONLINE</span>:
	<span class="k">case</span> <span class="n">MEM_CANCEL_OFFLINE</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">notifier_from_errno</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_MEMORY_HOTPLUG */</span><span class="cp"></span>

<span class="cm">/********************************************************************</span>
<span class="cm"> *			Basic setup of slabs</span>
<span class="cm"> *******************************************************************/</span>

<span class="cm">/*</span>
<span class="cm"> * Used for early kmem_cache structures that were allocated using</span>
<span class="cm"> * the page allocator</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">kmem_cache_bootstrap_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">kmem_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">caches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">temp_kmem_cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">temp_kmem_cache_node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kmalloc_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">debug_guardpage_minorder</span><span class="p">())</span>
		<span class="n">slub_max_order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">kmem_size</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">nr_node_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* Allocate two kmem_caches from the page allocator */</span>
	<span class="n">kmalloc_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">kmem_size</span><span class="p">,</span> <span class="n">cache_line_size</span><span class="p">());</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">kmalloc_size</span><span class="p">);</span>
	<span class="n">kmem_cache</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_NOWAIT</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Must first have the slab cache available for the allocations of the</span>
<span class="cm">	 * struct kmem_cache_node&#39;s. There is special bootstrap code in</span>
<span class="cm">	 * kmem_cache_open for slab_state == DOWN.</span>
<span class="cm">	 */</span>
	<span class="n">kmem_cache_node</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">kmem_cache</span> <span class="o">+</span> <span class="n">kmalloc_size</span><span class="p">;</span>

	<span class="n">kmem_cache_open</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span> <span class="s">&quot;kmem_cache_node&quot;</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_node</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">hotplug_memory_notifier</span><span class="p">(</span><span class="n">slab_memory_callback</span><span class="p">,</span> <span class="n">SLAB_CALLBACK_PRI</span><span class="p">);</span>

	<span class="cm">/* Able to allocate the per node structures */</span>
	<span class="n">slab_state</span> <span class="o">=</span> <span class="n">PARTIAL</span><span class="p">;</span>

	<span class="n">temp_kmem_cache</span> <span class="o">=</span> <span class="n">kmem_cache</span><span class="p">;</span>
	<span class="n">kmem_cache_open</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="s">&quot;kmem_cache&quot;</span><span class="p">,</span> <span class="n">kmem_size</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span> <span class="o">|</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">kmem_cache</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="n">temp_kmem_cache</span><span class="p">,</span> <span class="n">kmem_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate kmem_cache_node properly from the kmem_cache slab.</span>
<span class="cm">	 * kmem_cache_node is separately allocated so no need to</span>
<span class="cm">	 * update any list pointers.</span>
<span class="cm">	 */</span>
	<span class="n">temp_kmem_cache_node</span> <span class="o">=</span> <span class="n">kmem_cache_node</span><span class="p">;</span>

	<span class="n">kmem_cache_node</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">,</span> <span class="n">temp_kmem_cache_node</span><span class="p">,</span> <span class="n">kmem_size</span><span class="p">);</span>

	<span class="n">kmem_cache_bootstrap_fixup</span><span class="p">(</span><span class="n">kmem_cache_node</span><span class="p">);</span>

	<span class="n">caches</span><span class="o">++</span><span class="p">;</span>
	<span class="n">kmem_cache_bootstrap_fixup</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">);</span>
	<span class="n">caches</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* Free temporary boot structure */</span>
	<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">temp_kmem_cache</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>

	<span class="cm">/* Now we can use the kmem_cache to allocate kmalloc slabs */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Patch up the size_index table if we have strange large alignment</span>
<span class="cm">	 * requirements for the kmalloc array. This is only the case for</span>
<span class="cm">	 * MIPS it seems. The standard arches will not generate any code here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Largest permitted alignment is 256 bytes due to the way we</span>
<span class="cm">	 * handle the index determination for the smaller caches.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Make sure that nothing crazy happens if someone starts tinkering</span>
<span class="cm">	 * around with ARCH_KMALLOC_MINALIGN</span>
<span class="cm">	 */</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">&gt;</span> <span class="mi">256</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KMALLOC_MIN_SIZE</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">size_index_elem</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elem</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">size_index</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">size_index</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">=</span> <span class="n">KMALLOC_SHIFT_LOW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The 96 byte size cache is not used if the alignment</span>
<span class="cm">		 * is 64 byte.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">96</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">size_index</span><span class="p">[</span><span class="n">size_index_elem</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">==</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The 192 byte sized cache is not used if the alignment</span>
<span class="cm">		 * is 128 byte. Redirect kmalloc to use the 256 byte cache</span>
<span class="cm">		 * instead.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">192</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">size_index</span><span class="p">[</span><span class="n">size_index_elem</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Caches that are not of the two-to-the-power-of size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_kmalloc_cache</span><span class="p">(</span><span class="s">&quot;kmalloc-96&quot;</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">caches</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_kmalloc_cache</span><span class="p">(</span><span class="s">&quot;kmalloc-192&quot;</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">caches</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">KMALLOC_SHIFT_LOW</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SLUB_PAGE_SHIFT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_kmalloc_cache</span><span class="p">(</span><span class="s">&quot;kmalloc&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">caches</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">slab_state</span> <span class="o">=</span> <span class="n">UP</span><span class="p">;</span>

	<span class="cm">/* Provide the correct kmalloc names now that the caches are up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">KMALLOC_SHIFT_LOW</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SLUB_PAGE_SHIFT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_NOWAIT</span><span class="p">,</span> <span class="s">&quot;kmalloc-%d&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">);</span>
		<span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_notifier</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SLUB_PAGE_SHIFT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">kasprintf</span><span class="p">(</span><span class="n">GFP_NOWAIT</span><span class="p">,</span>
				 <span class="s">&quot;dma-kmalloc-%d&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">);</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">);</span>
			<span class="n">kmalloc_dma_caches</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_kmalloc_cache</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
				<span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">,</span> <span class="n">SLAB_CACHE_DMA</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		<span class="s">&quot;SLUB: Genslabs=%d, HWalign=%d, Order=%d-%d, MinObjects=%d,&quot;</span>
		<span class="s">&quot; CPUs=%d, Nodes=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">caches</span><span class="p">,</span> <span class="n">cache_line_size</span><span class="p">(),</span>
		<span class="n">slub_min_order</span><span class="p">,</span> <span class="n">slub_max_order</span><span class="p">,</span> <span class="n">slub_min_objects</span><span class="p">,</span>
		<span class="n">nr_cpu_ids</span><span class="p">,</span> <span class="n">nr_node_ids</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">kmem_cache_init_late</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find a mergeable slab cache</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">slab_unmergeable</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slub_nomerge</span> <span class="o">||</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLUB_NEVER_MERGE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We may have set a slab to be unmergeable during bootstrap.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="nf">find_mergeable</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slub_nomerge</span> <span class="o">||</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLUB_NEVER_MERGE</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctor</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
	<span class="n">align</span> <span class="o">=</span> <span class="n">calculate_alignment</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">kmem_cache_flags</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slab_unmergeable</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLUB_MERGE_SAME</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLUB_MERGE_SAME</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check if alignment is compatible.</span>
<span class="cm">		 * Courtesy of Adrian Drzewiecki</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="nf">kmem_cache_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
		<span class="kt">size_t</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">find_mergeable</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ctor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Adjust the object sizes so that we clear</span>
<span class="cm">		 * the complete object on kzalloc.</span>
<span class="cm">		 */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">size</span><span class="p">);</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">,</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_slab_alias</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="o">--</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">kstrdup</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">kmem_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kmem_cache_open</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
				<span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">ctor</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">);</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_slab_add</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_PANIC</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Cannot create slabcache %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">s</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_create</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/*</span>
<span class="cm"> * Use the cpu notifier to insure that the cpu slabs are flushed when</span>
<span class="cm"> * necessary.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">slab_cpuup_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nfb</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED</span>:
	<span class="k">case</span> <span class="n">CPU_UP_CANCELED_FROZEN</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD</span>:
	<span class="k">case</span> <span class="n">CPU_DEAD_FROZEN</span>:
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">__flush_cpu_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__cpuinitdata</span> <span class="n">slab_notifier</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span> <span class="o">=</span> <span class="n">slab_cpuup_callback</span>
<span class="p">};</span>

<span class="cp">#endif</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">__kmalloc_track_caller</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">SLUB_MAX_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">kmalloc_large</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">get_slab</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">s</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">,</span> <span class="n">caller</span><span class="p">);</span>

	<span class="cm">/* Honor the call site pointer we received. */</span>
	<span class="n">trace_kmalloc</span><span class="p">(</span><span class="n">caller</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">__kmalloc_node_track_caller</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">caller</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">SLUB_MAX_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">kmalloc_large_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="n">trace_kmalloc_node</span><span class="p">(</span><span class="n">caller</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
				   <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">get_order</span><span class="p">(</span><span class="n">size</span><span class="p">),</span>
				   <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">get_slab</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">s</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">caller</span><span class="p">);</span>

	<span class="cm">/* Honor the call site pointer we received. */</span>
	<span class="n">trace_kmalloc_node</span><span class="p">(</span><span class="n">caller</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">gfpflags</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">count_inuse</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">count_total</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">on_freelist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Now we know that a valid freelist exists */</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">);</span>

	<span class="n">get_map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
	<span class="n">for_each_object</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">slab_index</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">addr</span><span class="p">),</span> <span class="n">map</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">SLUB_RED_INACTIVE</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">for_each_object</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">slab_index</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">addr</span><span class="p">),</span> <span class="n">map</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_object</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">SLUB_RED_ACTIVE</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">validate_slab_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">slab_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">validate_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
	<span class="n">slab_unlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_slab_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">validate_slab_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SLUB %s: %ld partial slabs counted but &quot;</span>
			<span class="s">&quot;counter=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">validate_slab_slab</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_slabs</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SLUB: %s %ld slabs counted but &quot;</span>
			<span class="s">&quot;counter=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
			<span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_slabs</span><span class="p">));</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">validate_slab_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">oo_objects</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">))</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">flush_all</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="n">count</span> <span class="o">+=</span> <span class="n">validate_slab_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Generate lists of code addresses where slabcache objects are allocated</span>
<span class="cm"> * and freed.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">location</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">sum_time</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">min_time</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">max_time</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">min_pid</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">max_pid</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">cpus</span><span class="p">,</span> <span class="n">NR_CPUS</span><span class="p">);</span>
	<span class="n">nodemask_t</span> <span class="n">nodes</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">loc_track</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">location</span> <span class="o">*</span><span class="n">loc</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_loc_track</span><span class="p">(</span><span class="k">struct</span> <span class="n">loc_track</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">loc</span><span class="p">,</span>
			<span class="n">get_order</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">location</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_loc_track</span><span class="p">(</span><span class="k">struct</span> <span class="n">loc_track</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">location</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">order</span><span class="p">;</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">location</span><span class="p">)</span> <span class="o">*</span> <span class="n">max</span><span class="p">);</span>

	<span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">loc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">location</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="n">free_loc_track</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">loc</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_location</span><span class="p">(</span><span class="k">struct</span> <span class="n">loc_track</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">track</span> <span class="o">*</span><span class="n">track</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">location</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">caddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">age</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span> <span class="n">track</span><span class="o">-&gt;</span><span class="n">when</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * There is nothing at &quot;end&quot;. If we end up there</span>
<span class="cm">		 * we need to add something to before end.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">caddr</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">loc</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">addr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">track</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">==</span> <span class="n">caddr</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">l</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">loc</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
			<span class="n">l</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">track</span><span class="o">-&gt;</span><span class="n">when</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">l</span><span class="o">-&gt;</span><span class="n">sum_time</span> <span class="o">+=</span> <span class="n">age</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">age</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">min_time</span><span class="p">)</span>
					<span class="n">l</span><span class="o">-&gt;</span><span class="n">min_time</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">age</span> <span class="o">&gt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">max_time</span><span class="p">)</span>
					<span class="n">l</span><span class="o">-&gt;</span><span class="n">max_time</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">track</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">min_pid</span><span class="p">)</span>
					<span class="n">l</span><span class="o">-&gt;</span><span class="n">min_pid</span> <span class="o">=</span> <span class="n">track</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">track</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">max_pid</span><span class="p">)</span>
					<span class="n">l</span><span class="o">-&gt;</span><span class="n">max_pid</span> <span class="o">=</span> <span class="n">track</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>

				<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">track</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span>
						<span class="n">to_cpumask</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">node_set</span><span class="p">(</span><span class="n">page_to_nid</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">track</span><span class="p">)),</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">track</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">caddr</span><span class="p">)</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Not found. Insert new tracking element.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">alloc_loc_track</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">loc</span> <span class="o">+</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span>
		<span class="n">memmove</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span>
			<span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">location</span><span class="p">));</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">addr</span> <span class="o">=</span> <span class="n">track</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">sum_time</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">min_time</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">max_time</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">min_pid</span> <span class="o">=</span> <span class="n">track</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">max_pid</span> <span class="o">=</span> <span class="n">track</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">to_cpumask</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">));</span>
	<span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">track</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="p">,</span> <span class="n">to_cpumask</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">));</span>
	<span class="n">nodes_clear</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
	<span class="n">node_set</span><span class="p">(</span><span class="n">page_to_nid</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">track</span><span class="p">)),</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">process_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">loc_track</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">enum</span> <span class="n">track_item</span> <span class="n">alloc</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">);</span>
	<span class="n">get_map</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>

	<span class="n">for_each_object</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">slab_index</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">addr</span><span class="p">),</span> <span class="n">map</span><span class="p">))</span>
			<span class="n">add_location</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">get_track</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">alloc</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">list_locations</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">track_item</span> <span class="n">alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">loc_track</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">oo_objects</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">))</span> <span class="o">*</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span> <span class="o">||</span> <span class="o">!</span><span class="n">alloc_loc_track</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">location</span><span class="p">),</span>
				     <span class="n">GFP_TEMPORARY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;Out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Push back cpu slabs */</span>
	<span class="n">flush_all</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_slabs</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span>
			<span class="n">process_slab</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">alloc</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span>
			<span class="n">process_slab</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">alloc</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">location</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">KSYM_SYMBOL_LEN</span> <span class="o">-</span> <span class="mi">100</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%7ld &quot;</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;%pS&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;&lt;not-available&gt;&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">sum_time</span> <span class="o">!=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">min_time</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot; age=%ld/%ld/%ld&quot;</span><span class="p">,</span>
				<span class="n">l</span><span class="o">-&gt;</span><span class="n">min_time</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">div_u64</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">sum_time</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">),</span>
				<span class="n">l</span><span class="o">-&gt;</span><span class="n">max_time</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot; age=%ld&quot;</span><span class="p">,</span>
				<span class="n">l</span><span class="o">-&gt;</span><span class="n">min_time</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">min_pid</span> <span class="o">!=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">max_pid</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot; pid=%ld-%ld&quot;</span><span class="p">,</span>
				<span class="n">l</span><span class="o">-&gt;</span><span class="n">min_pid</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">max_pid</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot; pid=%ld&quot;</span><span class="p">,</span>
				<span class="n">l</span><span class="o">-&gt;</span><span class="n">min_pid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="n">cpumask_empty</span><span class="p">(</span><span class="n">to_cpumask</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
				<span class="n">len</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot; cpus=&quot;</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">cpulist_scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">50</span><span class="p">,</span>
						 <span class="n">to_cpumask</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">cpus</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nr_online_nodes</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nodes_empty</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">len</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot; nodes=&quot;</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">nodelist_scnprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">50</span><span class="p">,</span>
					<span class="n">l</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">free_loc_track</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;No data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef SLUB_RESILIENCY_TEST</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">resiliency_test</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span> <span class="o">&gt;</span> <span class="mi">16</span> <span class="o">||</span> <span class="n">SLUB_PAGE_SHIFT</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SLUB resiliency testing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;-----------------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;A. Corruption after allocation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">1. kmalloc-16: Clobber Redzone/next pointer&quot;</span>
			<span class="s">&quot; 0x12-&gt;0x%p</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>

	<span class="n">validate_slab_cache</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>

	<span class="cm">/* Hmmm... The next two are dangerous */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">32</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)]</span> <span class="o">=</span> <span class="mh">0x34</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">2. kmalloc-32: Clobber next pointer/next slab&quot;</span>
			<span class="s">&quot; 0x34 -&gt; -0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		<span class="s">&quot;If allocated object is overwritten then not detectable</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">validate_slab_cache</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="mi">64</span> <span class="o">+</span> <span class="p">(</span><span class="n">get_cycles</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mh">0x56</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">3. kmalloc-64: corrupting random byte 0x56-&gt;0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
									<span class="n">p</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		<span class="s">&quot;If allocated object is overwritten then not detectable</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">validate_slab_cache</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">B. Corruption after free</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mh">0x78</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;1. kmalloc-128: Clobber first word 0x78-&gt;0x%p</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">validate_slab_cache</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x9a</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">2. kmalloc-256: Clobber 50th byte 0x9a-&gt;0x%p</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">p</span><span class="p">);</span>
	<span class="n">validate_slab_cache</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">p</span><span class="p">[</span><span class="mi">512</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xab</span><span class="p">;</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">3. kmalloc-512: Clobber redzone 0xab-&gt;0x%p</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">validate_slab_cache</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">9</span><span class="p">]);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">resiliency_test</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{};</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="k">enum</span> <span class="n">slab_stat_type</span> <span class="p">{</span>
	<span class="n">SL_ALL</span><span class="p">,</span>			<span class="cm">/* All slabs */</span>
	<span class="n">SL_PARTIAL</span><span class="p">,</span>		<span class="cm">/* Only partially allocated slabs */</span>
	<span class="n">SL_CPU</span><span class="p">,</span>			<span class="cm">/* Only slabs used for cpu caches */</span>
	<span class="n">SL_OBJECTS</span><span class="p">,</span>		<span class="cm">/* Determine allocated objects not slabs */</span>
	<span class="n">SL_TOTAL</span>		<span class="cm">/* Determine object capacity not slabs */</span>
<span class="p">};</span>

<span class="cp">#define SO_ALL		(1 &lt;&lt; SL_ALL)</span>
<span class="cp">#define SO_PARTIAL	(1 &lt;&lt; SL_PARTIAL)</span>
<span class="cp">#define SO_CPU		(1 &lt;&lt; SL_CPU)</span>
<span class="cp">#define SO_OBJECTS	(1 &lt;&lt; SL_OBJECTS)</span>
<span class="cp">#define SO_TOTAL	(1 &lt;&lt; SL_TOTAL)</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_slab_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">per_cpu</span><span class="p">;</span>

	<span class="n">nodes</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_node_ids</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">per_cpu</span> <span class="o">=</span> <span class="n">nodes</span> <span class="o">+</span> <span class="n">nr_node_ids</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SO_CPU</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">kmem_cache_cpu</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SO_TOTAL</span><span class="p">)</span>
					<span class="n">x</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">objects</span><span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SO_OBJECTS</span><span class="p">)</span>
					<span class="n">x</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">inuse</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

				<span class="n">total</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
				<span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">pobjects</span><span class="p">;</span>
				<span class="n">total</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
				<span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">per_cpu</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">lock_memory_hotplug</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SO_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SO_TOTAL</span><span class="p">)</span>
			<span class="n">x</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">total_objects</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SO_OBJECTS</span><span class="p">)</span>
			<span class="n">x</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">total_objects</span><span class="p">)</span> <span class="o">-</span>
				<span class="n">count_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">count_free</span><span class="p">);</span>

			<span class="k">else</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_slabs</span><span class="p">);</span>
			<span class="n">total</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
			<span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SO_PARTIAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SO_TOTAL</span><span class="p">)</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">count_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">count_total</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SO_OBJECTS</span><span class="p">)</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">count_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">count_inuse</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span><span class="p">;</span>
			<span class="n">total</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
			<span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
			<span class="n">x</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="s">&quot; N%d=%lu&quot;</span><span class="p">,</span>
					<span class="n">node</span><span class="p">,</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
<span class="cp">#endif</span>
	<span class="n">unlock_memory_hotplug</span><span class="p">();</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">any_slab_objects</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">total_objects</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#define to_slab_attr(n) container_of(n, struct slab_attribute, attr)</span>
<span class="cp">#define to_slab(n) container_of(n, struct kmem_cache, kobj)</span>

<span class="k">struct</span> <span class="n">slab_attribute</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">attribute</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
	<span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define SLAB_ATTR_RO(_name) \</span>
<span class="cp">	static struct slab_attribute _name##_attr = \</span>
<span class="cp">	__ATTR(_name, 0400, _name##_show, NULL)</span>

<span class="cp">#define SLAB_ATTR(_name) \</span>
<span class="cp">	static struct slab_attribute _name##_attr =  \</span>
<span class="cp">	__ATTR(_name, 0600, _name##_show, _name##_store)</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">slab_size_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">slab_size</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">align_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">align</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">align</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">object_size_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">objsize</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">object_size</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">objs_per_slab_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oo_objects</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">oo</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">objs_per_slab</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">order_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">order</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&gt;</span> <span class="n">slub_max_order</span> <span class="o">||</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="n">slub_min_order</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">calculate_sizes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">order_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oo_order</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">oo</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">min_partial_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">min_partial</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">min_partial_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">set_min_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">min</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">min_partial</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cpu_partial_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_partial</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cpu_partial_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">objects</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objects</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">objects</span> <span class="o">&amp;&amp;</span> <span class="n">kmem_cache_debug</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_partial</span> <span class="o">=</span> <span class="n">objects</span><span class="p">;</span>
	<span class="n">flush_all</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">cpu_partial</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ctor_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%pS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">ctor</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">ctor</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">aliases_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">refcount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">aliases</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">partial_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">show_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SO_PARTIAL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">partial</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cpu_slabs_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">show_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SO_CPU</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">cpu_slabs</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">objects_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">show_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SO_ALL</span><span class="o">|</span><span class="n">SO_OBJECTS</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">objects</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">objects_partial_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">show_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SO_PARTIAL</span><span class="o">|</span><span class="n">SO_OBJECTS</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">objects_partial</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">slabs_cpu_partial_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">objects</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">partial</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pages</span> <span class="o">+=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
			<span class="n">objects</span> <span class="o">+=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">pobjects</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d(%d)&quot;</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">-&gt;</span><span class="n">partial</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot; C%d=%d(%d)&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span>
				<span class="n">page</span><span class="o">-&gt;</span><span class="n">pobjects</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">slabs_cpu_partial</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">reclaim_account_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">reclaim_account_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">reclaim_account</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">hwcache_align_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">hwcache_align</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cache_dma_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_CACHE_DMA</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">cache_dma</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">destroy_by_rcu_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DESTROY_BY_RCU</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">destroy_by_rcu</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">reserved_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">reserved</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">slabs_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">show_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SO_ALL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">slabs</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">total_objects_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">show_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SO_ALL</span><span class="o">|</span><span class="n">SO_TOTAL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">total_objects</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sanity_checks_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DEBUG_FREE</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">sanity_checks_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SLAB_DEBUG_FREE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__CMPXCHG_DOUBLE</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SLAB_DEBUG_FREE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">sanity_checks</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">trace_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_TRACE</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">trace_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
							<span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SLAB_TRACE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__CMPXCHG_DOUBLE</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SLAB_TRACE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">trace</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">red_zone_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RED_ZONE</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">red_zone_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">any_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SLAB_RED_ZONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__CMPXCHG_DOUBLE</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SLAB_RED_ZONE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">calculate_sizes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">red_zone</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">poison_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_POISON</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">poison_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">any_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SLAB_POISON</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__CMPXCHG_DOUBLE</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SLAB_POISON</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">calculate_sizes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">poison</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_user_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">store_user_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">any_slab_objects</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SLAB_STORE_USER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">__CMPXCHG_DOUBLE</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SLAB_STORE_USER</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">calculate_sizes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">store_user</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">validate_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">validate_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">validate_slab_cache</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">validate</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">alloc_calls_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">list_locations</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">TRACK_ALLOC</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">alloc_calls</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">free_calls_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_STORE_USER</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">list_locations</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">TRACK_FREE</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR_RO</span><span class="p">(</span><span class="n">free_calls</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SLUB_DEBUG */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_FAILSLAB</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">failslab_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_FAILSLAB</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">failslab_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
							<span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SLAB_FAILSLAB</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SLAB_FAILSLAB</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">failslab</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">shrink_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">shrink_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">kmem_cache_shrink</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">shrink</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">remote_node_defrag_ratio_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">remote_node_defrag_ratio</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">remote_node_defrag_ratio_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ratio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ratio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ratio</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">)</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">remote_node_defrag_ratio</span> <span class="o">=</span> <span class="n">ratio</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">SLAB_ATTR</span><span class="p">(</span><span class="n">remote_node_defrag_ratio</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SLUB_STATS</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">show_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">enum</span> <span class="n">stat_item</span> <span class="n">si</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sum</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">x</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">[</span><span class="n">si</span><span class="p">];</span>

		<span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot; C%d=%u&quot;</span><span class="p">,</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">cpu</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span> <span class="o">+</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">enum</span> <span class="n">stat_item</span> <span class="n">si</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cpu_slab</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">[</span><span class="n">si</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define STAT_ATTR(si, text) 					\</span>
<span class="cp">static ssize_t text##_show(struct kmem_cache *s, char *buf)	\</span>
<span class="cp">{								\</span>
<span class="cp">	return show_stat(s, buf, si);				\</span>
<span class="cp">}								\</span>
<span class="cp">static ssize_t text##_store(struct kmem_cache *s,		\</span>
<span class="cp">				const char *buf, size_t length)	\</span>
<span class="cp">{								\</span>
<span class="cp">	if (buf[0] != &#39;0&#39;)					\</span>
<span class="cp">		return -EINVAL;					\</span>
<span class="cp">	clear_stat(s, si);					\</span>
<span class="cp">	return length;						\</span>
<span class="cp">}								\</span>
<span class="cp">SLAB_ATTR(text);						\</span>

<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">ALLOC_FASTPATH</span><span class="p">,</span> <span class="n">alloc_fastpath</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">ALLOC_SLOWPATH</span><span class="p">,</span> <span class="n">alloc_slowpath</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">FREE_FASTPATH</span><span class="p">,</span> <span class="n">free_fastpath</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">FREE_SLOWPATH</span><span class="p">,</span> <span class="n">free_slowpath</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">FREE_FROZEN</span><span class="p">,</span> <span class="n">free_frozen</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">FREE_ADD_PARTIAL</span><span class="p">,</span> <span class="n">free_add_partial</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">FREE_REMOVE_PARTIAL</span><span class="p">,</span> <span class="n">free_remove_partial</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">ALLOC_FROM_PARTIAL</span><span class="p">,</span> <span class="n">alloc_from_partial</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">ALLOC_SLAB</span><span class="p">,</span> <span class="n">alloc_slab</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">ALLOC_REFILL</span><span class="p">,</span> <span class="n">alloc_refill</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">ALLOC_NODE_MISMATCH</span><span class="p">,</span> <span class="n">alloc_node_mismatch</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">FREE_SLAB</span><span class="p">,</span> <span class="n">free_slab</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">CPUSLAB_FLUSH</span><span class="p">,</span> <span class="n">cpuslab_flush</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">DEACTIVATE_FULL</span><span class="p">,</span> <span class="n">deactivate_full</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">DEACTIVATE_EMPTY</span><span class="p">,</span> <span class="n">deactivate_empty</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">DEACTIVATE_TO_HEAD</span><span class="p">,</span> <span class="n">deactivate_to_head</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">DEACTIVATE_TO_TAIL</span><span class="p">,</span> <span class="n">deactivate_to_tail</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">DEACTIVATE_REMOTE_FREES</span><span class="p">,</span> <span class="n">deactivate_remote_frees</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">DEACTIVATE_BYPASS</span><span class="p">,</span> <span class="n">deactivate_bypass</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">ORDER_FALLBACK</span><span class="p">,</span> <span class="n">order_fallback</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">CMPXCHG_DOUBLE_CPU_FAIL</span><span class="p">,</span> <span class="n">cmpxchg_double_cpu_fail</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">CMPXCHG_DOUBLE_FAIL</span><span class="p">,</span> <span class="n">cmpxchg_double_fail</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">CPU_PARTIAL_ALLOC</span><span class="p">,</span> <span class="n">cpu_partial_alloc</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">CPU_PARTIAL_FREE</span><span class="p">,</span> <span class="n">cpu_partial_free</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">CPU_PARTIAL_NODE</span><span class="p">,</span> <span class="n">cpu_partial_node</span><span class="p">);</span>
<span class="n">STAT_ATTR</span><span class="p">(</span><span class="n">CPU_PARTIAL_DRAIN</span><span class="p">,</span> <span class="n">cpu_partial_drain</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">slab_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">slab_size_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">object_size_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">objs_per_slab_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">order_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">min_partial_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cpu_partial_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">objects_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">objects_partial_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">partial_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cpu_slabs_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">ctor_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">aliases_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">align_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">hwcache_align_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">reclaim_account_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">destroy_by_rcu_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">shrink_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">reserved_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">slabs_cpu_partial_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
	<span class="o">&amp;</span><span class="n">total_objects_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">slabs_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">sanity_checks_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">trace_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">red_zone_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">poison_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">store_user_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">validate_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">alloc_calls_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">free_calls_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
	<span class="o">&amp;</span><span class="n">cache_dma_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="o">&amp;</span><span class="n">remote_node_defrag_ratio_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SLUB_STATS</span>
	<span class="o">&amp;</span><span class="n">alloc_fastpath_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">alloc_slowpath_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">free_fastpath_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">free_slowpath_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">free_frozen_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">free_add_partial_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">free_remove_partial_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">alloc_from_partial_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">alloc_slab_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">alloc_refill_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">alloc_node_mismatch_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">free_slab_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cpuslab_flush_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">deactivate_full_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">deactivate_empty_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">deactivate_to_head_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">deactivate_to_tail_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">deactivate_remote_frees_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">deactivate_bypass_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">order_fallback_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cmpxchg_double_fail_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cmpxchg_double_cpu_fail_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cpu_partial_alloc_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cpu_partial_free_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cpu_partial_node_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">cpu_partial_drain_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FAILSLAB</span>
	<span class="o">&amp;</span><span class="n">failslab_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>

	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">slab_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">slab_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">slab_attr_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slab_attribute</span> <span class="o">*</span><span class="n">attribute</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">attribute</span> <span class="o">=</span> <span class="n">to_slab_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">to_slab</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attribute</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">slab_attr_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">slab_attribute</span> <span class="o">*</span><span class="n">attribute</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">attribute</span> <span class="o">=</span> <span class="n">to_slab_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">);</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">to_slab</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">attribute</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">attribute</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmem_cache_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">to_slab</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sysfs_ops</span> <span class="n">slab_sysfs_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">slab_attr_show</span><span class="p">,</span>
	<span class="p">.</span><span class="n">store</span> <span class="o">=</span> <span class="n">slab_attr_store</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobj_type</span> <span class="n">slab_ktype</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">sysfs_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">slab_sysfs_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">kmem_cache_release</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">uevent_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">kset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobj_type</span> <span class="o">*</span><span class="n">ktype</span> <span class="o">=</span> <span class="n">get_ktype</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ktype</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">slab_ktype</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">kset_uevent_ops</span> <span class="n">slab_uevent_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">filter</span> <span class="o">=</span> <span class="n">uevent_filter</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kset</span> <span class="o">*</span><span class="n">slab_kset</span><span class="p">;</span>

<span class="cp">#define ID_STR_LENGTH 64</span>

<span class="cm">/* Create a unique string id for a slab cache:</span>
<span class="cm"> *</span>
<span class="cm"> * Format	:[flags-]size</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">create_unique_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ID_STR_LENGTH</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">);</span>

	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;:&#39;</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * First flags affecting slabcache operations. We will only</span>
<span class="cm">	 * get here for aliasable slabs so we do not need to support</span>
<span class="cm">	 * too many flags. The flags here must cover all flags that</span>
<span class="cm">	 * are matched during merging to guarantee that the id is</span>
<span class="cm">	 * unique.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_CACHE_DMA</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;d&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_DEBUG_FREE</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;F&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SLAB_NOTRACK</span><span class="p">))</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;t&#39;</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">name</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;%07d&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">name</span> <span class="o">+</span> <span class="n">ID_STR_LENGTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sysfs_slab_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unmergeable</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slab_state</span> <span class="o">&lt;</span> <span class="n">SYSFS</span><span class="p">)</span>
		<span class="cm">/* Defer until later */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">unmergeable</span> <span class="o">=</span> <span class="n">slab_unmergeable</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unmergeable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Slabcache can never be merged so we can use the name proper.</span>
<span class="cm">		 * This is typically the case for debug situations. In that</span>
<span class="cm">		 * case we can catch duplicate names easily.</span>
<span class="cm">		 */</span>
		<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Create a unique name for the slab as a target</span>
<span class="cm">		 * for the symlinks.</span>
<span class="cm">		 */</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">create_unique_id</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">kset</span> <span class="o">=</span> <span class="n">slab_kset</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kobject_init_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_ktype</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_attr_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kobject_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unmergeable</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Setup first alias */</span>
		<span class="n">sysfs_slab_alias</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sysfs_slab_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slab_state</span> <span class="o">&lt;</span> <span class="n">SYSFS</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * Sysfs has not been setup yet so no need to remove the</span>
<span class="cm">		 * cache from sysfs.</span>
<span class="cm">		 */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_REMOVE</span><span class="p">);</span>
	<span class="n">kobject_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
	<span class="n">kobject_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Need to buffer aliases during bootup until sysfs becomes</span>
<span class="cm"> * available lest we lose that information.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">saved_alias</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">saved_alias</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">saved_alias</span> <span class="o">*</span><span class="n">alias_list</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sysfs_slab_alias</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">saved_alias</span> <span class="o">*</span><span class="n">al</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slab_state</span> <span class="o">==</span> <span class="n">SYSFS</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we have a leftover link then remove it.</span>
<span class="cm">		 */</span>
		<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_kset</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">al</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">saved_alias</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">al</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">al</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">al</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">al</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">alias_list</span><span class="p">;</span>
	<span class="n">alias_list</span> <span class="o">=</span> <span class="n">al</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">slab_sysfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>

	<span class="n">slab_kset</span> <span class="o">=</span> <span class="n">kset_create_and_add</span><span class="p">(</span><span class="s">&quot;slab&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_uevent_ops</span><span class="p">,</span> <span class="n">kernel_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slab_kset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Cannot register slab subsystem.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">slab_state</span> <span class="o">=</span> <span class="n">SYSFS</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_slab_add</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SLUB: Unable to add boot slab %s&quot;</span>
						<span class="s">&quot; to sysfs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">alias_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">saved_alias</span> <span class="o">*</span><span class="n">al</span> <span class="o">=</span> <span class="n">alias_list</span><span class="p">;</span>

		<span class="n">alias_list</span> <span class="o">=</span> <span class="n">alias_list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sysfs_slab_alias</span><span class="p">(</span><span class="n">al</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">,</span> <span class="n">al</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SLUB: Unable to add boot slab alias&quot;</span>
					<span class="s">&quot; %s to sysfs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">al</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
	<span class="n">resiliency_test</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__initcall</span><span class="p">(</span><span class="n">slab_sysfs_init</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSFS */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * The /proc/slabinfo ABI</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SLABINFO</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_slabinfo_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;slabinfo - version: 2.1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;# name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &quot;</span>
		 <span class="s">&quot;&lt;objperslab&gt; &lt;pagesperslab&gt;&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt;&quot;</span><span class="p">);</span>
	<span class="n">seq_puts</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;&quot;</span><span class="p">);</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">s_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">n</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
		<span class="n">print_slabinfo_header</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">seq_list_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">s_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_list_next</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">s_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slub_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">s_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_partials</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_slabs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_inuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_objs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kmem_cache</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">nr_partials</span> <span class="o">+=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_partial</span><span class="p">;</span>
		<span class="n">nr_slabs</span> <span class="o">+=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">nr_slabs</span><span class="p">);</span>
		<span class="n">nr_objs</span> <span class="o">+=</span> <span class="n">atomic_long_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">total_objects</span><span class="p">);</span>
		<span class="n">nr_free</span> <span class="o">+=</span> <span class="n">count_partial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">count_free</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">nr_inuse</span> <span class="o">=</span> <span class="n">nr_objs</span> <span class="o">-</span> <span class="n">nr_free</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%-17s %6lu %6lu %6u %4u %4d&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">nr_inuse</span><span class="p">,</span>
		   <span class="n">nr_objs</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">oo_objects</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">oo</span><span class="p">),</span>
		   <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">oo_order</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">oo</span><span class="p">)));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : tunables %4u %4u %4u&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; : slabdata %6lu %6lu %6lu&quot;</span><span class="p">,</span> <span class="n">nr_slabs</span><span class="p">,</span> <span class="n">nr_slabs</span><span class="p">,</span>
		   <span class="mi">0UL</span><span class="p">);</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">slabinfo_op</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">s_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">s_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">s_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span> <span class="n">s_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">slabinfo_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slabinfo_op</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_slabinfo_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">slabinfo_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">slab_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;slabinfo&quot;</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_slabinfo_operations</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">slab_proc_init</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SLABINFO */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
