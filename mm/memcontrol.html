<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › memcontrol.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>memcontrol.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* memcontrol.c - Memory Controller</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright IBM Corporation, 2007</span>
<span class="cm"> * Author Balbir Singh &lt;balbir@linux.vnet.ibm.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 2007 OpenVZ SWsoft Inc</span>
<span class="cm"> * Author: Pavel Emelianov &lt;xemul@openvz.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Memory thresholds</span>
<span class="cm"> * Copyright (C) 2009 Nokia Corporation</span>
<span class="cm"> * Author: Kirill A. Shutemov</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/res_counter.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>
<span class="cp">#include &lt;linux/cgroup.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/page-flags.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/bit_spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/limits.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/swapops.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/eventfd.h&gt;</span>
<span class="cp">#include &lt;linux/sort.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/mm_inline.h&gt;</span>
<span class="cp">#include &lt;linux/page_cgroup.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/oom.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/tcp_memcontrol.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &lt;trace/events/vmscan.h&gt;</span>

<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="n">mem_cgroup_subsys</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="cp">#define MEM_CGROUP_RECLAIM_RETRIES	5</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">root_mem_cgroup</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP</span>
<span class="cm">/* Turned on only when memory cgroup is enabled &amp;&amp; really_do_swap_account = 1 */</span>
<span class="kt">int</span> <span class="n">do_swap_account</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* for remember boot option*/</span>
<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP_ENABLED</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">really_do_swap_account</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">really_do_swap_account</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#else</span>
<span class="cp">#define do_swap_account		0</span>
<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * Statistics for memory cgroup.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">mem_cgroup_stat_index</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * For MEM_CONTAINER_TYPE_ALL, usage = pagecache + rss.</span>
<span class="cm">	 */</span>
	<span class="n">MEM_CGROUP_STAT_CACHE</span><span class="p">,</span> 	   <span class="cm">/* # of pages charged as cache */</span>
	<span class="n">MEM_CGROUP_STAT_RSS</span><span class="p">,</span>	   <span class="cm">/* # of pages charged as anon rss */</span>
	<span class="n">MEM_CGROUP_STAT_FILE_MAPPED</span><span class="p">,</span>  <span class="cm">/* # of pages charged as file rss */</span>
	<span class="n">MEM_CGROUP_STAT_SWAPOUT</span><span class="p">,</span> <span class="cm">/* # of pages, swapped out */</span>
	<span class="n">MEM_CGROUP_STAT_NSTATS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">mem_cgroup_stat_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;cache&quot;</span><span class="p">,</span>
	<span class="s">&quot;rss&quot;</span><span class="p">,</span>
	<span class="s">&quot;mapped_file&quot;</span><span class="p">,</span>
	<span class="s">&quot;swap&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">mem_cgroup_events_index</span> <span class="p">{</span>
	<span class="n">MEM_CGROUP_EVENTS_PGPGIN</span><span class="p">,</span>	<span class="cm">/* # of pages paged in */</span>
	<span class="n">MEM_CGROUP_EVENTS_PGPGOUT</span><span class="p">,</span>	<span class="cm">/* # of pages paged out */</span>
	<span class="n">MEM_CGROUP_EVENTS_PGFAULT</span><span class="p">,</span>	<span class="cm">/* # of page-faults */</span>
	<span class="n">MEM_CGROUP_EVENTS_PGMAJFAULT</span><span class="p">,</span>	<span class="cm">/* # of major page-faults */</span>
	<span class="n">MEM_CGROUP_EVENTS_NSTATS</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">mem_cgroup_events_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;pgpgin&quot;</span><span class="p">,</span>
	<span class="s">&quot;pgpgout&quot;</span><span class="p">,</span>
	<span class="s">&quot;pgfault&quot;</span><span class="p">,</span>
	<span class="s">&quot;pgmajfault&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Per memcg event counter is incremented at every pagein/pageout. With THP,</span>
<span class="cm"> * it will be incremated by the number of pages. This counter is used for</span>
<span class="cm"> * for trigger some periodic events. This is straightforward and better</span>
<span class="cm"> * than using jiffies etc. to handle periodic memcg event.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">mem_cgroup_events_target</span> <span class="p">{</span>
	<span class="n">MEM_CGROUP_TARGET_THRESH</span><span class="p">,</span>
	<span class="n">MEM_CGROUP_TARGET_SOFTLIMIT</span><span class="p">,</span>
	<span class="n">MEM_CGROUP_TARGET_NUMAINFO</span><span class="p">,</span>
	<span class="n">MEM_CGROUP_NTARGETS</span><span class="p">,</span>
<span class="p">};</span>
<span class="cp">#define THRESHOLDS_EVENTS_TARGET 128</span>
<span class="cp">#define SOFTLIMIT_EVENTS_TARGET 1024</span>
<span class="cp">#define NUMAINFO_EVENTS_TARGET	1024</span>

<span class="k">struct</span> <span class="n">mem_cgroup_stat_cpu</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">count</span><span class="p">[</span><span class="n">MEM_CGROUP_STAT_NSTATS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">events</span><span class="p">[</span><span class="n">MEM_CGROUP_EVENTS_NSTATS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_page_events</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">targets</span><span class="p">[</span><span class="n">MEM_CGROUP_NTARGETS</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mem_cgroup_reclaim_iter</span> <span class="p">{</span>
	<span class="cm">/* css_id of the last scanned hierarchy member */</span>
	<span class="kt">int</span> <span class="n">position</span><span class="p">;</span>
	<span class="cm">/* scan generation, increased every round-trip */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">generation</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * per-zone information in memory controller.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">lruvec</span>		<span class="n">lruvec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">lru_size</span><span class="p">[</span><span class="n">NR_LRU_LISTS</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">mem_cgroup_reclaim_iter</span> <span class="n">reclaim_iter</span><span class="p">[</span><span class="n">DEF_PRIORITY</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">tree_node</span><span class="p">;</span>	<span class="cm">/* RB tree node */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>	<span class="n">usage_in_excess</span><span class="p">;</span><span class="cm">/* Set to the value by which */</span>
						<span class="cm">/* the soft limit is exceeded*/</span>
	<span class="n">bool</span>			<span class="n">on_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span>	<span class="o">*</span><span class="n">memcg</span><span class="p">;</span>		<span class="cm">/* Back pointer, we cannot */</span>
						<span class="cm">/* use container_of	   */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mem_cgroup_per_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="n">zoneinfo</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mem_cgroup_lru_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_node</span> <span class="o">*</span><span class="n">nodeinfo</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Cgroups above their limits are maintained in a RB-Tree, independent of</span>
<span class="cm"> * their hierarchy representation</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">rb_root</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="n">rb_tree_per_zone</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mem_cgroup_tree</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_node</span> <span class="o">*</span><span class="n">rb_tree_per_node</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_cgroup_tree</span> <span class="n">soft_limit_tree</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">mem_cgroup_threshold</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">eventfd_ctx</span> <span class="o">*</span><span class="n">eventfd</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">threshold</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* For threshold */</span>
<span class="k">struct</span> <span class="n">mem_cgroup_threshold_ary</span> <span class="p">{</span>
	<span class="cm">/* An array index points to threshold just below or equal to usage. */</span>
	<span class="kt">int</span> <span class="n">current_threshold</span><span class="p">;</span>
	<span class="cm">/* Size of entries[] */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/* Array of thresholds */</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_threshold</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mem_cgroup_thresholds</span> <span class="p">{</span>
	<span class="cm">/* Primary thresholds array */</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_threshold_ary</span> <span class="o">*</span><span class="n">primary</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Spare threshold array.</span>
<span class="cm">	 * This is needed to make mem_cgroup_unregister_event() &quot;never fail&quot;.</span>
<span class="cm">	 * It must be able to store at least primary-&gt;size - 1 entries.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_threshold_ary</span> <span class="o">*</span><span class="n">spare</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* for OOM */</span>
<span class="k">struct</span> <span class="n">mem_cgroup_eventfd_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">eventfd_ctx</span> <span class="o">*</span><span class="n">eventfd</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">mem_cgroup_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mem_cgroup_oom_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The memory controller data structure. The memory controller controls both</span>
<span class="cm"> * page cache and RSS per cgroup. We would eventually like to provide</span>
<span class="cm"> * statistics based on the statistics developed by Rik Van Riel for clock-pro,</span>
<span class="cm"> * to help the administrator determine what knobs to tune.</span>
<span class="cm"> *</span>
<span class="cm"> * TODO: Add a water mark for the memory controller. Reclaim will begin when</span>
<span class="cm"> * we hit the water mark. May be even add a low water mark, such that</span>
<span class="cm"> * no reclaim occurs from a cgroup at it&#39;s low water mark, this is</span>
<span class="cm"> * a feature that will be implemented much later in the future.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="n">css</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * the counter to account for memory usage</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">res_counter</span> <span class="n">res</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * the counter to account for mem+swap usage.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">res_counter</span> <span class="n">memsw</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * rcu_freeing is used only when freeing struct mem_cgroup,</span>
<span class="cm">		 * so put it into a union to avoid wasting more memory.</span>
<span class="cm">		 * It must be disjoint from the css field.  It could be</span>
<span class="cm">		 * in a union with the res field, but res plays a much</span>
<span class="cm">		 * larger part in mem_cgroup life than memsw, and might</span>
<span class="cm">		 * be of interest, even at time of free, when debugging.</span>
<span class="cm">		 * So share rcu_head with the less interesting memsw.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu_freeing</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We also need some space for a worker in deferred freeing.</span>
<span class="cm">		 * By the time we call it, rcu_freeing is no longer in use.</span>
<span class="cm">		 */</span>
		<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work_freeing</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * Per cgroup active and inactive list, similar to the</span>
<span class="cm">	 * per zone LRU lists.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_lru_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_scanned_node</span><span class="p">;</span>
<span class="cp">#if MAX_NUMNODES &gt; 1</span>
	<span class="n">nodemask_t</span>	<span class="n">scan_nodes</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">numainfo_events</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">numainfo_updating</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 * Should the accounting and control be hierarchical, per subtree?</span>
<span class="cm">	 */</span>
	<span class="n">bool</span> <span class="n">use_hierarchy</span><span class="p">;</span>

	<span class="n">bool</span>		<span class="n">oom_lock</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">under_oom</span><span class="p">;</span>

	<span class="n">atomic_t</span>	<span class="n">refcnt</span><span class="p">;</span>

	<span class="kt">int</span>	<span class="n">swappiness</span><span class="p">;</span>
	<span class="cm">/* OOM-Killer disable */</span>
	<span class="kt">int</span>		<span class="n">oom_kill_disable</span><span class="p">;</span>

	<span class="cm">/* set when res.limit == memsw.limit */</span>
	<span class="n">bool</span>		<span class="n">memsw_is_minimum</span><span class="p">;</span>

	<span class="cm">/* protect arrays of thresholds */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">thresholds_lock</span><span class="p">;</span>

	<span class="cm">/* thresholds for memory usage. RCU-protected */</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_thresholds</span> <span class="n">thresholds</span><span class="p">;</span>

	<span class="cm">/* thresholds for mem+swap usage. RCU-protected */</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_thresholds</span> <span class="n">memsw_thresholds</span><span class="p">;</span>

	<span class="cm">/* For oom notifier event fd */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">oom_notify</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Should we move charges of a task when a task is moved into this</span>
<span class="cm">	 * mem_cgroup ? And what type of charges should we move ?</span>
<span class="cm">	 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> 	<span class="n">move_charge_at_immigrate</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * set &gt; 0 if pages under this cgroup are moving to other cgroup.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_t</span>	<span class="n">moving_account</span><span class="p">;</span>
	<span class="cm">/* taken only while moving_account &gt; 0 */</span>
	<span class="n">spinlock_t</span>	<span class="n">move_lock</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * percpu counter.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_stat_cpu</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">stat</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * used when a cpu is offlined or other synchronizations</span>
<span class="cm">	 * See mem_cgroup_read_stat().</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_stat_cpu</span> <span class="n">nocpu_base</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">pcp_counter_lock</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_INET</span>
	<span class="k">struct</span> <span class="n">tcp_memcontrol</span> <span class="n">tcp_mem</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/* Stuffs for move charges at task migration. */</span>
<span class="cm">/*</span>
<span class="cm"> * Types of charges to be moved. &quot;move_charge_at_immitgrate&quot; is treated as a</span>
<span class="cm"> * left-shifted bitmap of these types.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">move_type</span> <span class="p">{</span>
	<span class="n">MOVE_CHARGE_TYPE_ANON</span><span class="p">,</span>	<span class="cm">/* private anonymous page and swap of it */</span>
	<span class="n">MOVE_CHARGE_TYPE_FILE</span><span class="p">,</span>	<span class="cm">/* file page(including tmpfs) and swap of it */</span>
	<span class="n">NR_MOVE_TYPE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* &quot;mc&quot; and its members are protected by cgroup_mutex */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">move_charge_struct</span> <span class="p">{</span>
	<span class="n">spinlock_t</span>	  <span class="n">lock</span><span class="p">;</span> <span class="cm">/* for from, to */</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">precharge</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">moved_charge</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">moved_swap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">moving_task</span><span class="p">;</span>	<span class="cm">/* a task moving charges */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">waitq</span><span class="p">;</span>		<span class="cm">/* a waitq for other context */</span>
<span class="p">}</span> <span class="n">mc</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">__SPIN_LOCK_UNLOCKED</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">lock</span><span class="p">),</span>
	<span class="p">.</span><span class="n">waitq</span> <span class="o">=</span> <span class="n">__WAIT_QUEUE_HEAD_INITIALIZER</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">waitq</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">move_anon</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">MOVE_CHARGE_TYPE_ANON</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">move_charge_at_immigrate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">move_file</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">MOVE_CHARGE_TYPE_FILE</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">move_charge_at_immigrate</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum loops in mem_cgroup_hierarchical_reclaim(), used for soft</span>
<span class="cm"> * limit reclaim to prevent infinite loops, if they ever occur.</span>
<span class="cm"> */</span>
<span class="cp">#define	MEM_CGROUP_MAX_RECLAIM_LOOPS		100</span>
<span class="cp">#define	MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS	2</span>

<span class="k">enum</span> <span class="n">charge_type</span> <span class="p">{</span>
	<span class="n">MEM_CGROUP_CHARGE_TYPE_CACHE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">MEM_CGROUP_CHARGE_TYPE_MAPPED</span><span class="p">,</span>
	<span class="n">MEM_CGROUP_CHARGE_TYPE_SHMEM</span><span class="p">,</span>	<span class="cm">/* used by page migration of shmem */</span>
	<span class="n">MEM_CGROUP_CHARGE_TYPE_FORCE</span><span class="p">,</span>	<span class="cm">/* used by force_empty */</span>
	<span class="n">MEM_CGROUP_CHARGE_TYPE_SWAPOUT</span><span class="p">,</span>	<span class="cm">/* for accounting swapcache */</span>
	<span class="n">MEM_CGROUP_CHARGE_TYPE_DROP</span><span class="p">,</span>	<span class="cm">/* a page was unused swap cache */</span>
	<span class="n">NR_CHARGE_TYPE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* for encoding cft-&gt;private value on file */</span>
<span class="cp">#define _MEM			(0)</span>
<span class="cp">#define _MEMSWAP		(1)</span>
<span class="cp">#define _OOM_TYPE		(2)</span>
<span class="cp">#define MEMFILE_PRIVATE(x, val)	((x) &lt;&lt; 16 | (val))</span>
<span class="cp">#define MEMFILE_TYPE(val)	((val) &gt;&gt; 16 &amp; 0xffff)</span>
<span class="cp">#define MEMFILE_ATTR(val)	((val) &amp; 0xffff)</span>
<span class="cm">/* Used for OOM nofiier */</span>
<span class="cp">#define OOM_CONTROL		(0)</span>

<span class="cm">/*</span>
<span class="cm"> * Reclaim flags for mem_cgroup_hierarchical_reclaim</span>
<span class="cm"> */</span>
<span class="cp">#define MEM_CGROUP_RECLAIM_NOSWAP_BIT	0x0</span>
<span class="cp">#define MEM_CGROUP_RECLAIM_NOSWAP	(1 &lt;&lt; MEM_CGROUP_RECLAIM_NOSWAP_BIT)</span>
<span class="cp">#define MEM_CGROUP_RECLAIM_SHRINK_BIT	0x1</span>
<span class="cp">#define MEM_CGROUP_RECLAIM_SHRINK	(1 &lt;&lt; MEM_CGROUP_RECLAIM_SHRINK_BIT)</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">mem_cgroup_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">mem_cgroup_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">);</span>

<span class="cm">/* Writing them here to avoid exposing memcg&#39;s inner layout */</span>
<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR_KMEM</span>
<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;net/ip.h&gt;</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">sock_update_memcg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="n">cg_proto</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">proto_cgroup</span><span class="p">);</span>

		<span class="cm">/* Socket cloning can throw us here with sk_cgrp already</span>
<span class="cm">		 * filled. It won&#39;t however, necessarily happen from</span>
<span class="cm">		 * process context. So the test for root memcg given</span>
<span class="cm">		 * the current task&#39;s memcg won&#39;t help us in this case.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Respecting the original socket&#39;s memcg is a better</span>
<span class="cm">		 * decision in this case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">));</span>
			<span class="n">mem_cgroup_get</span><span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_task</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
		<span class="n">cg_proto</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">proto_cgroup</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">memcg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">memcg_proto_active</span><span class="p">(</span><span class="n">cg_proto</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mem_cgroup_get</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
			<span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span> <span class="o">=</span> <span class="n">cg_proto</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sock_update_memcg</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sock_release_memcg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_sockets_enabled</span> <span class="o">&amp;&amp;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">);</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_cgrp</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">;</span>
		<span class="n">mem_cgroup_put</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_INET</span>
<span class="k">struct</span> <span class="n">cg_proto</span> <span class="o">*</span><span class="nf">tcp_proto_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span> <span class="o">||</span> <span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">tcp_mem</span><span class="p">.</span><span class="n">cg_proto</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tcp_proto_cgroup</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_INET */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CGROUP_MEM_RES_CTLR_KMEM */</span><span class="cp"></span>

<span class="cp">#if defined(CONFIG_INET) &amp;&amp; defined(CONFIG_CGROUP_MEM_RES_CTLR_KMEM)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">disarm_sock_keys</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg_proto_activated</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">tcp_mem</span><span class="p">.</span><span class="n">cg_proto</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">static_key_slow_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_socket_limit_enabled</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">disarm_sock_keys</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">drain_all_stock_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span>
<span class="nf">mem_cgroup_zoneinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">zid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">nodeinfo</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">zoneinfo</span><span class="p">[</span><span class="n">zid</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="nf">mem_cgroup_css</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span>
<span class="nf">page_cgroup_zoneinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">zid</span> <span class="o">=</span> <span class="n">page_zonenum</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mem_cgroup_zoneinfo</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">zid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="o">*</span>
<span class="nf">soft_limit_tree_node_zone</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">zid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">soft_limit_tree</span><span class="p">.</span><span class="n">rb_tree_per_node</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rb_tree_per_zone</span><span class="p">[</span><span class="n">zid</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="o">*</span>
<span class="nf">soft_limit_tree_from_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">zid</span> <span class="o">=</span> <span class="n">page_zonenum</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">soft_limit_tree</span><span class="p">.</span><span class="n">rb_tree_per_node</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rb_tree_per_zone</span><span class="p">[</span><span class="n">zid</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__mem_cgroup_insert_exceeded</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="o">*</span><span class="n">mctz</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">new_usage_in_excess</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">rb_root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz_node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">on_tree</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mz</span><span class="o">-&gt;</span><span class="n">usage_in_excess</span> <span class="o">=</span> <span class="n">new_usage_in_excess</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">usage_in_excess</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">mz_node</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span><span class="p">,</span>
					<span class="n">tree_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">usage_in_excess</span> <span class="o">&lt;</span> <span class="n">mz_node</span><span class="o">-&gt;</span><span class="n">usage_in_excess</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We can&#39;t avoid mem cgroups that are over their soft</span>
<span class="cm">		 * limit by the same amount</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">usage_in_excess</span> <span class="o">&gt;=</span> <span class="n">mz_node</span><span class="o">-&gt;</span><span class="n">usage_in_excess</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">tree_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">tree_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">rb_root</span><span class="p">);</span>
	<span class="n">mz</span><span class="o">-&gt;</span><span class="n">on_tree</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__mem_cgroup_remove_exceeded</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="o">*</span><span class="n">mctz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">on_tree</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">tree_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">rb_root</span><span class="p">);</span>
	<span class="n">mz</span><span class="o">-&gt;</span><span class="n">on_tree</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mem_cgroup_remove_exceeded</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="o">*</span><span class="n">mctz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">__mem_cgroup_remove_exceeded</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">mctz</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_update_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">excess</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="o">*</span><span class="n">mctz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">zid</span> <span class="o">=</span> <span class="n">page_zonenum</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">mctz</span> <span class="o">=</span> <span class="n">soft_limit_tree_from_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Necessary to update all ancestors when hierarchy is used.</span>
<span class="cm">	 * because their event counter is not touched.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">memcg</span><span class="p">;</span> <span class="n">memcg</span> <span class="o">=</span> <span class="n">parent_mem_cgroup</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mz</span> <span class="o">=</span> <span class="n">mem_cgroup_zoneinfo</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">zid</span><span class="p">);</span>
		<span class="n">excess</span> <span class="o">=</span> <span class="n">res_counter_soft_limit_excess</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have to update the tree if mz is on RB-tree or</span>
<span class="cm">		 * mem is over its softlimit.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">excess</span> <span class="o">||</span> <span class="n">mz</span><span class="o">-&gt;</span><span class="n">on_tree</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="cm">/* if on-tree, remove it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">on_tree</span><span class="p">)</span>
				<span class="n">__mem_cgroup_remove_exceeded</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">mctz</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Insert again. mz-&gt;usage_in_excess will be updated.</span>
<span class="cm">			 * If excess is 0, no tree ops.</span>
<span class="cm">			 */</span>
			<span class="n">__mem_cgroup_insert_exceeded</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">mctz</span><span class="p">,</span> <span class="n">excess</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_remove_from_trees</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">zone</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="o">*</span><span class="n">mctz</span><span class="p">;</span>

	<span class="n">for_each_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">zone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">zone</span> <span class="o">&lt;</span> <span class="n">MAX_NR_ZONES</span><span class="p">;</span> <span class="n">zone</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mz</span> <span class="o">=</span> <span class="n">mem_cgroup_zoneinfo</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>
			<span class="n">mctz</span> <span class="o">=</span> <span class="n">soft_limit_tree_node_zone</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>
			<span class="n">mem_cgroup_remove_exceeded</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">mctz</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span>
<span class="nf">__mem_cgroup_largest_soft_limit_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="o">*</span><span class="n">mctz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rightmost</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>

<span class="nl">retry:</span>
	<span class="n">mz</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rightmost</span> <span class="o">=</span> <span class="n">rb_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">rb_root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rightmost</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>		<span class="cm">/* Nothing to reclaim from */</span>

	<span class="n">mz</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rightmost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span><span class="p">,</span> <span class="n">tree_node</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Remove the node now but someone else can add it back,</span>
<span class="cm">	 * we will to add it back at the end of reclaim to its correct</span>
<span class="cm">	 * position in the tree.</span>
<span class="cm">	 */</span>
	<span class="n">__mem_cgroup_remove_exceeded</span><span class="p">(</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">mctz</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res_counter_soft_limit_excess</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">)</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">css_tryget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">mz</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span>
<span class="nf">mem_cgroup_largest_soft_limit_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="o">*</span><span class="n">mctz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mz</span> <span class="o">=</span> <span class="n">__mem_cgroup_largest_soft_limit_node</span><span class="p">(</span><span class="n">mctz</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mz</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Implementation Note: reading percpu statistics for memcg.</span>
<span class="cm"> *</span>
<span class="cm"> * Both of vmstat[] and percpu_counter has threshold and do periodic</span>
<span class="cm"> * synchronization to implement &quot;quick&quot; read. There are trade-off between</span>
<span class="cm"> * reading cost and precision of value. Then, we may have a chance to implement</span>
<span class="cm"> * a periodic synchronizion of counter in memcg&#39;s counter.</span>
<span class="cm"> *</span>
<span class="cm"> * But this _read() function is used for user interface now. The user accounts</span>
<span class="cm"> * memory usage by memory cgroup and he _always_ requires exact value because</span>
<span class="cm"> * he accounts memory. Even if we provide quick-and-fuzzy read, we always</span>
<span class="cm"> * have to visit all online cpus and make sum. So, for now, unnecessary</span>
<span class="cm"> * synchronization is not implemented. (just implemented for cpu hotplug)</span>
<span class="cm"> *</span>
<span class="cm"> * If there are kernel internal actions which can make use of some not-exact</span>
<span class="cm"> * value, and reading all cpu value can be performance bottleneck in some</span>
<span class="cm"> * common workload, threashold and synchonization as vmstat[] should be</span>
<span class="cm"> * implemented.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">mem_cgroup_read_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">mem_cgroup_stat_index</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">pcp_counter_lock</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">+=</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">nocpu_base</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">pcp_counter_lock</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">put_online_cpus</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_swap_statistics</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
					 <span class="n">bool</span> <span class="n">charge</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">charge</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">this_cpu_add</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">MEM_CGROUP_STAT_SWAPOUT</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mem_cgroup_read_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
					    <span class="k">enum</span> <span class="n">mem_cgroup_events_index</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">cpu</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_HOTPLUG_CPU</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">pcp_counter_lock</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">+=</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">nocpu_base</span><span class="p">.</span><span class="n">events</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">pcp_counter_lock</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_charge_statistics</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
					 <span class="n">bool</span> <span class="n">anon</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Here, RSS means &#39;mapped anon&#39; and anon&#39;s SwapCache. Shmem/tmpfs is</span>
<span class="cm">	 * counted as CACHE even if it&#39;s on ANON LRU.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">anon</span><span class="p">)</span>
		<span class="n">__this_cpu_add</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">MEM_CGROUP_STAT_RSS</span><span class="p">],</span>
				<span class="n">nr_pages</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__this_cpu_add</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">MEM_CGROUP_STAT_CACHE</span><span class="p">],</span>
				<span class="n">nr_pages</span><span class="p">);</span>

	<span class="cm">/* pagein of a big page is an event. So, ignore page size */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">MEM_CGROUP_EVENTS_PGPGIN</span><span class="p">]);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">MEM_CGROUP_EVENTS_PGPGOUT</span><span class="p">]);</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="o">-</span><span class="n">nr_pages</span><span class="p">;</span> <span class="cm">/* for event */</span>
	<span class="p">}</span>

	<span class="n">__this_cpu_add</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">nr_page_events</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>

	<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">mem_cgroup_get_lru_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>

	<span class="n">mz</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mz</span><span class="o">-&gt;</span><span class="n">lru_size</span><span class="p">[</span><span class="n">lru</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">mem_cgroup_zone_nr_lru_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">zid</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lru_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mz</span> <span class="o">=</span> <span class="n">mem_cgroup_zoneinfo</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">zid</span><span class="p">);</span>

	<span class="n">for_each_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BIT</span><span class="p">(</span><span class="n">lru</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">lru_mask</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">+=</span> <span class="n">mz</span><span class="o">-&gt;</span><span class="n">lru_size</span><span class="p">[</span><span class="n">lru</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">mem_cgroup_node_nr_lru_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lru_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">zid</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">zid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">zid</span> <span class="o">&lt;</span> <span class="n">MAX_NR_ZONES</span><span class="p">;</span> <span class="n">zid</span><span class="o">++</span><span class="p">)</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">mem_cgroup_zone_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span>
						<span class="n">nid</span><span class="p">,</span> <span class="n">zid</span><span class="p">,</span> <span class="n">lru_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mem_cgroup_nr_lru_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lru_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">mem_cgroup_node_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">lru_mask</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mem_cgroup_event_ratelimit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				       <span class="k">enum</span> <span class="n">mem_cgroup_events_target</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">nr_page_events</span><span class="p">);</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">__this_cpu_read</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">targets</span><span class="p">[</span><span class="n">target</span><span class="p">]);</span>
	<span class="cm">/* from time_after() in jiffies.h */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">next</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MEM_CGROUP_TARGET_THRESH</span>:
			<span class="n">next</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">THRESHOLDS_EVENTS_TARGET</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MEM_CGROUP_TARGET_SOFTLIMIT</span>:
			<span class="n">next</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">SOFTLIMIT_EVENTS_TARGET</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MEM_CGROUP_TARGET_NUMAINFO</span>:
			<span class="n">next</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">NUMAINFO_EVENTS_TARGET</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__this_cpu_write</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">targets</span><span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="n">next</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check events in order.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">memcg_check_events</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="cm">/* threshold event is triggered in finer grain than soft limit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mem_cgroup_event_ratelimit</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span>
						<span class="n">MEM_CGROUP_TARGET_THRESH</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">do_softlimit</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">do_numainfo</span> <span class="n">__maybe_unused</span><span class="p">;</span>

		<span class="n">do_softlimit</span> <span class="o">=</span> <span class="n">mem_cgroup_event_ratelimit</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span>
						<span class="n">MEM_CGROUP_TARGET_SOFTLIMIT</span><span class="p">);</span>
<span class="cp">#if MAX_NUMNODES &gt; 1</span>
		<span class="n">do_numainfo</span> <span class="o">=</span> <span class="n">mem_cgroup_event_ratelimit</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span>
						<span class="n">MEM_CGROUP_TARGET_NUMAINFO</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">preempt_enable</span><span class="p">();</span>

		<span class="n">mem_cgroup_threshold</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">do_softlimit</span><span class="p">))</span>
			<span class="n">mem_cgroup_update_tree</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="cp">#if MAX_NUMNODES &gt; 1</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">do_numainfo</span><span class="p">))</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">numainfo_events</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="nf">mem_cgroup_from_cont</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cgroup_subsys_state</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span>
				<span class="n">mem_cgroup_subsys_id</span><span class="p">),</span> <span class="k">struct</span> <span class="n">mem_cgroup</span><span class="p">,</span>
				<span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="nf">mem_cgroup_from_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * mm_update_next_owner() may clear mm-&gt;owner to NULL</span>
<span class="cm">	 * if it races with swapoff, page migration, etc.</span>
<span class="cm">	 * So this can be called with p == NULL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">task_subsys_state</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mem_cgroup_subsys_id</span><span class="p">),</span>
				<span class="k">struct</span> <span class="n">mem_cgroup</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="nf">try_get_mem_cgroup_from_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Because we have no locks, mm-&gt;owner&#39;s may be being moved to other</span>
<span class="cm">	 * cgroup. We use css_tryget() here even if this looks</span>
<span class="cm">	 * pessimistic (rather than adding locks here).</span>
<span class="cm">	 */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_task</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">css_tryget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">memcg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mem_cgroup_iter - iterate over memory cgroup hierarchy</span>
<span class="cm"> * @root: hierarchy root</span>
<span class="cm"> * @prev: previously returned memcg, NULL on first invocation</span>
<span class="cm"> * @reclaim: cookie for shared reclaim walks, NULL for full walks</span>
<span class="cm"> *</span>
<span class="cm"> * Returns references to children of the hierarchy below @root, or</span>
<span class="cm"> * @root itself, or %NULL after a full round-trip.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller must pass the return value in @prev on subsequent</span>
<span class="cm"> * invocations for reference counting, or use mem_cgroup_iter_break()</span>
<span class="cm"> * to cancel a hierarchy walk before the round-trip is complete.</span>
<span class="cm"> *</span>
<span class="cm"> * Reclaimers can specify a zone and a priority level in @reclaim to</span>
<span class="cm"> * divide up the memcgs in the hierarchy among all concurrent</span>
<span class="cm"> * reclaimers operating on the same zone and priority.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="nf">mem_cgroup_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">mem_cgroup_reclaim_cookie</span> <span class="o">*</span><span class="n">reclaim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">root_mem_cgroup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">reclaim</span><span class="p">)</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">css_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span>
		<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span> <span class="o">&amp;&amp;</span> <span class="n">root</span> <span class="o">!=</span> <span class="n">root_mem_cgroup</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">root</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mem_cgroup_reclaim_iter</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reclaim</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">zone_to_nid</span><span class="p">(</span><span class="n">reclaim</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">zid</span> <span class="o">=</span> <span class="n">zone_idx</span><span class="p">(</span><span class="n">reclaim</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>

			<span class="n">mz</span> <span class="o">=</span> <span class="n">mem_cgroup_zoneinfo</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">zid</span><span class="p">);</span>
			<span class="n">iter</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">reclaim_iter</span><span class="p">[</span><span class="n">reclaim</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">reclaim</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">!=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">id</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">position</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">css</span> <span class="o">=</span> <span class="n">css_get_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_cgroup_subsys</span><span class="p">,</span> <span class="n">id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">css</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">css</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">css</span> <span class="o">||</span> <span class="n">css_tryget</span><span class="p">(</span><span class="n">css</span><span class="p">))</span>
				<span class="n">memcg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">css</span><span class="p">,</span>
						     <span class="k">struct</span> <span class="n">mem_cgroup</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reclaim</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">css</span><span class="p">)</span>
				<span class="n">iter</span><span class="o">-&gt;</span><span class="n">generation</span><span class="o">++</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">memcg</span><span class="p">)</span>
				<span class="n">reclaim</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">css</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">memcg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mem_cgroup_iter_break - abort a hierarchy walk prematurely</span>
<span class="cm"> * @root: hierarchy root</span>
<span class="cm"> * @prev: last visited hierarchy member as returned by mem_cgroup_iter()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mem_cgroup_iter_break</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">root_mem_cgroup</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span>
		<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Iteration constructs for visiting all cgroups (under a tree).  If</span>
<span class="cm"> * loops are exited prematurely (break), mem_cgroup_iter_break() must</span>
<span class="cm"> * be used for reference counting.</span>
<span class="cm"> */</span>
<span class="cp">#define for_each_mem_cgroup_tree(iter, root)		\</span>
<span class="cp">	for (iter = mem_cgroup_iter(root, NULL, NULL);	\</span>
<span class="cp">	     iter != NULL;				\</span>
<span class="cp">	     iter = mem_cgroup_iter(root, iter, NULL))</span>

<span class="cp">#define for_each_mem_cgroup(iter)			\</span>
<span class="cp">	for (iter = mem_cgroup_iter(NULL, NULL, NULL);	\</span>
<span class="cp">	     iter != NULL;				\</span>
<span class="cp">	     iter = mem_cgroup_iter(NULL, iter, NULL))</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">mem_cgroup_is_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">memcg</span> <span class="o">==</span> <span class="n">root_mem_cgroup</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mem_cgroup_count_vm_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">enum</span> <span class="n">vm_event_item</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_task</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PGFAULT</span>:
		<span class="n">this_cpu_inc</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">MEM_CGROUP_EVENTS_PGFAULT</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">PGMAJFAULT</span>:
		<span class="n">this_cpu_inc</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">MEM_CGROUP_EVENTS_PGMAJFAULT</span><span class="p">]);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mem_cgroup_count_vm_event</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * mem_cgroup_zone_lruvec - get the lru list vector for a zone and memcg</span>
<span class="cm"> * @zone: zone of the wanted lruvec</span>
<span class="cm"> * @memcg: memcg of the wanted lruvec</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the lru list vector holding pages for the given @zone and</span>
<span class="cm"> * @mem.  This can be the global zone lruvec, if the memory controller</span>
<span class="cm"> * is disabled.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="nf">mem_cgroup_zone_lruvec</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lruvec</span><span class="p">;</span>

	<span class="n">mz</span> <span class="o">=</span> <span class="n">mem_cgroup_zoneinfo</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">zone_to_nid</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="n">zone_idx</span><span class="p">(</span><span class="n">zone</span><span class="p">));</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">lruvec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Following LRU functions are allowed to be used without PCG_LOCK.</span>
<span class="cm"> * Operations are called by routine of global LRU independently from memcg.</span>
<span class="cm"> * What we have to take care of here is validness of pc-&gt;mem_cgroup.</span>
<span class="cm"> *</span>
<span class="cm"> * Changes to pc-&gt;mem_cgroup happens when</span>
<span class="cm"> * 1. charge</span>
<span class="cm"> * 2. moving account</span>
<span class="cm"> * In typical case, &quot;charge&quot; is done before add-to-lru. Exception is SwapCache.</span>
<span class="cm"> * It is added to LRU before charge.</span>
<span class="cm"> * If PCG_USED bit is not set, page_cgroup is not added to this private LRU.</span>
<span class="cm"> * When moving account, the page is not on LRU. It&#39;s isolated.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * mem_cgroup_page_lruvec - return lruvec for adding an lru page</span>
<span class="cm"> * @page: the page</span>
<span class="cm"> * @zone: zone of the page</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="nf">mem_cgroup_page_lruvec</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lruvec</span><span class="p">;</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">memcg</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Surreptitiously switch any uncharged offlist page to root:</span>
<span class="cm">	 * an uncharged page off lru does nothing to secure</span>
<span class="cm">	 * its former mem_cgroup from sudden removal.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Our caller holds lru_lock, and PageCgroupUsed is updated</span>
<span class="cm">	 * under page_cgroup lock: between them, they make all uses</span>
<span class="cm">	 * of pc-&gt;mem_cgroup safe.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">memcg</span> <span class="o">!=</span> <span class="n">root_mem_cgroup</span><span class="p">)</span>
		<span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span> <span class="o">=</span> <span class="n">memcg</span> <span class="o">=</span> <span class="n">root_mem_cgroup</span><span class="p">;</span>

	<span class="n">mz</span> <span class="o">=</span> <span class="n">page_cgroup_zoneinfo</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">lruvec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mem_cgroup_update_lru_size - account for adding or removing an lru page</span>
<span class="cm"> * @lruvec: mem_cgroup per zone lru vector</span>
<span class="cm"> * @lru: index of lru list the page is sitting on</span>
<span class="cm"> * @nr_pages: positive when adding or negative when removing</span>
<span class="cm"> *</span>
<span class="cm"> * This function must be called when a page is added to or removed from an</span>
<span class="cm"> * lru list.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mem_cgroup_update_lru_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">lru_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mz</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">);</span>
	<span class="n">lru_size</span> <span class="o">=</span> <span class="n">mz</span><span class="o">-&gt;</span><span class="n">lru_size</span> <span class="o">+</span> <span class="n">lru</span><span class="p">;</span>
	<span class="o">*</span><span class="n">lru_size</span> <span class="o">+=</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">VM_BUG_ON</span><span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="o">*</span><span class="n">lru_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Checks whether given mem is same or in the root_mem_cgroup&#39;s</span>
<span class="cm"> * hierarchy subtree</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">__mem_cgroup_same_or_subtree</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">root_memcg</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root_memcg</span> <span class="o">==</span> <span class="n">memcg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root_memcg</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span> <span class="o">||</span> <span class="o">!</span><span class="n">memcg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">css_is_ancestor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mem_cgroup_same_or_subtree</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">root_memcg</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__mem_cgroup_same_or_subtree</span><span class="p">(</span><span class="n">root_memcg</span><span class="p">,</span> <span class="n">memcg</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">task_in_mem_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">find_lock_task_mm</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">try_get_mem_cgroup_from_mm</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * All threads may have already detached their mm&#39;s, but the oom</span>
<span class="cm">		 * killer still needs to detect if they have already been oom</span>
<span class="cm">		 * killed to prevent needlessly killing additional tasks.</span>
<span class="cm">		 */</span>
		<span class="n">task_lock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">mem_cgroup_from_task</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="p">)</span>
			<span class="n">css_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
		<span class="n">task_unlock</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We should check use_hierarchy of &quot;memcg&quot; not &quot;curr&quot;. Because checking</span>
<span class="cm">	 * use_hierarchy of &quot;curr&quot; here make this function true if hierarchy is</span>
<span class="cm">	 * enabled in &quot;curr&quot; and &quot;curr&quot; is a child of &quot;memcg&quot; in *cgroup*</span>
<span class="cm">	 * hierarchy(even if use_hierarchy is disabled in &quot;memcg&quot;).</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_same_or_subtree</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
	<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mem_cgroup_inactive_anon_is_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inactive_ratio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inactive</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gb</span><span class="p">;</span>

	<span class="n">inactive</span> <span class="o">=</span> <span class="n">mem_cgroup_get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">LRU_INACTIVE_ANON</span><span class="p">);</span>
	<span class="n">active</span> <span class="o">=</span> <span class="n">mem_cgroup_get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">LRU_ACTIVE_ANON</span><span class="p">);</span>

	<span class="n">gb</span> <span class="o">=</span> <span class="p">(</span><span class="n">inactive</span> <span class="o">+</span> <span class="n">active</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">30</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gb</span><span class="p">)</span>
		<span class="n">inactive_ratio</span> <span class="o">=</span> <span class="n">int_sqrt</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">gb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">inactive_ratio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">inactive</span> <span class="o">*</span> <span class="n">inactive_ratio</span> <span class="o">&lt;</span> <span class="n">active</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mem_cgroup_inactive_file_is_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inactive</span><span class="p">;</span>

	<span class="n">inactive</span> <span class="o">=</span> <span class="n">mem_cgroup_get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">LRU_INACTIVE_FILE</span><span class="p">);</span>
	<span class="n">active</span> <span class="o">=</span> <span class="n">mem_cgroup_get_lru_size</span><span class="p">(</span><span class="n">lruvec</span><span class="p">,</span> <span class="n">LRU_ACTIVE_FILE</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">active</span> <span class="o">&gt;</span> <span class="n">inactive</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define mem_cgroup_from_res_counter(counter, member)	\</span>
<span class="cp">	container_of(counter, struct mem_cgroup, member)</span>

<span class="cm">/**</span>
<span class="cm"> * mem_cgroup_margin - calculate chargeable space of a memory cgroup</span>
<span class="cm"> * @memcg: the memory cgroup</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the maximum amount of memory @mem can be charged with, in</span>
<span class="cm"> * pages.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mem_cgroup_margin</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">margin</span><span class="p">;</span>

	<span class="n">margin</span> <span class="o">=</span> <span class="n">res_counter_margin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span><span class="p">)</span>
		<span class="n">margin</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">margin</span><span class="p">,</span> <span class="n">res_counter_margin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">margin</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mem_cgroup_swappiness</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="p">;</span>

	<span class="cm">/* root ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vm_swappiness</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">swappiness</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * memcg-&gt;moving_account is used for checking possibility that some thread is</span>
<span class="cm"> * calling move_account(). When a thread on CPU-A starts moving pages under</span>
<span class="cm"> * a memcg, other threads should check memcg-&gt;moving_account under</span>
<span class="cm"> * rcu_read_lock(), like this:</span>
<span class="cm"> *</span>
<span class="cm"> *         CPU-A                                    CPU-B</span>
<span class="cm"> *                                              rcu_read_lock()</span>
<span class="cm"> *         memcg-&gt;moving_account+1              if (memcg-&gt;mocing_account)</span>
<span class="cm"> *                                                   take heavy locks.</span>
<span class="cm"> *         synchronize_rcu()                    update something.</span>
<span class="cm"> *                                              rcu_read_unlock()</span>
<span class="cm"> *         start move here.</span>
<span class="cm"> */</span>

<span class="cm">/* for quick checking without looking up memcg */</span>
<span class="n">atomic_t</span> <span class="n">memcg_moving</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_start_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_moving</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">moving_account</span><span class="p">);</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_end_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now, mem_cgroup_clear_mc() may call this function with NULL.</span>
<span class="cm">	 * We check NULL in callee rather than caller.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_moving</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">moving_account</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2 routines for checking &quot;mem&quot; is under move_account() or not.</span>
<span class="cm"> *</span>
<span class="cm"> * mem_cgroup_stolen() -  checking whether a cgroup is mc.from or not. This</span>
<span class="cm"> *			  is used for avoiding races in accounting.  If true,</span>
<span class="cm"> *			  pc-&gt;mem_cgroup may be overwritten.</span>
<span class="cm"> *</span>
<span class="cm"> * mem_cgroup_under_move() - checking a cgroup is mc.from or mc.to or</span>
<span class="cm"> *			  under hierarchy of moving cgroups. This is for</span>
<span class="cm"> *			  waiting at hith-memory prressure caused by &quot;move&quot;.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mem_cgroup_stolen</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rcu_read_lock_held</span><span class="p">());</span>
	<span class="k">return</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">moving_account</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mem_cgroup_under_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unlike task_move routines, we access mc.to, mc.from not under</span>
<span class="cm">	 * mutual exclusion by cgroup_mutex. Here, we take spinlock instead.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">from</span> <span class="o">=</span> <span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">;</span>
	<span class="n">to</span> <span class="o">=</span> <span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">from</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_same_or_subtree</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">from</span><span class="p">)</span>
		<span class="o">||</span> <span class="n">mem_cgroup_same_or_subtree</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mem_cgroup_wait_acct_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">moving_task</span> <span class="o">&amp;&amp;</span> <span class="n">current</span> <span class="o">!=</span> <span class="n">mc</span><span class="p">.</span><span class="n">moving_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_under_move</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
			<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
			<span class="cm">/* moving charge context might have finished. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">moving_task</span><span class="p">)</span>
				<span class="n">schedule</span><span class="p">();</span>
			<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Take this lock when</span>
<span class="cm"> * - a code tries to modify page&#39;s memcg while it&#39;s USED.</span>
<span class="cm"> * - a code tries to modify page state accounting in a memcg.</span>
<span class="cm"> * see mem_cgroup_stolen(), too.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">move_lock_mem_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">move_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">move_unlock_mem_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">move_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mem_cgroup_print_oom_info: Called from OOM with tasklist_lock held in read mode.</span>
<span class="cm"> * @memcg: The memory cgroup that went over limit</span>
<span class="cm"> * @p: Task that is going to be killed</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: @memcg and @p&#39;s mem_cgroup can be different when hierarchy is</span>
<span class="cm"> * enabled</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mem_cgroup_print_oom_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">task_cgrp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">mem_cgrp</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Need a buffer in BSS, can&#39;t rely on allocations. The code relies</span>
<span class="cm">	 * on the assumption that OOM is serialized for memory controller.</span>
<span class="cm">	 * If this assumption is broken, revisit this code.</span>
<span class="cm">	 */</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">memcg_name</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span> <span class="o">||</span> <span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">mem_cgrp</span> <span class="o">=</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="p">;</span>
	<span class="n">task_cgrp</span> <span class="o">=</span> <span class="n">task_cgroup</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mem_cgroup_subsys_id</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cgroup_path</span><span class="p">(</span><span class="n">task_cgrp</span><span class="p">,</span> <span class="n">memcg_name</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Unfortunately, we are unable to convert to a useful name</span>
<span class="cm">		 * But we&#39;ll still print out the usage information</span>
<span class="cm">		 */</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Task in %s killed&quot;</span><span class="p">,</span> <span class="n">memcg_name</span><span class="p">);</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">cgroup_path</span><span class="p">(</span><span class="n">mem_cgrp</span><span class="p">,</span> <span class="n">memcg_name</span><span class="p">,</span> <span class="n">PATH_MAX</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Continues from above, so we don&#39;t need an KERN_ level</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot; as a result of limit of %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">memcg_name</span><span class="p">);</span>
<span class="nl">done:</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;memory: usage %llukB, limit %llukB, failcnt %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_FAILCNT</span><span class="p">));</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;memory+swap: usage %llukB, limit %llukB, &quot;</span>
		<span class="s">&quot;failcnt %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">RES_FAILCNT</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function returns the number of memcg under hierarchy tree. Returns</span>
<span class="cm"> * 1(self count) if no children.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_count_children</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="n">for_each_mem_cgroup_tree</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">memcg</span><span class="p">)</span>
		<span class="n">num</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the memory (and swap, if configured) limit for a memcg.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">mem_cgroup_get_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">limit</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">memsw</span><span class="p">;</span>

	<span class="n">limit</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">);</span>
	<span class="n">limit</span> <span class="o">+=</span> <span class="n">total_swap_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">memsw</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If memsw is finite and limits the amount of swap space available</span>
<span class="cm">	 * to this memcg, return that limit.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">memsw</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mem_cgroup_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
					<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">noswap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MEM_CGROUP_RECLAIM_NOSWAP</span><span class="p">)</span>
		<span class="n">noswap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MEM_CGROUP_RECLAIM_SHRINK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw_is_minimum</span><span class="p">)</span>
		<span class="n">noswap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="n">MEM_CGROUP_MAX_RECLAIM_LOOPS</span><span class="p">;</span> <span class="n">loop</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="p">)</span>
			<span class="n">drain_all_stock_async</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">try_to_free_mem_cgroup_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">noswap</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Allow limit shrinkers, which are triggered directly</span>
<span class="cm">		 * by userspace, to catch signals and stop reclaim</span>
<span class="cm">		 * after minimal progress, regardless of the margin.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MEM_CGROUP_RECLAIM_SHRINK</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_margin</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If nothing was reclaimed after two attempts, there</span>
<span class="cm">		 * may be no reclaimable pages in this hierarchy.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loop</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">total</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * test_mem_cgroup_node_reclaimable</span>
<span class="cm"> * @memcg: the target memcg</span>
<span class="cm"> * @nid: the node ID to be checked.</span>
<span class="cm"> * @noswap : specify true here if the user wants flle only information.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns whether the specified memcg contains any</span>
<span class="cm"> * reclaimable pages on a node. Returns true if there are any reclaimable</span>
<span class="cm"> * pages in the node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">test_mem_cgroup_node_reclaimable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">bool</span> <span class="n">noswap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_node_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">LRU_ALL_FILE</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">noswap</span> <span class="o">||</span> <span class="o">!</span><span class="n">total_swap_pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_node_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">LRU_ALL_ANON</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="p">}</span>
<span class="cp">#if MAX_NUMNODES &gt; 1</span>

<span class="cm">/*</span>
<span class="cm"> * Always updating the nodemask is not very good - even if we have an empty</span>
<span class="cm"> * list or the wrong list here, we can start from some node and traverse all</span>
<span class="cm"> * nodes based on the zonelist. So update the list loosely once per 10 secs.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_may_update_nodemask</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * numainfo_events &gt; 0 means there was at least NUMAINFO_EVENTS_TARGET</span>
<span class="cm">	 * pagein/pageout changes since the last update.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">numainfo_events</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">numainfo_updating</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* make a nodemask where this memcg uses memory from */</span>
	<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">scan_nodes</span> <span class="o">=</span> <span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">];</span>

	<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">])</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_mem_cgroup_node_reclaimable</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
			<span class="n">node_clear</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">scan_nodes</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">numainfo_events</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">numainfo_updating</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Selecting a node where we start reclaim from. Because what we need is just</span>
<span class="cm"> * reducing usage counter, start from anywhere is O,K. Considering</span>
<span class="cm"> * memory reclaim from current node, there are pros. and cons.</span>
<span class="cm"> *</span>
<span class="cm"> * Freeing memory from current node means freeing memory from a node which</span>
<span class="cm"> * we&#39;ll use or we&#39;ve used. So, it may make LRU bad. And if several threads</span>
<span class="cm"> * hit limits, it will see a contention on a node. But freeing from remote</span>
<span class="cm"> * node means more costs for memory reclaim because of memory latency.</span>
<span class="cm"> *</span>
<span class="cm"> * Now, we use round-robin. Better algorithm is welcomed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mem_cgroup_select_victim_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">mem_cgroup_may_update_nodemask</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">last_scanned_node</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">scan_nodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">scan_nodes</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We call this when we hit limit, not when pages are added to LRU.</span>
<span class="cm">	 * No LRU may hold pages because all pages are UNEVICTABLE or</span>
<span class="cm">	 * memcg is too small and all pages are not on LRU. In that case,</span>
<span class="cm">	 * we use curret node.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">))</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">numa_node_id</span><span class="p">();</span>

	<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">last_scanned_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check all nodes whether it contains reclaimable pages or not.</span>
<span class="cm"> * For quick scan, we make use of scan_nodes. This will allow us to skip</span>
<span class="cm"> * unused nodes. But scan_nodes is lazily updated and may not cotain</span>
<span class="cm"> * enough new information. We need to do double check.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">mem_cgroup_reclaimable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">noswap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * quick check...making use of scan_node.</span>
<span class="cm">	 * We can skip unused nodes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodes_empty</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">scan_nodes</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">nid</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">scan_nodes</span><span class="p">);</span>
		     <span class="n">nid</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span>
		     <span class="n">nid</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">scan_nodes</span><span class="p">))</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">test_mem_cgroup_node_reclaimable</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">noswap</span><span class="p">))</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check rest of nodes.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node_isset</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">scan_nodes</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_mem_cgroup_node_reclaimable</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">noswap</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>
<span class="kt">int</span> <span class="nf">mem_cgroup_select_victim_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">mem_cgroup_reclaimable</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">noswap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_mem_cgroup_node_reclaimable</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">noswap</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_soft_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">root_memcg</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span>
				   <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">total_scanned</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">victim</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">excess</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scanned</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_reclaim_cookie</span> <span class="n">reclaim</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">zone</span> <span class="o">=</span> <span class="n">zone</span><span class="p">,</span>
		<span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">excess</span> <span class="o">=</span> <span class="n">res_counter_soft_limit_excess</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">victim</span> <span class="o">=</span> <span class="n">mem_cgroup_iter</span><span class="p">(</span><span class="n">root_memcg</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reclaim</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">loop</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">loop</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If we have not been able to reclaim</span>
<span class="cm">				 * anything, it might because there are</span>
<span class="cm">				 * no reclaimable pages under this hierarchy</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">total</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * We want to do more targeted reclaim.</span>
<span class="cm">				 * excess &gt;&gt; 2 is not to excessive so as to</span>
<span class="cm">				 * reclaim too much, nor too less that we keep</span>
<span class="cm">				 * coming back to reclaim from this cgroup</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">excess</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span>
					<span class="p">(</span><span class="n">loop</span> <span class="o">&gt;</span> <span class="n">MEM_CGROUP_MAX_RECLAIM_LOOPS</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_reclaimable</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">mem_cgroup_shrink_node_zone</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
						     <span class="n">zone</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_scanned</span><span class="p">);</span>
		<span class="o">*</span><span class="n">total_scanned</span> <span class="o">+=</span> <span class="n">nr_scanned</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res_counter_soft_limit_excess</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mem_cgroup_iter_break</span><span class="p">(</span><span class="n">root_memcg</span><span class="p">,</span> <span class="n">victim</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check OOM-Killer is already running under our hierarchy.</span>
<span class="cm"> * If someone is running, return false.</span>
<span class="cm"> * Has to be called with memcg_oom_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">mem_cgroup_oom_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="o">*</span><span class="n">failed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">for_each_mem_cgroup_tree</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">memcg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">oom_lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * this subtree of our hierarchy is already locked</span>
<span class="cm">			 * so we cannot give a lock.</span>
<span class="cm">			 */</span>
			<span class="n">failed</span> <span class="o">=</span> <span class="n">iter</span><span class="p">;</span>
			<span class="n">mem_cgroup_iter_break</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">iter</span><span class="o">-&gt;</span><span class="n">oom_lock</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">failed</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK, we failed to lock the whole subtree so we have to clean up</span>
<span class="cm">	 * what we set up to the failing subtree</span>
<span class="cm">	 */</span>
	<span class="n">for_each_mem_cgroup_tree</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">memcg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">failed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mem_cgroup_iter_break</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">oom_lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Has to be called with memcg_oom_lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_oom_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="n">for_each_mem_cgroup_tree</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">memcg</span><span class="p">)</span>
		<span class="n">iter</span><span class="o">-&gt;</span><span class="n">oom_lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_mark_under_oom</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="n">for_each_mem_cgroup_tree</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">memcg</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">under_oom</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_unmark_under_oom</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When a new child is created while the hierarchy is under oom,</span>
<span class="cm">	 * mem_cgroup_oom_lock() may not be called. We have to use</span>
<span class="cm">	 * atomic_add_unless() here.</span>
<span class="cm">	 */</span>
	<span class="n">for_each_mem_cgroup_tree</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">memcg</span><span class="p">)</span>
		<span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">under_oom</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">memcg_oom_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">memcg_oom_waitq</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">oom_wait_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
	<span class="n">wait_queue_t</span>	<span class="n">wait</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">memcg_oom_wake_function</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">wake_memcg</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">oom_wait_memcg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">oom_wait_info</span> <span class="o">*</span><span class="n">oom_wait_info</span><span class="p">;</span>

	<span class="n">oom_wait_info</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="k">struct</span> <span class="n">oom_wait_info</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">oom_wait_memcg</span> <span class="o">=</span> <span class="n">oom_wait_info</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Both of oom_wait_info-&gt;memcg and wake_memcg are stable under us.</span>
<span class="cm">	 * Then we can use css_is_ancestor without taking care of RCU.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_same_or_subtree</span><span class="p">(</span><span class="n">oom_wait_memcg</span><span class="p">,</span> <span class="n">wake_memcg</span><span class="p">)</span>
		<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mem_cgroup_same_or_subtree</span><span class="p">(</span><span class="n">wake_memcg</span><span class="p">,</span> <span class="n">oom_wait_memcg</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">autoremove_wake_function</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">memcg_wakeup_oom</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* for filtering, pass &quot;memcg&quot; as argument. */</span>
	<span class="n">__wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_waitq</span><span class="p">,</span> <span class="n">TASK_NORMAL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">memcg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">memcg_oom_recover</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">under_oom</span><span class="p">))</span>
		<span class="n">memcg_wakeup_oom</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * try to call OOM killer. returns false if we should exit memory-reclaim loop.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">mem_cgroup_handle_oom</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">mask</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">oom_wait_info</span> <span class="n">owait</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">locked</span><span class="p">,</span> <span class="n">need_to_kill</span><span class="p">;</span>

	<span class="n">owait</span><span class="p">.</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">;</span>
	<span class="n">owait</span><span class="p">.</span><span class="n">wait</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">owait</span><span class="p">.</span><span class="n">wait</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">memcg_oom_wake_function</span><span class="p">;</span>
	<span class="n">owait</span><span class="p">.</span><span class="n">wait</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owait</span><span class="p">.</span><span class="n">wait</span><span class="p">.</span><span class="n">task_list</span><span class="p">);</span>
	<span class="n">need_to_kill</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">mem_cgroup_mark_under_oom</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>

	<span class="cm">/* At first, try to OOM lock hierarchy under memcg.*/</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_lock</span><span class="p">);</span>
	<span class="n">locked</span> <span class="o">=</span> <span class="n">mem_cgroup_oom_lock</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Even if signal_pending(), we can&#39;t quit charge() loop without</span>
<span class="cm">	 * accounting. So, UNINTERRUPTIBLE is appropriate. But SIGKILL</span>
<span class="cm">	 * under OOM is always welcomed, use TASK_KILLABLE here.</span>
<span class="cm">	 */</span>
	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">owait</span><span class="p">.</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_KILLABLE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span> <span class="o">||</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">oom_kill_disable</span><span class="p">)</span>
		<span class="n">need_to_kill</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">mem_cgroup_oom_notify</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_to_kill</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">owait</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">mem_cgroup_out_of_memory</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_waitq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">owait</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span>
		<span class="n">mem_cgroup_oom_unlock</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="n">memcg_wakeup_oom</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_lock</span><span class="p">);</span>

	<span class="n">mem_cgroup_unmark_under_oom</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_MEMDIE</span><span class="p">)</span> <span class="o">||</span> <span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="cm">/* Give chance to dying process */</span>
	<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Currently used to update mapped file statistics, but the routine can be</span>
<span class="cm"> * generalized to update other statistics as well.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes: Race condition</span>
<span class="cm"> *</span>
<span class="cm"> * We usually use page_cgroup_lock() for accessing page_cgroup member but</span>
<span class="cm"> * it tends to be costly. But considering some conditions, we doesn&#39;t need</span>
<span class="cm"> * to do so _always_.</span>
<span class="cm"> *</span>
<span class="cm"> * Considering &quot;charge&quot;, lock_page_cgroup() is not required because all</span>
<span class="cm"> * file-stat operations happen after a page is attached to radix-tree. There</span>
<span class="cm"> * are no race with &quot;charge&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Considering &quot;uncharge&quot;, we know that memcg doesn&#39;t clear pc-&gt;mem_cgroup</span>
<span class="cm"> * at &quot;uncharge&quot; intentionally. So, we always see valid pc-&gt;mem_cgroup even</span>
<span class="cm"> * if there are race with &quot;uncharge&quot;. Statistics itself is properly handled</span>
<span class="cm"> * by flags.</span>
<span class="cm"> *</span>
<span class="cm"> * Considering &quot;move&quot;, this is an only case we see a race. To make the race</span>
<span class="cm"> * small, we check mm-&gt;moving_account and detect there are possibility of race</span>
<span class="cm"> * If there is, we take a lock.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">__mem_cgroup_begin_update_page_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				<span class="n">bool</span> <span class="o">*</span><span class="n">locked</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">memcg</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">memcg</span> <span class="o">||</span> <span class="o">!</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this memory cgroup is not under account moving, we don&#39;t</span>
<span class="cm">	 * need to take move_lock_page_cgroup(). Because we already hold</span>
<span class="cm">	 * rcu_read_lock(), any calls to move_account will be delayed until</span>
<span class="cm">	 * rcu_read_unlock() if mem_cgroup_stolen() == true.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_stolen</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">move_lock_mem_cgroup</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span> <span class="o">!=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span> <span class="o">||</span> <span class="o">!</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">move_unlock_mem_cgroup</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">locked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__mem_cgroup_end_update_page_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s guaranteed that pc-&gt;mem_cgroup never changes while</span>
<span class="cm">	 * lock is held because a routine modifies pc-&gt;mem_cgroup</span>
<span class="cm">	 * should take move_lock_page_cgroup().</span>
<span class="cm">	 */</span>
	<span class="n">move_unlock_mem_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mem_cgroup_update_page_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				 <span class="k">enum</span> <span class="n">mem_cgroup_page_stat_item</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memcg</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">memcg</span> <span class="o">||</span> <span class="o">!</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">)))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEMCG_NR_FILE_MAPPED</span>:
		<span class="n">idx</span> <span class="o">=</span> <span class="n">MEM_CGROUP_STAT_FILE_MAPPED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">this_cpu_add</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * size of first charge trial. &quot;32&quot; comes from vmscan.c&#39;s magic value.</span>
<span class="cm"> * TODO: maybe necessary to use big numbers in big irons.</span>
<span class="cm"> */</span>
<span class="cp">#define CHARGE_BATCH	32U</span>
<span class="k">struct</span> <span class="n">memcg_stock_pcp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">cached</span><span class="p">;</span> <span class="cm">/* this never be root cgroup */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define FLUSHING_CACHED_CHARGE	0</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="k">struct</span> <span class="n">memcg_stock_pcp</span><span class="p">,</span> <span class="n">memcg_stock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">percpu_charge_mutex</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Try to consume stocked charge on this cpu. If success, one page is consumed</span>
<span class="cm"> * from local stock and true is returned. If the stock is 0 or charges from a</span>
<span class="cm"> * cgroup which is not current target, returns false. This stock will be</span>
<span class="cm"> * refilled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">consume_stock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memcg_stock_pcp</span> <span class="o">*</span><span class="n">stock</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">stock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">memcg_stock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span> <span class="o">==</span> <span class="n">stock</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">&amp;&amp;</span> <span class="n">stock</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">)</span>
		<span class="n">stock</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="o">--</span><span class="p">;</span>
	<span class="k">else</span> <span class="cm">/* need to call res_counter_charge */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">memcg_stock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns stocks cached in percpu to res_counter and reset cached information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_stock</span><span class="p">(</span><span class="k">struct</span> <span class="n">memcg_stock_pcp</span> <span class="o">*</span><span class="n">stock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">stock</span><span class="o">-&gt;</span><span class="n">cached</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stock</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">stock</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span><span class="p">)</span>
			<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">stock</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">stock</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This must be called under preempt disabled or must be called by</span>
<span class="cm"> * a thread which is pinned to local cpu.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_local_stock</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">dummy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memcg_stock_pcp</span> <span class="o">*</span><span class="n">stock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">memcg_stock</span><span class="p">);</span>
	<span class="n">drain_stock</span><span class="p">(</span><span class="n">stock</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLUSHING_CACHED_CHARGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cache charges(val) which is from res_counter, to local per_cpu area.</span>
<span class="cm"> * This will be consumed by consume_stock() function, later.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">refill_stock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memcg_stock_pcp</span> <span class="o">*</span><span class="n">stock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">get_cpu_var</span><span class="p">(</span><span class="n">memcg_stock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">stock</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">!=</span> <span class="n">memcg</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* reset if necessary */</span>
		<span class="n">drain_stock</span><span class="p">(</span><span class="n">stock</span><span class="p">);</span>
		<span class="n">stock</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">stock</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">put_cpu_var</span><span class="p">(</span><span class="n">memcg_stock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Drains all per-CPU charge caches for given root_memcg resp. subtree</span>
<span class="cm"> * of the hierarchy under it. sync flag says whether we should block</span>
<span class="cm"> * until the work is done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_all_stock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">root_memcg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">curcpu</span><span class="p">;</span>

	<span class="cm">/* Notify other cpus that system-wide &quot;drain&quot; is running */</span>
	<span class="n">get_online_cpus</span><span class="p">();</span>
	<span class="n">curcpu</span> <span class="o">=</span> <span class="n">get_cpu</span><span class="p">();</span>
	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">memcg_stock_pcp</span> <span class="o">*</span><span class="n">stock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">memcg_stock</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>

		<span class="n">memcg</span> <span class="o">=</span> <span class="n">stock</span><span class="o">-&gt;</span><span class="n">cached</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span> <span class="o">||</span> <span class="o">!</span><span class="n">stock</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_same_or_subtree</span><span class="p">(</span><span class="n">root_memcg</span><span class="p">,</span> <span class="n">memcg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">FLUSHING_CACHED_CHARGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">curcpu</span><span class="p">)</span>
				<span class="n">drain_local_stock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stock</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">schedule_work_on</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stock</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">put_cpu</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">for_each_online_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">memcg_stock_pcp</span> <span class="o">*</span><span class="n">stock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">memcg_stock</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLUSHING_CACHED_CHARGE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">flush_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stock</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
 	<span class="n">put_online_cpus</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Tries to drain stocked charges in other cpus. This function is asynchronous</span>
<span class="cm"> * and just put a work per cpu for draining localy on each cpu. Caller can</span>
<span class="cm"> * expects some charges will be back to res_counter later but cannot wait for</span>
<span class="cm"> * it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_all_stock_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">root_memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * If someone calls draining, avoid adding more kworker runs.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">percpu_charge_mutex</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">drain_all_stock</span><span class="p">(</span><span class="n">root_memcg</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">percpu_charge_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This is a synchronous drain interface. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_all_stock_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">root_memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* called when force_empty is called */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">percpu_charge_mutex</span><span class="p">);</span>
	<span class="n">drain_all_stock</span><span class="p">(</span><span class="n">root_memcg</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">percpu_charge_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function drains percpu counter value from DEAD cpu and</span>
<span class="cm"> * move it to local cpu. Note that this function can be preempted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_drain_pcp_counter</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">pcp_counter_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEM_CGROUP_STAT_NSTATS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="n">per_cpu</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">nocpu_base</span><span class="p">.</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEM_CGROUP_EVENTS_NSTATS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="n">per_cpu</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="n">per_cpu</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">nocpu_base</span><span class="p">.</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">pcp_counter_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span> <span class="nf">memcg_cpu_hotplug_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">nb</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span>
					<span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memcg_stock_pcp</span> <span class="o">*</span><span class="n">stock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">CPU_ONLINE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">!=</span> <span class="n">CPU_DEAD</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">!=</span> <span class="n">CPU_DEAD_FROZEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>

	<span class="n">for_each_mem_cgroup</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span>
		<span class="n">mem_cgroup_drain_pcp_counter</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

	<span class="n">stock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">memcg_stock</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
	<span class="n">drain_stock</span><span class="p">(</span><span class="n">stock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* See __mem_cgroup_try_charge() for details */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CHARGE_OK</span><span class="p">,</span>		<span class="cm">/* success */</span>
	<span class="n">CHARGE_RETRY</span><span class="p">,</span>		<span class="cm">/* need to retry but retry is not bad */</span>
	<span class="n">CHARGE_NOMEM</span><span class="p">,</span>		<span class="cm">/* we can&#39;t do more. return -ENOMEM */</span>
	<span class="n">CHARGE_WOULDBLOCK</span><span class="p">,</span>	<span class="cm">/* GFP_WAIT wasn&#39;t set and no enough res. */</span>
	<span class="n">CHARGE_OOM_DIE</span><span class="p">,</span>		<span class="cm">/* the current is killed because of OOM */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_do_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">bool</span> <span class="n">oom_check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">csize</span> <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">mem_over_limit</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">res_counter</span> <span class="o">*</span><span class="n">fail_res</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">res_counter_charge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">csize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fail_res</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_swap_account</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">CHARGE_OK</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">res_counter_charge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">csize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fail_res</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">CHARGE_OK</span><span class="p">;</span>

		<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">csize</span><span class="p">);</span>
		<span class="n">mem_over_limit</span> <span class="o">=</span> <span class="n">mem_cgroup_from_res_counter</span><span class="p">(</span><span class="n">fail_res</span><span class="p">,</span> <span class="n">memsw</span><span class="p">);</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">MEM_CGROUP_RECLAIM_NOSWAP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">mem_over_limit</span> <span class="o">=</span> <span class="n">mem_cgroup_from_res_counter</span><span class="p">(</span><span class="n">fail_res</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * nr_pages can be either a huge page (HPAGE_PMD_NR), a batch</span>
<span class="cm">	 * of regular pages (CHARGE_BATCH), or a single regular page (1).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Never reclaim on behalf of optional batching, retry with a</span>
<span class="cm">	 * single page instead.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="n">CHARGE_BATCH</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CHARGE_RETRY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">CHARGE_WOULDBLOCK</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_reclaim</span><span class="p">(</span><span class="n">mem_over_limit</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_margin</span><span class="p">(</span><span class="n">mem_over_limit</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">nr_pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CHARGE_RETRY</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Even though the limit is exceeded at this point, reclaim</span>
<span class="cm">	 * may have been able to free some pages.  Retry the charge</span>
<span class="cm">	 * before killing the task.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Only for regular pages, though: huge pages are rather</span>
<span class="cm">	 * unlikely to succeed so close to the limit, and we fall back</span>
<span class="cm">	 * to regular pages anyway in case of failure.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CHARGE_RETRY</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At task move, charge accounts can be doubly counted. So, it&#39;s</span>
<span class="cm">	 * better to wait until the end of task_move if something is going on.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_wait_acct_move</span><span class="p">(</span><span class="n">mem_over_limit</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">CHARGE_RETRY</span><span class="p">;</span>

	<span class="cm">/* If we don&#39;t need to call oom-killer at el, return immediately */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oom_check</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">CHARGE_NOMEM</span><span class="p">;</span>
	<span class="cm">/* check OOM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_handle_oom</span><span class="p">(</span><span class="n">mem_over_limit</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">csize</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">CHARGE_OOM_DIE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">CHARGE_RETRY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __mem_cgroup_try_charge() does</span>
<span class="cm"> * 1. detect memcg to be charged against from passed *mm and *ptr,</span>
<span class="cm"> * 2. update res_counter</span>
<span class="cm"> * 3. call memory reclaim if necessary.</span>
<span class="cm"> *</span>
<span class="cm"> * In some special case, if the task is fatal, fatal_signal_pending() or</span>
<span class="cm"> * has TIF_MEMDIE, this function returns -EINTR while writing root_mem_cgroup</span>
<span class="cm"> * to *ptr. There are two reasons for this. 1: fatal threads should quit as soon</span>
<span class="cm"> * as possible without any hazards. 2: all pages should have a valid</span>
<span class="cm"> * pc-&gt;mem_cgroup. If mm is NULL and the caller doesn&#39;t pass a valid memcg</span>
<span class="cm"> * pointer, that is treated as a charge to root_mem_cgroup.</span>
<span class="cm"> *</span>
<span class="cm"> * So __mem_cgroup_try_charge() will return</span>
<span class="cm"> *  0       ...  on success, filling *ptr with a valid memcg pointer.</span>
<span class="cm"> *  -ENOMEM ...  charge failure because of resource limits.</span>
<span class="cm"> *  -EINTR  ...  if thread is fatal. *ptr is filled with root_mem_cgroup.</span>
<span class="cm"> *</span>
<span class="cm"> * Unlike the exported interface, an &quot;oom&quot; parameter is added. if oom==true,</span>
<span class="cm"> * the oom-killer can be invoked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__mem_cgroup_try_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				   <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">**</span><span class="n">ptr</span><span class="p">,</span>
				   <span class="n">bool</span> <span class="n">oom</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">batch</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">CHARGE_BATCH</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nr_oom_retries</span> <span class="o">=</span> <span class="n">MEM_CGROUP_RECLAIM_RETRIES</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unlike gloval-vm&#39;s OOM-kill, we&#39;re not in memory shortage</span>
<span class="cm">	 * in system level. So, allow to go ahead dying process in addition to</span>
<span class="cm">	 * MEMDIE process.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_MEMDIE</span><span class="p">)</span>
		     <span class="o">||</span> <span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">bypass</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We always charge the cgroup the mm_struct belongs to.</span>
<span class="cm">	 * The mm_struct&#39;s mem_cgroup changes on task migration if the</span>
<span class="cm">	 * thread group leader migrates. It&#39;s possible that mm is not</span>
<span class="cm">	 * set, if so charge the init_mm (happens for pagecache usage).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">ptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">root_mem_cgroup</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* css should be a valid one */</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">css_is_removed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">consume_stock</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="n">css_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Because we don&#39;t have task_lock(), &quot;p&quot; can exit.</span>
<span class="cm">		 * In that case, &quot;memcg&quot; can point to root or p can be NULL with</span>
<span class="cm">		 * race with swapoff. Then, we have small risk of mis-accouning.</span>
<span class="cm">		 * But such kind of mis-account by race always happens because</span>
<span class="cm">		 * we don&#39;t have cgroup_mutex(). It&#39;s overkill and we allo that</span>
<span class="cm">		 * small race, here.</span>
<span class="cm">		 * (*) swapoff at el will charge against mm-struct not against</span>
<span class="cm">		 * task-struct. So, mm-&gt;owner can be NULL.</span>
<span class="cm">		 */</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">)</span>
			<span class="n">memcg</span> <span class="o">=</span> <span class="n">root_mem_cgroup</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">consume_stock</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * It seems dagerous to access memcg without css_get().</span>
<span class="cm">			 * But considering how consume_stok works, it&#39;s not</span>
<span class="cm">			 * necessary. If consume_stock success, some charges</span>
<span class="cm">			 * from this memcg are cached on this cpu. So, we</span>
<span class="cm">			 * don&#39;t need to call css_get()/css_tryget() before</span>
<span class="cm">			 * calling consume_stock().</span>
<span class="cm">			 */</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* after here, we may be blocked. we need to get refcnt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">css_tryget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">oom_check</span><span class="p">;</span>

		<span class="cm">/* If killed, bypass charge */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bypass</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">oom_check</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oom</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nr_oom_retries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">oom_check</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">nr_oom_retries</span> <span class="o">=</span> <span class="n">MEM_CGROUP_RECLAIM_RETRIES</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_do_charge</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">oom_check</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CHARGE_OK</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CHARGE_RETRY</span>: <span class="cm">/* not in OOM situation but retry */</span>
			<span class="n">batch</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
			<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
			<span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CHARGE_WOULDBLOCK</span>: <span class="cm">/* !__GFP_WAIT */</span>
			<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CHARGE_NOMEM</span>: <span class="cm">/* OOM routine works */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oom</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* If oom, we never return -ENOMEM */</span>
			<span class="n">nr_oom_retries</span><span class="o">--</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CHARGE_OOM_DIE</span>: <span class="cm">/* Killed by OOM Killer */</span>
			<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bypass</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">CHARGE_OK</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">batch</span> <span class="o">&gt;</span> <span class="n">nr_pages</span><span class="p">)</span>
		<span class="n">refill_stock</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">batch</span> <span class="o">-</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
<span class="nl">done:</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">nomem:</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="nl">bypass:</span>
	<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">root_mem_cgroup</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Somemtimes we have to undo a charge we got by try_charge().</span>
<span class="cm"> * This function is for that and do uncharge, put css&#39;s refcnt.</span>
<span class="cm"> * gotten by try_charge().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mem_cgroup_cancel_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span><span class="p">)</span>
			<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Cancel chrages in this cgroup....doesn&#39;t propagate to parent cgroup.</span>
<span class="cm"> * This is useful when moving usage to parent cgroup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mem_cgroup_cancel_local_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">nr_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">res_counter_uncharge_until</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span><span class="p">)</span>
		<span class="n">res_counter_uncharge_until</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span>
						<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A helper function to get mem_cgroup from ID. must be called under</span>
<span class="cm"> * rcu_read_lock(). The caller must check css_is_removed() or some if</span>
<span class="cm"> * it&#39;s concern. (dropping refcnt from swap can be called against removed</span>
<span class="cm"> * memcg.)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="nf">mem_cgroup_lookup</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>

	<span class="cm">/* ID 0 is unused ID */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">id</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">css</span> <span class="o">=</span> <span class="n">css_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_cgroup_subsys</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">css</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">css</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span><span class="p">,</span> <span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="nf">try_get_mem_cgroup_from_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">swp_entry_t</span> <span class="n">ent</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">lock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">css_tryget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">))</span>
			<span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ent</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">id</span> <span class="o">=</span> <span class="n">lookup_swap_cgroup_id</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_lookup</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">css_tryget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">))</span>
			<span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">unlock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">memcg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mem_cgroup_commit_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span>
				       <span class="k">enum</span> <span class="n">charge_type</span> <span class="n">ctype</span><span class="p">,</span>
				       <span class="n">bool</span> <span class="n">lrucare</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">uninitialized_var</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">was_on_lru</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">anon</span><span class="p">;</span>

	<span class="n">lock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">unlock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
		<span class="n">__mem_cgroup_cancel_charge</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t need page_cgroup_lock about tail pages, becase they are not</span>
<span class="cm">	 * accessed by any other context at this point.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * In some cases, SwapCache and FUSE(splice_buf-&gt;radixtree), the page</span>
<span class="cm">	 * may already be on some other mem_cgroup&#39;s LRU.  Take care of it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lrucare</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">zone</span> <span class="o">=</span> <span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lruvec</span> <span class="o">=</span> <span class="n">mem_cgroup_zone_lruvec</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">);</span>
			<span class="n">ClearPageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">del_page_from_lru_list</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="n">page_lru</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">was_on_lru</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We access a page_cgroup asynchronously without lock_page_cgroup().</span>
<span class="cm">	 * Especially when a page_cgroup is taken from a page, pc-&gt;mem_cgroup</span>
<span class="cm">	 * is accessed after testing USED bit. To make pc-&gt;mem_cgroup visible</span>
<span class="cm">	 * before USED bit, we need memory barrier here.</span>
<span class="cm">	 * See mem_cgroup_add_lru_list(), etc.</span>
<span class="cm"> 	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">SetPageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lrucare</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">was_on_lru</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lruvec</span> <span class="o">=</span> <span class="n">mem_cgroup_zone_lruvec</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">);</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">SetPageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">add_page_to_lru_list</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="n">page_lru</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ctype</span> <span class="o">==</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_MAPPED</span><span class="p">)</span>
		<span class="n">anon</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">anon</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">mem_cgroup_charge_statistics</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">anon</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="n">unlock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * &quot;charge_statistics&quot; updated event counter. Then, check it.</span>
<span class="cm">	 * Insert ancestor (and ancestor&#39;s ancestors), to softlimit RB-tree.</span>
<span class="cm">	 * if they exceeds softlimit.</span>
<span class="cm">	 */</span>
	<span class="n">memcg_check_events</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>

<span class="cp">#define PCGF_NOCOPY_AT_SPLIT (1 &lt;&lt; PCG_LOCK | 1 &lt;&lt; PCG_MIGRATION)</span>
<span class="cm">/*</span>
<span class="cm"> * Because tail pages are not marked as &quot;used&quot;, set it. We&#39;re under</span>
<span class="cm"> * zone-&gt;lru_lock, &#39;splitting on pmd&#39; and compound_lock.</span>
<span class="cm"> * charge/uncharge will be never happen and move_account() is done under</span>
<span class="cm"> * compound_lock(), so we don&#39;t have to take care of races.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mem_cgroup_split_huge_fixup</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">head_pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HPAGE_PMD_NR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pc</span> <span class="o">=</span> <span class="n">head_pc</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span> <span class="o">=</span> <span class="n">head_pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">;</span>
		<span class="n">smp_wmb</span><span class="p">();</span><span class="cm">/* see __commit_charge() */</span>
		<span class="n">pc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">head_pc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PCGF_NOCOPY_AT_SPLIT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_TRANSPARENT_HUGEPAGE */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * mem_cgroup_move_account - move account of the page</span>
<span class="cm"> * @page: the page</span>
<span class="cm"> * @nr_pages: number of regular pages (&gt;1 for huge pages)</span>
<span class="cm"> * @pc:	page_cgroup of the page.</span>
<span class="cm"> * @from: mem_cgroup which the page is moved from.</span>
<span class="cm"> * @to:	mem_cgroup which the page is moved to. @from != @to.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must confirm following.</span>
<span class="cm"> * - page is not on LRU (isolate_page() is useful.)</span>
<span class="cm"> * - compound_lock is held when nr_pages &gt; 1</span>
<span class="cm"> *</span>
<span class="cm"> * This function doesn&#39;t do &quot;charge&quot; to new cgroup and doesn&#39;t do &quot;uncharge&quot;</span>
<span class="cm"> * from old cgroup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_move_account</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">anon</span> <span class="o">=</span> <span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">from</span> <span class="o">==</span> <span class="n">to</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * The page is isolated from LRU. So, collapse function</span>
<span class="cm">	 * will not handle this page. But page splitting can happen.</span>
<span class="cm">	 * Do this check under compound_page_lock(). The caller should</span>
<span class="cm">	 * hold it.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">lock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span> <span class="o">||</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span> <span class="o">!=</span> <span class="n">from</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">move_lock_mem_cgroup</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anon</span> <span class="o">&amp;&amp;</span> <span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Update mapped_file data for mem_cgroup */</span>
		<span class="n">preempt_disable</span><span class="p">();</span>
		<span class="n">__this_cpu_dec</span><span class="p">(</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">MEM_CGROUP_STAT_FILE_MAPPED</span><span class="p">]);</span>
		<span class="n">__this_cpu_inc</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">stat</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">[</span><span class="n">MEM_CGROUP_STAT_FILE_MAPPED</span><span class="p">]);</span>
		<span class="n">preempt_enable</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">mem_cgroup_charge_statistics</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">anon</span><span class="p">,</span> <span class="o">-</span><span class="n">nr_pages</span><span class="p">);</span>

	<span class="cm">/* caller should have done css_get */</span>
	<span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
	<span class="n">mem_cgroup_charge_statistics</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">anon</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We charges against &quot;to&quot; which may not have any tasks. Then, &quot;to&quot;</span>
<span class="cm">	 * can be under rmdir(). But in current implementation, caller of</span>
<span class="cm">	 * this function is just force_empty() and move charge, so it&#39;s</span>
<span class="cm">	 * guaranteed that &quot;to&quot; is never removed. So, we don&#39;t check rmdir</span>
<span class="cm">	 * status here.</span>
<span class="cm">	 */</span>
	<span class="n">move_unlock_mem_cgroup</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">unlock:</span>
	<span class="n">unlock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * check events</span>
<span class="cm">	 */</span>
	<span class="n">memcg_check_events</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">memcg_check_events</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * move charges to its parent.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_move_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">child</span><span class="p">,</span>
				  <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Is ROOT ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_page_unless_zero</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isolate_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">put</span><span class="p">;</span>

	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">hpage_nr_pages</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">parent_mem_cgroup</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If no parent, move charges to root cgroup.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">root_mem_cgroup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">compound_lock_irqsave</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_move_account</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span>
				<span class="n">pc</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">__mem_cgroup_cancel_local_charge</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">compound_unlock_irqrestore</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">putback_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">put:</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Charge the memory controller for page usage.</span>
<span class="cm"> * Return</span>
<span class="cm"> * 0 if the charge was successful</span>
<span class="cm"> * &lt; 0 if the cgroup is over its limit</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_charge_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="k">enum</span> <span class="n">charge_type</span> <span class="n">ctype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">oom</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nr_pages</span> <span class="o">&lt;&lt;=</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * Never OOM-kill a process for a huge page.  The</span>
<span class="cm">		 * fault handler will fall back to regular pages.</span>
<span class="cm">		 */</span>
		<span class="n">oom</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__mem_cgroup_try_charge</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="p">,</span> <span class="n">oom</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">__mem_cgroup_commit_charge</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mem_cgroup_newpage_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mem_cgroup_charge_common</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span>
					<span class="n">MEM_CGROUP_CHARGE_TYPE_MAPPED</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">__mem_cgroup_commit_charge_swapin</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">charge_type</span> <span class="n">ctype</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">mem_cgroup_cache_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">charge_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_CACHE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_is_file_cache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_SHMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_charge_common</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span> <span class="cm">/* page is swapcache/shmem */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_try_charge_swapin</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">__mem_cgroup_commit_charge_swapin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * While swap-in, try_charge -&gt; commit or cancel, the page is locked.</span>
<span class="cm"> * And when try_charge() successfully returns, one refcnt to memcg without</span>
<span class="cm"> * struct page_cgroup is acquired. This refcnt will be consumed by</span>
<span class="cm"> * &quot;commit()&quot; or removed by &quot;cancel()&quot;</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mem_cgroup_try_charge_swapin</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				 <span class="n">gfp_t</span> <span class="n">mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">**</span><span class="n">memcgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="o">*</span><span class="n">memcgp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_swap_account</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">charge_cur_mm</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * A racing thread&#39;s fault, or swapoff, may have already updated</span>
<span class="cm">	 * the pte, and even removed page from swap cache: in those cases</span>
<span class="cm">	 * do_swap_page()&#39;s pte_same() test will fail; but there&#39;s also a</span>
<span class="cm">	 * KSM case which does need to charge the page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">charge_cur_mm</span><span class="p">;</span>
	<span class="n">memcg</span> <span class="o">=</span> <span class="n">try_get_mem_cgroup_from_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">charge_cur_mm</span><span class="p">;</span>
	<span class="o">*</span><span class="n">memcgp</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__mem_cgroup_try_charge</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memcgp</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">charge_cur_mm:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">))</span>
		<span class="n">mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__mem_cgroup_try_charge</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memcgp</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__mem_cgroup_commit_charge_swapin</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
					<span class="k">enum</span> <span class="n">charge_type</span> <span class="n">ctype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cgroup_exclude_rmdir</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>

	<span class="n">__mem_cgroup_commit_charge</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now swap is on-memory. This means this page may be</span>
<span class="cm">	 * counted both as mem and swap....double count.</span>
<span class="cm">	 * Fix it by uncharging from memsw. Basically, this SwapCache is stable</span>
<span class="cm">	 * under lock_page(). But in do_swap_page()::memory.c, reuse_swap_page()</span>
<span class="cm">	 * may call delete_from_swap_cache() before reach here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span> <span class="o">&amp;&amp;</span> <span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">swp_entry_t</span> <span class="n">ent</span> <span class="o">=</span> <span class="p">{.</span><span class="n">val</span> <span class="o">=</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">)};</span>
		<span class="n">mem_cgroup_uncharge_swap</span><span class="p">(</span><span class="n">ent</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * At swapin, we may charge account against cgroup which has no tasks.</span>
<span class="cm">	 * So, rmdir()-&gt;pre_destroy() can be called while we do this charge.</span>
<span class="cm">	 * In that case, we need to call pre_destroy() again. check it here.</span>
<span class="cm">	 */</span>
	<span class="n">cgroup_release_and_wakeup_rmdir</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mem_cgroup_commit_charge_swapin</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__mem_cgroup_commit_charge_swapin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span>
					  <span class="n">MEM_CGROUP_CHARGE_TYPE_MAPPED</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mem_cgroup_cancel_charge_swapin</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">__mem_cgroup_cancel_charge</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_do_uncharge</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">enum</span> <span class="n">charge_type</span> <span class="n">ctype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memcg_batch_info</span> <span class="o">*</span><span class="n">batch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">uncharge_memsw</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* If swapout, usage of swap doesn&#39;t decrease */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_swap_account</span> <span class="o">||</span> <span class="n">ctype</span> <span class="o">==</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_SWAPOUT</span><span class="p">)</span>
		<span class="n">uncharge_memsw</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">batch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">memcg_batch</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * In usual, we do css_get() when we remember memcg pointer.</span>
<span class="cm">	 * But in this case, we keep res-&gt;usage until end of a series of</span>
<span class="cm">	 * uncharges. Then, it&#39;s ok to ignore memcg&#39;s refcnt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">)</span>
		<span class="n">batch</span><span class="o">-&gt;</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * do_batch &gt; 0 when unmapping pages or inode invalidate/truncate.</span>
<span class="cm">	 * In those cases, all pages freed continuously can be expected to be in</span>
<span class="cm">	 * the same cgroup and we have chance to coalesce uncharges.</span>
<span class="cm">	 * But we do uncharge one by one if this is killed by OOM(TIF_MEMDIE)</span>
<span class="cm">	 * because we want to do uncharge as soon as possible.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">do_batch</span> <span class="o">||</span> <span class="n">test_thread_flag</span><span class="p">(</span><span class="n">TIF_MEMDIE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">direct_uncharge</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">direct_uncharge</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In typical case, batch-&gt;memcg == mem. This means we can</span>
<span class="cm">	 * merge a series of uncharges to an uncharge of res_counter.</span>
<span class="cm">	 * If not, we uncharge res_counter ony by one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">memcg</span> <span class="o">!=</span> <span class="n">memcg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">direct_uncharge</span><span class="p">;</span>
	<span class="cm">/* remember freed charge and uncharge it later */</span>
	<span class="n">batch</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uncharge_memsw</span><span class="p">)</span>
		<span class="n">batch</span><span class="o">-&gt;</span><span class="n">memsw_nr_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">direct_uncharge:</span>
	<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">nr_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uncharge_memsw</span><span class="p">)</span>
		<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">nr_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">memcg</span> <span class="o">!=</span> <span class="n">memcg</span><span class="p">))</span>
		<span class="n">memcg_oom_recover</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * uncharge if !page_mapped(page)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span>
<span class="nf">__mem_cgroup_uncharge_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">enum</span> <span class="n">charge_type</span> <span class="n">ctype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">anon</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nr_pages</span> <span class="o">&lt;&lt;=</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check if our page_cgroup is valid</span>
<span class="cm">	 */</span>
	<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">lock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>

	<span class="n">memcg</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock_out</span><span class="p">;</span>

	<span class="n">anon</span> <span class="o">=</span> <span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ctype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_MAPPED</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Generally PageAnon tells if it&#39;s the anon statistics to be</span>
<span class="cm">		 * updated; but sometimes e.g. mem_cgroup_uncharge_page() is</span>
<span class="cm">		 * used before page reached the stage of being marked PageAnon.</span>
<span class="cm">		 */</span>
		<span class="n">anon</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="cm">/* fallthrough */</span>
	<span class="k">case</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_DROP</span>:
		<span class="cm">/* See mem_cgroup_prepare_migration() */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageCgroupMigration</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unlock_out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_SWAPOUT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* Shared memory */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">page_is_file_cache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">unlock_out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="cm">/* Anon */</span>
				<span class="k">goto</span> <span class="n">unlock_out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mem_cgroup_charge_statistics</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">anon</span><span class="p">,</span> <span class="o">-</span><span class="n">nr_pages</span><span class="p">);</span>

	<span class="n">ClearPageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * pc-&gt;mem_cgroup is not cleared here. It will be accessed when it&#39;s</span>
<span class="cm">	 * freed from LRU. This is safe because uncharged page is expected not</span>
<span class="cm">	 * to be reused (freed soon). Exception is SwapCache, it&#39;s handled by</span>
<span class="cm">	 * special functions.</span>
<span class="cm">	 */</span>

	<span class="n">unlock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * even after unlock, we have memcg-&gt;res.usage here and this memcg</span>
<span class="cm">	 * will never be freed.</span>
<span class="cm">	 */</span>
	<span class="n">memcg_check_events</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span> <span class="o">&amp;&amp;</span> <span class="n">ctype</span> <span class="o">==</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_SWAPOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mem_cgroup_swap_statistics</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">mem_cgroup_get</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span>
		<span class="n">mem_cgroup_do_uncharge</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">ctype</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">memcg</span><span class="p">;</span>

<span class="nl">unlock_out:</span>
	<span class="n">unlock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* early check. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">__mem_cgroup_uncharge_common</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_MAPPED</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mem_cgroup_uncharge_cache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">);</span>
	<span class="n">__mem_cgroup_uncharge_common</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_CACHE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Batch_start/batch_end is called in unmap_page_range/invlidate/trucate.</span>
<span class="cm"> * In that cases, pages are freed continuously and we can expect pages</span>
<span class="cm"> * are in the same memcg. All these calls itself limits the number of</span>
<span class="cm"> * pages freed at once, then uncharge_start/end() is called properly.</span>
<span class="cm"> * This may be called prural(2) times in a context,</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">mem_cgroup_uncharge_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">memcg_batch</span><span class="p">.</span><span class="n">do_batch</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* We can do nest. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">memcg_batch</span><span class="p">.</span><span class="n">do_batch</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">memcg_batch</span><span class="p">.</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">memcg_batch</span><span class="p">.</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">memcg_batch</span><span class="p">.</span><span class="n">memsw_nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mem_cgroup_uncharge_end</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">memcg_batch_info</span> <span class="o">*</span><span class="n">batch</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">memcg_batch</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">do_batch</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">batch</span><span class="o">-&gt;</span><span class="n">do_batch</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">do_batch</span><span class="p">)</span> <span class="cm">/* If stacked, do nothing. */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This &quot;batch-&gt;memcg&quot; is valid without any css_get/put etc...</span>
<span class="cm">	 * bacause we hide charges behind us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">)</span>
		<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span>
				     <span class="n">batch</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">memsw_nr_pages</span><span class="p">)</span>
		<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span>
				     <span class="n">batch</span><span class="o">-&gt;</span><span class="n">memsw_nr_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">memcg_oom_recover</span><span class="p">(</span><span class="n">batch</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">);</span>
	<span class="cm">/* forget this pointer (for sanity check) */</span>
	<span class="n">batch</span><span class="o">-&gt;</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SWAP</span>
<span class="cm">/*</span>
<span class="cm"> * called after __delete_from_swap_cache() and drop &quot;page&quot; account.</span>
<span class="cm"> * memcg information is recorded to swap_cgroup of &quot;ent&quot;</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">mem_cgroup_uncharge_swapcache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">swp_entry_t</span> <span class="n">ent</span><span class="p">,</span> <span class="n">bool</span> <span class="n">swapout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ctype</span> <span class="o">=</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_SWAPOUT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swapout</span><span class="p">)</span> <span class="cm">/* this was a swap cache but the swap is unused ! */</span>
		<span class="n">ctype</span> <span class="o">=</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_DROP</span><span class="p">;</span>

	<span class="n">memcg</span> <span class="o">=</span> <span class="n">__mem_cgroup_uncharge_common</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">ctype</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * record memcg information,  if swapout &amp;&amp; memcg != NULL,</span>
<span class="cm">	 * mem_cgroup_get() was called in uncharge().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span> <span class="o">&amp;&amp;</span> <span class="n">swapout</span> <span class="o">&amp;&amp;</span> <span class="n">memcg</span><span class="p">)</span>
		<span class="n">swap_cgroup_record</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">css_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP</span>
<span class="cm">/*</span>
<span class="cm"> * called from swap_entry_free(). remove record in swap_cgroup and</span>
<span class="cm"> * uncharge &quot;memsw&quot; account.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mem_cgroup_uncharge_swap</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_swap_account</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">swap_cgroup_record</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_lookup</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We uncharge this because swap is freed.</span>
<span class="cm">		 * This memcg can be obsolete one. We avoid calling css_tryget</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span>
			<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">mem_cgroup_swap_statistics</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">mem_cgroup_put</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mem_cgroup_move_swap_account - move swap charge and swap_cgroup&#39;s record.</span>
<span class="cm"> * @entry: swap entry to be moved</span>
<span class="cm"> * @from:  mem_cgroup which the entry is moved from</span>
<span class="cm"> * @to:  mem_cgroup which the entry is moved to</span>
<span class="cm"> *</span>
<span class="cm"> * It succeeds only when the swap_cgroup&#39;s record for this entry is the same</span>
<span class="cm"> * as the mem_cgroup&#39;s id of @from.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, -EINVAL on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have charged to @to, IOW, called res_counter_charge() about</span>
<span class="cm"> * both res and memsw, and called css_get().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_move_swap_account</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">old_id</span><span class="p">,</span> <span class="n">new_id</span><span class="p">;</span>

	<span class="n">old_id</span> <span class="o">=</span> <span class="n">css_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
	<span class="n">new_id</span> <span class="o">=</span> <span class="n">css_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">swap_cgroup_cmpxchg</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">old_id</span><span class="p">,</span> <span class="n">new_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">old_id</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mem_cgroup_swap_statistics</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">mem_cgroup_swap_statistics</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * This function is only called from task migration context now.</span>
<span class="cm">		 * It postpones res_counter and refcount handling till the end</span>
<span class="cm">		 * of task migration(mem_cgroup_clear_mc()) for performance</span>
<span class="cm">		 * improvement. But we cannot postpone mem_cgroup_get(to)</span>
<span class="cm">		 * because if the process that has been moved to @to does</span>
<span class="cm">		 * swap-in, the refcount of @to might be decreased to 0.</span>
<span class="cm">		 */</span>
		<span class="n">mem_cgroup_get</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mem_cgroup_move_swap_account</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Before starting migration, account PAGE_SIZE to mem_cgroup that the old</span>
<span class="cm"> * page belongs to.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mem_cgroup_prepare_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">newpage</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">**</span><span class="n">memcgp</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">charge_type</span> <span class="n">ctype</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">memcgp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">lock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">;</span>
		<span class="n">css_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * At migrating an anonymous page, its mapcount goes down</span>
<span class="cm">		 * to 0 and uncharge() will be called. But, even if it&#39;s fully</span>
<span class="cm">		 * unmapped, migration may fail and this page has to be</span>
<span class="cm">		 * charged again. We set MIGRATION flag here and delay uncharge</span>
<span class="cm">		 * until end_migration() is called</span>
<span class="cm">		 *</span>
<span class="cm">		 * Corner Case Thinking</span>
<span class="cm">		 * A)</span>
<span class="cm">		 * When the old page was mapped as Anon and it&#39;s unmap-and-freed</span>
<span class="cm">		 * while migration was ongoing.</span>
<span class="cm">		 * If unmap finds the old page, uncharge() of it will be delayed</span>
<span class="cm">		 * until end_migration(). If unmap finds a new page, it&#39;s</span>
<span class="cm">		 * uncharged when it make mapcount to be 1-&gt;0. If unmap code</span>
<span class="cm">		 * finds swap_migration_entry, the new page will not be mapped</span>
<span class="cm">		 * and end_migration() will find it(mapcount==0).</span>
<span class="cm">		 *</span>
<span class="cm">		 * B)</span>
<span class="cm">		 * When the old page was mapped but migraion fails, the kernel</span>
<span class="cm">		 * remaps it. A charge for it is kept by MIGRATION flag even</span>
<span class="cm">		 * if mapcount goes down to 0. We can do remap successfully</span>
<span class="cm">		 * without charging it again.</span>
<span class="cm">		 *</span>
<span class="cm">		 * C)</span>
<span class="cm">		 * The &quot;old&quot; page is under lock_page() until the end of</span>
<span class="cm">		 * migration, so, the old page itself will not be swapped-out.</span>
<span class="cm">		 * If the new page is swapped out before end_migraton, our</span>
<span class="cm">		 * hook to usual swap-out path will catch the event.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">SetPageCgroupMigration</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the page is not charged at this point,</span>
<span class="cm">	 * we return here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">memcgp</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__mem_cgroup_try_charge</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memcgp</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span><span class="cm">/* drop extra refcnt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
			<span class="n">ClearPageCgroupMigration</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
			<span class="n">unlock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * The old page may be fully unmapped while we kept it.</span>
<span class="cm">			 */</span>
			<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* we&#39;ll need to revisit this error code (we have -EINTR) */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We charge new page before it&#39;s used/mapped. So, even if unlock_page()</span>
<span class="cm">	 * is called before end_migration, we can catch all events on this new</span>
<span class="cm">	 * page. In the case new page is migrated but not remapped, new page&#39;s</span>
<span class="cm">	 * mapcount will be finally 0 and we call uncharge in end_migration().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">ctype</span> <span class="o">=</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_MAPPED</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page_is_file_cache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">ctype</span> <span class="o">=</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_CACHE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ctype</span> <span class="o">=</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_SHMEM</span><span class="p">;</span>
	<span class="n">__mem_cgroup_commit_charge</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">newpage</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ctype</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* remove redundant charge if migration failed*/</span>
<span class="kt">void</span> <span class="nf">mem_cgroup_end_migration</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">oldpage</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">newpage</span><span class="p">,</span> <span class="n">bool</span> <span class="n">migration_ok</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">used</span><span class="p">,</span> <span class="o">*</span><span class="n">unused</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">anon</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* blocks rmdir() */</span>
	<span class="n">cgroup_exclude_rmdir</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">migration_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">used</span> <span class="o">=</span> <span class="n">oldpage</span><span class="p">;</span>
		<span class="n">unused</span> <span class="o">=</span> <span class="n">newpage</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">used</span> <span class="o">=</span> <span class="n">newpage</span><span class="p">;</span>
		<span class="n">unused</span> <span class="o">=</span> <span class="n">oldpage</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We disallowed uncharge of pages under migration because mapcount</span>
<span class="cm">	 * of the page goes down to zero, temporarly.</span>
<span class="cm">	 * Clear the flag and check the page should be charged.</span>
<span class="cm">	 */</span>
	<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">oldpage</span><span class="p">);</span>
	<span class="n">lock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="n">ClearPageCgroupMigration</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="n">unlock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="n">anon</span> <span class="o">=</span> <span class="n">PageAnon</span><span class="p">(</span><span class="n">used</span><span class="p">);</span>
	<span class="n">__mem_cgroup_uncharge_common</span><span class="p">(</span><span class="n">unused</span><span class="p">,</span>
		<span class="n">anon</span> <span class="o">?</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_MAPPED</span>
		     <span class="o">:</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_CACHE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a page is a file cache, radix-tree replacement is very atomic</span>
<span class="cm">	 * and we can skip this check. When it was an Anon page, its mapcount</span>
<span class="cm">	 * goes down to 0. But because we added MIGRATION flage, it&#39;s not</span>
<span class="cm">	 * uncharged yet. There are several case but page-&gt;mapcount check</span>
<span class="cm">	 * and USED bit check in mem_cgroup_uncharge_page() will do enough</span>
<span class="cm">	 * check. (see prepare_charge() also)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">anon</span><span class="p">)</span>
		<span class="n">mem_cgroup_uncharge_page</span><span class="p">(</span><span class="n">used</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * At migration, we may charge account against cgroup which has no</span>
<span class="cm">	 * tasks.</span>
<span class="cm">	 * So, rmdir()-&gt;pre_destroy() can be called while we do this charge.</span>
<span class="cm">	 * In that case, we need to call pre_destroy() again. check it here.</span>
<span class="cm">	 */</span>
	<span class="n">cgroup_release_and_wakeup_rmdir</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * At replace page cache, newpage is not under any memcg but it&#39;s on</span>
<span class="cm"> * LRU. So, this function doesn&#39;t touch res_counter but handles LRU</span>
<span class="cm"> * in correct way. Both pages are locked so we cannot race with uncharge.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">mem_cgroup_replace_page_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">oldpage</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">newpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">charge_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_CACHE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">oldpage</span><span class="p">);</span>
	<span class="cm">/* fix accounting on old pages */</span>
	<span class="n">lock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">;</span>
		<span class="n">mem_cgroup_charge_statistics</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">ClearPageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlock_page_cgroup</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * When called from shmem_replace_page(), in some cases the</span>
<span class="cm">	 * oldpage has already been charged, and in some cases not.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageSwapBacked</span><span class="p">(</span><span class="n">oldpage</span><span class="p">))</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">MEM_CGROUP_CHARGE_TYPE_SHMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Even if newpage-&gt;mapping was NULL before starting replacement,</span>
<span class="cm">	 * the newpage may be on LRU(or pagevec for LRU) already. We lock</span>
<span class="cm">	 * LRU while we overwrite pc-&gt;mem_cgroup.</span>
<span class="cm">	 */</span>
	<span class="n">__mem_cgroup_commit_charge</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">newpage</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_VM</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="nf">lookup_page_cgroup_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Can be NULL while feeding pages into the page allocator for</span>
<span class="cm">	 * the first time, i.e. during boot or memory hotplug;</span>
<span class="cm">	 * or when mem_cgroup_disabled().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pc</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">mem_cgroup_bad_page_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_disabled</span><span class="p">())</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">lookup_page_cgroup_used</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mem_cgroup_print_bad_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup_used</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;pc:%p pc-&gt;flags:%lx pc-&gt;mem_cgroup:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">pc</span><span class="p">,</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">set_limit_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_resize_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retry_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">memswlimit</span><span class="p">,</span> <span class="n">memlimit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">children</span> <span class="o">=</span> <span class="n">mem_cgroup_count_children</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">curusage</span><span class="p">,</span> <span class="n">oldusage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enlarge</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For keeping hierarchical_reclaim simple, how long we should retry</span>
<span class="cm">	 * is depends on callers. We set our retry-count to be function</span>
<span class="cm">	 * of # of children which we should visit in this loop.</span>
<span class="cm">	 */</span>
	<span class="n">retry_count</span> <span class="o">=</span> <span class="n">MEM_CGROUP_RECLAIM_RETRIES</span> <span class="o">*</span> <span class="n">children</span><span class="p">;</span>

	<span class="n">oldusage</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">);</span>

	<span class="n">enlarge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">retry_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Rather than hide all in some function, I do this in</span>
<span class="cm">		 * open coded manner. You see what this really does.</span>
<span class="cm">		 * We have to guarantee memcg-&gt;res.limit &lt; memcg-&gt;memsw.limit.</span>
<span class="cm">		 */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_limit_mutex</span><span class="p">);</span>
		<span class="n">memswlimit</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memswlimit</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_limit_mutex</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memlimit</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memlimit</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span>
			<span class="n">enlarge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">res_counter_set_limit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memswlimit</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span>
				<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw_is_minimum</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw_is_minimum</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_limit_mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">mem_cgroup_reclaim</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
				   <span class="n">MEM_CGROUP_RECLAIM_SHRINK</span><span class="p">);</span>
		<span class="n">curusage</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">);</span>
		<span class="cm">/* Usage is reduced ? */</span>
  		<span class="k">if</span> <span class="p">(</span><span class="n">curusage</span> <span class="o">&gt;=</span> <span class="n">oldusage</span><span class="p">)</span>
			<span class="n">retry_count</span><span class="o">--</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">oldusage</span> <span class="o">=</span> <span class="n">curusage</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">enlarge</span><span class="p">)</span>
		<span class="n">memcg_oom_recover</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_resize_memsw_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retry_count</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">memlimit</span><span class="p">,</span> <span class="n">memswlimit</span><span class="p">,</span> <span class="n">oldusage</span><span class="p">,</span> <span class="n">curusage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">children</span> <span class="o">=</span> <span class="n">mem_cgroup_count_children</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">enlarge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* see mem_cgroup_resize_res_limit */</span>
 	<span class="n">retry_count</span> <span class="o">=</span> <span class="n">children</span> <span class="o">*</span> <span class="n">MEM_CGROUP_RECLAIM_RETRIES</span><span class="p">;</span>
	<span class="n">oldusage</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">retry_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Rather than hide all in some function, I do this in</span>
<span class="cm">		 * open coded manner. You see what this really does.</span>
<span class="cm">		 * We have to guarantee memcg-&gt;res.limit &lt; memcg-&gt;memsw.limit.</span>
<span class="cm">		 */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_limit_mutex</span><span class="p">);</span>
		<span class="n">memlimit</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memlimit</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_limit_mutex</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memswlimit</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memswlimit</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">)</span>
			<span class="n">enlarge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">res_counter_set_limit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memlimit</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span>
				<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw_is_minimum</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw_is_minimum</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">set_limit_mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">mem_cgroup_reclaim</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
				   <span class="n">MEM_CGROUP_RECLAIM_NOSWAP</span> <span class="o">|</span>
				   <span class="n">MEM_CGROUP_RECLAIM_SHRINK</span><span class="p">);</span>
		<span class="n">curusage</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">);</span>
		<span class="cm">/* Usage is reduced ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curusage</span> <span class="o">&gt;=</span> <span class="n">oldusage</span><span class="p">)</span>
			<span class="n">retry_count</span><span class="o">--</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">oldusage</span> <span class="o">=</span> <span class="n">curusage</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">enlarge</span><span class="p">)</span>
		<span class="n">memcg_oom_recover</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mem_cgroup_soft_limit_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span>
					    <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">total_scanned</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_reclaimed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">,</span> <span class="o">*</span><span class="n">next_mz</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reclaimed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="o">*</span><span class="n">mctz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">excess</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scanned</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mctz</span> <span class="o">=</span> <span class="n">soft_limit_tree_node_zone</span><span class="p">(</span><span class="n">zone_to_nid</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="n">zone_idx</span><span class="p">(</span><span class="n">zone</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * This loop can run a while, specially if mem_cgroup&#39;s continuously</span>
<span class="cm">	 * keep exceeding their soft limit and putting the system under</span>
<span class="cm">	 * pressure</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_mz</span><span class="p">)</span>
			<span class="n">mz</span> <span class="o">=</span> <span class="n">next_mz</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mz</span> <span class="o">=</span> <span class="n">mem_cgroup_largest_soft_limit_node</span><span class="p">(</span><span class="n">mctz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mz</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">nr_scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">reclaimed</span> <span class="o">=</span> <span class="n">mem_cgroup_soft_reclaim</span><span class="p">(</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span>
						    <span class="n">gfp_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_scanned</span><span class="p">);</span>
		<span class="n">nr_reclaimed</span> <span class="o">+=</span> <span class="n">reclaimed</span><span class="p">;</span>
		<span class="o">*</span><span class="n">total_scanned</span> <span class="o">+=</span> <span class="n">nr_scanned</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we failed to reclaim anything from this memory cgroup</span>
<span class="cm">		 * it is time to move on to the next cgroup</span>
<span class="cm">		 */</span>
		<span class="n">next_mz</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reclaimed</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Loop until we find yet another one.</span>
<span class="cm">				 *</span>
<span class="cm">				 * By the time we get the soft_limit lock</span>
<span class="cm">				 * again, someone might have aded the</span>
<span class="cm">				 * group back on the RB tree. Iterate to</span>
<span class="cm">				 * make sure we get a different mem.</span>
<span class="cm">				 * mem_cgroup_largest_soft_limit_node returns</span>
<span class="cm">				 * NULL if no other cgroup is present on</span>
<span class="cm">				 * the tree</span>
<span class="cm">				 */</span>
				<span class="n">next_mz</span> <span class="o">=</span>
				<span class="n">__mem_cgroup_largest_soft_limit_node</span><span class="p">(</span><span class="n">mctz</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">next_mz</span> <span class="o">==</span> <span class="n">mz</span><span class="p">)</span>
					<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_mz</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
				<span class="k">else</span> <span class="cm">/* next_mz == NULL or other memcg */</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">__mem_cgroup_remove_exceeded</span><span class="p">(</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">mctz</span><span class="p">);</span>
		<span class="n">excess</span> <span class="o">=</span> <span class="n">res_counter_soft_limit_excess</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * One school of thought says that we should not add</span>
<span class="cm">		 * back the node to the tree if reclaim returns 0.</span>
<span class="cm">		 * But our reclaim could return 0, simply because due</span>
<span class="cm">		 * to priority we are exposing a smaller subset of</span>
<span class="cm">		 * memory to reclaim from. Consider this as a longer</span>
<span class="cm">		 * term TODO.</span>
<span class="cm">		 */</span>
		<span class="cm">/* If excess == 0, no tree ops */</span>
		<span class="n">__mem_cgroup_insert_exceeded</span><span class="p">(</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="p">,</span> <span class="n">mz</span><span class="p">,</span> <span class="n">mctz</span><span class="p">,</span> <span class="n">excess</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mctz</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
		<span class="n">loop</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Could not reclaim anything and there are no more</span>
<span class="cm">		 * mem cgroups to try or we seem to be looping without</span>
<span class="cm">		 * reclaiming anything.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_reclaimed</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">next_mz</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
			<span class="n">loop</span> <span class="o">&gt;</span> <span class="n">MEM_CGROUP_MAX_SOFT_LIMIT_RECLAIM_LOOPS</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_reclaimed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_mz</span><span class="p">)</span>
		<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_mz</span><span class="o">-&gt;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nr_reclaimed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This routine traverse page_cgroup in given list and drop them all.</span>
<span class="cm"> * *And* this routine doesn&#39;t reclaim page itself, just removes page_cgroup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_force_empty_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">zid</span><span class="p">,</span> <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">loop</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">busy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">zone</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_zones</span><span class="p">[</span><span class="n">zid</span><span class="p">];</span>
	<span class="n">mz</span> <span class="o">=</span> <span class="n">mem_cgroup_zoneinfo</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">zid</span><span class="p">);</span>
	<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">lruvec</span><span class="p">.</span><span class="n">lists</span><span class="p">[</span><span class="n">lru</span><span class="p">];</span>

	<span class="n">loop</span> <span class="o">=</span> <span class="n">mz</span><span class="o">-&gt;</span><span class="n">lru_size</span><span class="p">[</span><span class="n">lru</span><span class="p">];</span>
	<span class="cm">/* give some margin against EBUSY etc...*/</span>
	<span class="n">loop</span> <span class="o">+=</span> <span class="mi">256</span><span class="p">;</span>
	<span class="n">busy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">loop</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">busy</span> <span class="o">==</span> <span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">busy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_move_parent</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">memcg</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* found lock contention or &quot;pc&quot; is obsolete. */</span>
			<span class="n">busy</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">busy</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">list</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * make mem_cgroup&#39;s charge to be 0 if there is no task.</span>
<span class="cm"> * This enables deleting this mem_cgroup.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_force_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">free_all</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">zid</span><span class="p">,</span> <span class="n">shrink</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_retries</span> <span class="o">=</span> <span class="n">MEM_CGROUP_RECLAIM_RETRIES</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span> <span class="o">=</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="p">;</span>

	<span class="n">css_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>

	<span class="n">shrink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* should free all ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_all</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">try_to_free</span><span class="p">;</span>
<span class="nl">move_account:</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cgroup_task_count</span><span class="p">(</span><span class="n">cgrp</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="cm">/* This is for making all *used* pages to be on LRU. */</span>
		<span class="n">lru_add_drain_all</span><span class="p">();</span>
		<span class="n">drain_all_stock_sync</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mem_cgroup_start_move</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
		<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">zid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">zid</span> <span class="o">&lt;</span> <span class="n">MAX_NR_ZONES</span><span class="p">;</span> <span class="n">zid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">enum</span> <span class="n">lru_list</span> <span class="n">lru</span><span class="p">;</span>
				<span class="n">for_each_lru</span><span class="p">(</span><span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_force_empty_list</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span>
							<span class="n">node</span><span class="p">,</span> <span class="n">zid</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mem_cgroup_end_move</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
		<span class="n">memcg_oom_recover</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
		<span class="cm">/* it seems parent cgroup doesn&#39;t have enough mem */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">try_to_free</span><span class="p">;</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="cm">/* &quot;ret&quot; should also be checked to ensure all lists are empty. */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ret</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">css_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">try_to_free:</span>
	<span class="cm">/* returns EBUSY if there is a task or if we come here twice. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cgroup_task_count</span><span class="p">(</span><span class="n">cgrp</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">)</span> <span class="o">||</span> <span class="n">shrink</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* we call try-to-free pages for make this cgroup empty */</span>
	<span class="n">lru_add_drain_all</span><span class="p">();</span>
	<span class="cm">/* try to free all pages in this cgroup */</span>
	<span class="n">shrink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nr_retries</span> <span class="o">&amp;&amp;</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">progress</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">progress</span> <span class="o">=</span> <span class="n">try_to_free_mem_cgroup_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
						<span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">progress</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr_retries</span><span class="o">--</span><span class="p">;</span>
			<span class="cm">/* maybe some writeback is necessary */</span>
			<span class="n">congestion_wait</span><span class="p">(</span><span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="n">lru_add_drain</span><span class="p">();</span>
	<span class="cm">/* try move_account...there may be some *locked* pages. */</span>
	<span class="k">goto</span> <span class="n">move_account</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_force_empty_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mem_cgroup_force_empty</span><span class="p">(</span><span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cont</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="n">u64</span> <span class="nf">mem_cgroup_hierarchy_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_hierarchy_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">cont</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">parent_memcg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">parent_memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">cgroup_lock</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * If parent&#39;s use_hierarchy is set, we can&#39;t make any modifications</span>
<span class="cm">	 * in the child subtrees. If it is unset, then the change can</span>
<span class="cm">	 * occur, provided the current cgroup has no children.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For the root cgroup, parent_mem is NULL, we allow value to be</span>
<span class="cm">	 * set if there are no children.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">parent_memcg</span> <span class="o">||</span> <span class="o">!</span><span class="n">parent_memcg</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">))</span>
			<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mem_cgroup_recursive_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
					       <span class="k">enum</span> <span class="n">mem_cgroup_stat_index</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Per-cpu values can be negative, use a signed accumulator */</span>
	<span class="n">for_each_mem_cgroup_tree</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">memcg</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">mem_cgroup_read_stat</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* race ? */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">mem_cgroup_usage</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">swap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swap</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">mem_cgroup_recursive_stat</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">MEM_CGROUP_STAT_CACHE</span><span class="p">);</span>
	<span class="n">val</span> <span class="o">+=</span> <span class="n">mem_cgroup_recursive_stat</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">MEM_CGROUP_STAT_RSS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">swap</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">+=</span> <span class="n">mem_cgroup_recursive_stat</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">MEM_CGROUP_STAT_SWAPOUT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">mem_cgroup_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">MEMFILE_TYPE</span><span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">MEMFILE_ATTR</span><span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_swap_account</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">_MEMSWAP</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">_MEM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">RES_USAGE</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">mem_cgroup_usage</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">_MEMSWAP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">RES_USAGE</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">mem_cgroup_usage</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">val</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">scnprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">),</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * The user of this function is...</span>
<span class="cm"> * RES_LIMIT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">MEMFILE_TYPE</span><span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">MEMFILE_ATTR</span><span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_swap_account</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">_MEMSWAP</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RES_LIMIT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* Can&#39;t set limit on root */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* This function does all necessary parse...reuse it */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">res_counter_memparse_write_strategy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">_MEM</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_resize_limit</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_resize_memsw_limit</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RES_SOFT_LIMIT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">res_counter_memparse_write_strategy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * For memsw, soft limits are hard to implement in terms</span>
<span class="cm">		 * of semantics, for now, we support soft limits for</span>
<span class="cm">		 * control without swap</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">_MEM</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">res_counter_set_soft_limit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span> <span class="cm">/* should be BUG() ? */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">memcg_get_hierarchical_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mem_limit</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="o">*</span><span class="n">memsw_limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">min_limit</span><span class="p">,</span> <span class="n">min_memsw_limit</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">min_limit</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">);</span>
	<span class="n">min_memsw_limit</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">);</span>
	<span class="n">cgroup</span> <span class="o">=</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">.</span><span class="n">cgroup</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cgroup</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cgroup</span> <span class="o">=</span> <span class="n">cgroup</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgroup</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">);</span>
		<span class="n">min_limit</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min_limit</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">res_counter_read_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">);</span>
		<span class="n">min_memsw_limit</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min_memsw_limit</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="o">*</span><span class="n">mem_limit</span> <span class="o">=</span> <span class="n">min_limit</span><span class="p">;</span>
	<span class="o">*</span><span class="n">memsw_limit</span> <span class="o">=</span> <span class="n">min_memsw_limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">name</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">MEMFILE_TYPE</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">MEMFILE_ATTR</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_swap_account</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">==</span> <span class="n">_MEMSWAP</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RES_MAX_USAGE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">_MEM</span><span class="p">)</span>
			<span class="n">res_counter_reset_max</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">res_counter_reset_max</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RES_FAILCNT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">_MEM</span><span class="p">)</span>
			<span class="n">res_counter_reset_failcnt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">res_counter_reset_failcnt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">mem_cgroup_move_charge_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">move_charge_at_immigrate</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_move_charge_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">NR_MOVE_TYPE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * We check this value several times in both in can_attach() and</span>
<span class="cm">	 * attach(), so we need cgroup lock to prevent this value from being</span>
<span class="cm">	 * inconsistent.</span>
<span class="cm">	 */</span>
	<span class="n">cgroup_lock</span><span class="p">();</span>
	<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">move_charge_at_immigrate</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_move_charge_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_control_numa_stat_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_nr</span><span class="p">,</span> <span class="n">file_nr</span><span class="p">,</span> <span class="n">anon_nr</span><span class="p">,</span> <span class="n">unevictable_nr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_nr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>

	<span class="n">total_nr</span> <span class="o">=</span> <span class="n">mem_cgroup_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">LRU_ALL</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total=%lu&quot;</span><span class="p">,</span> <span class="n">total_nr</span><span class="p">);</span>
	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node_nr</span> <span class="o">=</span> <span class="n">mem_cgroup_node_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">LRU_ALL</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; N%d=%lu&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">node_nr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="n">file_nr</span> <span class="o">=</span> <span class="n">mem_cgroup_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">LRU_ALL_FILE</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;file=%lu&quot;</span><span class="p">,</span> <span class="n">file_nr</span><span class="p">);</span>
	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node_nr</span> <span class="o">=</span> <span class="n">mem_cgroup_node_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span>
				<span class="n">LRU_ALL_FILE</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; N%d=%lu&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">node_nr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="n">anon_nr</span> <span class="o">=</span> <span class="n">mem_cgroup_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">LRU_ALL_ANON</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;anon=%lu&quot;</span><span class="p">,</span> <span class="n">anon_nr</span><span class="p">);</span>
	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node_nr</span> <span class="o">=</span> <span class="n">mem_cgroup_node_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span>
				<span class="n">LRU_ALL_ANON</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; N%d=%lu&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">node_nr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>

	<span class="n">unevictable_nr</span> <span class="o">=</span> <span class="n">mem_cgroup_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">LRU_UNEVICTABLE</span><span class="p">));</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;unevictable=%lu&quot;</span><span class="p">,</span> <span class="n">unevictable_nr</span><span class="p">);</span>
	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node_nr</span> <span class="o">=</span> <span class="n">mem_cgroup_node_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span>
				<span class="n">BIT</span><span class="p">(</span><span class="n">LRU_UNEVICTABLE</span><span class="p">));</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot; N%d=%lu&quot;</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">node_nr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">seq_putc</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">mem_cgroup_lru_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;inactive_anon&quot;</span><span class="p">,</span>
	<span class="s">&quot;active_anon&quot;</span><span class="p">,</span>
	<span class="s">&quot;inactive_file&quot;</span><span class="p">,</span>
	<span class="s">&quot;active_file&quot;</span><span class="p">,</span>
	<span class="s">&quot;unevictable&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mem_cgroup_lru_names_not_uptodate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">mem_cgroup_lru_names</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NR_LRU_LISTS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_control_stat_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">mi</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEM_CGROUP_STAT_NSTATS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MEM_CGROUP_STAT_SWAPOUT</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">do_swap_account</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem_cgroup_stat_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			   <span class="n">mem_cgroup_read_stat</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEM_CGROUP_EVENTS_NSTATS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem_cgroup_events_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			   <span class="n">mem_cgroup_read_events</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_LRU_LISTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;%s %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem_cgroup_lru_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
			   <span class="n">mem_cgroup_nr_lru_pages</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="cm">/* Hierarchical information */</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">,</span> <span class="n">memsw_limit</span><span class="p">;</span>
		<span class="n">memcg_get_hierarchical_limit</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">limit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memsw_limit</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;hierarchical_memory_limit %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;hierarchical_memsw_limit %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">memsw_limit</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEM_CGROUP_STAT_NSTATS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">MEM_CGROUP_STAT_SWAPOUT</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">do_swap_account</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">for_each_mem_cgroup_tree</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">memcg</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">+=</span> <span class="n">mem_cgroup_read_stat</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total_%s %lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem_cgroup_stat_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MEM_CGROUP_EVENTS_NSTATS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">for_each_mem_cgroup_tree</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">memcg</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">+=</span> <span class="n">mem_cgroup_read_events</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total_%s %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">mem_cgroup_events_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_LRU_LISTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">for_each_mem_cgroup_tree</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">memcg</span><span class="p">)</span>
			<span class="n">val</span> <span class="o">+=</span> <span class="n">mem_cgroup_nr_lru_pages</span><span class="p">(</span><span class="n">mi</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;total_%s %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mem_cgroup_lru_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_VM</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">zid</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">zone_reclaim_stat</span> <span class="o">*</span><span class="n">rstat</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">recent_rotated</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">recent_scanned</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

		<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">zid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">zid</span> <span class="o">&lt;</span> <span class="n">MAX_NR_ZONES</span><span class="p">;</span> <span class="n">zid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mz</span> <span class="o">=</span> <span class="n">mem_cgroup_zoneinfo</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">zid</span><span class="p">);</span>
				<span class="n">rstat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">lruvec</span><span class="p">.</span><span class="n">reclaim_stat</span><span class="p">;</span>

				<span class="n">recent_rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rstat</span><span class="o">-&gt;</span><span class="n">recent_rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="n">recent_rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rstat</span><span class="o">-&gt;</span><span class="n">recent_rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
				<span class="n">recent_scanned</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rstat</span><span class="o">-&gt;</span><span class="n">recent_scanned</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="n">recent_scanned</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rstat</span><span class="o">-&gt;</span><span class="n">recent_scanned</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="p">}</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;recent_rotated_anon %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">recent_rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;recent_rotated_file %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">recent_rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;recent_scanned_anon %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">recent_scanned</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;recent_scanned_file %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">recent_scanned</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">mem_cgroup_swappiness_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mem_cgroup_swappiness</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_swappiness_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">cgroup_lock</span><span class="p">();</span>

	<span class="cm">/* If under hierarchy, only empty-root can set this value */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">cgroup_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">swappiness</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">cgroup_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mem_cgroup_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="n">bool</span> <span class="n">swap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_threshold_ary</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">usage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swap</span><span class="p">)</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">thresholds</span><span class="p">.</span><span class="n">primary</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw_thresholds</span><span class="p">.</span><span class="n">primary</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">usage</span> <span class="o">=</span> <span class="n">mem_cgroup_usage</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">swap</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * current_threshold points to threshold just below or equal to usage.</span>
<span class="cm">	 * If it&#39;s not true, a threshold was crossed after last</span>
<span class="cm">	 * call of __mem_cgroup_threshold().</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">current_threshold</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Iterate backward over array of thresholds starting from</span>
<span class="cm">	 * current_threshold and check if a threshold is crossed.</span>
<span class="cm">	 * If none of thresholds below usage is crossed, we read</span>
<span class="cm">	 * only one element of the array here.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&gt;</span> <span class="n">usage</span><span class="p">);</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">eventfd_signal</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">eventfd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* i = current_threshold + 1 */</span>
	<span class="n">i</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Iterate forward over array of thresholds starting from</span>
<span class="cm">	 * current_threshold+1 and check if a threshold is crossed.</span>
<span class="cm">	 * If none of thresholds above usage is crossed, we read</span>
<span class="cm">	 * only one element of the array here.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&lt;=</span> <span class="n">usage</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">eventfd_signal</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">eventfd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Update current_threshold */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">current_threshold</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">unlock:</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_threshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">memcg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__mem_cgroup_threshold</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span><span class="p">)</span>
			<span class="n">__mem_cgroup_threshold</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

		<span class="n">memcg</span> <span class="o">=</span> <span class="n">parent_mem_cgroup</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compare_thresholds</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">mem_cgroup_threshold</span> <span class="o">*</span><span class="n">_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">mem_cgroup_threshold</span> <span class="o">*</span><span class="n">_b</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">_a</span><span class="o">-&gt;</span><span class="n">threshold</span> <span class="o">-</span> <span class="n">_b</span><span class="o">-&gt;</span><span class="n">threshold</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_oom_notify_cb</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_eventfd_list</span> <span class="o">*</span><span class="n">ev</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">oom_notify</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">eventfd_signal</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">eventfd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_oom_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>

	<span class="n">for_each_mem_cgroup_tree</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">memcg</span><span class="p">)</span>
		<span class="n">mem_cgroup_oom_notify_cb</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_usage_register_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="k">struct</span> <span class="n">eventfd_ctx</span> <span class="o">*</span><span class="n">eventfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_thresholds</span> <span class="o">*</span><span class="n">thresholds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_threshold_ary</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">MEMFILE_TYPE</span><span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">usage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">res_counter_memparse_write_strategy</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threshold</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">thresholds_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">_MEM</span><span class="p">)</span>
		<span class="n">thresholds</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">thresholds</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">_MEMSWAP</span><span class="p">)</span>
		<span class="n">thresholds</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw_thresholds</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">usage</span> <span class="o">=</span> <span class="n">mem_cgroup_usage</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">type</span> <span class="o">==</span> <span class="n">_MEMSWAP</span><span class="p">);</span>

	<span class="cm">/* Check if a threshold crossed before adding a new one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">)</span>
		<span class="n">__mem_cgroup_threshold</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">type</span> <span class="o">==</span> <span class="n">_MEMSWAP</span><span class="p">);</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span> <span class="o">?</span> <span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for new array of thresholds */</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup_threshold</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* Copy thresholds (if any) to new array */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup_threshold</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Add new threshold */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">eventfd</span> <span class="o">=</span> <span class="n">eventfd</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">;</span>

	<span class="cm">/* Sort thresholds. Registering of new threshold isn&#39;t time-critical */</span>
	<span class="n">sort</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup_threshold</span><span class="p">),</span>
			<span class="n">compare_thresholds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Find current threshold */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">current_threshold</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&lt;=</span> <span class="n">usage</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * new-&gt;current_threshold will not be used until</span>
<span class="cm">			 * rcu_assign_pointer(), so it&#39;s safe to increment</span>
<span class="cm">			 * it here.</span>
<span class="cm">			 */</span>
			<span class="o">++</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">current_threshold</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Free old spare buffer and save old primary buffer as spare */</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">spare</span><span class="p">);</span>
	<span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">spare</span> <span class="o">=</span> <span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">;</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

	<span class="cm">/* To be sure that nobody uses thresholds */</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>

<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">thresholds_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_usage_unregister_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="k">struct</span> <span class="n">eventfd_ctx</span> <span class="o">*</span><span class="n">eventfd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_thresholds</span> <span class="o">*</span><span class="n">thresholds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_threshold_ary</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">MEMFILE_TYPE</span><span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">usage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">thresholds_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">_MEM</span><span class="p">)</span>
		<span class="n">thresholds</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">thresholds</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">_MEMSWAP</span><span class="p">)</span>
		<span class="n">thresholds</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw_thresholds</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>

	<span class="n">usage</span> <span class="o">=</span> <span class="n">mem_cgroup_usage</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">type</span> <span class="o">==</span> <span class="n">_MEMSWAP</span><span class="p">);</span>

	<span class="cm">/* Check if a threshold crossed before removing */</span>
	<span class="n">__mem_cgroup_threshold</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">type</span> <span class="o">==</span> <span class="n">_MEMSWAP</span><span class="p">);</span>

	<span class="cm">/* Calculate new number of threshold */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">eventfd</span> <span class="o">!=</span> <span class="n">eventfd</span><span class="p">)</span>
			<span class="n">size</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">spare</span><span class="p">;</span>

	<span class="cm">/* Set thresholds array to NULL if we don&#39;t have thresholds */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">swap_buffers</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">new</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* Copy thresholds and find current threshold */</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">current_threshold</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">eventfd</span> <span class="o">==</span> <span class="n">eventfd</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">new</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&lt;=</span> <span class="n">usage</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * new-&gt;current_threshold will not be used</span>
<span class="cm">			 * until rcu_assign_pointer(), so it&#39;s safe to increment</span>
<span class="cm">			 * it here.</span>
<span class="cm">			 */</span>
			<span class="o">++</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">current_threshold</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">j</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">swap_buffers:</span>
	<span class="cm">/* Swap primary and spare array */</span>
	<span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">spare</span> <span class="o">=</span> <span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">;</span>
	<span class="cm">/* If all events are unregistered, free the spare array */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">spare</span><span class="p">);</span>
		<span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">spare</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">thresholds</span><span class="o">-&gt;</span><span class="n">primary</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>

	<span class="cm">/* To be sure that nobody uses thresholds */</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>
<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">thresholds_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_oom_register_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="k">struct</span> <span class="n">eventfd_ctx</span> <span class="o">*</span><span class="n">eventfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_eventfd_list</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">MEMFILE_TYPE</span><span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">_OOM_TYPE</span><span class="p">);</span>
	<span class="n">event</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="p">),</span>	<span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">event</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_lock</span><span class="p">);</span>

	<span class="n">event</span><span class="o">-&gt;</span><span class="n">eventfd</span> <span class="o">=</span> <span class="n">eventfd</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">oom_notify</span><span class="p">);</span>

	<span class="cm">/* already in OOM ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">under_oom</span><span class="p">))</span>
		<span class="n">eventfd_signal</span><span class="p">(</span><span class="n">eventfd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_oom_unregister_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="k">struct</span> <span class="n">eventfd_ctx</span> <span class="o">*</span><span class="n">eventfd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_eventfd_list</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">MEMFILE_TYPE</span><span class="p">(</span><span class="n">cft</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">_OOM_TYPE</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">oom_notify</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">eventfd</span> <span class="o">==</span> <span class="n">eventfd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg_oom_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_oom_control_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">cgroup_map_cb</span> <span class="o">*</span><span class="n">cb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>

	<span class="n">cb</span><span class="o">-&gt;</span><span class="n">fill</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="s">&quot;oom_kill_disable&quot;</span><span class="p">,</span> <span class="n">memcg</span><span class="o">-&gt;</span><span class="n">oom_kill_disable</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">under_oom</span><span class="p">))</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">fill</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="s">&quot;under_oom&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cb</span><span class="o">-&gt;</span><span class="n">fill</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="s">&quot;under_oom&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_oom_control_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgrp</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">cftype</span> <span class="o">*</span><span class="n">cft</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="cm">/* cannot set to root cgroup and only 0 and 1 are allowed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">||</span> <span class="o">!</span><span class="p">((</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">cgroup_lock</span><span class="p">();</span>
	<span class="cm">/* oom-kill-disable is a flag for subhierarchy. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">cgroup_unlock</span><span class="p">();</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">oom_kill_disable</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">val</span><span class="p">)</span>
		<span class="n">memcg_oom_recover</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="n">cgroup_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR_KMEM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">memcg_init_kmem</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mem_cgroup_sockets_init</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">ss</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmem_cgroup_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mem_cgroup_sockets_destroy</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">memcg_init_kmem</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">kmem_cgroup_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cftype</span> <span class="n">mem_cgroup_files</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;usage_in_bytes&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">MEMFILE_PRIVATE</span><span class="p">(</span><span class="n">_MEM</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mem_cgroup_read</span><span class="p">,</span>
		<span class="p">.</span><span class="n">register_event</span> <span class="o">=</span> <span class="n">mem_cgroup_usage_register_event</span><span class="p">,</span>
		<span class="p">.</span><span class="n">unregister_event</span> <span class="o">=</span> <span class="n">mem_cgroup_usage_unregister_event</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;max_usage_in_bytes&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">MEMFILE_PRIVATE</span><span class="p">(</span><span class="n">_MEM</span><span class="p">,</span> <span class="n">RES_MAX_USAGE</span><span class="p">),</span>
		<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="n">mem_cgroup_reset</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mem_cgroup_read</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;limit_in_bytes&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">MEMFILE_PRIVATE</span><span class="p">(</span><span class="n">_MEM</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">write_string</span> <span class="o">=</span> <span class="n">mem_cgroup_write</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mem_cgroup_read</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;soft_limit_in_bytes&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">MEMFILE_PRIVATE</span><span class="p">(</span><span class="n">_MEM</span><span class="p">,</span> <span class="n">RES_SOFT_LIMIT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">write_string</span> <span class="o">=</span> <span class="n">mem_cgroup_write</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mem_cgroup_read</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;failcnt&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">MEMFILE_PRIVATE</span><span class="p">(</span><span class="n">_MEM</span><span class="p">,</span> <span class="n">RES_FAILCNT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="n">mem_cgroup_reset</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mem_cgroup_read</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;stat&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">mem_control_stat_show</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;force_empty&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="n">mem_cgroup_force_empty_write</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;use_hierarchy&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">mem_cgroup_hierarchy_write</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">mem_cgroup_hierarchy_read</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;swappiness&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">mem_cgroup_swappiness_read</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">mem_cgroup_swappiness_write</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;move_charge_at_immigrate&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_u64</span> <span class="o">=</span> <span class="n">mem_cgroup_move_charge_read</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">mem_cgroup_move_charge_write</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;oom_control&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_map</span> <span class="o">=</span> <span class="n">mem_cgroup_oom_control_read</span><span class="p">,</span>
		<span class="p">.</span><span class="n">write_u64</span> <span class="o">=</span> <span class="n">mem_cgroup_oom_control_write</span><span class="p">,</span>
		<span class="p">.</span><span class="n">register_event</span> <span class="o">=</span> <span class="n">mem_cgroup_oom_register_event</span><span class="p">,</span>
		<span class="p">.</span><span class="n">unregister_event</span> <span class="o">=</span> <span class="n">mem_cgroup_oom_unregister_event</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">MEMFILE_PRIVATE</span><span class="p">(</span><span class="n">_OOM_TYPE</span><span class="p">,</span> <span class="n">OOM_CONTROL</span><span class="p">),</span>
	<span class="p">},</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;numa_stat&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read_seq_string</span> <span class="o">=</span> <span class="n">mem_control_numa_stat_show</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;memsw.usage_in_bytes&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">MEMFILE_PRIVATE</span><span class="p">(</span><span class="n">_MEMSWAP</span><span class="p">,</span> <span class="n">RES_USAGE</span><span class="p">),</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mem_cgroup_read</span><span class="p">,</span>
		<span class="p">.</span><span class="n">register_event</span> <span class="o">=</span> <span class="n">mem_cgroup_usage_register_event</span><span class="p">,</span>
		<span class="p">.</span><span class="n">unregister_event</span> <span class="o">=</span> <span class="n">mem_cgroup_usage_unregister_event</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;memsw.max_usage_in_bytes&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">MEMFILE_PRIVATE</span><span class="p">(</span><span class="n">_MEMSWAP</span><span class="p">,</span> <span class="n">RES_MAX_USAGE</span><span class="p">),</span>
		<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="n">mem_cgroup_reset</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mem_cgroup_read</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;memsw.limit_in_bytes&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">MEMFILE_PRIVATE</span><span class="p">(</span><span class="n">_MEMSWAP</span><span class="p">,</span> <span class="n">RES_LIMIT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">write_string</span> <span class="o">=</span> <span class="n">mem_cgroup_write</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mem_cgroup_read</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;memsw.failcnt&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">MEMFILE_PRIVATE</span><span class="p">(</span><span class="n">_MEMSWAP</span><span class="p">,</span> <span class="n">RES_FAILCNT</span><span class="p">),</span>
		<span class="p">.</span><span class="n">trigger</span> <span class="o">=</span> <span class="n">mem_cgroup_reset</span><span class="p">,</span>
		<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">mem_cgroup_read</span><span class="p">,</span>
	<span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">{</span> <span class="p">},</span>	<span class="cm">/* terminate */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_mem_cgroup_per_zone_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_node</span> <span class="o">*</span><span class="n">pn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_per_zone</span> <span class="o">*</span><span class="n">mz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">zone</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This routine is called against possible nodes.</span>
<span class="cm">	 * But it&#39;s BUG to call kmalloc() against offline node.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TODO: this routine can waste much memory for nodes which will</span>
<span class="cm">	 *       never be onlined. It&#39;s better to use memory hotplug callback</span>
<span class="cm">	 *       function.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">))</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">pn</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pn</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pn</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">zone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">zone</span> <span class="o">&lt;</span> <span class="n">MAX_NR_ZONES</span><span class="p">;</span> <span class="n">zone</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mz</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pn</span><span class="o">-&gt;</span><span class="n">zoneinfo</span><span class="p">[</span><span class="n">zone</span><span class="p">];</span>
		<span class="n">lruvec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mz</span><span class="o">-&gt;</span><span class="n">lruvec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_zones</span><span class="p">[</span><span class="n">zone</span><span class="p">]);</span>
		<span class="n">mz</span><span class="o">-&gt;</span><span class="n">usage_in_excess</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mz</span><span class="o">-&gt;</span><span class="n">on_tree</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">mz</span><span class="o">-&gt;</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">nodeinfo</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">pn</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_mem_cgroup_per_zone_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">nodeinfo</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="nf">mem_cgroup_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span><span class="p">);</span>

	<span class="cm">/* Can be very big if MAX_NUMNODES is very big */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">memcg</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span> <span class="o">=</span> <span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup_stat_cpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">pcp_counter_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">memcg</span><span class="p">;</span>

<span class="nl">out_free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helpers for freeing a kmalloc()ed/vzalloc()ed mem_cgroup by RCU,</span>
<span class="cm"> * but in process context.  The work_freeing structure is overlaid</span>
<span class="cm"> * on the rcu_freeing structure, which itself is overlaid on memsw.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span><span class="p">);</span>

	<span class="n">memcg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span><span class="p">,</span> <span class="n">work_freeing</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need to make sure that (at least for now), the jump label</span>
<span class="cm">	 * destruction code runs outside of the cgroup lock. This is because</span>
<span class="cm">	 * get_online_cpus(), which is called from the static_branch update,</span>
<span class="cm">	 * can&#39;t be called inside the cgroup_lock. cpusets are the ones</span>
<span class="cm">	 * enforcing this dependency, so if they ever change, we might as well.</span>
<span class="cm">	 *</span>
<span class="cm">	 * schedule_work() will guarantee this happens. Be careful if you need</span>
<span class="cm">	 * to move this code around, and make sure it is outside</span>
<span class="cm">	 * the cgroup_lock.</span>
<span class="cm">	 */</span>
	<span class="n">disarm_sock_keys</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_rcu</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">rcu_head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>

	<span class="n">memcg</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">rcu_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mem_cgroup</span><span class="p">,</span> <span class="n">rcu_freeing</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">work_freeing</span><span class="p">,</span> <span class="n">free_work</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">work_freeing</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * At destroying mem_cgroup, references from swap_cgroup can remain.</span>
<span class="cm"> * (scanning all at force_empty is too costly...)</span>
<span class="cm"> *</span>
<span class="cm"> * Instead of clearing all references at force_empty, we remember</span>
<span class="cm"> * the number of reference from swap_cgroup and free mem_cgroup when</span>
<span class="cm"> * it goes down to 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Removal of cgroup itself succeeds regardless of refs from swap.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mem_cgroup_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">mem_cgroup_remove_from_trees</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="n">free_css_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem_cgroup_subsys</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">);</span>

	<span class="n">for_each_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="n">free_mem_cgroup_per_zone_info</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="n">free_percpu</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">);</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">rcu_freeing</span><span class="p">,</span> <span class="n">free_rcu</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mem_cgroup_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_sub_and_test</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent_mem_cgroup</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
		<span class="n">__mem_cgroup_free</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">mem_cgroup_put</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__mem_cgroup_put</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns the parent mem_cgroup in memcgroup hierarchy with hierarchy enabled.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="nf">parent_mem_cgroup</span><span class="p">(</span><span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">.</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mem_cgroup_from_res_counter</span><span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parent_mem_cgroup</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">enable_swap_cgroup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_disabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">really_do_swap_account</span><span class="p">)</span>
		<span class="n">do_swap_account</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">enable_swap_cgroup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_soft_limit_tree_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_node</span> <span class="o">*</span><span class="n">rtpn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup_tree_per_zone</span> <span class="o">*</span><span class="n">rtpz</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">zone</span><span class="p">;</span>

	<span class="n">for_each_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_NORMAL_MEMORY</span><span class="p">))</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">rtpn</span> <span class="o">=</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rtpn</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtpn</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_cleanup</span><span class="p">;</span>

		<span class="n">soft_limit_tree</span><span class="p">.</span><span class="n">rb_tree_per_node</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">rtpn</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">zone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">zone</span> <span class="o">&lt;</span> <span class="n">MAX_NR_ZONES</span><span class="p">;</span> <span class="n">zone</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rtpz</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rtpn</span><span class="o">-&gt;</span><span class="n">rb_tree_per_zone</span><span class="p">[</span><span class="n">zone</span><span class="p">];</span>
			<span class="n">rtpz</span><span class="o">-&gt;</span><span class="n">rb_root</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
			<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtpz</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_cleanup:</span>
	<span class="n">for_each_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">soft_limit_tree</span><span class="p">.</span><span class="n">rb_tree_per_node</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">soft_limit_tree</span><span class="p">.</span><span class="n">rb_tree_per_node</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
		<span class="n">soft_limit_tree</span><span class="p">.</span><span class="n">rb_tree_per_node</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span> <span class="n">__ref</span>
<span class="nf">mem_cgroup_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

	<span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memcg</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="n">for_each_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alloc_mem_cgroup_per_zone_info</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>

	<span class="cm">/* root ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="n">enable_swap_cgroup</span><span class="p">();</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_soft_limit_tree_init</span><span class="p">())</span>
			<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
		<span class="n">root_mem_cgroup</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">;</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">memcg_stock_pcp</span> <span class="o">*</span><span class="n">stock</span> <span class="o">=</span>
						<span class="o">&amp;</span><span class="n">per_cpu</span><span class="p">(</span><span class="n">memcg_stock</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
			<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stock</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">drain_local_stock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">memcg_cpu_hotplug_callback</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cont</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span><span class="p">;</span>
		<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">oom_kill_disable</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">oom_kill_disable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">use_hierarchy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">);</span>
		<span class="n">res_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We increment refcnt of the parent to ensure that we can</span>
<span class="cm">		 * safely access it on res_counter_charge/uncharge.</span>
<span class="cm">		 * This refcnt will be decremented when freeing this</span>
<span class="cm">		 * mem_cgroup(see mem_cgroup_put).</span>
<span class="cm">		 */</span>
		<span class="n">mem_cgroup_get</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">res_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">res_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">last_scanned_node</span> <span class="o">=</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">oom_notify</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">swappiness</span> <span class="o">=</span> <span class="n">mem_cgroup_swappiness</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">memcg</span><span class="o">-&gt;</span><span class="n">move_charge_at_immigrate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">thresholds_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">move_lock</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">memcg_init_kmem</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mem_cgroup_subsys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We call put now because our (and parent&#39;s) refcnts</span>
<span class="cm">		 * are already in place. mem_cgroup_put() will internally</span>
<span class="cm">		 * call __mem_cgroup_free, so return directly</span>
<span class="cm">		 */</span>
		<span class="n">mem_cgroup_put</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">;</span>
<span class="nl">free_out:</span>
	<span class="n">__mem_cgroup_free</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_pre_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mem_cgroup_force_empty</span><span class="p">(</span><span class="n">memcg</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cont</span><span class="p">);</span>

	<span class="n">kmem_cgroup_destroy</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>

	<span class="n">mem_cgroup_put</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MMU</span>
<span class="cm">/* Handlers for move charge at task migration. */</span>
<span class="cp">#define PRECHARGE_COUNT_AT_ONCE	256</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_do_precharge</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">batch_count</span> <span class="o">=</span> <span class="n">PRECHARGE_COUNT_AT_ONCE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">memcg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">precharge</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="cm">/* we don&#39;t need css_get for root */</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* try to charge at once */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">res_counter</span> <span class="o">*</span><span class="n">dummy</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * &quot;memcg&quot; cannot be under rmdir() because we&#39;ve already checked</span>
<span class="cm">		 * by cgroup_lock_live_cgroup() that it is not removed and we</span>
<span class="cm">		 * are still under the same cgroup_mutex. So we can postpone</span>
<span class="cm">		 * css_get().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res_counter_charge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">one_by_one</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span> <span class="o">&amp;&amp;</span> <span class="n">res_counter_charge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span>
						<span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">count</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">one_by_one</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">precharge</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">one_by_one:</span>
	<span class="cm">/* fall back to one by one charge */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">batch_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">batch_count</span> <span class="o">=</span> <span class="n">PRECHARGE_COUNT_AT_ONCE</span><span class="p">;</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__mem_cgroup_try_charge</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="cm">/* mem_cgroup_clear_mc() will do uncharge later */</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">precharge</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * get_mctgt_type - get target type of moving charge</span>
<span class="cm"> * @vma: the vma the pte to be checked belongs</span>
<span class="cm"> * @addr: the address corresponding to the pte to be checked</span>
<span class="cm"> * @ptent: the pte to be checked</span>
<span class="cm"> * @target: the pointer the target page or swap ent will be stored(can be NULL)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns</span>
<span class="cm"> *   0(MC_TARGET_NONE): if the pte is not a target for move charge.</span>
<span class="cm"> *   1(MC_TARGET_PAGE): if the page corresponding to this pte is a target for</span>
<span class="cm"> *     move charge. if @target is not NULL, the page is stored in target-&gt;page</span>
<span class="cm"> *     with extra refcnt got(Callers should handle it).</span>
<span class="cm"> *   2(MC_TARGET_SWAP): if the swap entry corresponding to this pte is a</span>
<span class="cm"> *     target for charge migration. if @target is not NULL, the entry is stored</span>
<span class="cm"> *     in target-&gt;ent.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with pte lock held.</span>
<span class="cm"> */</span>
<span class="k">union</span> <span class="n">mc_target</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span>	<span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">swp_entry_t</span>	<span class="n">ent</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">mc_target_type</span> <span class="p">{</span>
	<span class="n">MC_TARGET_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">MC_TARGET_PAGE</span><span class="p">,</span>
	<span class="n">MC_TARGET_SWAP</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">mc_handle_present_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">ptent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">vm_normal_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span> <span class="o">||</span> <span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we don&#39;t move shared anon */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">move_anon</span><span class="p">())</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">move_file</span><span class="p">())</span>
		<span class="cm">/* we ignore mapcount for file pages */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">get_page_unless_zero</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SWAP</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">mc_handle_swap_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">ptent</span><span class="p">,</span> <span class="n">swp_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">swp_entry_t</span> <span class="n">ent</span> <span class="o">=</span> <span class="n">pte_to_swp_entry</span><span class="p">(</span><span class="n">ptent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">move_anon</span><span class="p">()</span> <span class="o">||</span> <span class="n">non_swap_entry</span><span class="p">(</span><span class="n">ent</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Because lookup_swap_cache() updates some statistics counter,</span>
<span class="cm">	 * we call find_get_page() with swapper_space directly.</span>
<span class="cm">	 */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapper_space</span><span class="p">,</span> <span class="n">ent</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span><span class="p">)</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">ent</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">mc_handle_swap_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">ptent</span><span class="p">,</span> <span class="n">swp_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">mc_handle_file_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">ptent</span><span class="p">,</span> <span class="n">swp_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="cm">/* anonymous vma */</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">move_file</span><span class="p">())</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">ptent</span><span class="p">))</span>
		<span class="n">pgoff</span> <span class="o">=</span> <span class="n">linear_page_index</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">else</span> <span class="cm">/* pte_file(ptent) is true */</span>
		<span class="n">pgoff</span> <span class="o">=</span> <span class="n">pte_to_pgoff</span><span class="p">(</span><span class="n">ptent</span><span class="p">);</span>

	<span class="cm">/* page is moved even if it&#39;s not RSS of this task(page-faulted). */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_SWAP</span>
	<span class="cm">/* shmem/tmpfs may report page out on swap: account for that too. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">radix_tree_exceptional_entry</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">swp_entry_t</span> <span class="n">swap</span> <span class="o">=</span> <span class="n">radix_to_swp_entry</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_swap_account</span><span class="p">)</span>
			<span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">swap</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapper_space</span><span class="p">,</span> <span class="n">swap</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">mc_target_type</span> <span class="nf">get_mctgt_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">ptent</span><span class="p">,</span> <span class="k">union</span> <span class="n">mc_target</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mc_target_type</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">MC_TARGET_NONE</span><span class="p">;</span>
	<span class="n">swp_entry_t</span> <span class="n">ent</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pte_present</span><span class="p">(</span><span class="n">ptent</span><span class="p">))</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">mc_handle_present_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptent</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_swap_pte</span><span class="p">(</span><span class="n">ptent</span><span class="p">))</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">mc_handle_swap_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pte_none</span><span class="p">(</span><span class="n">ptent</span><span class="p">)</span> <span class="o">||</span> <span class="n">pte_file</span><span class="p">(</span><span class="n">ptent</span><span class="p">))</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">mc_handle_file_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ent</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do only loose check w/o page_cgroup lock.</span>
<span class="cm">		 * mem_cgroup_move_account() checks the pc is valid or not under</span>
<span class="cm">		 * the lock.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span> <span class="o">==</span> <span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">MC_TARGET_PAGE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span>
				<span class="n">target</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">target</span><span class="p">)</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* There is a swap entry and a page doesn&#39;t exist or isn&#39;t charged */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ent</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span>
			<span class="n">css_id</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">css</span><span class="p">)</span> <span class="o">==</span> <span class="n">lookup_swap_cgroup_id</span><span class="p">(</span><span class="n">ent</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">MC_TARGET_SWAP</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span>
			<span class="n">target</span><span class="o">-&gt;</span><span class="n">ent</span> <span class="o">=</span> <span class="n">ent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="cm">/*</span>
<span class="cm"> * We don&#39;t consider swapping or file mapped pages because THP does not</span>
<span class="cm"> * support them for now.</span>
<span class="cm"> * Caller should make sure that pmd_trans_huge(pmd) is true.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">mc_target_type</span> <span class="nf">get_mctgt_type_thp</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">,</span> <span class="k">union</span> <span class="n">mc_target</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mc_target_type</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">MC_TARGET_NONE</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">pmd_page</span><span class="p">(</span><span class="n">pmd</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page</span> <span class="o">||</span> <span class="o">!</span><span class="n">PageHead</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">move_anon</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageCgroupUsed</span><span class="p">(</span><span class="n">pc</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pc</span><span class="o">-&gt;</span><span class="n">mem_cgroup</span> <span class="o">==</span> <span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">MC_TARGET_PAGE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">target</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">enum</span> <span class="n">mc_target_type</span> <span class="nf">get_mctgt_type_thp</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">,</span> <span class="k">union</span> <span class="n">mc_target</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">MC_TARGET_NONE</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_count_precharge_pte_range</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">mm_walk</span> <span class="o">*</span><span class="n">walk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_trans_huge_lock</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_mctgt_type_thp</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">MC_TARGET_PAGE</span><span class="p">)</span>
			<span class="n">mc</span><span class="p">.</span><span class="n">precharge</span> <span class="o">+=</span> <span class="n">HPAGE_PMD_NR</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_trans_unstable</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="n">pte</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_mctgt_type</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="n">mc</span><span class="p">.</span><span class="n">precharge</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* increment precharge temporarily */</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="n">cond_resched</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">mem_cgroup_count_precharge</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">precharge</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mm_walk</span> <span class="n">mem_cgroup_count_precharge_walk</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">pmd_entry</span> <span class="o">=</span> <span class="n">mem_cgroup_count_precharge_pte_range</span><span class="p">,</span>
			<span class="p">.</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">,</span>
			<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">vma</span><span class="p">,</span>
		<span class="p">};</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">walk_page_range</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">mem_cgroup_count_precharge_walk</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="n">precharge</span> <span class="o">=</span> <span class="n">mc</span><span class="p">.</span><span class="n">precharge</span><span class="p">;</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">precharge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">precharge</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_precharge_mc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">precharge</span> <span class="o">=</span> <span class="n">mem_cgroup_count_precharge</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">moving_task</span><span class="p">);</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">moving_task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mem_cgroup_do_precharge</span><span class="p">(</span><span class="n">precharge</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* cancels all extra charges on mc.from and mc.to, and wakes up all waiters. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__mem_cgroup_clear_mc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="p">;</span>

	<span class="cm">/* we must uncharge all the leftover precharges from mc.to */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">precharge</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__mem_cgroup_cancel_charge</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="p">,</span> <span class="n">mc</span><span class="p">.</span><span class="n">precharge</span><span class="p">);</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">precharge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * we didn&#39;t uncharge from mc.from at mem_cgroup_move_account(), so</span>
<span class="cm">	 * we must uncharge here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">moved_charge</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__mem_cgroup_cancel_charge</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">,</span> <span class="n">mc</span><span class="p">.</span><span class="n">moved_charge</span><span class="p">);</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">moved_charge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* we must fixup refcnts and charges */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">moved_swap</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* uncharge swap account from the old cgroup */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">))</span>
			<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="o">-&gt;</span><span class="n">memsw</span><span class="p">,</span>
						<span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">mc</span><span class="p">.</span><span class="n">moved_swap</span><span class="p">);</span>
		<span class="n">__mem_cgroup_put</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">,</span> <span class="n">mc</span><span class="p">.</span><span class="n">moved_swap</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_is_root</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * we charged both to-&gt;res and to-&gt;memsw, so we should</span>
<span class="cm">			 * uncharge to-&gt;res.</span>
<span class="cm">			 */</span>
			<span class="n">res_counter_uncharge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">,</span>
						<span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">mc</span><span class="p">.</span><span class="n">moved_swap</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* we&#39;ve already done mem_cgroup_get(mc.to) */</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">moved_swap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcg_oom_recover</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="n">memcg_oom_recover</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
	<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">waitq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_clear_mc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we must clear moving_task before waking up waiters at the end of</span>
<span class="cm">	 * task migration.</span>
<span class="cm">	 */</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">moving_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">__mem_cgroup_clear_mc</span><span class="p">();</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">from</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mem_cgroup_end_move</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_can_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cgroup_taskset_first</span><span class="p">(</span><span class="n">tset</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span> <span class="o">=</span> <span class="n">mem_cgroup_from_cont</span><span class="p">(</span><span class="n">cgroup</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcg</span><span class="o">-&gt;</span><span class="n">move_charge_at_immigrate</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="n">mem_cgroup_from_task</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">from</span> <span class="o">==</span> <span class="n">memcg</span><span class="p">);</span>

		<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* We move charges only when we move a owner of the mm */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">);</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="p">);</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">precharge</span><span class="p">);</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">moved_charge</span><span class="p">);</span>
			<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">moved_swap</span><span class="p">);</span>
			<span class="n">mem_cgroup_start_move</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">mc</span><span class="p">.</span><span class="n">from</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
			<span class="n">mc</span><span class="p">.</span><span class="n">to</span> <span class="o">=</span> <span class="n">memcg</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
			<span class="cm">/* We set mc.moving_task later */</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_precharge_mc</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">mem_cgroup_clear_mc</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_cancel_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mem_cgroup_clear_mc</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_move_charge_pte_range</span><span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">mm_walk</span> <span class="o">*</span><span class="n">walk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span> <span class="o">=</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mc_target_type</span> <span class="n">target_type</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">mc_target</span> <span class="n">target</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page_cgroup</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t take compound_lock() here but no race with splitting thp</span>
<span class="cm">	 * happens because:</span>
<span class="cm">	 *  - if pmd_trans_huge_lock() returns 1, the relevant thp is not</span>
<span class="cm">	 *    under splitting, which means there&#39;s no concurrent thp split,</span>
<span class="cm">	 *  - if another thread runs into split_huge_page() just after we</span>
<span class="cm">	 *    entered this if-block, the thread must wait for page table lock</span>
<span class="cm">	 *    to be unlocked in __split_huge_page_splitting(), where the main</span>
<span class="cm">	 *    part of thp split is not executed yet.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_trans_huge_lock</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">precharge</span> <span class="o">&lt;</span> <span class="n">HPAGE_PMD_NR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">target_type</span> <span class="o">=</span> <span class="n">get_mctgt_type_thp</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target_type</span> <span class="o">==</span> <span class="n">MC_TARGET_PAGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="n">page</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isolate_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_move_account</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">HPAGE_PMD_NR</span><span class="p">,</span>
							<span class="n">pc</span><span class="p">,</span> <span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">,</span> <span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">mc</span><span class="p">.</span><span class="n">precharge</span> <span class="o">-=</span> <span class="n">HPAGE_PMD_NR</span><span class="p">;</span>
					<span class="n">mc</span><span class="p">.</span><span class="n">moved_charge</span> <span class="o">+=</span> <span class="n">HPAGE_PMD_NR</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">putback_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmd_trans_unstable</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="n">ptent</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">pte</span><span class="o">++</span><span class="p">);</span>
		<span class="n">swp_entry_t</span> <span class="n">ent</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mc</span><span class="p">.</span><span class="n">precharge</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">get_mctgt_type</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">ptent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">target</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MC_TARGET_PAGE</span>:
			<span class="n">page</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="n">page</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">isolate_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">put</span><span class="p">;</span>
			<span class="n">pc</span> <span class="o">=</span> <span class="n">lookup_page_cgroup</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_move_account</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span>
						     <span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">,</span> <span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mc</span><span class="p">.</span><span class="n">precharge</span><span class="o">--</span><span class="p">;</span>
				<span class="cm">/* we uncharge from mc.from later. */</span>
				<span class="n">mc</span><span class="p">.</span><span class="n">moved_charge</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">putback_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">put:</span>			<span class="cm">/* get_mctgt_type() gets the page */</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MC_TARGET_SWAP</span>:
			<span class="n">ent</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="n">ent</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem_cgroup_move_swap_account</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">mc</span><span class="p">.</span><span class="n">from</span><span class="p">,</span> <span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mc</span><span class="p">.</span><span class="n">precharge</span><span class="o">--</span><span class="p">;</span>
				<span class="cm">/* we fixup refcnts and charges later. */</span>
				<span class="n">mc</span><span class="p">.</span><span class="n">moved_swap</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
	<span class="n">cond_resched</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We have consumed all precharges we got in can_attach().</span>
<span class="cm">		 * We try charge one by one, but don&#39;t do any additional</span>
<span class="cm">		 * charges to mc.to if we have failed in charge once in attach()</span>
<span class="cm">		 * phase.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mem_cgroup_do_precharge</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_move_charge</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="n">lru_add_drain_all</span><span class="p">();</span>
<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Someone who are holding the mmap_sem might be waiting in</span>
<span class="cm">		 * waitq. So we cancel all extra charges, wake up all waiters,</span>
<span class="cm">		 * and retry. Because we cancel precharges, we might not be able</span>
<span class="cm">		 * to move enough charges, but moving charge is a best-effort</span>
<span class="cm">		 * feature anyway, so it wouldn&#39;t be a big problem.</span>
<span class="cm">		 */</span>
		<span class="n">__mem_cgroup_clear_mc</span><span class="p">();</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">mm_walk</span> <span class="n">mem_cgroup_move_charge_walk</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">pmd_entry</span> <span class="o">=</span> <span class="n">mem_cgroup_move_charge_pte_range</span><span class="p">,</span>
			<span class="p">.</span><span class="n">mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">,</span>
			<span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">vma</span><span class="p">,</span>
		<span class="p">};</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_page_range</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">mem_cgroup_move_charge_walk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * means we have consumed all precharges and failed in</span>
<span class="cm">			 * doing additional charge. Just abandon here.</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_move_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cgroup_taskset_first</span><span class="p">(</span><span class="n">tset</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="p">)</span>
			<span class="n">mem_cgroup_move_charge</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
		<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mc</span><span class="p">.</span><span class="n">to</span><span class="p">)</span>
		<span class="n">mem_cgroup_clear_mc</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#else	</span><span class="cm">/* !CONFIG_MMU */</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mem_cgroup_can_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_cancel_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cgroup</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mem_cgroup_move_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">cont</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">cgroup_taskset</span> <span class="o">*</span><span class="n">tset</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="n">mem_cgroup_subsys</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">subsys_id</span> <span class="o">=</span> <span class="n">mem_cgroup_subsys_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">mem_cgroup_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">pre_destroy</span> <span class="o">=</span> <span class="n">mem_cgroup_pre_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">mem_cgroup_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_attach</span> <span class="o">=</span> <span class="n">mem_cgroup_can_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cancel_attach</span> <span class="o">=</span> <span class="n">mem_cgroup_cancel_attach</span><span class="p">,</span>
	<span class="p">.</span><span class="n">attach</span> <span class="o">=</span> <span class="n">mem_cgroup_move_task</span><span class="p">,</span>
	<span class="p">.</span><span class="n">base_cftypes</span> <span class="o">=</span> <span class="n">mem_cgroup_files</span><span class="p">,</span>
	<span class="p">.</span><span class="n">early_init</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">__DEPRECATED_clear_css_refs</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_CGROUP_MEM_RES_CTLR_SWAP</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">enable_swap_account</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* consider enabled if no parameter or 1 is given */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">))</span>
		<span class="n">really_do_swap_account</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;0&quot;</span><span class="p">))</span>
		<span class="n">really_do_swap_account</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;swapaccount=&quot;</span><span class="p">,</span> <span class="n">enable_swap_account</span><span class="p">);</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
