<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › percpu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>percpu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * mm/percpu.c - percpu memory allocator</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2009		SUSE Linux Products GmbH</span>
<span class="cm"> * Copyright (C) 2009		Tejun Heo &lt;tj@kernel.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is released under the GPLv2.</span>
<span class="cm"> *</span>
<span class="cm"> * This is percpu allocator which can handle both static and dynamic</span>
<span class="cm"> * areas.  Percpu areas are allocated in chunks.  Each chunk is</span>
<span class="cm"> * consisted of boot-time determined number of units and the first</span>
<span class="cm"> * chunk is used for static percpu variables in the kernel image</span>
<span class="cm"> * (special boot time alloc/init handling necessary as these areas</span>
<span class="cm"> * need to be brought up before allocation services are running).</span>
<span class="cm"> * Unit grows as necessary and all units grow or shrink in unison.</span>
<span class="cm"> * When a chunk is filled up, another chunk is allocated.</span>
<span class="cm"> *</span>
<span class="cm"> *  c0                           c1                         c2</span>
<span class="cm"> *  -------------------          -------------------        ------------</span>
<span class="cm"> * | u0 | u1 | u2 | u3 |        | u0 | u1 | u2 | u3 |      | u0 | u1 | u</span>
<span class="cm"> *  -------------------  ......  -------------------  ....  ------------</span>
<span class="cm"> *</span>
<span class="cm"> * Allocation is done in offset-size areas of single unit space.  Ie,</span>
<span class="cm"> * an area of 512 bytes at 6k in c1 occupies 512 bytes at 6k of c1:u0,</span>
<span class="cm"> * c1:u1, c1:u2 and c1:u3.  On UMA, units corresponds directly to</span>
<span class="cm"> * cpus.  On NUMA, the mapping can be non-linear and even sparse.</span>
<span class="cm"> * Percpu access can be done by configuring percpu base registers</span>
<span class="cm"> * according to cpu to unit mapping and pcpu_unit_size.</span>
<span class="cm"> *</span>
<span class="cm"> * There are usually many small percpu allocations many of them being</span>
<span class="cm"> * as small as 4 bytes.  The allocator organizes chunks into lists</span>
<span class="cm"> * according to free size and tries to allocate from the fullest one.</span>
<span class="cm"> * Each chunk keeps the maximum contiguous area size hint which is</span>
<span class="cm"> * guaranteed to be equal to or larger than the maximum contiguous</span>
<span class="cm"> * area in the chunk.  This helps the allocator not to iterate the</span>
<span class="cm"> * chunk maps unnecessarily.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocation state in each chunk is kept using an array of integers</span>
<span class="cm"> * on chunk-&gt;map.  A positive value in the map represents a free</span>
<span class="cm"> * region and negative allocated.  Allocation inside a chunk is done</span>
<span class="cm"> * by scanning this map sequentially and serving the first matching</span>
<span class="cm"> * entry.  This is mostly copied from the percpu_modalloc() allocator.</span>
<span class="cm"> * Chunks can be determined from the address using the index field</span>
<span class="cm"> * in the page struct. The index field contains a pointer to the chunk.</span>
<span class="cm"> *</span>
<span class="cm"> * To use this allocator, arch code should do the followings.</span>
<span class="cm"> *</span>
<span class="cm"> * - define __addr_to_pcpu_ptr() and __pcpu_ptr_to_addr() to translate</span>
<span class="cm"> *   regular address to percpu pointer and back if they need to be</span>
<span class="cm"> *   different from the default</span>
<span class="cm"> *</span>
<span class="cm"> * - use pcpu_setup_first_chunk() during percpu area initialization to</span>
<span class="cm"> *   setup the first chunk containing the kernel static percpu area</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/pfn.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/kmemleak.h&gt;</span>

<span class="cp">#include &lt;asm/cacheflush.h&gt;</span>
<span class="cp">#include &lt;asm/sections.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>

<span class="cp">#define PCPU_SLOT_BASE_SHIFT		5	</span><span class="cm">/* 1-31 shares the same slot */</span><span class="cp"></span>
<span class="cp">#define PCPU_DFL_MAP_ALLOC		16	</span><span class="cm">/* start a map with 16 ents */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SMP</span>
<span class="cm">/* default addr &lt;-&gt; pcpu_ptr mapping, override in asm/percpu.h if necessary */</span>
<span class="cp">#ifndef __addr_to_pcpu_ptr</span>
<span class="cp">#define __addr_to_pcpu_ptr(addr)					\</span>
<span class="cp">	(void __percpu *)((unsigned long)(addr) -			\</span>
<span class="cp">			  (unsigned long)pcpu_base_addr	+		\</span>
<span class="cp">			  (unsigned long)__per_cpu_start)</span>
<span class="cp">#endif</span>
<span class="cp">#ifndef __pcpu_ptr_to_addr</span>
<span class="cp">#define __pcpu_ptr_to_addr(ptr)						\</span>
<span class="cp">	(void __force *)((unsigned long)(ptr) +				\</span>
<span class="cp">			 (unsigned long)pcpu_base_addr -		\</span>
<span class="cp">			 (unsigned long)__per_cpu_start)</span>
<span class="cp">#endif</span>
<span class="cp">#else	</span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>
<span class="cm">/* on UP, it&#39;s always identity mapped */</span>
<span class="cp">#define __addr_to_pcpu_ptr(addr)	(void __percpu *)(addr)</span>
<span class="cp">#define __pcpu_ptr_to_addr(ptr)		(void __force *)(ptr)</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>		<span class="cm">/* linked to pcpu_slot lists */</span>
	<span class="kt">int</span>			<span class="n">free_size</span><span class="p">;</span>	<span class="cm">/* free bytes in the chunk */</span>
	<span class="kt">int</span>			<span class="n">contig_hint</span><span class="p">;</span>	<span class="cm">/* max contiguous size hint */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">base_addr</span><span class="p">;</span>	<span class="cm">/* base address of this chunk */</span>
	<span class="kt">int</span>			<span class="n">map_used</span><span class="p">;</span>	<span class="cm">/* # of map entries used */</span>
	<span class="kt">int</span>			<span class="n">map_alloc</span><span class="p">;</span>	<span class="cm">/* # of map entries allocated */</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">map</span><span class="p">;</span>		<span class="cm">/* allocation map */</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">data</span><span class="p">;</span>		<span class="cm">/* chunk data */</span>
	<span class="n">bool</span>			<span class="n">immutable</span><span class="p">;</span>	<span class="cm">/* no [de]population allowed */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">populated</span><span class="p">[];</span>	<span class="cm">/* populated bitmap */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pcpu_unit_pages</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcpu_unit_size</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcpu_nr_units</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcpu_atom_size</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcpu_nr_slots</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="n">pcpu_chunk_struct_size</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* cpus with the lowest and highest unit addresses */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcpu_low_unit_cpu</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pcpu_high_unit_cpu</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/* the address of the first chunk which starts with the kernel static area */</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">pcpu_base_addr</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pcpu_base_addr</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pcpu_unit_map</span> <span class="n">__read_mostly</span><span class="p">;</span>		<span class="cm">/* cpu -&gt; unit */</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pcpu_unit_offsets</span> <span class="n">__read_mostly</span><span class="p">;</span>	<span class="cm">/* cpu -&gt; unit offset */</span>

<span class="cm">/* group information, used for vm allocation */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcpu_nr_groups</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pcpu_group_offsets</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">pcpu_group_sizes</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The first chunk which always exists.  Note that unlike other</span>
<span class="cm"> * chunks, this one can be allocated and mapped in several different</span>
<span class="cm"> * ways and thus often doesn&#39;t live in the vmalloc area.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">pcpu_first_chunk</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Optional reserved chunk.  This chunk reserves part of the first</span>
<span class="cm"> * chunk and serves it for reserved allocations.  The amount of</span>
<span class="cm"> * reserved offset is in pcpu_reserved_chunk_limit.  When reserved</span>
<span class="cm"> * area doesn&#39;t exist, the following variables contain NULL and 0</span>
<span class="cm"> * respectively.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">pcpu_reserved_chunk</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcpu_reserved_chunk_limit</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Synchronization rules.</span>
<span class="cm"> *</span>
<span class="cm"> * There are two locks - pcpu_alloc_mutex and pcpu_lock.  The former</span>
<span class="cm"> * protects allocation/reclaim paths, chunks, populated bitmap and</span>
<span class="cm"> * vmalloc mapping.  The latter is a spinlock and protects the index</span>
<span class="cm"> * data structures - chunk slots, chunks and area maps in chunks.</span>
<span class="cm"> *</span>
<span class="cm"> * During allocation, pcpu_alloc_mutex is kept locked all the time and</span>
<span class="cm"> * pcpu_lock is grabbed and released as necessary.  All actual memory</span>
<span class="cm"> * allocations are done using GFP_KERNEL with pcpu_lock released.  In</span>
<span class="cm"> * general, percpu memory can&#39;t be allocated with irq off but</span>
<span class="cm"> * irqsave/restore are still used in alloc path so that it can be used</span>
<span class="cm"> * from early init path - sched_init() specifically.</span>
<span class="cm"> *</span>
<span class="cm"> * Free path accesses and alters only the index data structures, so it</span>
<span class="cm"> * can be safely called from atomic context.  When memory needs to be</span>
<span class="cm"> * returned to the system, free path schedules reclaim_work which</span>
<span class="cm"> * grabs both pcpu_alloc_mutex and pcpu_lock, unlinks chunks to be</span>
<span class="cm"> * reclaimed, release both locks and frees the chunks.  Note that it&#39;s</span>
<span class="cm"> * necessary to grab both locks to remove a chunk from circulation as</span>
<span class="cm"> * allocation path might be referencing the chunk with only</span>
<span class="cm"> * pcpu_alloc_mutex locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">pcpu_alloc_mutex</span><span class="p">);</span>	<span class="cm">/* protects whole alloc and reclaim */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">pcpu_lock</span><span class="p">);</span>	<span class="cm">/* protects index data structures */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pcpu_slot</span> <span class="n">__read_mostly</span><span class="p">;</span> <span class="cm">/* chunk list slots */</span>

<span class="cm">/* reclaim work to release fully free chunks, scheduled from free path */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcpu_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">pcpu_reclaim_work</span><span class="p">,</span> <span class="n">pcpu_reclaim</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">pcpu_addr_in_first_chunk</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">first_start</span> <span class="o">=</span> <span class="n">pcpu_first_chunk</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">first_start</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">first_start</span> <span class="o">+</span> <span class="n">pcpu_unit_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">pcpu_addr_in_reserved_chunk</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">first_start</span> <span class="o">=</span> <span class="n">pcpu_first_chunk</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">first_start</span> <span class="o">&amp;&amp;</span>
		<span class="n">addr</span> <span class="o">&lt;</span> <span class="n">first_start</span> <span class="o">+</span> <span class="n">pcpu_reserved_chunk_limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__pcpu_size_to_slot</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">highbit</span> <span class="o">=</span> <span class="n">fls</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>	<span class="cm">/* size is in bytes */</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">highbit</span> <span class="o">-</span> <span class="n">PCPU_SLOT_BASE_SHIFT</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcpu_size_to_slot</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">pcpu_unit_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pcpu_nr_slots</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__pcpu_size_to_slot</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcpu_chunk_slot</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">||</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">pcpu_size_to_slot</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* set the pointer to a chunk in a page struct */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcpu_set_page_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">pcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pcpu</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* obtain pointer to a chunk from a page struct */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="nf">pcpu_get_page_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__maybe_unused</span> <span class="nf">pcpu_page_idx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pcpu_unit_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">*</span> <span class="n">pcpu_unit_pages</span> <span class="o">+</span> <span class="n">page_idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">pcpu_chunk_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">pcpu_unit_offsets</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">+</span>
		<span class="p">(</span><span class="n">page_idx</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__maybe_unused</span> <span class="nf">pcpu_next_unpop</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="o">*</span><span class="n">rs</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">re</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">rs</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">populated</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">*</span><span class="n">rs</span><span class="p">);</span>
	<span class="o">*</span><span class="n">re</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">populated</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">*</span><span class="n">rs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__maybe_unused</span> <span class="nf">pcpu_next_pop</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="o">*</span><span class="n">rs</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">re</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">rs</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">populated</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">*</span><span class="n">rs</span><span class="p">);</span>
	<span class="o">*</span><span class="n">re</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">populated</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">*</span><span class="n">rs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * (Un)populated page region iterators.  Iterate over (un)populated</span>
<span class="cm"> * page regions between @start and @end in @chunk.  @rs and @re should</span>
<span class="cm"> * be integer variables and will be set to start and end page index of</span>
<span class="cm"> * the current region.</span>
<span class="cm"> */</span>
<span class="cp">#define pcpu_for_each_unpop_region(chunk, rs, re, start, end)		    \</span>
<span class="cp">	for ((rs) = (start), pcpu_next_unpop((chunk), &amp;(rs), &amp;(re), (end)); \</span>
<span class="cp">	     (rs) &lt; (re);						    \</span>
<span class="cp">	     (rs) = (re) + 1, pcpu_next_unpop((chunk), &amp;(rs), &amp;(re), (end)))</span>

<span class="cp">#define pcpu_for_each_pop_region(chunk, rs, re, start, end)		    \</span>
<span class="cp">	for ((rs) = (start), pcpu_next_pop((chunk), &amp;(rs), &amp;(re), (end));   \</span>
<span class="cp">	     (rs) &lt; (re);						    \</span>
<span class="cp">	     (rs) = (re) + 1, pcpu_next_pop((chunk), &amp;(rs), &amp;(re), (end)))</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_mem_zalloc - allocate memory</span>
<span class="cm"> * @size: bytes to allocate</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate @size bytes.  If @size is smaller than PAGE_SIZE,</span>
<span class="cm"> * kzalloc() is used; otherwise, vzalloc() is used.  The returned</span>
<span class="cm"> * memory is always zeroed.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Does GFP_KERNEL allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to the allocated area on success, NULL on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">pcpu_mem_zalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">slab_is_available</span><span class="p">()))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_mem_free - free memory</span>
<span class="cm"> * @ptr: memory to free</span>
<span class="cm"> * @size: size of the area</span>
<span class="cm"> *</span>
<span class="cm"> * Free @ptr.  @ptr should have been allocated using pcpu_mem_zalloc().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcpu_mem_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_chunk_relocate - put chunk in the appropriate chunk slot</span>
<span class="cm"> * @chunk: chunk of interest</span>
<span class="cm"> * @oslot: the previous slot it was on</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called after an allocation or free changed @chunk.</span>
<span class="cm"> * New slot according to the changed state is determined and @chunk is</span>
<span class="cm"> * moved to the slot.  Note that the reserved chunk is never put on</span>
<span class="cm"> * chunk slots.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * pcpu_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcpu_chunk_relocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oslot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nslot</span> <span class="o">=</span> <span class="n">pcpu_chunk_slot</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">!=</span> <span class="n">pcpu_reserved_chunk</span> <span class="o">&amp;&amp;</span> <span class="n">oslot</span> <span class="o">!=</span> <span class="n">nslot</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oslot</span> <span class="o">&lt;</span> <span class="n">nslot</span><span class="p">)</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcpu_slot</span><span class="p">[</span><span class="n">nslot</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcpu_slot</span><span class="p">[</span><span class="n">nslot</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_need_to_extend - determine whether chunk area map needs to be extended</span>
<span class="cm"> * @chunk: chunk of interest</span>
<span class="cm"> *</span>
<span class="cm"> * Determine whether area map of @chunk needs to be extended to</span>
<span class="cm"> * accommodate a new allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * pcpu_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * New target map allocation length if extension is necessary, 0</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcpu_need_to_extend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">new_alloc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_alloc</span> <span class="o">&gt;=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">new_alloc</span> <span class="o">=</span> <span class="n">PCPU_DFL_MAP_ALLOC</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">new_alloc</span> <span class="o">&lt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">new_alloc</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">new_alloc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_extend_area_map - extend area map of a chunk</span>
<span class="cm"> * @chunk: chunk of interest</span>
<span class="cm"> * @new_alloc: new target allocation length of the area map</span>
<span class="cm"> *</span>
<span class="cm"> * Extend area map of @chunk to have @new_alloc entries.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Does GFP_KERNEL allocation.  Grabs and releases pcpu_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcpu_extend_area_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">old_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_size</span> <span class="o">=</span> <span class="n">new_alloc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">pcpu_mem_zalloc</span><span class="p">(</span><span class="n">new_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* acquire pcpu_lock and switch to new area map */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_alloc</span> <span class="o">&lt;=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_alloc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">old_size</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_alloc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">old_size</span><span class="p">);</span>

	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_alloc</span> <span class="o">=</span> <span class="n">new_alloc</span><span class="p">;</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * pcpu_mem_free() might end up calling vfree() which uses</span>
<span class="cm">	 * IRQ-unsafe lock and thus can&#39;t be called under pcpu_lock.</span>
<span class="cm">	 */</span>
	<span class="n">pcpu_mem_free</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">old_size</span><span class="p">);</span>
	<span class="n">pcpu_mem_free</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_split_block - split a map block</span>
<span class="cm"> * @chunk: chunk of interest</span>
<span class="cm"> * @i: index of map block to split</span>
<span class="cm"> * @head: head size in bytes (can be 0)</span>
<span class="cm"> * @tail: tail size in bytes (can be 0)</span>
<span class="cm"> *</span>
<span class="cm"> * Split the @i&#39;th map block into two or three blocks.  If @head is</span>
<span class="cm"> * non-zero, @head bytes block is inserted before block @i moving it</span>
<span class="cm"> * to @i+1 and reducing its size by @head bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * If @tail is non-zero, the target block, which can be @i or @i+1</span>
<span class="cm"> * depending on @head, is reduced by @tail bytes and @tail byte block</span>
<span class="cm"> * is inserted after the target block.</span>
<span class="cm"> *</span>
<span class="cm"> * @chunk-&gt;map must have enough free slots to accommodate the split.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * pcpu_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcpu_split_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tail</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_extra</span> <span class="o">=</span> <span class="o">!!</span><span class="n">head</span> <span class="o">+</span> <span class="o">!!</span><span class="n">tail</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_alloc</span> <span class="o">&lt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span> <span class="o">+</span> <span class="n">nr_extra</span><span class="p">);</span>

	<span class="cm">/* insert new subblocks */</span>
	<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">nr_extra</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span> <span class="o">+=</span> <span class="n">nr_extra</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">head</span><span class="p">;</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tail</span><span class="p">;</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_alloc_area - allocate area from a pcpu_chunk</span>
<span class="cm"> * @chunk: chunk of interest</span>
<span class="cm"> * @size: wanted size in bytes</span>
<span class="cm"> * @align: wanted align</span>
<span class="cm"> *</span>
<span class="cm"> * Try to allocate @size bytes area aligned at @align from @chunk.</span>
<span class="cm"> * Note that this function only allocates the offset.  It doesn&#39;t</span>
<span class="cm"> * populate or map the area.</span>
<span class="cm"> *</span>
<span class="cm"> * @chunk-&gt;map must have at least two free slots.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * pcpu_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Allocated offset in @chunk on success, -1 if no matching area is</span>
<span class="cm"> * found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pcpu_alloc_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">oslot</span> <span class="o">=</span> <span class="n">pcpu_chunk_slot</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">max_contig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">off</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span><span class="p">;</span> <span class="n">off</span> <span class="o">+=</span> <span class="n">abs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]))</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">is_last</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">;</span>

		<span class="cm">/* extra for alignment requirement */</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">off</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">head</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">head</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">max_contig</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">max_contig</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If head is small or the previous block is free,</span>
<span class="cm">		 * merge&#39;em.  Note that &#39;small&#39; is defined as smaller</span>
<span class="cm">		 * than sizeof(int), which is very small but isn&#39;t too</span>
<span class="cm">		 * uncommon for percpu allocations.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">head</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">||</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">head</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">head</span><span class="p">;</span>
				<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">-=</span> <span class="n">head</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">head</span><span class="p">;</span>
			<span class="n">off</span> <span class="o">+=</span> <span class="n">head</span><span class="p">;</span>
			<span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* if tail is small, just keep it around */</span>
		<span class="n">tail</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">head</span> <span class="o">-</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tail</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
			<span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* split if warranted */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">||</span> <span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pcpu_split_block</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
				<span class="n">off</span> <span class="o">+=</span> <span class="n">head</span><span class="p">;</span>
				<span class="n">max_contig</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">max_contig</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tail</span><span class="p">)</span>
				<span class="n">max_contig</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">max_contig</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* update hint and mark allocated */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_last</span><span class="p">)</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span> <span class="o">=</span> <span class="n">max_contig</span><span class="p">;</span> <span class="cm">/* fully scanned */</span>
		<span class="k">else</span>
			<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span><span class="p">,</span>
						 <span class="n">max_contig</span><span class="p">);</span>

		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">-=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">pcpu_chunk_relocate</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">oslot</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">off</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span> <span class="o">=</span> <span class="n">max_contig</span><span class="p">;</span>	<span class="cm">/* fully scanned */</span>
	<span class="n">pcpu_chunk_relocate</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">oslot</span><span class="p">);</span>

	<span class="cm">/* tell the upper layer that this chunk has no matching area */</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_free_area - free area to a pcpu_chunk</span>
<span class="cm"> * @chunk: chunk of interest</span>
<span class="cm"> * @freeme: offset of area to free</span>
<span class="cm"> *</span>
<span class="cm"> * Free area starting from @freeme to @chunk.  Note that this function</span>
<span class="cm"> * only modifies the allocation map.  It doesn&#39;t depopulate or unmap</span>
<span class="cm"> * the area.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * pcpu_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcpu_free_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">freeme</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">oslot</span> <span class="o">=</span> <span class="n">pcpu_chunk_slot</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">off</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span><span class="p">;</span> <span class="n">off</span> <span class="o">+=</span> <span class="n">abs</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">==</span> <span class="n">freeme</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">off</span> <span class="o">!=</span> <span class="n">freeme</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">+=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/* merge with previous? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span><span class="o">--</span><span class="p">;</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
			<span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* merge with next? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span> <span class="o">&amp;&amp;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span><span class="o">--</span><span class="p">;</span>
		<span class="n">memmove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span>
			<span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="p">}</span>

	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span><span class="p">);</span>
	<span class="n">pcpu_chunk_relocate</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">oslot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="nf">pcpu_alloc_chunk</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>

	<span class="n">chunk</span> <span class="o">=</span> <span class="n">pcpu_mem_zalloc</span><span class="p">(</span><span class="n">pcpu_chunk_struct_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span> <span class="o">=</span> <span class="n">pcpu_mem_zalloc</span><span class="p">(</span><span class="n">PCPU_DFL_MAP_ALLOC</span> <span class="o">*</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_alloc</span> <span class="o">=</span> <span class="n">PCPU_DFL_MAP_ALLOC</span><span class="p">;</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_used</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcpu_unit_size</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">=</span> <span class="n">pcpu_unit_size</span><span class="p">;</span>
	<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span> <span class="o">=</span> <span class="n">pcpu_unit_size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">chunk</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcpu_free_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">pcpu_mem_free</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map_alloc</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Chunk management implementation.</span>
<span class="cm"> *</span>
<span class="cm"> * To allow different implementations, chunk alloc/free and</span>
<span class="cm"> * [de]population are implemented in a separate file which is pulled</span>
<span class="cm"> * into this file and compiled together.  The following functions</span>
<span class="cm"> * should be implemented.</span>
<span class="cm"> *</span>
<span class="cm"> * pcpu_populate_chunk		- populate the specified range of a chunk</span>
<span class="cm"> * pcpu_depopulate_chunk	- depopulate the specified range of a chunk</span>
<span class="cm"> * pcpu_create_chunk		- create a new chunk</span>
<span class="cm"> * pcpu_destroy_chunk		- destroy a chunk, always preceded by full depop</span>
<span class="cm"> * pcpu_addr_to_page		- translate address to physical address</span>
<span class="cm"> * pcpu_verify_alloc_info	- check alloc_info is acceptable during init</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pcpu_populate_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcpu_depopulate_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">pcpu_create_chunk</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">pcpu_destroy_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pcpu_addr_to_page</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="n">pcpu_verify_alloc_info</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NEED_PER_CPU_KM</span>
<span class="cp">#include &quot;percpu-km.c&quot;</span>
<span class="cp">#else</span>
<span class="cp">#include &quot;percpu-vm.c&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_chunk_addr_search - determine chunk containing specified address</span>
<span class="cm"> * @addr: address for which the chunk needs to be determined.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * The address of the found chunk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="nf">pcpu_chunk_addr_search</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* is it in the first chunk? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcpu_addr_in_first_chunk</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* is it in the reserved area? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcpu_addr_in_reserved_chunk</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">pcpu_reserved_chunk</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">pcpu_first_chunk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The address is relative to unit0 which might be unused and</span>
<span class="cm">	 * thus unmapped.  Offset the address to the unit space of the</span>
<span class="cm">	 * current processor before looking it up in the vmalloc</span>
<span class="cm">	 * space.  Note that any possible cpu id can be used here, so</span>
<span class="cm">	 * there&#39;s no need to worry about preemption or cpu hotplug.</span>
<span class="cm">	 */</span>
	<span class="n">addr</span> <span class="o">+=</span> <span class="n">pcpu_unit_offsets</span><span class="p">[</span><span class="n">raw_smp_processor_id</span><span class="p">()];</span>
	<span class="k">return</span> <span class="n">pcpu_get_page_chunk</span><span class="p">(</span><span class="n">pcpu_addr_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_alloc - the percpu allocator</span>
<span class="cm"> * @size: size of area to allocate in bytes</span>
<span class="cm"> * @align: alignment of area (max PAGE_SIZE)</span>
<span class="cm"> * @reserved: allocate from the reserved chunk if available</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate percpu area of @size bytes aligned at @align.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Does GFP_KERNEL allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Percpu pointer to the allocated area on success, NULL on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="nf">pcpu_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">align</span><span class="p">,</span> <span class="n">bool</span> <span class="n">reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">warn_limit</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">new_alloc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">size</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">PCPU_MIN_UNIT_SIZE</span> <span class="o">||</span> <span class="n">align</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="s">&quot;illegal size (%zu) or align (%zu) for &quot;</span>
		     <span class="s">&quot;percpu allocation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_alloc_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* serve reserved allocations from the reserved chunk if available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reserved</span> <span class="o">&amp;&amp;</span> <span class="n">pcpu_reserved_chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chunk</span> <span class="o">=</span> <span class="n">pcpu_reserved_chunk</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="s">&quot;alloc from reserved chunk failed&quot;</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">new_alloc</span> <span class="o">=</span> <span class="n">pcpu_need_to_extend</span><span class="p">(</span><span class="n">chunk</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcpu_extend_area_map</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">new_alloc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="s">&quot;failed to extend area map of reserved chunk&quot;</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fail_unlock_mutex</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">off</span> <span class="o">=</span> <span class="n">pcpu_alloc_area</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">area_found</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="s">&quot;alloc from reserved chunk failed&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_unlock</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">restart:</span>
	<span class="cm">/* search through normal chunks */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="n">pcpu_size_to_slot</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="n">slot</span> <span class="o">&lt;</span> <span class="n">pcpu_nr_slots</span><span class="p">;</span> <span class="n">slot</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcpu_slot</span><span class="p">[</span><span class="n">slot</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">new_alloc</span> <span class="o">=</span> <span class="n">pcpu_need_to_extend</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_alloc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pcpu_extend_area_map</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span>
							 <span class="n">new_alloc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="s">&quot;failed to extend area map&quot;</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">fail_unlock_mutex</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * pcpu_lock has been dropped, need to</span>
<span class="cm">				 * restart cpu_slot list walking.</span>
<span class="cm">				 */</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">off</span> <span class="o">=</span> <span class="n">pcpu_alloc_area</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">area_found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* hmmm... no space left, create a new chunk */</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">chunk</span> <span class="o">=</span> <span class="n">pcpu_create_chunk</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="s">&quot;failed to allocate new chunk&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_unlock_mutex</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">pcpu_chunk_relocate</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>

<span class="nl">area_found:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* populate, map and clear the area */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcpu_populate_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">pcpu_free_area</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="s">&quot;failed to populate&quot;</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_alloc_mutex</span><span class="p">);</span>

	<span class="cm">/* return address relative to base address */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">__addr_to_pcpu_ptr</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">+</span> <span class="n">off</span><span class="p">);</span>
	<span class="n">kmemleak_alloc_percpu</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>

<span class="nl">fail_unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">fail_unlock_mutex:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_alloc_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">warn_limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;PERCPU: allocation failed, size=%zu align=%zu, &quot;</span>
			   <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">warn_limit</span><span class="p">)</span>
			<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;PERCPU: limit reached, disable warning</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __alloc_percpu - allocate dynamic percpu area</span>
<span class="cm"> * @size: size of area to allocate in bytes</span>
<span class="cm"> * @align: alignment of area (max PAGE_SIZE)</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate zero-filled percpu area of @size bytes aligned at @align.</span>
<span class="cm"> * Might sleep.  Might trigger writeouts.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Does GFP_KERNEL allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Percpu pointer to the allocated area on success, NULL on failure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="nf">__alloc_percpu</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pcpu_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__alloc_percpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __alloc_reserved_percpu - allocate reserved percpu area</span>
<span class="cm"> * @size: size of area to allocate in bytes</span>
<span class="cm"> * @align: alignment of area (max PAGE_SIZE)</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate zero-filled percpu area of @size bytes aligned at @align</span>
<span class="cm"> * from reserved percpu area if arch has set it up; otherwise,</span>
<span class="cm"> * allocation is served from the same dynamic area.  Might sleep.</span>
<span class="cm"> * Might trigger writeouts.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Does GFP_KERNEL allocation.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Percpu pointer to the allocated area on success, NULL on failure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="nf">__alloc_reserved_percpu</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pcpu_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_reclaim - reclaim fully free chunks, workqueue function</span>
<span class="cm"> * @work: unused</span>
<span class="cm"> *</span>
<span class="cm"> * Reclaim all fully free chunks except for the first one.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * workqueue context.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcpu_reclaim</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">todo</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pcpu_slot</span><span class="p">[</span><span class="n">pcpu_nr_slots</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_alloc_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">immutable</span><span class="p">);</span>

		<span class="cm">/* spare the first one */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">==</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pcpu_chunk</span><span class="p">,</span> <span class="n">list</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">todo</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">todo</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pcpu_depopulate_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pcpu_unit_size</span><span class="p">);</span>
		<span class="n">pcpu_destroy_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_alloc_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_percpu - free percpu area</span>
<span class="cm"> * @ptr: pointer to area to free</span>
<span class="cm"> *</span>
<span class="cm"> * Free percpu area @ptr.</span>
<span class="cm"> *</span>
<span class="cm"> * CONTEXT:</span>
<span class="cm"> * Can be called from atomic context.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">free_percpu</span><span class="p">(</span><span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kmemleak_free_percpu</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

	<span class="n">addr</span> <span class="o">=</span> <span class="n">__pcpu_ptr_to_addr</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">chunk</span> <span class="o">=</span> <span class="n">pcpu_chunk_addr_search</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">off</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">;</span>

	<span class="n">pcpu_free_area</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>

	<span class="cm">/* if there are more than one fully free chunks, wake up grim reaper */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">==</span> <span class="n">pcpu_unit_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcpu_slot</span><span class="p">[</span><span class="n">pcpu_nr_slots</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">chunk</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_reclaim_work</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">free_percpu</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * is_kernel_percpu_address - test whether address is from static percpu area</span>
<span class="cm"> * @addr: address to test</span>
<span class="cm"> *</span>
<span class="cm"> * Test whether @addr belongs to in-kernel static percpu area.  Module</span>
<span class="cm"> * static percpu areas are not considered.  For those, use</span>
<span class="cm"> * is_module_percpu_address().</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * %true if @addr is from in-kernel static percpu area, %false otherwise.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">is_kernel_percpu_address</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">static_size</span> <span class="o">=</span> <span class="n">__per_cpu_end</span> <span class="o">-</span> <span class="n">__per_cpu_start</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">__addr_to_pcpu_ptr</span><span class="p">(</span><span class="n">pcpu_base_addr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">static_size</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* on UP, can&#39;t distinguish from other static vars, always false */</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * per_cpu_ptr_to_phys - convert translated percpu address to physical address</span>
<span class="cm"> * @addr: the address to be converted to physical address</span>
<span class="cm"> *</span>
<span class="cm"> * Given @addr which is dereferenceable address obtained via one of</span>
<span class="cm"> * percpu access macros, this function translates it into its physical</span>
<span class="cm"> * address.  The caller is responsible for ensuring @addr stays valid</span>
<span class="cm"> * until this function finishes.</span>
<span class="cm"> *</span>
<span class="cm"> * percpu allocator has special setup for the first chunk, which currently</span>
<span class="cm"> * supports either embedding in linear address space or vmalloc mapping,</span>
<span class="cm"> * and, from the second one, the backing allocator (currently either vm or</span>
<span class="cm"> * km) provides translation.</span>
<span class="cm"> *</span>
<span class="cm"> * The addr can be tranlated simply without checking if it falls into the</span>
<span class="cm"> * first chunk. But the current code reflects better how percpu allocator</span>
<span class="cm"> * actually works, and the verification can discover both bugs in percpu</span>
<span class="cm"> * allocator itself and per_cpu_ptr_to_phys() callers. So we keep current</span>
<span class="cm"> * code.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * The physical address for @addr.</span>
<span class="cm"> */</span>
<span class="n">phys_addr_t</span> <span class="nf">per_cpu_ptr_to_phys</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">__addr_to_pcpu_ptr</span><span class="p">(</span><span class="n">pcpu_base_addr</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">in_first_chunk</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_low</span><span class="p">,</span> <span class="n">first_high</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following test on unit_low/high isn&#39;t strictly</span>
<span class="cm">	 * necessary but will speed up lookups of addresses which</span>
<span class="cm">	 * aren&#39;t in the first chunk.</span>
<span class="cm">	 */</span>
	<span class="n">first_low</span> <span class="o">=</span> <span class="n">pcpu_chunk_addr</span><span class="p">(</span><span class="n">pcpu_first_chunk</span><span class="p">,</span> <span class="n">pcpu_low_unit_cpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">first_high</span> <span class="o">=</span> <span class="n">pcpu_chunk_addr</span><span class="p">(</span><span class="n">pcpu_first_chunk</span><span class="p">,</span> <span class="n">pcpu_high_unit_cpu</span><span class="p">,</span>
				     <span class="n">pcpu_unit_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">first_low</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">addr</span> <span class="o">&lt;</span> <span class="n">first_high</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">pcpu_unit_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">in_first_chunk</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">in_first_chunk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_vmalloc_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">__pa</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">vmalloc_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="o">+</span>
			       <span class="n">offset_in_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">pcpu_addr_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="o">+</span>
		       <span class="n">offset_in_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_alloc_alloc_info - allocate percpu allocation info</span>
<span class="cm"> * @nr_groups: the number of groups</span>
<span class="cm"> * @nr_units: the number of units</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate ai which is large enough for @nr_groups groups containing</span>
<span class="cm"> * @nr_units units.  The returned ai&#39;s groups[0].cpu_map points to the</span>
<span class="cm"> * cpu_map array which is long enough for @nr_units and filled with</span>
<span class="cm"> * NR_CPUS.  It&#39;s the caller&#39;s responsibility to initialize cpu_map</span>
<span class="cm"> * pointer of other groups.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * Pointer to the allocated pcpu_alloc_info on success, NULL on</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">pcpu_alloc_alloc_info</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr_groups</span><span class="p">,</span>
						      <span class="kt">int</span> <span class="n">nr_units</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">base_size</span><span class="p">,</span> <span class="n">ai_size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unit</span><span class="p">;</span>

	<span class="n">base_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ai</span><span class="p">)</span> <span class="o">+</span> <span class="n">nr_groups</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			  <span class="n">__alignof__</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cpu_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">ai_size</span> <span class="o">=</span> <span class="n">base_size</span> <span class="o">+</span> <span class="n">nr_units</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cpu_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">alloc_bootmem_nopanic</span><span class="p">(</span><span class="n">PFN_ALIGN</span><span class="p">(</span><span class="n">ai_size</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ai</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">+=</span> <span class="n">base_size</span><span class="p">;</span>

	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cpu_map</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">unit</span> <span class="o">&lt;</span> <span class="n">nr_units</span><span class="p">;</span> <span class="n">unit</span><span class="o">++</span><span class="p">)</span>
		<span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cpu_map</span><span class="p">[</span><span class="n">unit</span><span class="p">]</span> <span class="o">=</span> <span class="n">NR_CPUS</span><span class="p">;</span>

	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span> <span class="o">=</span> <span class="n">nr_groups</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">__ai_size</span> <span class="o">=</span> <span class="n">PFN_ALIGN</span><span class="p">(</span><span class="n">ai_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ai</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_free_alloc_info - free percpu allocation info</span>
<span class="cm"> * @ai: pcpu_alloc_info to free</span>
<span class="cm"> *</span>
<span class="cm"> * Free @ai which was allocated by pcpu_alloc_alloc_info().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">pcpu_free_alloc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_bootmem</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">__ai_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_dump_alloc_info - print out information about pcpu_alloc_info</span>
<span class="cm"> * @lvl: loglevel</span>
<span class="cm"> * @ai: allocation info to dump</span>
<span class="cm"> *</span>
<span class="cm"> * Print out information about @ai using loglevel @lvl.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcpu_dump_alloc_info</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lvl</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">group_width</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cpu_width</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">empty_str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;--------&quot;</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alloc_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">upa</span><span class="p">,</span> <span class="n">apl</span><span class="p">;</span>	<span class="cm">/* units per alloc, allocs per line */</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">v</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">)</span>
		<span class="n">group_width</span><span class="o">++</span><span class="p">;</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">num_possible_cpus</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">v</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">)</span>
		<span class="n">cpu_width</span><span class="o">++</span><span class="p">;</span>
	<span class="n">empty_str</span><span class="p">[</span><span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">cpu_width</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">empty_str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">upa</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">alloc_size</span> <span class="o">/</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">;</span>
	<span class="n">width</span> <span class="o">=</span> <span class="n">upa</span> <span class="o">*</span> <span class="p">(</span><span class="n">cpu_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">group_width</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">apl</span> <span class="o">=</span> <span class="n">rounddown_pow_of_two</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mi">60</span> <span class="o">/</span> <span class="n">width</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%spcpu-alloc: s%zu r%zu d%zu u%zu alloc=%zu*%zu&quot;</span><span class="p">,</span>
	       <span class="n">lvl</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">reserved_size</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">dyn_size</span><span class="p">,</span>
	       <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">alloc_size</span> <span class="o">/</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">atom_size</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">atom_size</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">pcpu_group_info</span> <span class="o">*</span><span class="n">gi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">unit_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span> <span class="o">%</span> <span class="n">upa</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">alloc_end</span> <span class="o">+=</span> <span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span> <span class="o">/</span> <span class="n">upa</span><span class="p">;</span>
		     <span class="n">alloc</span> <span class="o">&lt;</span> <span class="n">alloc_end</span><span class="p">;</span> <span class="n">alloc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">alloc</span> <span class="o">%</span> <span class="n">apl</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%spcpu-alloc: &quot;</span><span class="p">,</span> <span class="n">lvl</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;[%0*d] &quot;</span><span class="p">,</span> <span class="n">group_width</span><span class="p">,</span> <span class="n">group</span><span class="p">);</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">unit_end</span> <span class="o">+=</span> <span class="n">upa</span><span class="p">;</span> <span class="n">unit</span> <span class="o">&lt;</span> <span class="n">unit_end</span><span class="p">;</span> <span class="n">unit</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">gi</span><span class="o">-&gt;</span><span class="n">cpu_map</span><span class="p">[</span><span class="n">unit</span><span class="p">]</span> <span class="o">!=</span> <span class="n">NR_CPUS</span><span class="p">)</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%0*d &quot;</span><span class="p">,</span> <span class="n">cpu_width</span><span class="p">,</span>
					       <span class="n">gi</span><span class="o">-&gt;</span><span class="n">cpu_map</span><span class="p">[</span><span class="n">unit</span><span class="p">]);</span>
				<span class="k">else</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">empty_str</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CONT</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * pcpu_setup_first_chunk - initialize the first percpu chunk</span>
<span class="cm"> * @ai: pcpu_alloc_info describing how to percpu area is shaped</span>
<span class="cm"> * @base_addr: mapped address</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize the first percpu chunk which contains the kernel static</span>
<span class="cm"> * perpcu area.  This function is to be called from arch percpu area</span>
<span class="cm"> * setup path.</span>
<span class="cm"> *</span>
<span class="cm"> * @ai contains all information necessary to initialize the first</span>
<span class="cm"> * chunk and prime the dynamic percpu allocator.</span>
<span class="cm"> *</span>
<span class="cm"> * @ai-&gt;static_size is the size of static percpu area.</span>
<span class="cm"> *</span>
<span class="cm"> * @ai-&gt;reserved_size, if non-zero, specifies the amount of bytes to</span>
<span class="cm"> * reserve after the static area in the first chunk.  This reserves</span>
<span class="cm"> * the first chunk such that it&#39;s available only through reserved</span>
<span class="cm"> * percpu allocation.  This is primarily used to serve module percpu</span>
<span class="cm"> * static areas on architectures where the addressing model has</span>
<span class="cm"> * limited offset range for symbol relocations to guarantee module</span>
<span class="cm"> * percpu symbols fall inside the relocatable range.</span>
<span class="cm"> *</span>
<span class="cm"> * @ai-&gt;dyn_size determines the number of bytes available for dynamic</span>
<span class="cm"> * allocation in the first chunk.  The area between @ai-&gt;static_size +</span>
<span class="cm"> * @ai-&gt;reserved_size + @ai-&gt;dyn_size and @ai-&gt;unit_size is unused.</span>
<span class="cm"> *</span>
<span class="cm"> * @ai-&gt;unit_size specifies unit size and must be aligned to PAGE_SIZE</span>
<span class="cm"> * and equal to or larger than @ai-&gt;static_size + @ai-&gt;reserved_size +</span>
<span class="cm"> * @ai-&gt;dyn_size.</span>
<span class="cm"> *</span>
<span class="cm"> * @ai-&gt;atom_size is the allocation atom size and used as alignment</span>
<span class="cm"> * for vm areas.</span>
<span class="cm"> *</span>
<span class="cm"> * @ai-&gt;alloc_size is the allocation size and always multiple of</span>
<span class="cm"> * @ai-&gt;atom_size.  This is larger than @ai-&gt;atom_size if</span>
<span class="cm"> * @ai-&gt;unit_size is larger than @ai-&gt;atom_size.</span>
<span class="cm"> *</span>
<span class="cm"> * @ai-&gt;nr_groups and @ai-&gt;groups describe virtual memory layout of</span>
<span class="cm"> * percpu areas.  Units which should be colocated are put into the</span>
<span class="cm"> * same group.  Dynamic VM areas will be allocated according to these</span>
<span class="cm"> * groupings.  If @ai-&gt;nr_groups is zero, a single group containing</span>
<span class="cm"> * all units is assumed.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller should have mapped the first chunk at @base_addr and</span>
<span class="cm"> * copied static data to each unit.</span>
<span class="cm"> *</span>
<span class="cm"> * If the first chunk ends up with both reserved and dynamic areas, it</span>
<span class="cm"> * is served by two chunks - one to serve the core static and reserved</span>
<span class="cm"> * areas and the other for the dynamic area.  They share the same vm</span>
<span class="cm"> * and page map but uses different area allocation map to stay away</span>
<span class="cm"> * from each other.  The latter chunk is circulated in the chunk slots</span>
<span class="cm"> * and available for dynamic allocation like any other chunks.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">pcpu_setup_first_chunk</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">base_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">cpus_buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">smap</span><span class="p">[</span><span class="n">PERCPU_DYNAMIC_EARLY_SLOTS</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">dmap</span><span class="p">[</span><span class="n">PERCPU_DYNAMIC_EARLY_SLOTS</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">dyn_size</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">dyn_size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size_sum</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span> <span class="o">+</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">reserved_size</span> <span class="o">+</span> <span class="n">dyn_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">schunk</span><span class="p">,</span> <span class="o">*</span><span class="n">dchunk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">group_offsets</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="o">*</span><span class="n">group_sizes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">unit_off</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">unit_map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cpumask_scnprintf</span><span class="p">(</span><span class="n">cpus_buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cpus_buf</span><span class="p">),</span> <span class="n">cpu_possible_mask</span><span class="p">);</span>

<span class="cp">#define PCPU_SETUP_BUG_ON(cond)	do {					\</span>
<span class="cp">	if (unlikely(cond)) {						\</span>
<span class="cp">		pr_emerg(&quot;PERCPU: failed to initialize, %s&quot;, #cond);	\</span>
<span class="cp">		pr_emerg(&quot;PERCPU: cpu_possible_mask=%s\n&quot;, cpus_buf);	\</span>
<span class="cp">		pcpu_dump_alloc_info(KERN_EMERG, ai);			\</span>
<span class="cp">		BUG();							\</span>
<span class="cp">	}								\</span>
<span class="cp">} while (0)</span>

	<span class="cm">/* sanity checks */</span>
	<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_SMP</span>
	<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span><span class="p">);</span>
	<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__per_cpu_start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">base_addr</span><span class="p">);</span>
	<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">base_addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>
	<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span> <span class="o">&lt;</span> <span class="n">size_sum</span><span class="p">);</span>
	<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>
	<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span> <span class="o">&lt;</span> <span class="n">PCPU_MIN_UNIT_SIZE</span><span class="p">);</span>
	<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">dyn_size</span> <span class="o">&lt;</span> <span class="n">PERCPU_DYNAMIC_EARLY_SIZE</span><span class="p">);</span>
	<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="n">pcpu_verify_alloc_info</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* process group information and build config tables accordingly */</span>
	<span class="n">group_offsets</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">group_offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">group_sizes</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">group_sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">unit_map</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">unit_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">unit_off</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">nr_cpu_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">unit_off</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cpu</span> <span class="o">&lt;</span> <span class="n">nr_cpu_ids</span><span class="p">;</span> <span class="n">cpu</span><span class="o">++</span><span class="p">)</span>
		<span class="n">unit_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>

	<span class="n">pcpu_low_unit_cpu</span> <span class="o">=</span> <span class="n">NR_CPUS</span><span class="p">;</span>
	<span class="n">pcpu_high_unit_cpu</span> <span class="o">=</span> <span class="n">NR_CPUS</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">,</span> <span class="n">unit</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">pcpu_group_info</span> <span class="o">*</span><span class="n">gi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">];</span>

		<span class="n">group_offsets</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">gi</span><span class="o">-&gt;</span><span class="n">base_offset</span><span class="p">;</span>
		<span class="n">group_sizes</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span> <span class="o">*</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">gi</span><span class="o">-&gt;</span><span class="n">cpu_map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">NR_CPUS</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="n">cpu</span> <span class="o">&gt;</span> <span class="n">nr_cpu_ids</span><span class="p">);</span>
			<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">));</span>
			<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="n">unit_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">!=</span> <span class="n">UINT_MAX</span><span class="p">);</span>

			<span class="n">unit_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">unit_off</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">gi</span><span class="o">-&gt;</span><span class="n">base_offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">;</span>

			<span class="cm">/* determine low/high unit_cpu */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcpu_low_unit_cpu</span> <span class="o">==</span> <span class="n">NR_CPUS</span> <span class="o">||</span>
			    <span class="n">unit_off</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">unit_off</span><span class="p">[</span><span class="n">pcpu_low_unit_cpu</span><span class="p">])</span>
				<span class="n">pcpu_low_unit_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcpu_high_unit_cpu</span> <span class="o">==</span> <span class="n">NR_CPUS</span> <span class="o">||</span>
			    <span class="n">unit_off</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">unit_off</span><span class="p">[</span><span class="n">pcpu_high_unit_cpu</span><span class="p">])</span>
				<span class="n">pcpu_high_unit_cpu</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pcpu_nr_units</span> <span class="o">=</span> <span class="n">unit</span><span class="p">;</span>

	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">PCPU_SETUP_BUG_ON</span><span class="p">(</span><span class="n">unit_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">==</span> <span class="n">UINT_MAX</span><span class="p">);</span>

	<span class="cm">/* we&#39;re done parsing the input, undefine BUG macro and dump config */</span>
<span class="cp">#undef PCPU_SETUP_BUG_ON</span>
	<span class="n">pcpu_dump_alloc_info</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">ai</span><span class="p">);</span>

	<span class="n">pcpu_nr_groups</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span><span class="p">;</span>
	<span class="n">pcpu_group_offsets</span> <span class="o">=</span> <span class="n">group_offsets</span><span class="p">;</span>
	<span class="n">pcpu_group_sizes</span> <span class="o">=</span> <span class="n">group_sizes</span><span class="p">;</span>
	<span class="n">pcpu_unit_map</span> <span class="o">=</span> <span class="n">unit_map</span><span class="p">;</span>
	<span class="n">pcpu_unit_offsets</span> <span class="o">=</span> <span class="n">unit_off</span><span class="p">;</span>

	<span class="cm">/* determine basic parameters */</span>
	<span class="n">pcpu_unit_pages</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">pcpu_unit_size</span> <span class="o">=</span> <span class="n">pcpu_unit_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">pcpu_atom_size</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">atom_size</span><span class="p">;</span>
	<span class="n">pcpu_chunk_struct_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pcpu_chunk</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">BITS_TO_LONGS</span><span class="p">(</span><span class="n">pcpu_unit_pages</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate chunk slots.  The additional last slot is for</span>
<span class="cm">	 * empty chunks.</span>
<span class="cm">	 */</span>
	<span class="n">pcpu_nr_slots</span> <span class="o">=</span> <span class="n">__pcpu_size_to_slot</span><span class="p">(</span><span class="n">pcpu_unit_size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">pcpu_slot</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">pcpu_nr_slots</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pcpu_slot</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pcpu_nr_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_slot</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize static chunk.  If reserved_size is zero, the</span>
<span class="cm">	 * static chunk covers static area + dynamic allocation area</span>
<span class="cm">	 * in the first chunk.  If reserved_size is not zero, it</span>
<span class="cm">	 * covers static area + reserved area (mostly used for module</span>
<span class="cm">	 * static percpu allocation).</span>
<span class="cm">	 */</span>
	<span class="n">schunk</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">pcpu_chunk_struct_size</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">schunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">schunk</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">base_addr</span><span class="p">;</span>
	<span class="n">schunk</span><span class="o">-&gt;</span><span class="n">map</span> <span class="o">=</span> <span class="n">smap</span><span class="p">;</span>
	<span class="n">schunk</span><span class="o">-&gt;</span><span class="n">map_alloc</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">smap</span><span class="p">);</span>
	<span class="n">schunk</span><span class="o">-&gt;</span><span class="n">immutable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">bitmap_fill</span><span class="p">(</span><span class="n">schunk</span><span class="o">-&gt;</span><span class="n">populated</span><span class="p">,</span> <span class="n">pcpu_unit_pages</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">reserved_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schunk</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">reserved_size</span><span class="p">;</span>
		<span class="n">pcpu_reserved_chunk</span> <span class="o">=</span> <span class="n">schunk</span><span class="p">;</span>
		<span class="n">pcpu_reserved_chunk_limit</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span> <span class="o">+</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">reserved_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">schunk</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">=</span> <span class="n">dyn_size</span><span class="p">;</span>
		<span class="n">dyn_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/* dynamic area covered */</span>
	<span class="p">}</span>
	<span class="n">schunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span> <span class="o">=</span> <span class="n">schunk</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">;</span>

	<span class="n">schunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">schunk</span><span class="o">-&gt;</span><span class="n">map_used</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">schunk</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">)</span>
		<span class="n">schunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">schunk</span><span class="o">-&gt;</span><span class="n">map_used</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">schunk</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">;</span>

	<span class="cm">/* init dynamic chunk if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dyn_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dchunk</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">pcpu_chunk_struct_size</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">base_addr</span> <span class="o">=</span> <span class="n">base_addr</span><span class="p">;</span>
		<span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">map</span> <span class="o">=</span> <span class="n">dmap</span><span class="p">;</span>
		<span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">map_alloc</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">dmap</span><span class="p">);</span>
		<span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">immutable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">bitmap_fill</span><span class="p">(</span><span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">populated</span><span class="p">,</span> <span class="n">pcpu_unit_pages</span><span class="p">);</span>

		<span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">contig_hint</span> <span class="o">=</span> <span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">=</span> <span class="n">dyn_size</span><span class="p">;</span>
		<span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">map_used</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">pcpu_reserved_chunk_limit</span><span class="p">;</span>
		<span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">[</span><span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">map_used</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">dchunk</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* link the first chunk in */</span>
	<span class="n">pcpu_first_chunk</span> <span class="o">=</span> <span class="n">dchunk</span> <span class="o">?:</span> <span class="n">schunk</span><span class="p">;</span>
	<span class="n">pcpu_chunk_relocate</span><span class="p">(</span><span class="n">pcpu_first_chunk</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* we&#39;re done */</span>
	<span class="n">pcpu_base_addr</span> <span class="o">=</span> <span class="n">base_addr</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SMP</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pcpu_fc_names</span><span class="p">[</span><span class="n">PCPU_FC_NR</span><span class="p">]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">PCPU_FC_AUTO</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;auto&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PCPU_FC_EMBED</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;embed&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">PCPU_FC_PAGE</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;page&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">pcpu_fc</span> <span class="n">pcpu_chosen_fc</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="n">PCPU_FC_AUTO</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">percpu_alloc_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* nada */</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;embed&quot;</span><span class="p">))</span>
		<span class="n">pcpu_chosen_fc</span> <span class="o">=</span> <span class="n">PCPU_FC_EMBED</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;page&quot;</span><span class="p">))</span>
		<span class="n">pcpu_chosen_fc</span> <span class="o">=</span> <span class="n">PCPU_FC_PAGE</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;PERCPU: unknown allocator %s specified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;percpu_alloc&quot;</span><span class="p">,</span> <span class="n">percpu_alloc_setup</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * pcpu_embed_first_chunk() is used by the generic percpu setup.</span>
<span class="cm"> * Build it if needed by the arch config or the generic setup is going</span>
<span class="cm"> * to be used.</span>
<span class="cm"> */</span>
<span class="cp">#if defined(CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK) || \</span>
<span class="cp">	!defined(CONFIG_HAVE_SETUP_PER_CPU_AREA)</span>
<span class="cp">#define BUILD_EMBED_FIRST_CHUNK</span>
<span class="cp">#endif</span>

<span class="cm">/* build pcpu_page_first_chunk() iff needed by the arch config */</span>
<span class="cp">#if defined(CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK)</span>
<span class="cp">#define BUILD_PAGE_FIRST_CHUNK</span>
<span class="cp">#endif</span>

<span class="cm">/* pcpu_build_alloc_info() is used by both embed and page first chunk */</span>
<span class="cp">#if defined(BUILD_EMBED_FIRST_CHUNK) || defined(BUILD_PAGE_FIRST_CHUNK)</span>
<span class="cm">/**</span>
<span class="cm"> * pcpu_build_alloc_info - build alloc_info considering distances between CPUs</span>
<span class="cm"> * @reserved_size: the size of reserved percpu area in bytes</span>
<span class="cm"> * @dyn_size: minimum free size for dynamic allocation in bytes</span>
<span class="cm"> * @atom_size: allocation atom size</span>
<span class="cm"> * @cpu_distance_fn: callback to determine distance between cpus, optional</span>
<span class="cm"> *</span>
<span class="cm"> * This function determines grouping of units, their mappings to cpus</span>
<span class="cm"> * and other parameters considering needed percpu size, allocation</span>
<span class="cm"> * atom size and distances between CPUs.</span>
<span class="cm"> *</span>
<span class="cm"> * Groups are always mutliples of atom size and CPUs which are of</span>
<span class="cm"> * LOCAL_DISTANCE both ways are grouped together and share space for</span>
<span class="cm"> * units in the same group.  The returned configuration is guaranteed</span>
<span class="cm"> * to have CPUs on different nodes on different groups and &gt;=75% usage</span>
<span class="cm"> * of allocated virtual address space.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * On success, pointer to the new allocation_info is returned.  On</span>
<span class="cm"> * failure, ERR_PTR value is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">pcpu_build_alloc_info</span><span class="p">(</span>
				<span class="kt">size_t</span> <span class="n">reserved_size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dyn_size</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">atom_size</span><span class="p">,</span>
				<span class="n">pcpu_fc_cpu_distance_fn_t</span> <span class="n">cpu_distance_fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">group_map</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">group_cnt</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">static_size</span> <span class="o">=</span> <span class="n">__per_cpu_end</span> <span class="o">-</span> <span class="n">__per_cpu_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_groups</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nr_units</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size_sum</span><span class="p">,</span> <span class="n">min_unit_size</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">upa</span><span class="p">,</span> <span class="n">max_upa</span><span class="p">,</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">best_upa</span><span class="p">);</span>	<span class="cm">/* units_per_alloc */</span>
	<span class="kt">int</span> <span class="n">last_allocs</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">unit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="n">tcpu</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">cpu_map</span><span class="p">;</span>

	<span class="cm">/* this function may be called multiple times */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">group_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">group_map</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">group_cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">group_cnt</span><span class="p">));</span>

	<span class="cm">/* calculate size_sum and ensure dyn_size is enough for early alloc */</span>
	<span class="n">size_sum</span> <span class="o">=</span> <span class="n">PFN_ALIGN</span><span class="p">(</span><span class="n">static_size</span> <span class="o">+</span> <span class="n">reserved_size</span> <span class="o">+</span>
			    <span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">dyn_size</span><span class="p">,</span> <span class="n">PERCPU_DYNAMIC_EARLY_SIZE</span><span class="p">));</span>
	<span class="n">dyn_size</span> <span class="o">=</span> <span class="n">size_sum</span> <span class="o">-</span> <span class="n">static_size</span> <span class="o">-</span> <span class="n">reserved_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Determine min_unit_size, alloc_size and max_upa such that</span>
<span class="cm">	 * alloc_size is multiple of atom_size and is the smallest</span>
<span class="cm">	 * which can accommodate 4k aligned segments which are equal to</span>
<span class="cm">	 * or larger than min_unit_size.</span>
<span class="cm">	 */</span>
	<span class="n">min_unit_size</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">size_sum</span><span class="p">,</span> <span class="n">PCPU_MIN_UNIT_SIZE</span><span class="p">);</span>

	<span class="n">alloc_size</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">min_unit_size</span><span class="p">,</span> <span class="n">atom_size</span><span class="p">);</span>
	<span class="n">upa</span> <span class="o">=</span> <span class="n">alloc_size</span> <span class="o">/</span> <span class="n">min_unit_size</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">alloc_size</span> <span class="o">%</span> <span class="n">upa</span> <span class="o">||</span> <span class="p">((</span><span class="n">alloc_size</span> <span class="o">/</span> <span class="n">upa</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">))</span>
		<span class="n">upa</span><span class="o">--</span><span class="p">;</span>
	<span class="n">max_upa</span> <span class="o">=</span> <span class="n">upa</span><span class="p">;</span>

	<span class="cm">/* group cpus according to their proximity */</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">next_group:</span>
		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">tcpu</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">tcpu</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">group_map</span><span class="p">[</span><span class="n">tcpu</span><span class="p">]</span> <span class="o">==</span> <span class="n">group</span> <span class="o">&amp;&amp;</span> <span class="n">cpu_distance_fn</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">cpu_distance_fn</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">tcpu</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">LOCAL_DISTANCE</span> <span class="o">||</span>
			     <span class="n">cpu_distance_fn</span><span class="p">(</span><span class="n">tcpu</span><span class="p">,</span> <span class="n">cpu</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">LOCAL_DISTANCE</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">group</span><span class="o">++</span><span class="p">;</span>
				<span class="n">nr_groups</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">nr_groups</span><span class="p">,</span> <span class="n">group</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">next_group</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">group_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span><span class="p">;</span>
		<span class="n">group_cnt</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Expand unit size until address space usage goes over 75%</span>
<span class="cm">	 * and then as much as possible without using more address</span>
<span class="cm">	 * space.</span>
<span class="cm">	 */</span>
	<span class="n">last_allocs</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">upa</span> <span class="o">=</span> <span class="n">max_upa</span><span class="p">;</span> <span class="n">upa</span><span class="p">;</span> <span class="n">upa</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">allocs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wasted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">alloc_size</span> <span class="o">%</span> <span class="n">upa</span> <span class="o">||</span> <span class="p">((</span><span class="n">alloc_size</span> <span class="o">/</span> <span class="n">upa</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">nr_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">this_allocs</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">group_cnt</span><span class="p">[</span><span class="n">group</span><span class="p">],</span> <span class="n">upa</span><span class="p">);</span>
			<span class="n">allocs</span> <span class="o">+=</span> <span class="n">this_allocs</span><span class="p">;</span>
			<span class="n">wasted</span> <span class="o">+=</span> <span class="n">this_allocs</span> <span class="o">*</span> <span class="n">upa</span> <span class="o">-</span> <span class="n">group_cnt</span><span class="p">[</span><span class="n">group</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t accept if wastage is over 1/3.  The</span>
<span class="cm">		 * greater-than comparison ensures upa==1 always</span>
<span class="cm">		 * passes the following check.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wasted</span> <span class="o">&gt;</span> <span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* and then don&#39;t consume more memory */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">allocs</span> <span class="o">&gt;</span> <span class="n">last_allocs</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">last_allocs</span> <span class="o">=</span> <span class="n">allocs</span><span class="p">;</span>
		<span class="n">best_upa</span> <span class="o">=</span> <span class="n">upa</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">upa</span> <span class="o">=</span> <span class="n">best_upa</span><span class="p">;</span>

	<span class="cm">/* allocate and fill alloc_info */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">nr_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span>
		<span class="n">nr_units</span> <span class="o">+=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">group_cnt</span><span class="p">[</span><span class="n">group</span><span class="p">],</span> <span class="n">upa</span><span class="p">);</span>

	<span class="n">ai</span> <span class="o">=</span> <span class="n">pcpu_alloc_alloc_info</span><span class="p">(</span><span class="n">nr_groups</span><span class="p">,</span> <span class="n">nr_units</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ai</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">cpu_map</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cpu_map</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">nr_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">].</span><span class="n">cpu_map</span> <span class="o">=</span> <span class="n">cpu_map</span><span class="p">;</span>
		<span class="n">cpu_map</span> <span class="o">+=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">group_cnt</span><span class="p">[</span><span class="n">group</span><span class="p">],</span> <span class="n">upa</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span> <span class="o">=</span> <span class="n">static_size</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">reserved_size</span> <span class="o">=</span> <span class="n">reserved_size</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">dyn_size</span> <span class="o">=</span> <span class="n">dyn_size</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span> <span class="o">=</span> <span class="n">alloc_size</span> <span class="o">/</span> <span class="n">upa</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">atom_size</span> <span class="o">=</span> <span class="n">atom_size</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">alloc_size</span> <span class="o">=</span> <span class="n">alloc_size</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group_cnt</span><span class="p">[</span><span class="n">group</span><span class="p">];</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pcpu_group_info</span> <span class="o">*</span><span class="n">gi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Initialize base_offset as if all groups are located</span>
<span class="cm">		 * back-to-back.  The caller should update this to</span>
<span class="cm">		 * reflect actual allocation.</span>
<span class="cm">		 */</span>
		<span class="n">gi</span><span class="o">-&gt;</span><span class="n">base_offset</span> <span class="o">=</span> <span class="n">unit</span> <span class="o">*</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">;</span>

		<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">group_map</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">==</span> <span class="n">group</span><span class="p">)</span>
				<span class="n">gi</span><span class="o">-&gt;</span><span class="n">cpu_map</span><span class="p">[</span><span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu</span><span class="p">;</span>
		<span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span><span class="p">,</span> <span class="n">upa</span><span class="p">);</span>
		<span class="n">unit</span> <span class="o">+=</span> <span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">unit</span> <span class="o">!=</span> <span class="n">nr_units</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ai</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* BUILD_EMBED_FIRST_CHUNK || BUILD_PAGE_FIRST_CHUNK */</span><span class="cp"></span>

<span class="cp">#if defined(BUILD_EMBED_FIRST_CHUNK)</span>
<span class="cm">/**</span>
<span class="cm"> * pcpu_embed_first_chunk - embed the first percpu chunk into bootmem</span>
<span class="cm"> * @reserved_size: the size of reserved percpu area in bytes</span>
<span class="cm"> * @dyn_size: minimum free size for dynamic allocation in bytes</span>
<span class="cm"> * @atom_size: allocation atom size</span>
<span class="cm"> * @cpu_distance_fn: callback to determine distance between cpus, optional</span>
<span class="cm"> * @alloc_fn: function to allocate percpu page</span>
<span class="cm"> * @free_fn: function to free percpu page</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper to ease setting up embedded first percpu chunk and</span>
<span class="cm"> * can be called where pcpu_setup_first_chunk() is expected.</span>
<span class="cm"> *</span>
<span class="cm"> * If this function is used to setup the first chunk, it is allocated</span>
<span class="cm"> * by calling @alloc_fn and used as-is without being mapped into</span>
<span class="cm"> * vmalloc area.  Allocations are always whole multiples of @atom_size</span>
<span class="cm"> * aligned to @atom_size.</span>
<span class="cm"> *</span>
<span class="cm"> * This enables the first chunk to piggy back on the linear physical</span>
<span class="cm"> * mapping which often uses larger page size.  Please note that this</span>
<span class="cm"> * can result in very sparse cpu-&gt;unit mapping on NUMA machines thus</span>
<span class="cm"> * requiring large vmalloc address space.  Don&#39;t use this allocator if</span>
<span class="cm"> * vmalloc space is not orders of magnitude larger than distances</span>
<span class="cm"> * between node memory addresses (ie. 32bit NUMA machines).</span>
<span class="cm"> *</span>
<span class="cm"> * @dyn_size specifies the minimum dynamic area size.</span>
<span class="cm"> *</span>
<span class="cm"> * If the needed size is smaller than the minimum or specified unit</span>
<span class="cm"> * size, the leftover is returned using @free_fn.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">pcpu_embed_first_chunk</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">reserved_size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dyn_size</span><span class="p">,</span>
				  <span class="kt">size_t</span> <span class="n">atom_size</span><span class="p">,</span>
				  <span class="n">pcpu_fc_cpu_distance_fn_t</span> <span class="n">cpu_distance_fn</span><span class="p">,</span>
				  <span class="n">pcpu_fc_alloc_fn_t</span> <span class="n">alloc_fn</span><span class="p">,</span>
				  <span class="n">pcpu_fc_free_fn_t</span> <span class="n">free_fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ULONG_MAX</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">**</span><span class="n">areas</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size_sum</span><span class="p">,</span> <span class="n">areas_size</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">group</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ai</span> <span class="o">=</span> <span class="n">pcpu_build_alloc_info</span><span class="p">(</span><span class="n">reserved_size</span><span class="p">,</span> <span class="n">dyn_size</span><span class="p">,</span> <span class="n">atom_size</span><span class="p">,</span>
				   <span class="n">cpu_distance_fn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ai</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ai</span><span class="p">);</span>

	<span class="n">size_sum</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span> <span class="o">+</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">reserved_size</span> <span class="o">+</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">dyn_size</span><span class="p">;</span>
	<span class="n">areas_size</span> <span class="o">=</span> <span class="n">PFN_ALIGN</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

	<span class="n">areas</span> <span class="o">=</span> <span class="n">alloc_bootmem_nopanic</span><span class="p">(</span><span class="n">areas_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">areas</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allocate, copy and determine base address */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pcpu_group_info</span> <span class="o">*</span><span class="n">gi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">];</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">NR_CPUS</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span> <span class="o">&amp;&amp;</span> <span class="n">cpu</span> <span class="o">==</span> <span class="n">NR_CPUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">cpu</span> <span class="o">=</span> <span class="n">gi</span><span class="o">-&gt;</span><span class="n">cpu_map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cpu</span> <span class="o">==</span> <span class="n">NR_CPUS</span><span class="p">);</span>

		<span class="cm">/* allocate space for the whole group */</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">alloc_fn</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span> <span class="o">*</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">,</span> <span class="n">atom_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_areas</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* kmemleak tracks the percpu allocations separately */</span>
		<span class="n">kmemleak_free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="n">areas</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

		<span class="n">base</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy data and free unused parts.  This should happen after all</span>
<span class="cm">	 * allocations are complete; otherwise, we may end up with</span>
<span class="cm">	 * overlapping groups.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pcpu_group_info</span> <span class="o">*</span><span class="n">gi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">];</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">areas</span><span class="p">[</span><span class="n">group</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gi</span><span class="o">-&gt;</span><span class="n">nr_units</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">+=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gi</span><span class="o">-&gt;</span><span class="n">cpu_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">NR_CPUS</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* unused unit, free whole */</span>
				<span class="n">free_fn</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* copy and return the unused part */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">__per_cpu_load</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span><span class="p">);</span>
			<span class="n">free_fn</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">size_sum</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span> <span class="o">-</span> <span class="n">size_sum</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* base address is now known, determine group base offsets */</span>
	<span class="n">max_distance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">].</span><span class="n">base_offset</span> <span class="o">=</span> <span class="n">areas</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
		<span class="n">max_distance</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span>
				     <span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">].</span><span class="n">base_offset</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">max_distance</span> <span class="o">+=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">;</span>

	<span class="cm">/* warn if maximum distance is further than 75% of vmalloc space */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_distance</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">VMALLOC_END</span> <span class="o">-</span> <span class="n">VMALLOC_START</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;PERCPU: max_distance=0x%zx too large for vmalloc &quot;</span>
			   <span class="s">&quot;space 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">VMALLOC_END</span> <span class="o">-</span> <span class="n">VMALLOC_START</span><span class="p">));</span>
<span class="cp">#ifdef CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK</span>
		<span class="cm">/* and fail if we have fallback */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;PERCPU: Embedded %zu pages/cpu @%p s%zu r%zu d%zu u%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">size_sum</span><span class="p">),</span> <span class="n">base</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">reserved_size</span><span class="p">,</span>
		<span class="n">ai</span><span class="o">-&gt;</span><span class="n">dyn_size</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcpu_setup_first_chunk</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

<span class="nl">out_free_areas:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">group</span> <span class="o">&lt;</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span><span class="p">;</span> <span class="n">group</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_fn</span><span class="p">(</span><span class="n">areas</span><span class="p">[</span><span class="n">group</span><span class="p">],</span>
			<span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="n">group</span><span class="p">].</span><span class="n">nr_units</span> <span class="o">*</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">pcpu_free_alloc_info</span><span class="p">(</span><span class="n">ai</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">areas</span><span class="p">)</span>
		<span class="n">free_bootmem</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">areas</span><span class="p">),</span> <span class="n">areas_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* BUILD_EMBED_FIRST_CHUNK */</span><span class="cp"></span>

<span class="cp">#ifdef BUILD_PAGE_FIRST_CHUNK</span>
<span class="cm">/**</span>
<span class="cm"> * pcpu_page_first_chunk - map the first chunk using PAGE_SIZE pages</span>
<span class="cm"> * @reserved_size: the size of reserved percpu area in bytes</span>
<span class="cm"> * @alloc_fn: function to allocate percpu page, always called with PAGE_SIZE</span>
<span class="cm"> * @free_fn: function to free percpu page, always called with PAGE_SIZE</span>
<span class="cm"> * @populate_pte_fn: function to populate pte</span>
<span class="cm"> *</span>
<span class="cm"> * This is a helper to ease setting up page-remapped first percpu</span>
<span class="cm"> * chunk and can be called where pcpu_setup_first_chunk() is expected.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the basic allocator.  Static percpu area is allocated</span>
<span class="cm"> * page-by-page into vmalloc area.</span>
<span class="cm"> *</span>
<span class="cm"> * RETURNS:</span>
<span class="cm"> * 0 on success, -errno on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">pcpu_page_first_chunk</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">reserved_size</span><span class="p">,</span>
				 <span class="n">pcpu_fc_alloc_fn_t</span> <span class="n">alloc_fn</span><span class="p">,</span>
				 <span class="n">pcpu_fc_free_fn_t</span> <span class="n">free_fn</span><span class="p">,</span>
				 <span class="n">pcpu_fc_populate_pte_fn_t</span> <span class="n">populate_pte_fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">struct</span> <span class="n">vm_struct</span> <span class="n">vm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">psize_str</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">unit_pages</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">pages_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unit</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">psize_str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">psize_str</span><span class="p">),</span> <span class="s">&quot;%luK&quot;</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>

	<span class="n">ai</span> <span class="o">=</span> <span class="n">pcpu_build_alloc_info</span><span class="p">(</span><span class="n">reserved_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ai</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ai</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">nr_groups</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">nr_units</span> <span class="o">!=</span> <span class="n">num_possible_cpus</span><span class="p">());</span>

	<span class="n">unit_pages</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="cm">/* unaligned allocations can&#39;t be freed, round up to page size */</span>
	<span class="n">pages_size</span> <span class="o">=</span> <span class="n">PFN_ALIGN</span><span class="p">(</span><span class="n">unit_pages</span> <span class="o">*</span> <span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">*</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">pages</span> <span class="o">=</span> <span class="n">alloc_bootmem</span><span class="p">(</span><span class="n">pages_size</span><span class="p">);</span>

	<span class="cm">/* allocate pages */</span>
	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">unit</span> <span class="o">&lt;</span> <span class="n">num_possible_cpus</span><span class="p">();</span> <span class="n">unit</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">unit_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cpu_map</span><span class="p">[</span><span class="n">unit</span><span class="p">];</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

			<span class="n">ptr</span> <span class="o">=</span> <span class="n">alloc_fn</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warning</span><span class="p">(</span><span class="s">&quot;PERCPU: failed to allocate %s page &quot;</span>
					   <span class="s">&quot;for cpu%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">psize_str</span><span class="p">,</span> <span class="n">cpu</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">enomem</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* kmemleak tracks the percpu allocations separately */</span>
			<span class="n">kmemleak_free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
			<span class="n">pages</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="cm">/* allocate vm area, map the pages and copy static data */</span>
	<span class="n">vm</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VM_ALLOC</span><span class="p">;</span>
	<span class="n">vm</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">num_possible_cpus</span><span class="p">()</span> <span class="o">*</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">;</span>
	<span class="n">vm_area_register_early</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">unit</span> <span class="o">&lt;</span> <span class="n">num_possible_cpus</span><span class="p">();</span> <span class="n">unit</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unit_addr</span> <span class="o">=</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vm</span><span class="p">.</span><span class="n">addr</span> <span class="o">+</span> <span class="n">unit</span> <span class="o">*</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">unit_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">populate_pte_fn</span><span class="p">(</span><span class="n">unit_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>

		<span class="cm">/* pte already populated, the following shouldn&#39;t fail */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">__pcpu_map_pages</span><span class="p">(</span><span class="n">unit_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">[</span><span class="n">unit</span> <span class="o">*</span> <span class="n">unit_pages</span><span class="p">],</span>
				      <span class="n">unit_pages</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">&quot;failed to map percpu area, err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * FIXME: Archs with virtual cache should flush local</span>
<span class="cm">		 * cache for the linear mapping here - something</span>
<span class="cm">		 * equivalent to flush_cache_vmap() on the local cpu.</span>
<span class="cm">		 * flush_cache_vmap() can&#39;t be used as most supporting</span>
<span class="cm">		 * data structures are not set up yet.</span>
<span class="cm">		 */</span>

		<span class="cm">/* copy static data */</span>
		<span class="n">memcpy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">unit_addr</span><span class="p">,</span> <span class="n">__per_cpu_load</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* we&#39;re ready, commit */</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;PERCPU: %d %s pages/cpu @%p s%zu r%zu d%zu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">unit_pages</span><span class="p">,</span> <span class="n">psize_str</span><span class="p">,</span> <span class="n">vm</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">static_size</span><span class="p">,</span>
		<span class="n">ai</span><span class="o">-&gt;</span><span class="n">reserved_size</span><span class="p">,</span> <span class="n">ai</span><span class="o">-&gt;</span><span class="n">dyn_size</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcpu_setup_first_chunk</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="n">vm</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out_free_ar</span><span class="p">;</span>

<span class="nl">enomem:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">free_fn</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="nl">out_free_ar:</span>
	<span class="n">free_bootmem</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">pages</span><span class="p">),</span> <span class="n">pages_size</span><span class="p">);</span>
	<span class="n">pcpu_free_alloc_info</span><span class="p">(</span><span class="n">ai</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* BUILD_PAGE_FIRST_CHUNK */</span><span class="cp"></span>

<span class="cp">#ifndef	CONFIG_HAVE_SETUP_PER_CPU_AREA</span>
<span class="cm">/*</span>
<span class="cm"> * Generic SMP percpu area setup.</span>
<span class="cm"> *</span>
<span class="cm"> * The embedding helper is used because its behavior closely resembles</span>
<span class="cm"> * the original non-dynamic generic percpu area setup.  This is</span>
<span class="cm"> * important because many archs have addressing restrictions and might</span>
<span class="cm"> * fail if the percpu area is located far away from the previous</span>
<span class="cm"> * location.  As an added bonus, in non-NUMA cases, embedding is</span>
<span class="cm"> * generally a good idea TLB-wise because percpu area can piggy back</span>
<span class="cm"> * on the physical linear memory mapping which uses large page</span>
<span class="cm"> * mappings on applicable archs.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__per_cpu_offset</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">]</span> <span class="n">__read_mostly</span><span class="p">;</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__per_cpu_offset</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">pcpu_dfl_fc_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				       <span class="kt">size_t</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__alloc_bootmem_nopanic</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">MAX_DMA_ADDRESS</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">pcpu_dfl_fc_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">free_bootmem</span><span class="p">(</span><span class="n">__pa</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_per_cpu_areas</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Always reserve area for module percpu variables.  That&#39;s</span>
<span class="cm">	 * what the legacy allocator did.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcpu_embed_first_chunk</span><span class="p">(</span><span class="n">PERCPU_MODULE_RESERVE</span><span class="p">,</span>
				    <span class="n">PERCPU_DYNAMIC_RESERVE</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				    <span class="n">pcpu_dfl_fc_alloc</span><span class="p">,</span> <span class="n">pcpu_dfl_fc_free</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed to initialize percpu areas.&quot;</span><span class="p">);</span>

	<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pcpu_base_addr</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">__per_cpu_start</span><span class="p">;</span>
	<span class="n">for_each_possible_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">)</span>
		<span class="n">__per_cpu_offset</span><span class="p">[</span><span class="n">cpu</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta</span> <span class="o">+</span> <span class="n">pcpu_unit_offsets</span><span class="p">[</span><span class="n">cpu</span><span class="p">];</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* CONFIG_HAVE_SETUP_PER_CPU_AREA */</span><span class="cp"></span>

<span class="cp">#else	</span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * UP percpu area setup.</span>
<span class="cm"> *</span>
<span class="cm"> * UP always uses km-based percpu allocator with identity mapping.</span>
<span class="cm"> * Static percpu variables are indistinguishable from the usual static</span>
<span class="cm"> * variables and don&#39;t require any special preparation.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_per_cpu_areas</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">unit_size</span> <span class="o">=</span>
		<span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">PCPU_MIN_UNIT_SIZE</span><span class="p">,</span>
					 <span class="n">PERCPU_DYNAMIC_RESERVE</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">pcpu_alloc_info</span> <span class="o">*</span><span class="n">ai</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">fc</span><span class="p">;</span>

	<span class="n">ai</span> <span class="o">=</span> <span class="n">pcpu_alloc_alloc_info</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">fc</span> <span class="o">=</span> <span class="n">__alloc_bootmem</span><span class="p">(</span><span class="n">unit_size</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">__pa</span><span class="p">(</span><span class="n">MAX_DMA_ADDRESS</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ai</span> <span class="o">||</span> <span class="o">!</span><span class="n">fc</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed to allocate memory for percpu areas.&quot;</span><span class="p">);</span>
	<span class="cm">/* kmemleak tracks the percpu allocations separately */</span>
	<span class="n">kmemleak_free</span><span class="p">(</span><span class="n">fc</span><span class="p">);</span>

	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">dyn_size</span> <span class="o">=</span> <span class="n">unit_size</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">unit_size</span> <span class="o">=</span> <span class="n">unit_size</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">atom_size</span> <span class="o">=</span> <span class="n">unit_size</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">alloc_size</span> <span class="o">=</span> <span class="n">unit_size</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">nr_units</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ai</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cpu_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcpu_setup_first_chunk</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="n">fc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed to initialize percpu areas.&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* CONFIG_SMP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * First and reserved chunks are initialized with temporary allocation</span>
<span class="cm"> * map in initdata so that they can be used before slab is online.</span>
<span class="cm"> * This function is called after slab is brought up and replaces those</span>
<span class="cm"> * with properly allocated maps.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">percpu_init_late</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">target_chunks</span><span class="p">[]</span> <span class="o">=</span>
		<span class="p">{</span> <span class="n">pcpu_first_chunk</span><span class="p">,</span> <span class="n">pcpu_reserved_chunk</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">pcpu_chunk</span> <span class="o">*</span><span class="n">chunk</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">=</span> <span class="n">target_chunks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">PERCPU_DYNAMIC_EARLY_SLOTS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="n">map</span> <span class="o">=</span> <span class="n">pcpu_mem_zalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">map</span> <span class="o">=</span> <span class="n">map</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcpu_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
