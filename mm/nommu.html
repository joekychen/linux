<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › nommu.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>nommu.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/mm/nommu.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Replacement code for mm functions to support CPU&#39;s that don&#39;t</span>
<span class="cm"> *  have any form of memory management unit (thus no virtual memory).</span>
<span class="cm"> *</span>
<span class="cm"> *  See Documentation/nommu-mmap.txt</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2004-2008 David Howells &lt;dhowells@redhat.com&gt;</span>
<span class="cm"> *  Copyright (c) 2000-2003 David McCullough &lt;davidm@snapgear.com&gt;</span>
<span class="cm"> *  Copyright (c) 2000-2001 D Jeff Dionne &lt;jeff@uClinux.org&gt;</span>
<span class="cm"> *  Copyright (c) 2002      Greg Ungerer &lt;gerg@snapgear.com&gt;</span>
<span class="cm"> *  Copyright (c) 2007-2010 Paul Mundt &lt;lethal@linux-sh.org&gt;</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/audit.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/tlb.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;asm/mmu_context.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define kenter(FMT, ...) \</span>
<span class="c">	printk(KERN_DEBUG &quot;==&gt; %s(&quot;FMT&quot;)\n&quot;, __func__, ##__VA_ARGS__)</span>
<span class="c">#define kleave(FMT, ...) \</span>
<span class="c">	printk(KERN_DEBUG &quot;&lt;== %s()&quot;FMT&quot;\n&quot;, __func__, ##__VA_ARGS__)</span>
<span class="c">#define kdebug(FMT, ...) \</span>
<span class="c">	printk(KERN_DEBUG &quot;xxx&quot; FMT&quot;yyy\n&quot;, ##__VA_ARGS__)</span>
<span class="cp">#else</span>
<span class="cp">#define kenter(FMT, ...) \</span>
<span class="cp">	no_printk(KERN_DEBUG &quot;==&gt; %s(&quot;FMT&quot;)\n&quot;, __func__, ##__VA_ARGS__)</span>
<span class="cp">#define kleave(FMT, ...) \</span>
<span class="cp">	no_printk(KERN_DEBUG &quot;&lt;== %s()&quot;FMT&quot;\n&quot;, __func__, ##__VA_ARGS__)</span>
<span class="cp">#define kdebug(FMT, ...) \</span>
<span class="cp">	no_printk(KERN_DEBUG FMT&quot;\n&quot;, ##__VA_ARGS__)</span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="o">*</span><span class="n">high_memory</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">mem_map</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_mapnr</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_physpages</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">highest_memmap_pfn</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">percpu_counter</span> <span class="n">vm_committed_as</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_overcommit_memory</span> <span class="o">=</span> <span class="n">OVERCOMMIT_GUESS</span><span class="p">;</span> <span class="cm">/* heuristic overcommit */</span>
<span class="kt">int</span> <span class="n">sysctl_overcommit_ratio</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="cm">/* default is 50% */</span>
<span class="kt">int</span> <span class="n">sysctl_max_map_count</span> <span class="o">=</span> <span class="n">DEFAULT_MAX_MAP_COUNT</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sysctl_nr_trim_pages</span> <span class="o">=</span> <span class="n">CONFIG_NOMMU_INITIAL_TRIM_EXCESS</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">heap_stack_gap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">atomic_long_t</span> <span class="n">mmap_pages_allocated</span><span class="p">;</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mem_map</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">num_physpages</span><span class="p">);</span>

<span class="cm">/* list of mapped, potentially shareable regions */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">vm_region_jar</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">nommu_region_tree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
<span class="n">DECLARE_RWSEM</span><span class="p">(</span><span class="n">nommu_region_sem</span><span class="p">);</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">generic_file_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Return the total memory allocated for this pointer, not</span>
<span class="cm"> * just what the caller asked for.</span>
<span class="cm"> *</span>
<span class="cm"> * Doesn&#39;t have to be accurate, i.e. may have races.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">kobjsize</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the object we have should not have ksize performed on it,</span>
<span class="cm">	 * return size of 0</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">objp</span> <span class="o">||</span> <span class="o">!</span><span class="n">virt_addr_valid</span><span class="p">(</span><span class="n">objp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_head_page</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the allocator sets PageSlab, we know the pointer came from</span>
<span class="cm">	 * kmalloc().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ksize</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If it&#39;s not a compound page, see if we have a matching VMA</span>
<span class="cm">	 * region. This test is intentionally done in reverse order,</span>
<span class="cm">	 * so if there&#39;s no VMA, we still fall through and hand back</span>
<span class="cm">	 * PAGE_SIZE for 0-order pages.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">objp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The ksize() function is only guaranteed to work for pointers</span>
<span class="cm">	 * returned by kmalloc(). So handle arbitrary pointers here.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__get_user_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">foll_flags</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">vmas</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="o">*</span><span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* calculate required read or write permissions.</span>
<span class="cm">	 * If FOLL_FORCE is set, we only require the &quot;MAY&quot; flags.</span>
<span class="cm">	 */</span>
	<span class="n">vm_flags</span>  <span class="o">=</span> <span class="p">(</span><span class="n">foll_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span> <span class="o">?</span>
			<span class="p">(</span><span class="n">VM_WRITE</span> <span class="o">|</span> <span class="n">VM_MAYWRITE</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">VM_READ</span> <span class="o">|</span> <span class="n">VM_MAYREAD</span><span class="p">);</span>
	<span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">foll_flags</span> <span class="o">&amp;</span> <span class="n">FOLL_FORCE</span><span class="p">)</span> <span class="o">?</span>
			<span class="p">(</span><span class="n">VM_MAYREAD</span> <span class="o">|</span> <span class="n">VM_MAYWRITE</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">VM_READ</span> <span class="o">|</span> <span class="n">VM_WRITE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">finish_or_fault</span><span class="p">;</span>

		<span class="cm">/* protect what we can, including chardevs */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">))</span> <span class="o">||</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">finish_or_fault</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">page_cache_get</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vmas</span><span class="p">)</span>
			<span class="n">vmas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>

<span class="nl">finish_or_fault:</span>
	<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get a list of pages in an address range belonging to the specified process</span>
<span class="cm"> * and indicate the VMA that covers each page</span>
<span class="cm"> * - this is potentially dodgy as we may end incrementing the page count of a</span>
<span class="cm"> *   slab page or a secondary page from a compound page</span>
<span class="cm"> * - don&#39;t permit access to VMAs that don&#39;t support it, such as I/O mappings</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">get_user_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">vmas</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FOLL_WRITE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">FOLL_FORCE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__get_user_pages</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">vmas</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">get_user_pages</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * follow_pfn - look up PFN at a user virtual address</span>
<span class="cm"> * @vma: memory mapping</span>
<span class="cm"> * @address: user virtual address</span>
<span class="cm"> * @pfn: location to store found PFN</span>
<span class="cm"> *</span>
<span class="cm"> * Only IO mappings and raw PFN mappings are allowed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero and the pfn at @pfn on success, -ve otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">follow_pfn</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">follow_pfn</span><span class="p">);</span>

<span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">vmlist_lock</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">vm_struct</span> <span class="o">*</span><span class="n">vmlist</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">vfree</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfree</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">__vmalloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  You can&#39;t specify __GFP_HIGHMEM with kmalloc() since kmalloc()</span>
<span class="cm">	 * returns only a logical address.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">|</span> <span class="n">__GFP_COMP</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_HIGHMEM</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__vmalloc</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">vmalloc_user</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_HIGHMEM</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span>
			<span class="n">PAGE_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_USERMAP</span><span class="p">;</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vmalloc_user</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">vmalloc_to_page</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vmalloc_to_page</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vmalloc_to_pfn</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vmalloc_to_pfn</span><span class="p">);</span>

<span class="kt">long</span> <span class="nf">vread</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">vwrite</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Don&#39;t allow overflow */</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	vmalloc  -  allocate virtually continguos memory</span>
<span class="cm"> *</span>
<span class="cm"> *	@size:		allocation size</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate enough pages to cover @size from the page level</span>
<span class="cm"> *	allocator and map them into continguos kernel virtual space.</span>
<span class="cm"> *</span>
<span class="cm"> *	For tight control over page level allocator and protection flags</span>
<span class="cm"> *	use __vmalloc() instead.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">vmalloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
       <span class="k">return</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_HIGHMEM</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vmalloc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *	vzalloc - allocate virtually continguos memory with zero fill</span>
<span class="cm"> *</span>
<span class="cm"> *	@size:		allocation size</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate enough pages to cover @size from the page level</span>
<span class="cm"> *	allocator and map them into continguos kernel virtual space.</span>
<span class="cm"> *	The memory allocated is set to zero.</span>
<span class="cm"> *</span>
<span class="cm"> *	For tight control over page level allocator and protection flags</span>
<span class="cm"> *	use __vmalloc() instead.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">vzalloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_HIGHMEM</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">,</span>
			<span class="n">PAGE_KERNEL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vzalloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vmalloc_node - allocate memory on a specific node</span>
<span class="cm"> * @size:	allocation size</span>
<span class="cm"> * @node:	numa node</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate enough pages to cover @size from the page level</span>
<span class="cm"> * allocator and map them into contiguous kernel virtual space.</span>
<span class="cm"> *</span>
<span class="cm"> * For tight control over page level allocator and protection flags</span>
<span class="cm"> * use __vmalloc() instead.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">vmalloc_node</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vmalloc_node</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vzalloc_node - allocate memory on a specific node with zero fill</span>
<span class="cm"> * @size:	allocation size</span>
<span class="cm"> * @node:	numa node</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate enough pages to cover @size from the page level</span>
<span class="cm"> * allocator and map them into contiguous kernel virtual space.</span>
<span class="cm"> * The memory allocated is set to zero.</span>
<span class="cm"> *</span>
<span class="cm"> * For tight control over page level allocator and protection flags</span>
<span class="cm"> * use __vmalloc() instead.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">vzalloc_node</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vzalloc_node</span><span class="p">);</span>

<span class="cp">#ifndef PAGE_KERNEL_EXEC</span>
<span class="cp"># define PAGE_KERNEL_EXEC PAGE_KERNEL</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	vmalloc_exec  -  allocate virtually contiguous, executable memory</span>
<span class="cm"> *	@size:		allocation size</span>
<span class="cm"> *</span>
<span class="cm"> *	Kernel-internal function to allocate enough pages to cover @size</span>
<span class="cm"> *	the page level allocator and map them into contiguous and</span>
<span class="cm"> *	executable kernel virtual space.</span>
<span class="cm"> *</span>
<span class="cm"> *	For tight control over page level allocator and protection flags</span>
<span class="cm"> *	use __vmalloc() instead.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">vmalloc_exec</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_HIGHMEM</span><span class="p">,</span> <span class="n">PAGE_KERNEL_EXEC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vmalloc_32  -  allocate virtually contiguous memory (32bit addressable)</span>
<span class="cm"> *	@size:		allocation size</span>
<span class="cm"> *</span>
<span class="cm"> *	Allocate enough 32bit PA addressable pages to cover @size from the</span>
<span class="cm"> *	page level allocator and map them into continguos kernel virtual space.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">vmalloc_32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__vmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">PAGE_KERNEL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vmalloc_32</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vmalloc_32_user - allocate zeroed virtually contiguous 32bit memory</span>
<span class="cm"> *	@size:		allocation size</span>
<span class="cm"> *</span>
<span class="cm"> * The resulting memory area is 32bit addressable and zeroed so it can be</span>
<span class="cm"> * mapped to userspace without leaking data.</span>
<span class="cm"> *</span>
<span class="cm"> * VM_USERMAP is set on the corresponding VMA so that subsequent calls to</span>
<span class="cm"> * remap_vmalloc_range() are permissible.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">vmalloc_32_user</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We&#39;ll have to sort out the ZONE_DMA bits for 64-bit,</span>
<span class="cm">	 * but for now this can simply use vmalloc_user() directly.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">vmalloc_user</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vmalloc_32_user</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">vmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vmap</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">vunmap</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vunmap</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">vm_map_ram</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vm_map_ram</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">vm_unmap_ram</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vm_unmap_ram</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">vm_unmap_aliases</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vm_unmap_aliases</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Implement a stub for vmalloc_sync_all() if the architecture chose not to</span>
<span class="cm"> * have one.</span>
<span class="cm"> */</span>
<span class="kt">void</span>  <span class="nf">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="n">vmalloc_sync_all</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	alloc_vm_area - allocate a range of kernel address space</span>
<span class="cm"> *	@size:		size of the area</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns:	NULL on failure, vm_struct on success</span>
<span class="cm"> *</span>
<span class="cm"> *	This function reserves a range of kernel address space, and</span>
<span class="cm"> *	allocates pagetables to map that range.  No actual mappings</span>
<span class="cm"> *	are created.  If the kernel address space is not shared</span>
<span class="cm"> *	between processes, it syncs the pagetable across all</span>
<span class="cm"> *	processes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vm_struct</span> <span class="o">*</span><span class="nf">alloc_vm_area</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">**</span><span class="n">ptes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">alloc_vm_area</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">free_vm_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_struct</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">free_vm_area</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vm_insert_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vm_insert_page</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  sys_brk() for the most part doesn&#39;t need the global kernel</span>
<span class="cm"> *  lock, except when an application is doing something nasty</span>
<span class="cm"> *  like trying to un-brk an area that has already been mapped</span>
<span class="cm"> *  to a regular file.  in this case, the unmapping will need</span>
<span class="cm"> *  to invoke file system routines that need the global lock.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">brk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">brk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">brk</span> <span class="o">&lt;</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_brk</span> <span class="o">||</span> <span class="n">brk</span> <span class="o">&gt;</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">end_brk</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">==</span> <span class="n">brk</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Always allow shrinking brk</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">brk</span> <span class="o">&lt;=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">brk</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">brk</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok, looks good - let it rip.</span>
<span class="cm">	 */</span>
	<span class="n">flush_icache_range</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span><span class="p">,</span> <span class="n">brk</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">brk</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * initialise the VMA and region record slabs</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="n">mmap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">percpu_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm_committed_as</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="n">vm_region_jar</span> <span class="o">=</span> <span class="n">KMEM_CACHE</span><span class="p">(</span><span class="n">vm_region</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * validate the region tree</span>
<span class="cm"> * - the caller must hold the region lock</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_DEBUG_NOMMU_REGIONS</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="n">validate_nommu_regions</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">region</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">lastp</span><span class="p">;</span>

	<span class="n">lastp</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_tree</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lastp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">last</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">lastp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_region</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">vm_top</span> <span class="o">&lt;</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">lastp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">region</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_region</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">lastp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_region</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&lt;=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span> <span class="o">&lt;</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">vm_top</span><span class="p">));</span>

		<span class="n">lastp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">validate_nommu_regions</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * add a region into the global tree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">add_nommu_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">pregion</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">validate_nommu_regions</span><span class="p">();</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nommu_region_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">pregion</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_region</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pregion</span> <span class="o">==</span> <span class="n">region</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nommu_region_tree</span><span class="p">);</span>

	<span class="n">validate_nommu_regions</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * delete a region from the global tree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">delete_nommu_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nommu_region_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">);</span>

	<span class="n">validate_nommu_regions</span><span class="p">();</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nommu_region_tree</span><span class="p">);</span>
	<span class="n">validate_nommu_regions</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * free a contiguous series of pages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">free_page_series</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">from</span> <span class="o">&lt;</span> <span class="n">to</span><span class="p">;</span> <span class="n">from</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>

		<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;- free %lx&quot;</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
		<span class="n">atomic_long_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmap_pages_allocated</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;free page %p: refcount not one: %d&quot;</span><span class="p">,</span>
			       <span class="n">page</span><span class="p">,</span> <span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * release a reference to a region</span>
<span class="cm"> * - the caller must hold the region semaphore for writing, which this releases</span>
<span class="cm"> * - the region may not have been added to the tree yet, in which case vm_top</span>
<span class="cm"> *   will equal vm_start</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__put_nommu_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">region</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">nommu_region_sem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%p{%d}&quot;</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_usage</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nommu_region_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_usage</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span> <span class="o">&gt;</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
			<span class="n">delete_nommu_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>

		<span class="cm">/* IO memory and memory shared directly out of the pagecache</span>
<span class="cm">		 * from ramfs/tmpfs mustn&#39;t be released here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAPPED_COPY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;free series&quot;</span><span class="p">);</span>
			<span class="n">free_page_series</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_region_jar</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * release a reference to a region</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">put_nommu_region</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">region</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>
	<span class="n">__put_nommu_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update protection on a vma</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">protect_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_MPU</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">protect_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">update_protections</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * add a VMA into a process&#39;s mm_struct in the appropriate place in the list</span>
<span class="cm"> * and tree and add to the address space&#39;s page tree also if not an anonymous</span>
<span class="cm"> * page</span>
<span class="cm"> * - should be called with mm-&gt;mmap_sem held writelocked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">add_vma_to_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">pvma</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">rb_prev</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;,%p&quot;</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="p">);</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>

	<span class="n">protect_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span><span class="p">);</span>

	<span class="cm">/* add the VMA to the mapping */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
		<span class="n">flush_dcache_mmap_lock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">vma_prio_tree_insert</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">);</span>
		<span class="n">flush_dcache_mmap_unlock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* add the VMA to the tree */</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">rb_prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">pvma</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>

		<span class="cm">/* sort by: start addr, end addr, VMA struct addr in that order</span>
<span class="cm">		 * (the latter is necessary as we may get identical VMAs) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">pvma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">pvma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rb_prev</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&lt;</span> <span class="n">pvma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;</span> <span class="n">pvma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rb_prev</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&lt;</span> <span class="n">pvma</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&gt;</span> <span class="n">pvma</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rb_prev</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">);</span>

	<span class="cm">/* add VMA to the VMA list also */</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rb_prev</span><span class="p">)</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb_prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>

	<span class="n">__vma_link_list</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * delete a VMA from its owning mm_struct and address space</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">delete_vma_from_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%p&quot;</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>

	<span class="n">protect_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span> <span class="o">==</span> <span class="n">vma</span><span class="p">)</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* remove the VMA from the mapping */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
		<span class="n">flush_dcache_mmap_lock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">vma_prio_tree_remove</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">);</span>
		<span class="n">flush_dcache_mmap_unlock</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* remove from the MM&#39;s tree and list */</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_rb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_prev</span><span class="p">)</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_prev</span><span class="o">-&gt;</span><span class="n">vm_next</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="o">-&gt;</span><span class="n">vm_prev</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_prev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * destroy a VMA record</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">delete_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;%p&quot;</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXECUTABLE</span><span class="p">)</span>
			<span class="n">removed_exe_file_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_nommu_region</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * look up the first VMA in which addr resides, NULL if none</span>
<span class="cm"> * - should be called with mm-&gt;mmap_sem at least held readlocked</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">find_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="cm">/* check the cache first */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;=</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>

	<span class="cm">/* trawl the list (there may be multiple mappings in which addr</span>
<span class="cm">	 * resides) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">find_vma</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * find a VMA</span>
<span class="cm"> * - we don&#39;t extend stack VMAs under NOMMU conditions</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">find_extend_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * expand a stack to a given address</span>
<span class="cm"> * - not supported under NOMMU conditions</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">expand_stack</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * look up the first VMA exactly that exactly matches addr</span>
<span class="cm"> * - should be called with mm-&gt;mmap_sem at least held readlocked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">find_vma_exact</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
					     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* check the cache first */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">==</span> <span class="n">addr</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>

	<span class="cm">/* trawl the list (there may be multiple mappings in which addr</span>
<span class="cm">	 * resides) */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&lt;</span> <span class="n">addr</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&gt;</span> <span class="n">addr</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_cache</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">vma</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * determine whether a mapping should be permitted and, if so, what sort of</span>
<span class="cm"> * mapping we&#39;re capable of supporting</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">validate_mmap_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">_capabilities</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capabilities</span><span class="p">,</span> <span class="n">rlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* do the simple checks first */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_FIXED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
		       <span class="s">&quot;%d: Can&#39;t do fixed-address/overlay mmap of RAM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_TYPE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MAP_PRIVATE</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_TYPE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MAP_SHARED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Careful about overflows.. */</span>
	<span class="n">rlen</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rlen</span> <span class="o">||</span> <span class="n">rlen</span> <span class="o">&gt;</span> <span class="n">TASK_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* offset overflow? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pgoff</span> <span class="o">+</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">pgoff</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* validate file mapping requests */</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>

		<span class="cm">/* files must support mmap */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

		<span class="cm">/* work out if what we&#39;ve got could possibly be shared</span>
<span class="cm">		 * - we support chardevs that provide their own &quot;memory&quot;</span>
<span class="cm">		 * - we support files/blockdevs that are memory backed</span>
<span class="cm">		 */</span>
		<span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="p">)</span>
			<span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>

		<span class="n">capabilities</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">)</span>
			<span class="n">capabilities</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="o">-&gt;</span><span class="n">capabilities</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capabilities</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* no explicit capabilities set, so assume some</span>
<span class="cm">			 * defaults */</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">S_IFREG</span>:
			<span class="k">case</span> <span class="n">S_IFBLK</span>:
				<span class="n">capabilities</span> <span class="o">=</span> <span class="n">BDI_CAP_MAP_COPY</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">case</span> <span class="n">S_IFCHR</span>:
				<span class="n">capabilities</span> <span class="o">=</span>
					<span class="n">BDI_CAP_MAP_DIRECT</span> <span class="o">|</span>
					<span class="n">BDI_CAP_READ_MAP</span> <span class="o">|</span>
					<span class="n">BDI_CAP_WRITE_MAP</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="nl">default:</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* eliminate any capabilities that we can&#39;t support on this</span>
<span class="cm">		 * device */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">get_unmapped_area</span><span class="p">)</span>
			<span class="n">capabilities</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BDI_CAP_MAP_DIRECT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">)</span>
			<span class="n">capabilities</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BDI_CAP_MAP_COPY</span><span class="p">;</span>

		<span class="cm">/* The file shall have been opened with read permission. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_SHARED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* do checks for writing, appending and locking */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">IS_APPEND</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">locks_verify_locked</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_MAP_DIRECT</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

			<span class="cm">/* we mustn&#39;t privatise shared mappings */</span>
			<span class="n">capabilities</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BDI_CAP_MAP_COPY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* we&#39;re going to read the file into private memory we</span>
<span class="cm">			 * allocate */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_MAP_COPY</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

			<span class="cm">/* we don&#39;t permit a private writable mapping to be</span>
<span class="cm">			 * shared with the backing device */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_WRITE</span><span class="p">)</span>
				<span class="n">capabilities</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BDI_CAP_MAP_DIRECT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_MAP_DIRECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_READ</span><span class="p">)</span>  <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_READ_MAP</span><span class="p">))</span>  <span class="o">||</span>
			    <span class="p">((</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_WRITE_MAP</span><span class="p">))</span> <span class="o">||</span>
			    <span class="p">((</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_EXEC</span><span class="p">)</span>  <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_EXEC_MAP</span><span class="p">))</span>
			    <span class="p">)</span> <span class="p">{</span>
				<span class="n">capabilities</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BDI_CAP_MAP_DIRECT</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_SHARED</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
					       <span class="s">&quot;MAP_SHARED not completely supported on !MMU</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* handle executable mappings and implied executable</span>
<span class="cm">		 * mappings */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NOEXEC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_EXEC</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_READ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_EXEC</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* handle implication of PROT_EXEC by PROT_READ */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">READ_IMPLIES_EXEC</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_EXEC_MAP</span><span class="p">)</span>
					<span class="n">prot</span> <span class="o">|=</span> <span class="n">PROT_EXEC</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_READ</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			 <span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_EXEC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			 <span class="o">!</span><span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_EXEC_MAP</span><span class="p">)</span>
			 <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* backing file is not executable, try to copy */</span>
			<span class="n">capabilities</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BDI_CAP_MAP_DIRECT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* anonymous mappings are always memory backed and can be</span>
<span class="cm">		 * privately mapped</span>
<span class="cm">		 */</span>
		<span class="n">capabilities</span> <span class="o">=</span> <span class="n">BDI_CAP_MAP_COPY</span><span class="p">;</span>

		<span class="cm">/* handle PROT_EXEC implication by PROT_READ */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_READ</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">READ_IMPLIES_EXEC</span><span class="p">))</span>
			<span class="n">prot</span> <span class="o">|=</span> <span class="n">PROT_EXEC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* allow the security API to have its say */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">security_mmap_addr</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* looks okay */</span>
	<span class="o">*</span><span class="n">_capabilities</span> <span class="o">=</span> <span class="n">capabilities</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * we&#39;ve determined that we can make the mapping, now translate what we</span>
<span class="cm"> * now know into VMA flags</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">determine_vm_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capabilities</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_flags</span><span class="p">;</span>

	<span class="n">vm_flags</span> <span class="o">=</span> <span class="n">calc_vm_prot_bits</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span> <span class="o">|</span> <span class="n">calc_vm_flag_bits</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="cm">/* vm_flags |= mm-&gt;def_flags; */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_MAP_DIRECT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* attempt to share read-only copies of mapped file chunks */</span>
		<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_MAYREAD</span> <span class="o">|</span> <span class="n">VM_MAYWRITE</span> <span class="o">|</span> <span class="n">VM_MAYEXEC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">prot</span> <span class="o">&amp;</span> <span class="n">PROT_WRITE</span><span class="p">))</span>
			<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_MAYSHARE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* overlay a shareable mapping on the backing device or inode</span>
<span class="cm">		 * if possible - used for chardevs, ramfs/tmpfs/shmfs and</span>
<span class="cm">		 * romfs/cramfs */</span>
		<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_MAYSHARE</span> <span class="o">|</span> <span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_VMFLAGS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_SHARED</span><span class="p">)</span>
			<span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_SHARED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* refuse to let anyone share private mappings with this process if</span>
<span class="cm">	 * it&#39;s being traced - otherwise breakpoints set in it may interfere</span>
<span class="cm">	 * with another untraced process</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_PRIVATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">)</span>
		<span class="n">vm_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">VM_MAYSHARE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">vm_flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set up a shared mapping on a file (the driver or filesystem provides and</span>
<span class="cm"> * pins the storage)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_mmap_shared_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="o">-&gt;</span><span class="n">vm_top</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* getting -ENOSYS indicates that direct mmap isn&#39;t possible (as</span>
<span class="cm">	 * opposed to tried but failed) so we can only give a suitable error as</span>
<span class="cm">	 * it&#39;s not possible to make a private copy if MAP_SHARED was given */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set up a private mapping or an anonymous shared mapping</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_mmap_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">region</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capabilities</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">order</span><span class="p">;</span>

	<span class="cm">/* invoke the file&#39;s mapping function so that it can keep track of</span>
<span class="cm">	 * shared mappings on devices or memory</span>
<span class="cm">	 * - VM_MAYSHARE will be set if it may attempt to share</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_MAP_DIRECT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* shouldn&#39;t return success if we&#39;re not sharing */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">));</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="o">-&gt;</span><span class="n">vm_top</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="cm">/* getting an ENOSYS error indicates that direct mmap isn&#39;t</span>
<span class="cm">		 * possible (as opposed to tried but failed) so we&#39;ll try to</span>
<span class="cm">		 * make a private copy of the data and map that instead */</span>
	<span class="p">}</span>


	<span class="cm">/* allocate some memory to hold the mapping</span>
<span class="cm">	 * - note that this may not return a page-aligned address if the object</span>
<span class="cm">	 *   we&#39;re allocating is smaller than a page</span>
<span class="cm">	 */</span>
	<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;alloc order %d for %lx&quot;</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">enomem</span><span class="p">;</span>

	<span class="n">total</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">atomic_long_add</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mmap_pages_allocated</span><span class="p">);</span>

	<span class="n">point</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="cm">/* we allocated a power-of-2 sized page set, so we may want to trim off</span>
<span class="cm">	 * the excess */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_nr_trim_pages</span> <span class="o">&amp;&amp;</span> <span class="n">total</span> <span class="o">-</span> <span class="n">point</span> <span class="o">&gt;=</span> <span class="n">sysctl_nr_trim_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="n">point</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">order</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">total</span> <span class="o">-</span> <span class="n">point</span><span class="p">);</span>
			<span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
			<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;shave %lu/%lu @%lu&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">total</span> <span class="o">-</span> <span class="n">point</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
			<span class="n">atomic_long_sub</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mmap_pages_allocated</span><span class="p">);</span>
			<span class="n">total</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
			<span class="n">set_page_refcounted</span><span class="p">(</span><span class="n">pages</span> <span class="o">+</span> <span class="n">total</span><span class="p">);</span>
			<span class="n">__free_pages</span><span class="p">(</span><span class="n">pages</span> <span class="o">+</span> <span class="n">total</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">point</span> <span class="o">&lt;</span> <span class="n">total</span><span class="p">;</span> <span class="n">point</span><span class="o">++</span><span class="p">)</span>
		<span class="n">set_page_refcounted</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pages</span><span class="p">[</span><span class="n">point</span><span class="p">]);</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_MAPPED_COPY</span><span class="p">;</span>
	<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_end</span>   <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span>   <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">total</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span>   <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* read the contents of a file into the copy */</span>
		<span class="n">mm_segment_t</span> <span class="n">old_fs</span><span class="p">;</span>
		<span class="n">loff_t</span> <span class="n">fpos</span><span class="p">;</span>

		<span class="n">fpos</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">;</span>
		<span class="n">fpos</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

		<span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
		<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpos</span><span class="p">);</span>
		<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error_free</span><span class="p">;</span>

		<span class="cm">/* clear the last little bit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">ret</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_free:</span>
	<span class="n">free_page_series</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span><span class="p">);</span>
	<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_end</span>   <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">enomem:</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Allocation of length %lu from process %d (%s) failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">len</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
	<span class="n">show_free_areas</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * handle mapping creation for uClinux</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">do_mmap_pgoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">region</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">capabilities</span><span class="p">,</span> <span class="n">vm_flags</span><span class="p">,</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;,%lx,%lx,%lx,%lx,%lx&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">);</span>

	<span class="cm">/* decide whether we should attempt the mapping, and if so what sort of</span>
<span class="cm">	 * mapping */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">validate_mmap_request</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">capabilities</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %d [val]&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we ignore the address hint */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>

	<span class="cm">/* we&#39;ve determined that we can make the mapping, now translate what we</span>
<span class="cm">	 * now know into VMA flags */</span>
	<span class="n">vm_flags</span> <span class="o">=</span> <span class="n">determine_vm_flags</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">capabilities</span><span class="p">);</span>

	<span class="cm">/* we&#39;re going to need to record the mapping */</span>
	<span class="n">region</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">vm_region_jar</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">region</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_getting_region</span><span class="p">;</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_getting_vma</span><span class="p">;</span>

	<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_usage</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="n">vm_flags</span><span class="p">;</span>
	<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">pgoff</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma_chain</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">=</span> <span class="n">vm_flags</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">pgoff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
		<span class="n">get_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
		<span class="n">get_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXECUTABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">added_exe_file_vma</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>

	<span class="cm">/* if we want to share, we need to check for regions created by other</span>
<span class="cm">	 * mmap() calls that overlap with our proposed mapping</span>
<span class="cm">	 * - we can only share with a superset match on most regular files</span>
<span class="cm">	 * - shared mappings on character devices and memory backed files are</span>
<span class="cm">	 *   permitted to overlap inexactly as far as we are concerned for in</span>
<span class="cm">	 *   these cases, sharing is handled in the driver or filesystem rather</span>
<span class="cm">	 *   than here</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">pregion</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pglen</span><span class="p">,</span> <span class="n">rpglen</span><span class="p">,</span> <span class="n">pgend</span><span class="p">,</span> <span class="n">rpgend</span><span class="p">,</span> <span class="n">start</span><span class="p">;</span>

		<span class="n">pglen</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">pgend</span> <span class="o">=</span> <span class="n">pgoff</span> <span class="o">+</span> <span class="n">pglen</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">rb</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_tree</span><span class="p">);</span> <span class="n">rb</span><span class="p">;</span> <span class="n">rb</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">rb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pregion</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_region</span><span class="p">,</span> <span class="n">vm_rb</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* search for overlapping mappings on the same file */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span>
			    <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&gt;=</span> <span class="n">pgend</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">rpglen</span> <span class="o">=</span> <span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
			<span class="n">rpglen</span> <span class="o">=</span> <span class="p">(</span><span class="n">rpglen</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="n">rpgend</span> <span class="o">=</span> <span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+</span> <span class="n">rpglen</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pgoff</span> <span class="o">&gt;=</span> <span class="n">rpgend</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* handle inexactly overlapping matches between</span>
<span class="cm">			 * mappings */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">!=</span> <span class="n">pgoff</span> <span class="o">||</span> <span class="n">rpglen</span> <span class="o">!=</span> <span class="n">pglen</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">pgoff</span> <span class="o">&gt;=</span> <span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&amp;&amp;</span> <span class="n">pgend</span> <span class="o">&lt;=</span> <span class="n">rpgend</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* new mapping is not a subset of the region */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_MAP_DIRECT</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">sharing_violation</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* we&#39;ve found a region we can share */</span>
			<span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_usage</span><span class="o">++</span><span class="p">;</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span> <span class="o">=</span> <span class="n">pregion</span><span class="p">;</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
			<span class="n">start</span> <span class="o">+=</span> <span class="p">(</span><span class="n">pgoff</span> <span class="o">-</span> <span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAPPED_COPY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;share copy&quot;</span><span class="p">);</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_MAPPED_COPY</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;share mmap&quot;</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">do_mmap_shared_file</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">pregion</span><span class="o">-&gt;</span><span class="n">vm_usage</span><span class="o">--</span><span class="p">;</span>
					<span class="n">pregion</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">error_just_free</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
			<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_region_jar</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>
			<span class="n">region</span> <span class="o">=</span> <span class="n">pregion</span><span class="p">;</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">share</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* obtain the address at which to make a shared mapping</span>
<span class="cm">		 * - this is the hook for quasi-memory character devices to</span>
<span class="cm">		 *   tell us the location of a shared mapping</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_MAP_DIRECT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">addr</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">get_unmapped_area</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
							     <span class="n">pgoff</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_VALUE</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">error_just_free</span><span class="p">;</span>

				<span class="cm">/* the driver refused to tell us where to site</span>
<span class="cm">				 * the mapping so we&#39;ll have to attempt to copy</span>
<span class="cm">				 * it */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">BDI_CAP_MAP_COPY</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">error_just_free</span><span class="p">;</span>

				<span class="n">capabilities</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BDI_CAP_MAP_DIRECT</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
				<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span> <span class="o">=</span> <span class="n">region</span><span class="p">;</span>

	<span class="cm">/* set up the mapping</span>
<span class="cm">	 * - the region is filled in if BDI_CAP_MAP_DIRECT is still set</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_mmap_shared_file</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_mmap_private</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">capabilities</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">error_just_free</span><span class="p">;</span>
	<span class="n">add_nommu_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

	<span class="cm">/* clear anonymous mappings that don&#39;t ask for uninitialized data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_UNINITIALIZED</span><span class="p">))</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">);</span>

	<span class="cm">/* okay... we have a mapping; now we have to register it */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

<span class="nl">share:</span>
	<span class="n">add_vma_to_mm</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>

	<span class="cm">/* we flush the region from the icache only when the first executable</span>
<span class="cm">	 * mapping of it is made  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_icache_flushed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flush_icache_range</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
		<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_icache_flushed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>

	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %lx&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="nl">error_just_free:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_region_jar</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXECUTABLE</span><span class="p">)</span>
		<span class="n">removed_exe_file_vma</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">sharing_violation:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Attempt to share mismatched mappings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

<span class="nl">error_getting_vma:</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_region_jar</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Allocation of vma for %lu byte allocation&quot;</span>
	       <span class="s">&quot; from process %d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">len</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">show_free_areas</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="nl">error_getting_region:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Allocation of vm region for %lu byte allocation&quot;</span>
	       <span class="s">&quot; from process %d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">len</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="n">show_free_areas</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">mmap_pgoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>

	<span class="n">audit_mmap_fd</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MAP_ANONYMOUS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">MAP_EXECUTABLE</span> <span class="o">|</span> <span class="n">MAP_DENYWRITE</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">vm_mmap_pgoff</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_OLD_MMAP</span>
<span class="k">struct</span> <span class="n">mmap_arg_struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">old_mmap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mmap_arg_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mmap_arg_struct</span> <span class="n">a</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sys_mmap_pgoff</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">prot</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">flags</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">fd</span><span class="p">,</span>
			      <span class="n">a</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* __ARCH_WANT_SYS_OLD_MMAP */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * split a vma into two pieces at address &#39;addr&#39;, a new vma is allocated either</span>
<span class="cm"> * for the first part or the tail.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">split_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
	      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_below</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">region</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npages</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="cm">/* we&#39;re only permitted to split anonymous regions (these should have</span>
<span class="cm">	 * only a single usage on the region) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span> <span class="o">&gt;=</span> <span class="n">sysctl_max_map_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">region</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">vm_region_jar</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">region</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">vm_area_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">vm_region_jar</span><span class="p">,</span> <span class="n">region</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* most fields are the same, copy all, and then fixup */</span>
	<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="o">*</span><span class="n">region</span> <span class="o">=</span> <span class="o">*</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_region</span> <span class="o">=</span> <span class="n">region</span><span class="p">;</span>

	<span class="n">npages</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_below</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+=</span> <span class="n">npages</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">&amp;&amp;</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_ops</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>

	<span class="n">delete_vma_from_mm</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>
	<span class="n">delete_nommu_region</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_below</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">+=</span> <span class="n">npages</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="o">-&gt;</span><span class="n">vm_top</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">add_nommu_region</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="p">);</span>
	<span class="n">add_nommu_region</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>
	<span class="n">add_vma_to_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="n">add_vma_to_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * shrink a VMA by removing the specified chunk from either the beginning or</span>
<span class="cm"> * the end</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">shrink_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">region</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="cm">/* adjust the VMA&#39;s pointers, which may reposition it in the MM&#39;s tree</span>
<span class="cm">	 * and list */</span>
	<span class="n">delete_vma_from_mm</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
	<span class="n">add_vma_to_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>

	<span class="cm">/* cut the backing region down to size */</span>
	<span class="n">region</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_usage</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>
	<span class="n">delete_nommu_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span><span class="p">;</span>
		<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">add_nommu_region</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>

	<span class="n">free_page_series</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * release a mapping</span>
<span class="cm"> * - under NOMMU conditions the chunk to be unmapped must be backed by a single</span>
<span class="cm"> *   VMA, though it need not cover the whole VMA</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">do_munmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;,%lx,%zx&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>

	<span class="cm">/* find the first potentially overlapping VMA */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;munmap of memory not mmapped by process %d&quot;</span>
			       <span class="s">&quot; (%s): 0x%lx-0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span>
			       <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">limit</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we&#39;re allowed to split an anonymous VMA but not a file-backed one */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = -EINVAL [miss]&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">erase_whole_vma</span><span class="p">;</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">vma</span><span class="p">);</span>
		<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = -EINVAL [split file]&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* the chunk must be a subset of the VMA found */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">==</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">erase_whole_vma</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">||</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = -EINVAL [superset]&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = -EINVAL [unaligned start]&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">!=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = -EINVAL [unaligned split]&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">!=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">split_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %d [split]&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">shrink_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">erase_whole_vma:</span>
	<span class="n">delete_vma_from_mm</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="n">delete_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = 0&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">do_munmap</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">vm_munmap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_munmap</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vm_munmap</span><span class="p">);</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">munmap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vm_munmap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * release all the mappings made in a process&#39;s VM space</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">exit_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
		<span class="n">delete_vma_from_mm</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
		<span class="n">delete_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_brk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * expand (or shrink) an existing mapping, potentially moving it at the same</span>
<span class="cm"> * time (controlled by the MREMAP_MAYMOVE flag and available VM space)</span>
<span class="cm"> *</span>
<span class="cm"> * under NOMMU conditions, we only permit changing a mapping&#39;s size, and only</span>
<span class="cm"> * as long as it stays within the region allocated by do_mmap_private() and the</span>
<span class="cm"> * block is not shareable</span>
<span class="cm"> *</span>
<span class="cm"> * MREMAP_FIXED is not supported under NOMMU conditions</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">do_mremap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_len</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="cm">/* insanity checks first */</span>
	<span class="n">old_len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">old_len</span><span class="p">);</span>
	<span class="n">new_len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">new_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">new_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MREMAP_FIXED</span> <span class="o">&amp;&amp;</span> <span class="n">new_addr</span> <span class="o">!=</span> <span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma_exact</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">old_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">!=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="n">old_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_len</span> <span class="o">&gt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* all checks complete - do it */</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="n">new_len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">do_mremap</span><span class="p">);</span>

<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">mremap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">old_len</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">new_len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">new_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_mremap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">old_len</span><span class="p">,</span> <span class="n">new_len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">new_addr</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">follow_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">foll_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">remap_pfn_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">!=</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_RESERVED</span> <span class="o">|</span> <span class="n">VM_PFNMAP</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">remap_pfn_range</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">remap_vmalloc_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_USERMAP</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">remap_vmalloc_range</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arch_get_unmapped_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pgoff</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">arch_unmap_area</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unmap_mapping_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			 <span class="n">loff_t</span> <span class="k">const</span> <span class="n">holebegin</span><span class="p">,</span> <span class="n">loff_t</span> <span class="k">const</span> <span class="n">holelen</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">even_cows</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">unmap_mapping_range</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Check that a process has enough memory to allocate a new virtual</span>
<span class="cm"> * mapping. 0 means there is enough memory for the allocation to</span>
<span class="cm"> * succeed and -ENOMEM implies there is not.</span>
<span class="cm"> *</span>
<span class="cm"> * We currently support three overcommit policies, which are set via the</span>
<span class="cm"> * vm.overcommit_memory sysctl.  See Documentation/vm/overcommit-accounting</span>
<span class="cm"> *</span>
<span class="cm"> * Strict overcommit modes added 2002 Feb 26 by Alan Cox.</span>
<span class="cm"> * Additional code 2002 Jul 20 by Robert Love.</span>
<span class="cm"> *</span>
<span class="cm"> * cap_sys_admin is 1 if the process has admin privileges, 0 otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * Note this is a helper function intended to be used by LSMs which</span>
<span class="cm"> * wish to use this logic.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__vm_enough_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap_sys_admin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">free</span><span class="p">,</span> <span class="n">allowed</span><span class="p">;</span>

	<span class="n">vm_acct_memory</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sometimes we want to use more memory than we have</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_overcommit_memory</span> <span class="o">==</span> <span class="n">OVERCOMMIT_ALWAYS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sysctl_overcommit_memory</span> <span class="o">==</span> <span class="n">OVERCOMMIT_GUESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free</span> <span class="o">=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_FREE_PAGES</span><span class="p">);</span>
		<span class="n">free</span> <span class="o">+=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_FILE_PAGES</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * shmem pages shouldn&#39;t be counted as free in this</span>
<span class="cm">		 * case, they can&#39;t be purged, only swapped out, and</span>
<span class="cm">		 * that won&#39;t affect the overall amount of available</span>
<span class="cm">		 * memory in the system.</span>
<span class="cm">		 */</span>
		<span class="n">free</span> <span class="o">-=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_SHMEM</span><span class="p">);</span>

		<span class="n">free</span> <span class="o">+=</span> <span class="n">nr_swap_pages</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Any slabs which are created with the</span>
<span class="cm">		 * SLAB_RECLAIM_ACCOUNT flag claim to have contents</span>
<span class="cm">		 * which are reclaimable, under pressure.  The dentry</span>
<span class="cm">		 * cache and most inode caches should fall into this</span>
<span class="cm">		 */</span>
		<span class="n">free</span> <span class="o">+=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_SLAB_RECLAIMABLE</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Leave reserved pages. The pages are not for anonymous pages.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&lt;=</span> <span class="n">totalreserve_pages</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">free</span> <span class="o">-=</span> <span class="n">totalreserve_pages</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Leave the last 3% for root</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_sys_admin</span><span class="p">)</span>
			<span class="n">free</span> <span class="o">-=</span> <span class="n">free</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&gt;</span> <span class="n">pages</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">allowed</span> <span class="o">=</span> <span class="n">totalram_pages</span> <span class="o">*</span> <span class="n">sysctl_overcommit_ratio</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Leave the last 3% for root</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cap_sys_admin</span><span class="p">)</span>
		<span class="n">allowed</span> <span class="o">-=</span> <span class="n">allowed</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">allowed</span> <span class="o">+=</span> <span class="n">total_swap_pages</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t let a single process grow too big:</span>
<span class="cm">	   leave 3% of the size of this process for other processes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">allowed</span> <span class="o">-=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">total_vm</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">percpu_counter_read_positive</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm_committed_as</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">allowed</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="n">vm_unacct_memory</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">in_gate_area_no_mm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">filemap_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">filemap_fault</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__access_remote_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="cm">/* the access must start within one of the target process&#39;s mappings */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_vma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* don&#39;t overrun this mapping */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">addr</span><span class="p">;</span>

		<span class="cm">/* only read or write mappings where it is permitted */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYWRITE</span><span class="p">)</span>
			<span class="n">copy_to_user_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
					 <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYREAD</span><span class="p">)</span>
			<span class="n">copy_from_user_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
					    <span class="n">buf</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * @access_remote_vm - access another process&#39; address space</span>
<span class="cm"> * @mm:		the mm_struct of the target address space</span>
<span class="cm"> * @addr:	start address to access</span>
<span class="cm"> * @buf:	source or destination buffer</span>
<span class="cm"> * @len:	number of bytes to transfer</span>
<span class="cm"> * @write:	whether the access is a write</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold a reference on @mm.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">access_remote_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__access_remote_vm</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Access another process&#39; address space.</span>
<span class="cm"> * - source/target buffer must be kernel space</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">access_process_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">addr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mm</span> <span class="o">=</span> <span class="n">get_task_mm</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">__access_remote_vm</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">write</span><span class="p">);</span>

	<span class="n">mmput</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nommu_shrink_inode_mappings - Shrink the shared mappings on an inode</span>
<span class="cm"> * @inode: The inode to check</span>
<span class="cm"> * @size: The current filesize of the inode</span>
<span class="cm"> * @newsize: The proposed filesize of the inode</span>
<span class="cm"> *</span>
<span class="cm"> * Check the shared mappings on an inode on behalf of a shrinking truncate to</span>
<span class="cm"> * make sure that that any outstanding VMAs aren&#39;t broken and then shrink the</span>
<span class="cm"> * vm_regions that extend that beyond so that do_mmap_pgoff() doesn&#39;t</span>
<span class="cm"> * automatically grant mappings that are too large.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nommu_shrink_inode_mappings</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
				<span class="kt">size_t</span> <span class="n">newsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_region</span> <span class="o">*</span><span class="n">region</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">r_size</span><span class="p">,</span> <span class="n">r_top</span><span class="p">;</span>

	<span class="n">low</span> <span class="o">=</span> <span class="n">newsize</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">high</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>

	<span class="cm">/* search for VMAs that fall within the dead zone */</span>
	<span class="n">vma_prio_tree_foreach</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">,</span>
			      <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* found one - only interested if it&#39;s shared out of the page</span>
<span class="cm">		 * cache */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETXTBSY</span><span class="p">;</span> <span class="cm">/* not quite true, but near enough */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* reduce any regions that overlap the dead zone - if in existence,</span>
<span class="cm">	 * these will be pointed to by VMAs that don&#39;t overlap the dead zone</span>
<span class="cm">	 *</span>
<span class="cm">	 * we don&#39;t check for any regions that start beyond the EOF as there</span>
<span class="cm">	 * shouldn&#39;t be any</span>
<span class="cm">	 */</span>
	<span class="n">vma_prio_tree_foreach</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">,</span>
			      <span class="mi">0</span><span class="p">,</span> <span class="n">ULONG_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">region</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_region</span><span class="p">;</span>
		<span class="n">r_size</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span> <span class="o">-</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="n">r_top</span> <span class="o">=</span> <span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">r_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">r_top</span> <span class="o">&gt;</span> <span class="n">newsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span> <span class="o">-=</span> <span class="n">r_top</span> <span class="o">-</span> <span class="n">newsize</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&gt;</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span><span class="p">)</span>
				<span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">=</span> <span class="n">region</span><span class="o">-&gt;</span><span class="n">vm_top</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nommu_region_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
