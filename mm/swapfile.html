<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › swapfile.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>swapfile.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/mm/swapfile.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds</span>
<span class="cm"> *  Swap reorganised 29.12.95, Stephen Tweedie</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/kernel_stat.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/shmem_fs.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/ksm.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/memcontrol.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/oom.h&gt;</span>
<span class="cp">#include &lt;linux/frontswap.h&gt;</span>
<span class="cp">#include &lt;linux/swapfile.h&gt;</span>

<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;asm/tlbflush.h&gt;</span>
<span class="cp">#include &lt;linux/swapops.h&gt;</span>
<span class="cp">#include &lt;linux/page_cgroup.h&gt;</span>

<span class="k">static</span> <span class="n">bool</span> <span class="n">swap_count_continued</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="p">,</span> <span class="n">pgoff_t</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">char</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">free_swap_count_continuations</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="n">sector_t</span> <span class="n">map_swap_entry</span><span class="p">(</span><span class="n">swp_entry_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span><span class="o">**</span><span class="p">);</span>

<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">swap_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_swapfiles</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">nr_swap_pages</span><span class="p">;</span>
<span class="kt">long</span> <span class="n">total_swap_pages</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">least_priority</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">Bad_file</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Bad swap file entry &quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">Unused_file</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Unused swap file entry &quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">Bad_offset</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Bad swap offset entry &quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">Unused_offset</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;Unused swap offset entry &quot;</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">swap_list_t</span> <span class="n">swap_list</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">swap_info</span><span class="p">[</span><span class="n">MAX_SWAPFILES</span><span class="p">];</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">swapon_mutex</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">proc_poll_wait</span><span class="p">);</span>
<span class="cm">/* Activity counter to indicate that a swapon or swapoff has occurred */</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">proc_poll_event</span> <span class="o">=</span> <span class="n">ATOMIC_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">swap_count</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ent</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SWAP_HAS_CACHE</span><span class="p">;</span>	<span class="cm">/* may include SWAP_HAS_CONT flag */</span>
<span class="p">}</span>

<span class="cm">/* returns 1 if swap entry is freed */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__try_to_reclaim_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">swp_entry_t</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">swp_entry</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapper_space</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This function is called from scan_swap_map() and it&#39;s called</span>
<span class="cm">	 * by vmscan.c at reclaiming pages. So, we hold a lock on a page, here.</span>
<span class="cm">	 * We have to use trylock for avoiding deadlock. This is a special</span>
<span class="cm">	 * case and you should use try_to_free_swap() with explicit lock_page()</span>
<span class="cm">	 * in usual operations.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_free_swap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * swapon tell device that all the old swap contents can be discarded,</span>
<span class="cm"> * to allow the swap device to optimize its wear-levelling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">discard_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_extent</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">start_block</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">nr_blocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Do not discard the swap header page! */</span>
	<span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">first_swap_extent</span><span class="p">;</span>
	<span class="n">start_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">start_block</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">nr_blocks</span> <span class="o">=</span> <span class="p">((</span><span class="n">sector_t</span><span class="p">)</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">9</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">blkdev_issue_discard</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">start_block</span><span class="p">,</span>
				<span class="n">nr_blocks</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">first_swap_extent</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_block</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">start_block</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">9</span><span class="p">);</span>
		<span class="n">nr_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">sector_t</span><span class="p">)</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">9</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">blkdev_issue_discard</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">start_block</span><span class="p">,</span>
				<span class="n">nr_blocks</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>		<span class="cm">/* That will often be -EOPNOTSUPP */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * swap allocation tell device that a cluster of swap can now be discarded,</span>
<span class="cm"> * to allow the swap device to optimize its wear-levelling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">discard_swap_cluster</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span><span class="p">,</span>
				 <span class="n">pgoff_t</span> <span class="n">start_page</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_extent</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">curr_swap_extent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found_extent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">start_page</span> <span class="o">&lt;=</span> <span class="n">start_page</span> <span class="o">&amp;&amp;</span>
		    <span class="n">start_page</span> <span class="o">&lt;</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">start_page</span> <span class="o">+</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pgoff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">start_page</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">start_page</span><span class="p">;</span>
			<span class="n">sector_t</span> <span class="n">start_block</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">start_block</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">sector_t</span> <span class="n">nr_blocks</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">nr_blocks</span> <span class="o">&gt;</span> <span class="n">nr_pages</span><span class="p">)</span>
				<span class="n">nr_blocks</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
			<span class="n">start_page</span> <span class="o">+=</span> <span class="n">nr_blocks</span><span class="p">;</span>
			<span class="n">nr_pages</span> <span class="o">-=</span> <span class="n">nr_blocks</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found_extent</span><span class="o">++</span><span class="p">)</span>
				<span class="n">si</span><span class="o">-&gt;</span><span class="n">curr_swap_extent</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>

			<span class="n">start_block</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">9</span><span class="p">;</span>
			<span class="n">nr_blocks</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">9</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blkdev_issue_discard</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">start_block</span><span class="p">,</span>
				    <span class="n">nr_blocks</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lh</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">se</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">swap_extent</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">wait_for_discard</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">schedule</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define SWAPFILE_CLUSTER	256</span>
<span class="cp">#define LATENCY_LIMIT		256</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">scan_swap_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">usage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">scan_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_in_cluster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">latency_ration</span> <span class="o">=</span> <span class="n">LATENCY_LIMIT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found_free_cluster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We try to cluster swap pages by allocating them sequentially</span>
<span class="cm">	 * in swap.  Once we&#39;ve allocated SWAPFILE_CLUSTER pages this</span>
<span class="cm">	 * way, however, we resort to first-free allocation, starting</span>
<span class="cm">	 * a new cluster.  This prevents us from scattering swap pages</span>
<span class="cm">	 * all over the entire swap partition, so that we reduce</span>
<span class="cm">	 * overall disk seek times between swap pages.  -- sct</span>
<span class="cm">	 * But we do now try to find an empty cluster.  -Andrea</span>
<span class="cm">	 * And we let swap pages go all over an SSD partition.  Hugh</span>
<span class="cm">	 */</span>

	<span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">+=</span> <span class="n">SWP_SCANNING</span><span class="p">;</span>
	<span class="n">scan_base</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">cluster_next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">cluster_nr</span><span class="o">--</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">-</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">inuse_pages</span> <span class="o">&lt;</span> <span class="n">SWAPFILE_CLUSTER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">si</span><span class="o">-&gt;</span><span class="n">cluster_nr</span> <span class="o">=</span> <span class="n">SWAPFILE_CLUSTER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">checks</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_DISCARDABLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Start range check on racing allocations, in case</span>
<span class="cm">			 * they overlap the cluster we eventually decide on</span>
<span class="cm">			 * (we scan without swap_lock to allow preemption).</span>
<span class="cm">			 * It&#39;s hardly conceivable that cluster_nr could be</span>
<span class="cm">			 * wrapped during our scan, but don&#39;t depend on it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_alloc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">checks</span><span class="p">;</span>
			<span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_alloc</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">;</span>
			<span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If seek is expensive, start searching for new cluster from</span>
<span class="cm">		 * start of partition, to minimize the span of allocated swap.</span>
<span class="cm">		 * But if seek is cheap, search from our current position, so</span>
<span class="cm">		 * that swap is allocated from all over the partition: if the</span>
<span class="cm">		 * Flash Translation Layer only remaps within limited zones,</span>
<span class="cm">		 * we don&#39;t want to wear out the first zone too quickly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_SOLIDSTATE</span><span class="p">))</span>
			<span class="n">scan_base</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_bit</span><span class="p">;</span>
		<span class="n">last_in_cluster</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">SWAPFILE_CLUSTER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Locate the first empty (unaligned) cluster */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">last_in_cluster</span> <span class="o">&lt;=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_bit</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">])</span>
				<span class="n">last_in_cluster</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">SWAPFILE_CLUSTER</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">last_in_cluster</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
				<span class="n">offset</span> <span class="o">-=</span> <span class="n">SWAPFILE_CLUSTER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">si</span><span class="o">-&gt;</span><span class="n">cluster_next</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
				<span class="n">si</span><span class="o">-&gt;</span><span class="n">cluster_nr</span> <span class="o">=</span> <span class="n">SWAPFILE_CLUSTER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">found_free_cluster</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">checks</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">--</span><span class="n">latency_ration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cond_resched</span><span class="p">();</span>
				<span class="n">latency_ration</span> <span class="o">=</span> <span class="n">LATENCY_LIMIT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_bit</span><span class="p">;</span>
		<span class="n">last_in_cluster</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">SWAPFILE_CLUSTER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Locate the first empty (unaligned) cluster */</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">last_in_cluster</span> <span class="o">&lt;</span> <span class="n">scan_base</span><span class="p">;</span> <span class="n">offset</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">])</span>
				<span class="n">last_in_cluster</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">SWAPFILE_CLUSTER</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">last_in_cluster</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
				<span class="n">offset</span> <span class="o">-=</span> <span class="n">SWAPFILE_CLUSTER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">si</span><span class="o">-&gt;</span><span class="n">cluster_next</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
				<span class="n">si</span><span class="o">-&gt;</span><span class="n">cluster_nr</span> <span class="o">=</span> <span class="n">SWAPFILE_CLUSTER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">found_free_cluster</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">checks</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">--</span><span class="n">latency_ration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">cond_resched</span><span class="p">();</span>
				<span class="n">latency_ration</span> <span class="o">=</span> <span class="n">LATENCY_LIMIT</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">scan_base</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
		<span class="n">si</span><span class="o">-&gt;</span><span class="n">cluster_nr</span> <span class="o">=</span> <span class="n">SWAPFILE_CLUSTER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">checks:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_WRITEOK</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">no_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_bit</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">no_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_bit</span><span class="p">)</span>
		<span class="n">scan_base</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_bit</span><span class="p">;</span>

	<span class="cm">/* reuse swap entry of cache-only swap if not busy. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_swap_full</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">==</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">swap_was_freed</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
		<span class="n">swap_was_freed</span> <span class="o">=</span> <span class="n">__try_to_reclaim_swap</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
		<span class="cm">/* entry was freed successfully, try to use this again */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swap_was_freed</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">checks</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">scan</span><span class="p">;</span> <span class="cm">/* check next one */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">])</span>
		<span class="k">goto</span> <span class="n">scan</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_bit</span><span class="p">)</span>
		<span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_bit</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_bit</span><span class="p">)</span>
		<span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_bit</span><span class="o">--</span><span class="p">;</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">inuse_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">inuse_pages</span> <span class="o">==</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_bit</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">;</span>
		<span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">usage</span><span class="p">;</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">cluster_next</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">-=</span> <span class="n">SWP_SCANNING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Only set when SWP_DISCARDABLE, and there&#39;s a scan</span>
<span class="cm">		 * for a free cluster in progress or just completed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_free_cluster</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * To optimize wear-levelling, discard the</span>
<span class="cm">			 * old data of the cluster, taking care not to</span>
<span class="cm">			 * discard any of its pages that have already</span>
<span class="cm">			 * been allocated by racing tasks (offset has</span>
<span class="cm">			 * already stepped over any at the beginning).</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_alloc</span> <span class="o">&amp;&amp;</span>
			    <span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_alloc</span> <span class="o">&lt;=</span> <span class="n">last_in_cluster</span><span class="p">)</span>
				<span class="n">last_in_cluster</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_alloc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SWP_DISCARDING</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">last_in_cluster</span><span class="p">)</span>
				<span class="n">discard_swap_cluster</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					<span class="n">last_in_cluster</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
			<span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SWP_DISCARDING</span><span class="p">;</span>

			<span class="n">smp_mb</span><span class="p">();</span>	<span class="cm">/* wake_up_bit advises this */</span>
			<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">SWP_DISCARDING</span><span class="p">));</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_DISCARDING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Delay using pages allocated by racing tasks</span>
<span class="cm">			 * until the whole discard has been issued. We</span>
<span class="cm">			 * could defer that delay until swap_writepage,</span>
<span class="cm">			 * but it&#39;s easier to keep this self-contained.</span>
<span class="cm">			 */</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
			<span class="n">wait_on_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">SWP_DISCARDING</span><span class="p">),</span>
				<span class="n">wait_for_discard</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Note pages allocated by racing tasks while</span>
<span class="cm">			 * scan for a free cluster is in progress, so</span>
<span class="cm">			 * that its final discard can exclude them.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_alloc</span><span class="p">)</span>
				<span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_alloc</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_alloc</span><span class="p">)</span>
				<span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_alloc</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>

<span class="nl">scan:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_bit</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">checks</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vm_swap_full</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">==</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">checks</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">--</span><span class="n">latency_ration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">latency_ration</span> <span class="o">=</span> <span class="n">LATENCY_LIMIT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">lowest_bit</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">scan_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">checks</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vm_swap_full</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">==</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">checks</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">--</span><span class="n">latency_ration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">latency_ration</span> <span class="o">=</span> <span class="n">LATENCY_LIMIT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>

<span class="nl">no_page:</span>
	<span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">-=</span> <span class="n">SWP_SCANNING</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">swp_entry_t</span> <span class="nf">get_swap_page</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wrapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_swap_pages</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">noswap</span><span class="p">;</span>
	<span class="n">nr_swap_pages</span><span class="o">--</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="n">swap_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span> <span class="n">type</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wrapped</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">wrapped</span> <span class="o">&amp;&amp;</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">!=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">swap_list</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
			<span class="n">wrapped</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">highest_bit</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_WRITEOK</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">swap_list</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="cm">/* This is called for allocating swap entry for cache */</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">scan_swap_map</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">swp_entry</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">swap_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nr_swap_pages</span><span class="o">++</span><span class="p">;</span>
<span class="nl">noswap:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">swp_entry_t</span><span class="p">)</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="p">}</span>

<span class="cm">/* The only caller of this function is now susupend routine */</span>
<span class="n">swp_entry_t</span> <span class="nf">get_swap_page_of_type</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="n">si</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">si</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_WRITEOK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nr_swap_pages</span><span class="o">--</span><span class="p">;</span>
		<span class="cm">/* This is called for allocating swap entry, not cache */</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">scan_swap_map</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">swp_entry</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">nr_swap_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">swp_entry_t</span><span class="p">)</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="nf">swap_info_get</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">swp_type</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">nr_swapfiles</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_nofile</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_USED</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad_device</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">swp_offset</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">])</span>
		<span class="k">goto</span> <span class="n">bad_free</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>

<span class="nl">bad_free:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;swap_free: %s%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Unused_offset</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">bad_offset:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;swap_free: %s%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Bad_offset</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">bad_device:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;swap_free: %s%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Unused_file</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">bad_nofile:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;swap_free: %s%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Bad_file</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">swap_entry_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				     <span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">usage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">swp_offset</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">has_cache</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
	<span class="n">has_cache</span> <span class="o">=</span> <span class="n">count</span> <span class="o">&amp;</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SWAP_HAS_CACHE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usage</span> <span class="o">==</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">has_cache</span><span class="p">);</span>
		<span class="n">has_cache</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">SWAP_MAP_SHMEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Or we could insist on shmem.c using a special</span>
<span class="cm">		 * swap_shmem_free() and free_shmem_swap_and_cache()...</span>
<span class="cm">		 */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">COUNT_CONTINUED</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">SWAP_MAP_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">COUNT_CONTINUED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">swap_count_continued</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
				<span class="n">count</span> <span class="o">=</span> <span class="n">SWAP_MAP_MAX</span> <span class="o">|</span> <span class="n">COUNT_CONTINUED</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">count</span> <span class="o">=</span> <span class="n">SWAP_MAP_MAX</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="n">mem_cgroup_uncharge_swap</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

	<span class="n">usage</span> <span class="o">=</span> <span class="n">count</span> <span class="o">|</span> <span class="n">has_cache</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">usage</span><span class="p">;</span>

	<span class="cm">/* free if no reference */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usage</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lowest_bit</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">lowest_bit</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">highest_bit</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">highest_bit</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swap_list</span><span class="p">.</span><span class="n">next</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&gt;</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">swap_list</span><span class="p">.</span><span class="n">next</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
			<span class="n">swap_list</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">nr_swap_pages</span><span class="o">++</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">inuse_pages</span><span class="o">--</span><span class="p">;</span>
		<span class="n">frontswap_invalidate_page</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_BLKDEV</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span><span class="o">-&gt;</span><span class="n">swap_slot_free_notify</span><span class="p">)</span>
			<span class="n">disk</span><span class="o">-&gt;</span><span class="n">fops</span><span class="o">-&gt;</span><span class="n">swap_slot_free_notify</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">usage</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Caller has made sure that the swapdevice corresponding to entry</span>
<span class="cm"> * is still around or has not been recycled.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">swap_free</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">swap_info_get</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swap_entry_free</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called after dropping swapcache to decrease refcnt to swap entries.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">swapcache_free</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">swap_info_get</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">swap_entry_free</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
			<span class="n">mem_cgroup_uncharge_swapcache</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * How many references to page are currently swapped out?</span>
<span class="cm"> * This does not give an exact answer when swap count is continued,</span>
<span class="cm"> * but does include the high COUNT_CONTINUED flag to allow for that.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">page_swapcount</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">;</span>

	<span class="n">entry</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">swap_info_get</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">swap_count</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">swp_offset</span><span class="p">(</span><span class="n">entry</span><span class="p">)]);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We can write to an anon page without COW if there are no other references</span>
<span class="cm"> * to it.  And as a side-effect, free up its swap: because the old content</span>
<span class="cm"> * on disk will never be read, and seeking back there to write new content</span>
<span class="cm"> * later would only waste time away from clustering.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">reuse_swap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageKsm</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">page_swapcount</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">delete_from_swap_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">SetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If swap is getting full, or if there are no more mappings of this page,</span>
<span class="cm"> * then try_to_free_swap is called to free its swap space.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">try_to_free_swap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_swapcount</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Once hibernation has begun to create its image of memory,</span>
<span class="cm">	 * there&#39;s a danger that one of the calls to try_to_free_swap()</span>
<span class="cm">	 * - most probably a call from __try_to_reclaim_swap() while</span>
<span class="cm">	 * hibernation is allocating its own swap pages for the image,</span>
<span class="cm">	 * but conceivably even a call from memory reclaim - will free</span>
<span class="cm">	 * the swap from a page which has already been recorded in the</span>
<span class="cm">	 * image as a clean swapcache page, and then reuse its swap for</span>
<span class="cm">	 * another page of the image.  On waking from hibernation, the</span>
<span class="cm">	 * original page might be freed under memory pressure, then</span>
<span class="cm">	 * later read back in from swap, now with the wrong data.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Hibration suspends storage while it is writing the image</span>
<span class="cm">	 * to disk so check that here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pm_suspended_storage</span><span class="p">())</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">delete_from_swap_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">SetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free the swap entry like above, but also try to</span>
<span class="cm"> * free the page cache entry if it is the last user.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">free_swap_and_cache</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">non_swap_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">swap_info_get</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swap_entry_free</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapper_space</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Not mapped elsewhere, or swap space full? Free it!</span>
<span class="cm">		 * Also recheck PageSwapCache now page is locked (above).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="o">!</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">vm_swap_full</span><span class="p">()))</span> <span class="p">{</span>
			<span class="n">delete_from_swap_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">SetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HIBERNATION</span>
<span class="cm">/*</span>
<span class="cm"> * Find the swap type that corresponds to given device (if any).</span>
<span class="cm"> *</span>
<span class="cm"> * @offset - number of the PAGE_SIZE-sized block of the device, starting</span>
<span class="cm"> * from 0, in which the swap header is expected to be located.</span>
<span class="cm"> *</span>
<span class="cm"> * This is needed for the suspend to disk (aka swsusp).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">swap_type_of</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">device</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">**</span><span class="n">bdev_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="p">)</span>
		<span class="n">bdev</span> <span class="o">=</span> <span class="n">bdget</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">nr_swapfiles</span><span class="p">;</span> <span class="n">type</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">sis</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sis</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_WRITEOK</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bdev_p</span><span class="p">)</span>
				<span class="o">*</span><span class="n">bdev_p</span> <span class="o">=</span> <span class="n">bdgrab</span><span class="p">(</span><span class="n">sis</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>

			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">type</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bdev</span> <span class="o">==</span> <span class="n">sis</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">swap_extent</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sis</span><span class="o">-&gt;</span><span class="n">first_swap_extent</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">start_block</span> <span class="o">==</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bdev_p</span><span class="p">)</span>
					<span class="o">*</span><span class="n">bdev_p</span> <span class="o">=</span> <span class="n">bdgrab</span><span class="p">(</span><span class="n">sis</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>

				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
				<span class="n">bdput</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">type</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdev</span><span class="p">)</span>
		<span class="n">bdput</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Get the (PAGE_SIZE) block corresponding to given offset on the swapdev</span>
<span class="cm"> * corresponding to given index in swap_info (swap type).</span>
<span class="cm"> */</span>
<span class="n">sector_t</span> <span class="nf">swapdev_block</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">nr_swapfiles</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_WRITEOK</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">map_swap_entry</span><span class="p">(</span><span class="n">swp_entry</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">offset</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">bdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return either the total number of swap pages of given type, or the number</span>
<span class="cm"> * of free pages of that type (depending on @free)</span>
<span class="cm"> *</span>
<span class="cm"> * This is needed for software suspend</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">count_swap_pages</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">free</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">nr_swapfiles</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">sis</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sis</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_WRITEOK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">sis</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">free</span><span class="p">)</span>
				<span class="n">n</span> <span class="o">-=</span> <span class="n">sis</span><span class="o">-&gt;</span><span class="n">inuse_pages</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_HIBERNATION */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * No need to decide whether this PTE shares the swap entry with others,</span>
<span class="cm"> * just let do_wp_page work it out if a write is requested later - to</span>
<span class="cm"> * force COW, vm_page_prot omits write permission from any private vma.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">unuse_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mem_cgroup</span> <span class="o">*</span><span class="n">memcg</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="o">*</span><span class="n">ptl</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem_cgroup_try_charge_swapin</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
					 <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">memcg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_nolock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map_lock</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ptl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">swp_entry_to_pte</span><span class="p">(</span><span class="n">entry</span><span class="p">))))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">mem_cgroup_cancel_charge_swapin</span><span class="p">(</span><span class="n">memcg</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dec_mm_counter</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">MM_SWAPENTS</span><span class="p">);</span>
	<span class="n">inc_mm_counter</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">MM_ANONPAGES</span><span class="p">);</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">set_pte_at</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">pte</span><span class="p">,</span>
		   <span class="n">pte_mkold</span><span class="p">(</span><span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">)));</span>
	<span class="n">page_add_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="n">mem_cgroup_commit_charge_swapin</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">memcg</span><span class="p">);</span>
	<span class="n">swap_free</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Move the page to the active list so it is not</span>
<span class="cm">	 * immediately swapped out again after swapon.</span>
<span class="cm">	 */</span>
	<span class="n">activate_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">pte_unmap_unlock</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">ptl</span><span class="p">);</span>
<span class="nl">out_nolock:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unuse_pte_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">swp_pte</span> <span class="o">=</span> <span class="n">swp_entry_to_pte</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t actually need pte lock while scanning for swp_pte: since</span>
<span class="cm">	 * we hold page lock and mmap_sem, swp_pte cannot be inserted into the</span>
<span class="cm">	 * page table while we&#39;re scanning; though it could get zapped, and on</span>
<span class="cm">	 * some architectures (e.g. x86_32 with PAE) we might catch a glimpse</span>
<span class="cm">	 * of unmatched parts which look like swp_pte, so unuse_pte must</span>
<span class="cm">	 * recheck under pte lock.  Scanning without pte lock lets it be</span>
<span class="cm">	 * preemptible whenever CONFIG_PREEMPT but not CONFIG_HIGHPTE.</span>
<span class="cm">	 */</span>
	<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * swapoff spends a _lot_ of time in this loop!</span>
<span class="cm">		 * Test inline before going to call unuse_pte.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pte_same</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="n">swp_pte</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pte_unmap</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">unuse_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset_map</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pte</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">pte_unmap</span><span class="p">(</span><span class="n">pte</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">unuse_pmd_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pmd_t</span> <span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pmd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmd_none_or_trans_huge_or_clear_bad</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">unuse_pte_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">pmd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pmd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">unuse_pud_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offset</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pud_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pud_none_or_clear_bad</span><span class="p">(</span><span class="n">pud</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">unuse_pmd_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">pud</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pud</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unuse_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				<span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_anon_vma</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">page_address_in_vma</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">pgd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pgd_none_or_clear_bad</span><span class="p">(</span><span class="n">pgd</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">unuse_pud_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">pgd</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pgd</span><span class="o">++</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">addr</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unuse_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span>
				<span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">down_read_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Activate page so shrink_inactive_list is unlikely to unmap</span>
<span class="cm">		 * its ptes while lock is dropped, so swapoff can make progress.</span>
<span class="cm">		 */</span>
		<span class="n">activate_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
		<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">unuse_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">page</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span> <span class="n">ret</span><span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Scan swap_map (or frontswap_map if frontswap parameter is true)</span>
<span class="cm"> * from current position to next entry still in use.</span>
<span class="cm"> * Recycle to start on reaching the end, returning 0 when empty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">find_next_to_unuse</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">frontswap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * No need for swap_lock here: we&#39;re just looking</span>
<span class="cm">	 * for whether an entry is in use, not modifying it; false</span>
<span class="cm">	 * hits are okay, and sys_swapoff() has already prevented new</span>
<span class="cm">	 * allocations from this area (while holding swap_lock).</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 * No entries in use at top of swap_map,</span>
<span class="cm">			 * loop back to start and recheck there.</span>
<span class="cm">			 */</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frontswap</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frontswap_test</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">swap_count</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SWAP_MAP_BAD</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We completely avoid races by reading each swap page in advance,</span>
<span class="cm"> * and then search for the process using it.  All the necessary</span>
<span class="cm"> * page table adjustments can then be made atomically.</span>
<span class="cm"> *</span>
<span class="cm"> * if the boolean frontswap is true, only unuse pages_to_unuse pages;</span>
<span class="cm"> * pages_to_unuse==0 means all pages; ignored if frontswap is false</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">try_to_unuse</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">bool</span> <span class="n">frontswap</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages_to_unuse</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">start_mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">swap_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">swcount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When searching mms for an entry, a good strategy is to</span>
<span class="cm">	 * start at the first mm we freed the previous entry from</span>
<span class="cm">	 * (though actually we don&#39;t notice whether we or coincidence</span>
<span class="cm">	 * freed the entry).  Initialize this start_mm with a hold.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A simpler strategy would be to start at the last mm we</span>
<span class="cm">	 * freed the previous entry from; but that would take less</span>
<span class="cm">	 * advantage of mmlist ordering, which clusters forked mms</span>
<span class="cm">	 * together, child after parent.  If we race with dup_mmap(), we</span>
<span class="cm">	 * prefer to resolve parent before child, lest we miss entries</span>
<span class="cm">	 * duplicated after we scanned child: using last mm would invert</span>
<span class="cm">	 * that.</span>
<span class="cm">	 */</span>
	<span class="n">start_mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mm_users</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Keep on scanning until all entries have gone.  Usually,</span>
<span class="cm">	 * one pass through swap_map is enough, but not necessarily:</span>
<span class="cm">	 * there are races when an instance of an entry might be missed.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">find_next_to_unuse</span><span class="p">(</span><span class="n">si</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">frontswap</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get a page for the entry, using the existing swap</span>
<span class="cm">		 * cache page if there is one.  Otherwise, get a clean</span>
<span class="cm">		 * page and read the swap into it.</span>
<span class="cm">		 */</span>
		<span class="n">swap_map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">swp_entry</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">read_swap_cache_async</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span>
					<span class="n">GFP_HIGHUSER_MOVABLE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Either swap_duplicate() failed because entry</span>
<span class="cm">			 * has been freed independently, and will not be</span>
<span class="cm">			 * reused since sys_swapoff() already disabled</span>
<span class="cm">			 * allocation from here, or alloc_page() failed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">swap_map</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t hold on to start_mm if it looks like exiting.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start_mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mmput</span><span class="p">(</span><span class="n">start_mm</span><span class="p">);</span>
			<span class="n">start_mm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">;</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mm_users</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Wait for and lock page.  When do_swap_page races with</span>
<span class="cm">		 * try_to_unuse, do_swap_page can handle the fault much</span>
<span class="cm">		 * faster than try_to_unuse can locate the entry.  This</span>
<span class="cm">		 * apparently redundant &quot;wait_on_page_locked&quot; lets try_to_unuse</span>
<span class="cm">		 * defer to do_swap_page in such a case - in some tests,</span>
<span class="cm">		 * do_swap_page and try_to_unuse repeatedly compete.</span>
<span class="cm">		 */</span>
		<span class="n">wait_on_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remove all references to entry.</span>
<span class="cm">		 */</span>
		<span class="n">swcount</span> <span class="o">=</span> <span class="o">*</span><span class="n">swap_map</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swap_count</span><span class="p">(</span><span class="n">swcount</span><span class="p">)</span> <span class="o">==</span> <span class="n">SWAP_MAP_SHMEM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">shmem_unuse</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="cm">/* page has already been unlocked and released */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swap_count</span><span class="p">(</span><span class="n">swcount</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">start_mm</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">unuse_mm</span><span class="p">(</span><span class="n">start_mm</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">swap_count</span><span class="p">(</span><span class="o">*</span><span class="n">swap_map</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">set_start_mm</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">swap_map</span> <span class="o">&gt;=</span> <span class="n">swcount</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">start_mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">new_start_mm</span> <span class="o">=</span> <span class="n">start_mm</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">prev_mm</span> <span class="o">=</span> <span class="n">start_mm</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>

			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_start_mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">);</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prev_mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">swap_count</span><span class="p">(</span><span class="o">*</span><span class="n">swap_map</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">retval</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">start_mm</span><span class="o">-&gt;</span><span class="n">mmlist</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mm</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span><span class="p">,</span> <span class="n">mmlist</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
				<span class="n">mmput</span><span class="p">(</span><span class="n">prev_mm</span><span class="p">);</span>
				<span class="n">prev_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>

				<span class="n">cond_resched</span><span class="p">();</span>

				<span class="n">swcount</span> <span class="o">=</span> <span class="o">*</span><span class="n">swap_map</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swap_count</span><span class="p">(</span><span class="n">swcount</span><span class="p">))</span> <span class="cm">/* any usage ? */</span>
					<span class="p">;</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mm</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">)</span>
					<span class="n">set_start_mm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">retval</span> <span class="o">=</span> <span class="n">unuse_mm</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">set_start_mm</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">swap_map</span> <span class="o">&lt;</span> <span class="n">swcount</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">mmput</span><span class="p">(</span><span class="n">new_start_mm</span><span class="p">);</span>
					<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mm_users</span><span class="p">);</span>
					<span class="n">new_start_mm</span> <span class="o">=</span> <span class="n">mm</span><span class="p">;</span>
					<span class="n">set_start_mm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
			<span class="n">mmput</span><span class="p">(</span><span class="n">prev_mm</span><span class="p">);</span>
			<span class="n">mmput</span><span class="p">(</span><span class="n">start_mm</span><span class="p">);</span>
			<span class="n">start_mm</span> <span class="o">=</span> <span class="n">new_start_mm</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If a reference remains (rare), we would like to leave</span>
<span class="cm">		 * the page in the swap cache; but try_to_unmap could</span>
<span class="cm">		 * then re-duplicate the entry once we drop page lock,</span>
<span class="cm">		 * so we might loop indefinitely; also, that page could</span>
<span class="cm">		 * not be swapped out to other storage meanwhile.  So:</span>
<span class="cm">		 * delete from cache even if there&#39;s another reference,</span>
<span class="cm">		 * after ensuring that the data has been saved to disk -</span>
<span class="cm">		 * since if the reference remains (rarer), it will be</span>
<span class="cm">		 * read from disk into another page.  Splitting into two</span>
<span class="cm">		 * pages would be incorrect if swap supported &quot;shared</span>
<span class="cm">		 * private&quot; pages, but they are handled by tmpfs files.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Given how unuse_vma() targets one particular offset</span>
<span class="cm">		 * in an anon_vma, once the anon_vma has been determined,</span>
<span class="cm">		 * this splitting happens to be just what is needed to</span>
<span class="cm">		 * handle where KSM pages have been swapped out: re-reading</span>
<span class="cm">		 * is unnecessarily slow, but we can fix that later on.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swap_count</span><span class="p">(</span><span class="o">*</span><span class="n">swap_map</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">writeback_control</span> <span class="n">wbc</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">sync_mode</span> <span class="o">=</span> <span class="n">WB_SYNC_NONE</span><span class="p">,</span>
			<span class="p">};</span>

			<span class="n">swap_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wbc</span><span class="p">);</span>
			<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * It is conceivable that a racing task removed this page from</span>
<span class="cm">		 * swap cache just before we acquired the page lock at the top,</span>
<span class="cm">		 * or while we dropped it in unuse_mm().  The page might even</span>
<span class="cm">		 * be back in swap cache on another swap area: that we must not</span>
<span class="cm">		 * delete, since it may not have been written out to swap yet.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageSwapCache</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">likely</span><span class="p">(</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">))</span>
			<span class="n">delete_from_swap_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * So we could skip searching mms once swap count went</span>
<span class="cm">		 * to 1, we did not mark any present ptes as dirty: must</span>
<span class="cm">		 * mark page dirty so shrink_page_list will preserve it.</span>
<span class="cm">		 */</span>
		<span class="n">SetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make sure that we aren&#39;t completely killing</span>
<span class="cm">		 * interactive performance.</span>
<span class="cm">		 */</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frontswap</span> <span class="o">&amp;&amp;</span> <span class="n">pages_to_unuse</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">pages_to_unuse</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mmput</span><span class="p">(</span><span class="n">start_mm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * After a successful try_to_unuse, if no swap is now in use, we know</span>
<span class="cm"> * we can empty the mmlist.  swap_lock must be held on entry and exit.</span>
<span class="cm"> * Note that mmlist_lock nests inside swap_lock, and an mm must be</span>
<span class="cm"> * added to the mmlist just after page_duplicate - before would be racy.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">drain_mmlist</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">nr_swapfiles</span><span class="p">;</span> <span class="n">type</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">inuse_pages</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_mm</span><span class="p">.</span><span class="n">mmlist</span><span class="p">)</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mmlist_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use this swapdev&#39;s extent info to locate the (PAGE_SIZE) block which</span>
<span class="cm"> * corresponds to page offset for the specified swap entry.</span>
<span class="cm"> * Note that the type of this function is sector_t, but it returns page offset</span>
<span class="cm"> * into the bdev, not sector offset.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">map_swap_entry</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">**</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">sis</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">swap_extent</span> <span class="o">*</span><span class="n">start_se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">swap_extent</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">sis</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">swp_type</span><span class="p">(</span><span class="n">entry</span><span class="p">)];</span>
	<span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">sis</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">swp_offset</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">start_se</span> <span class="o">=</span> <span class="n">sis</span><span class="o">-&gt;</span><span class="n">curr_swap_extent</span><span class="p">;</span>
	<span class="n">se</span> <span class="o">=</span> <span class="n">start_se</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">start_page</span> <span class="o">&lt;=</span> <span class="n">offset</span> <span class="o">&amp;&amp;</span>
				<span class="n">offset</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">start_page</span> <span class="o">+</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">start_block</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">start_page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lh</span> <span class="o">=</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">se</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">swap_extent</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">sis</span><span class="o">-&gt;</span><span class="n">curr_swap_extent</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">se</span> <span class="o">==</span> <span class="n">start_se</span><span class="p">);</span>		<span class="cm">/* It *must* be present */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns the page offset into bdev for the specified page&#39;s swap entry.</span>
<span class="cm"> */</span>
<span class="n">sector_t</span> <span class="nf">map_swap_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">**</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">;</span>
	<span class="n">entry</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">map_swap_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">bdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free all of a swapdev&#39;s extent information</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_swap_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">sis</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sis</span><span class="o">-&gt;</span><span class="n">first_swap_extent</span><span class="p">.</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">swap_extent</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>

		<span class="n">se</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">sis</span><span class="o">-&gt;</span><span class="n">first_swap_extent</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">swap_extent</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a block range (and the corresponding page range) into this swapdev&#39;s</span>
<span class="cm"> * extent list.  The extent list is kept sorted in page order.</span>
<span class="cm"> *</span>
<span class="cm"> * This function rather assumes that it is called in ascending page order.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">add_swap_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">sis</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_page</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">start_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_extent</span> <span class="o">*</span><span class="n">se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">swap_extent</span> <span class="o">*</span><span class="n">new_se</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start_page</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sis</span><span class="o">-&gt;</span><span class="n">first_swap_extent</span><span class="p">;</span>
		<span class="n">sis</span><span class="o">-&gt;</span><span class="n">curr_swap_extent</span> <span class="o">=</span> <span class="n">se</span><span class="p">;</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">start_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
		<span class="n">se</span><span class="o">-&gt;</span><span class="n">start_block</span> <span class="o">=</span> <span class="n">start_block</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lh</span> <span class="o">=</span> <span class="n">sis</span><span class="o">-&gt;</span><span class="n">first_swap_extent</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>	<span class="cm">/* Highest extent */</span>
		<span class="n">se</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">swap_extent</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">start_page</span> <span class="o">+</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">!=</span> <span class="n">start_page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">start_block</span> <span class="o">+</span> <span class="n">se</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="n">start_block</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Merge it */</span>
			<span class="n">se</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">nr_pages</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * No merge.  Insert a new extent, preserving ordering.</span>
<span class="cm">	 */</span>
	<span class="n">new_se</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">se</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_se</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">new_se</span><span class="o">-&gt;</span><span class="n">start_page</span> <span class="o">=</span> <span class="n">start_page</span><span class="p">;</span>
	<span class="n">new_se</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">new_se</span><span class="o">-&gt;</span><span class="n">start_block</span> <span class="o">=</span> <span class="n">start_block</span><span class="p">;</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_se</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sis</span><span class="o">-&gt;</span><span class="n">first_swap_extent</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A `swap extent&#39; is a simple thing which maps a contiguous range of pages</span>
<span class="cm"> * onto a contiguous range of disk blocks.  An ordered list of swap extents</span>
<span class="cm"> * is built at swapon time and is then used at swap_writepage/swap_readpage</span>
<span class="cm"> * time for locating where on disk a page belongs.</span>
<span class="cm"> *</span>
<span class="cm"> * If the swapfile is an S_ISBLK block device, a single extent is installed.</span>
<span class="cm"> * This is done so that the main operating code can treat S_ISBLK and S_ISREG</span>
<span class="cm"> * swap files identically.</span>
<span class="cm"> *</span>
<span class="cm"> * Whether the swapdev is an S_ISREG file or an S_ISBLK blockdev, the swap</span>
<span class="cm"> * extent list operates in PAGE_SIZE disk blocks.  Both S_ISREG and S_ISBLK</span>
<span class="cm"> * swapfiles are handled *identically* after swapon time.</span>
<span class="cm"> *</span>
<span class="cm"> * For S_ISREG swapfiles, setup_swap_extents() will walk all the file&#39;s blocks</span>
<span class="cm"> * and will parse them into an ordered extent list, in PAGE_SIZE chunks.  If</span>
<span class="cm"> * some stray blocks are found which do not fall within the PAGE_SIZE alignment</span>
<span class="cm"> * requirements, they are simply tossed out - we will never use those blocks</span>
<span class="cm"> * for swapping.</span>
<span class="cm"> *</span>
<span class="cm"> * For S_ISREG swapfiles we set S_SWAPFILE across the life of the swapon.  This</span>
<span class="cm"> * prevents root from shooting her foot off by ftruncating an in-use swapfile,</span>
<span class="cm"> * which will scribble on the fs.</span>
<span class="cm"> *</span>
<span class="cm"> * The amount of disk space which a single swap extent represents varies.</span>
<span class="cm"> * Typically it is in the 1-4 megabyte range.  So we can have hundreds of</span>
<span class="cm"> * extents in the list.  To avoid much list walking, we cache the previous</span>
<span class="cm"> * search location in `curr_swap_extent&#39;, and start new searches from there.</span>
<span class="cm"> * This is extremely effective.  The average number of iterations in</span>
<span class="cm"> * map_swap_page() has been measured at about 0.3 per page.  - akpm.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_swap_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">sis</span><span class="p">,</span> <span class="n">sector_t</span> <span class="o">*</span><span class="n">span</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocks_per_page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page_no</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">probe_block</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">last_block</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">lowest_block</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">highest_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_extents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">sis</span><span class="o">-&gt;</span><span class="n">swap_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">add_swap_extent</span><span class="p">(</span><span class="n">sis</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sis</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="o">*</span><span class="n">span</span> <span class="o">=</span> <span class="n">sis</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">blkbits</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">blocks_per_page</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Map all the blocks into the extent list.  This code doesn&#39;t try</span>
<span class="cm">	 * to be very smart.</span>
<span class="cm">	 */</span>
	<span class="n">probe_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">page_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">last_block</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">probe_block</span> <span class="o">+</span> <span class="n">blocks_per_page</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">last_block</span> <span class="o">&amp;&amp;</span>
			<span class="n">page_no</span> <span class="o">&lt;</span> <span class="n">sis</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">block_in_page</span><span class="p">;</span>
		<span class="n">sector_t</span> <span class="n">first_block</span><span class="p">;</span>

		<span class="n">first_block</span> <span class="o">=</span> <span class="n">bmap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">probe_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first_block</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">bad_bmap</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * It must be PAGE_SIZE aligned on-disk</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first_block</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocks_per_page</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">probe_block</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">reprobe</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">block_in_page</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">block_in_page</span> <span class="o">&lt;</span> <span class="n">blocks_per_page</span><span class="p">;</span>
					<span class="n">block_in_page</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sector_t</span> <span class="n">block</span><span class="p">;</span>

			<span class="n">block</span> <span class="o">=</span> <span class="n">bmap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">probe_block</span> <span class="o">+</span> <span class="n">block_in_page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">bad_bmap</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">!=</span> <span class="n">first_block</span> <span class="o">+</span> <span class="n">block_in_page</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Discontiguity */</span>
				<span class="n">probe_block</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">reprobe</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">first_block</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="n">blkbits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_no</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* exclude the header page */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">first_block</span> <span class="o">&lt;</span> <span class="n">lowest_block</span><span class="p">)</span>
				<span class="n">lowest_block</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">first_block</span> <span class="o">&gt;</span> <span class="n">highest_block</span><span class="p">)</span>
				<span class="n">highest_block</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * We found a PAGE_SIZE-length, PAGE_SIZE-aligned run of blocks</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">add_swap_extent</span><span class="p">(</span><span class="n">sis</span><span class="p">,</span> <span class="n">page_no</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">nr_extents</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">page_no</span><span class="o">++</span><span class="p">;</span>
		<span class="n">probe_block</span> <span class="o">+=</span> <span class="n">blocks_per_page</span><span class="p">;</span>
<span class="nl">reprobe:</span>
		<span class="k">continue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nr_extents</span><span class="p">;</span>
	<span class="o">*</span><span class="n">span</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">highest_block</span> <span class="o">-</span> <span class="n">lowest_block</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_no</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">page_no</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* force Empty message */</span>
	<span class="n">sis</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">page_no</span><span class="p">;</span>
	<span class="n">sis</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">page_no</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sis</span><span class="o">-&gt;</span><span class="n">highest_bit</span> <span class="o">=</span> <span class="n">page_no</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">bad_bmap:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;swapon: swapfile has holes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enable_swap_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prio</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">swap_map</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">frontswap_map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">prev</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prio</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">prio</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="o">--</span><span class="n">least_priority</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_map</span> <span class="o">=</span> <span class="n">swap_map</span><span class="p">;</span>
	<span class="n">frontswap_map_set</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">frontswap_map</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SWP_WRITEOK</span><span class="p">;</span>
	<span class="n">nr_swap_pages</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
	<span class="n">total_swap_pages</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>

	<span class="cm">/* insert swap space into swap_list: */</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">swap_list</span><span class="p">.</span><span class="n">head</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&gt;=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">swap_list</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">swap_list</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">swap_info</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">frontswap_init</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">swapoff</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">specialfile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">swap_map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">swap_file</span><span class="p">,</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oom_score_adj</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">prev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>

	<span class="n">pathname</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">specialfile</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pathname</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pathname</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">victim</span> <span class="o">=</span> <span class="n">filp_open</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="o">|</span><span class="n">O_LARGEFILE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">putname</span><span class="p">(</span><span class="n">pathname</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">victim</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">victim</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="n">swap_list</span><span class="p">.</span><span class="n">head</span><span class="p">;</span> <span class="n">type</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_WRITEOK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span> <span class="o">==</span> <span class="n">mapping</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">security_vm_enough_memory_mm</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">))</span>
		<span class="n">vm_unacct_memory</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">swap_list</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">swap_info</span><span class="p">[</span><span class="n">prev</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">swap_list</span><span class="p">.</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* just pick something that&#39;s safe... */</span>
		<span class="n">swap_list</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">swap_list</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
			<span class="n">swap_info</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">prio</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="o">--</span><span class="p">;</span>
		<span class="n">least_priority</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nr_swap_pages</span> <span class="o">-=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
	<span class="n">total_swap_pages</span> <span class="o">-=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SWP_WRITEOK</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>

	<span class="n">oom_score_adj</span> <span class="o">=</span> <span class="n">test_set_oom_score_adj</span><span class="p">(</span><span class="n">OOM_SCORE_ADJ_MAX</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">try_to_unuse</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* force all pages to be unused */</span>
	<span class="n">compare_swap_oom_score_adj</span><span class="p">(</span><span class="n">OOM_SCORE_ADJ_MAX</span><span class="p">,</span> <span class="n">oom_score_adj</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * reading p-&gt;prio and p-&gt;swap_map outside the lock is</span>
<span class="cm">		 * safe here because only sys_swapon and sys_swapoff</span>
<span class="cm">		 * change them, and there can be no other sys_swapon or</span>
<span class="cm">		 * sys_swapoff for this swap_info_struct at this point.</span>
<span class="cm">		 */</span>
		<span class="cm">/* re-insert swap space back into swap_list */</span>
		<span class="n">enable_swap_info</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">,</span> <span class="n">frontswap_map_get</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">destroy_swap_extents</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_CONTINUED</span><span class="p">)</span>
		<span class="n">free_swap_count_continuations</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapon_mutex</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="n">drain_mmlist</span><span class="p">();</span>

	<span class="cm">/* wait for anyone still in scan_swap_map */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">highest_bit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* cuts scans short */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&gt;=</span> <span class="n">SWP_SCANNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">swap_file</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_file</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">swap_map</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">frontswap_invalidate_area</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapon_mutex</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">swap_map</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">frontswap_map_get</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="cm">/* Destroy swap account informatin */</span>
	<span class="n">swap_cgroup_swapoff</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">I_BDEV</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">set_blocksize</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">old_block_size</span><span class="p">);</span>
		<span class="n">blkdev_put</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_WRITE</span> <span class="o">|</span> <span class="n">FMODE_EXCL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">S_SWAPFILE</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">filp_close</span><span class="p">(</span><span class="n">swap_file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_poll_event</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_poll_wait</span><span class="p">);</span>

<span class="nl">out_dput:</span>
	<span class="n">filp_close</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">swaps_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">poll_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_poll_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">seq</span><span class="o">-&gt;</span><span class="n">poll_event</span> <span class="o">!=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_poll_event</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">seq</span><span class="o">-&gt;</span><span class="n">poll_event</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_poll_event</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span> <span class="o">|</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLPRI</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* iterator */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">swap_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">swap</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">l</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapon_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SEQ_START_TOKEN</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">nr_swapfiles</span><span class="p">;</span> <span class="n">type</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smp_rmb</span><span class="p">();</span>	<span class="cm">/* read nr_swapfiles before swap_info[type] */</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_USED</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">l</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">si</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">swap_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">swap</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">nr_swapfiles</span><span class="p">;</span> <span class="n">type</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">smp_rmb</span><span class="p">();</span>	<span class="cm">/* read nr_swapfiles before swap_info[type] */</span>
		<span class="n">si</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_USED</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="o">++*</span><span class="n">pos</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">si</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">swap_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">swap</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapon_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">swap_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">swap</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">si</span> <span class="o">==</span> <span class="n">SEQ_START_TOKEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">swap</span><span class="p">,</span><span class="s">&quot;Filename</span><span class="se">\t\t\t\t</span><span class="s">Type</span><span class="se">\t\t</span><span class="s">Size</span><span class="se">\t</span><span class="s">Used</span><span class="se">\t</span><span class="s">Priority</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_file</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">seq_path</span><span class="p">(</span><span class="n">swap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">,</span> <span class="s">&quot; </span><span class="se">\t\n\\</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">swap</span><span class="p">,</span> <span class="s">&quot;%*s%s</span><span class="se">\t</span><span class="s">%u</span><span class="se">\t</span><span class="s">%u</span><span class="se">\t</span><span class="s">%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">len</span> <span class="o">&lt;</span> <span class="mi">40</span> <span class="o">?</span> <span class="mi">40</span> <span class="o">-</span> <span class="n">len</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">,</span>
			<span class="n">S_ISBLK</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">?</span>
				<span class="s">&quot;partition&quot;</span> <span class="o">:</span> <span class="s">&quot;file</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">si</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">),</span>
			<span class="n">si</span><span class="o">-&gt;</span><span class="n">inuse_pages</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">),</span>
			<span class="n">si</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">swaps_op</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span>	<span class="n">swap_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span> <span class="o">=</span>		<span class="n">swap_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span> <span class="o">=</span>		<span class="n">swap_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span> <span class="o">=</span>		<span class="n">swap_show</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">swaps_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">swaps_op</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">seq</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">seq</span><span class="o">-&gt;</span><span class="n">poll_event</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_poll_event</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_swaps_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">swaps_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span>		<span class="o">=</span> <span class="n">swaps_poll</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">procswaps_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;swaps&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_swaps_operations</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__initcall</span><span class="p">(</span><span class="n">procswaps_init</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_FS */</span><span class="cp"></span>

<span class="cp">#ifdef MAX_SWAPFILES_CHECK</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">max_swapfiles_check</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MAX_SWAPFILES_CHECK</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">max_swapfiles_check</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="nf">alloc_swap_info</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">nr_swapfiles</span><span class="p">;</span> <span class="n">type</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_USED</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">MAX_SWAPFILES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EPERM</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">nr_swapfiles</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Write swap_info[type] before nr_swapfiles, in case a</span>
<span class="cm">		 * racing procfs swap_start() or swap_next() is reading them.</span>
<span class="cm">		 * (We never shrink nr_swapfiles, we never free this entry.)</span>
<span class="cm">		 */</span>
		<span class="n">smp_wmb</span><span class="p">();</span>
		<span class="n">nr_swapfiles</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not memset this entry: a racing procfs swap_next()</span>
<span class="cm">		 * would be relying on p-&gt;type to remain valid.</span>
<span class="cm">		 */</span>
	<span class="p">}</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">first_swap_extent</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SWP_USED</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">claim_swapfile</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">bdgrab</span><span class="p">(</span><span class="n">I_BDEV</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">blkdev_get</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span>
				   <span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_WRITE</span> <span class="o">|</span> <span class="n">FMODE_EXCL</span><span class="p">,</span>
				   <span class="n">sys_swapon</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">old_block_size</span> <span class="o">=</span> <span class="n">block_size</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">set_blocksize</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SWP_BLKDEV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_SWAPFILE</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">read_swap_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					<span class="k">union</span> <span class="n">swap_header</span> <span class="o">*</span><span class="n">swap_header</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxpages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">swapfilepages</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="s">&quot;SWAPSPACE2&quot;</span><span class="p">,</span> <span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">.</span><span class="n">magic</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to find swap-space signature</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* swap partition endianess hack... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swab32</span><span class="p">(</span><span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">version</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swab32s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>
		<span class="n">swab32s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">last_page</span><span class="p">);</span>
		<span class="n">swab32s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">nr_badpages</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">nr_badpages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">swab32s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">badpages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="cm">/* Check the swap header&#39;s sub-version */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">version</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;Unable to handle swap header version %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">lowest_bit</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">cluster_next</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">cluster_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find out how many pages are allowed for a single swap</span>
<span class="cm">	 * device. There are two limiting factors: 1) the number</span>
<span class="cm">	 * of bits for the swap offset in the swp_entry_t type, and</span>
<span class="cm">	 * 2) the number of bits in the swap pte as defined by the</span>
<span class="cm">	 * different architectures. In order to find the</span>
<span class="cm">	 * largest possible bit mask, a swap entry with swap type 0</span>
<span class="cm">	 * and swap offset ~0UL is created, encoded to a swap pte,</span>
<span class="cm">	 * decoded to a swp_entry_t again, and finally the swap</span>
<span class="cm">	 * offset is extracted. This will mask all the bits from</span>
<span class="cm">	 * the initial ~0UL mask that can&#39;t be encoded in either</span>
<span class="cm">	 * the swp_entry_t or the architecture definition of a</span>
<span class="cm">	 * swap pte.</span>
<span class="cm">	 */</span>
	<span class="n">maxpages</span> <span class="o">=</span> <span class="n">swp_offset</span><span class="p">(</span><span class="n">pte_to_swp_entry</span><span class="p">(</span>
			<span class="n">swp_entry_to_pte</span><span class="p">(</span><span class="n">swp_entry</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">))))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxpages</span> <span class="o">&gt;</span> <span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">last_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">maxpages</span> <span class="o">=</span> <span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">last_page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* p-&gt;max is an unsigned int: don&#39;t overflow it */</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">maxpages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">maxpages</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">highest_bit</span> <span class="o">=</span> <span class="n">maxpages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">maxpages</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">swapfilepages</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swapfilepages</span> <span class="o">&amp;&amp;</span> <span class="n">maxpages</span> <span class="o">&gt;</span> <span class="n">swapfilepages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;Swap area shorter than signature indicates</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">nr_badpages</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">nr_badpages</span> <span class="o">&gt;</span> <span class="n">MAX_SWAP_BADPAGES</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">maxpages</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_swap_map_and_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					<span class="k">union</span> <span class="n">swap_header</span> <span class="o">*</span><span class="n">swap_header</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">swap_map</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxpages</span><span class="p">,</span>
					<span class="n">sector_t</span> <span class="o">*</span><span class="n">span</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_good_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_extents</span><span class="p">;</span>

	<span class="n">nr_good_pages</span> <span class="o">=</span> <span class="n">maxpages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* omit header page */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">nr_badpages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_nr</span> <span class="o">=</span> <span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">badpages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_nr</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">page_nr</span> <span class="o">&gt;</span> <span class="n">swap_header</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">.</span><span class="n">last_page</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_nr</span> <span class="o">&lt;</span> <span class="n">maxpages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">swap_map</span><span class="p">[</span><span class="n">page_nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">SWAP_MAP_BAD</span><span class="p">;</span>
			<span class="n">nr_good_pages</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_good_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swap_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SWAP_MAP_BAD</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">maxpages</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">nr_good_pages</span><span class="p">;</span>
		<span class="n">nr_extents</span> <span class="o">=</span> <span class="n">setup_swap_extents</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">span</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_extents</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">nr_extents</span><span class="p">;</span>
		<span class="n">nr_good_pages</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_good_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Empty swap-file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nr_extents</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">swapon</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">specialfile</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">swap_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">swap_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">swap_header</span> <span class="o">*</span><span class="n">swap_header</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_extents</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">span</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">maxpages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">swap_map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">frontswap_map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">swap_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SWAP_FLAGS_VALID</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">alloc_swap_info</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">getname</span><span class="p">(</span><span class="n">specialfile</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
		<span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_swap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">swap_file</span> <span class="o">=</span> <span class="n">filp_open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="o">|</span><span class="n">O_LARGEFILE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">swap_file</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">swap_file</span><span class="p">);</span>
		<span class="n">swap_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_swap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_file</span> <span class="o">=</span> <span class="n">swap_file</span><span class="p">;</span>
	<span class="n">mapping</span> <span class="o">=</span> <span class="n">swap_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_swapfiles</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">swap_file</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">swap_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">bad_swap</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="cm">/* If S_ISREG(inode-&gt;i_mode) will do mutex_lock(&amp;inode-&gt;i_mutex); */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">claim_swapfile</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad_swap</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the swap header.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_swap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">read_mapping_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">swap_file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bad_swap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">swap_header</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">maxpages</span> <span class="o">=</span> <span class="n">read_swap_header</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">swap_header</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">maxpages</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_swap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* OK, set up the swap map and apply the bad block list */</span>
	<span class="n">swap_map</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">maxpages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swap_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_swap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">swap_cgroup_swapon</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">maxpages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_swap</span><span class="p">;</span>

	<span class="n">nr_extents</span> <span class="o">=</span> <span class="n">setup_swap_map_and_extents</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">swap_header</span><span class="p">,</span> <span class="n">swap_map</span><span class="p">,</span>
		<span class="n">maxpages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">span</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nr_extents</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">nr_extents</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">bad_swap</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* frontswap enabled? set up bit-per-page map for frontswap */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frontswap_enabled</span><span class="p">)</span>
		<span class="n">frontswap_map</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">maxpages</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_nonrot</span><span class="p">(</span><span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SWP_SOLIDSTATE</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">cluster_next</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">random32</span><span class="p">()</span> <span class="o">%</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">highest_bit</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">swap_flags</span> <span class="o">&amp;</span> <span class="n">SWAP_FLAG_DISCARD</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">discard_swap</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SWP_DISCARDABLE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapon_mutex</span><span class="p">);</span>
	<span class="n">prio</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swap_flags</span> <span class="o">&amp;</span> <span class="n">SWAP_FLAG_PREFER</span><span class="p">)</span>
		<span class="n">prio</span> <span class="o">=</span>
		  <span class="p">(</span><span class="n">swap_flags</span> <span class="o">&amp;</span> <span class="n">SWAP_FLAG_PRIO_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">SWAP_FLAG_PRIO_SHIFT</span><span class="p">;</span>
	<span class="n">enable_swap_info</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">prio</span><span class="p">,</span> <span class="n">swap_map</span><span class="p">,</span> <span class="n">frontswap_map</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Adding %uk swap on %s.  &quot;</span>
			<span class="s">&quot;Priority:%d extents:%d across:%lluk %s%s%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">pages</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">prio</span><span class="p">,</span>
		<span class="n">nr_extents</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">span</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span>
		<span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_SOLIDSTATE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;SS&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_DISCARDABLE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;D&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">frontswap_map</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;FS&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swapon_mutex</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_poll_event</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc_poll_wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_SWAPFILE</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">bad_swap:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_blocksize</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">old_block_size</span><span class="p">);</span>
		<span class="n">blkdev_put</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_WRITE</span> <span class="o">|</span> <span class="n">FMODE_EXCL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">destroy_swap_extents</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">swap_cgroup_swapoff</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">swap_map</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">swap_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
			<span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">filp_close</span><span class="p">(</span><span class="n">swap_file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span>
		<span class="n">putname</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">si_swapinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">sysinfo</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_to_be_unused</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">type</span> <span class="o">&lt;</span> <span class="n">nr_swapfiles</span><span class="p">;</span> <span class="n">type</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_USED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SWP_WRITEOK</span><span class="p">))</span>
			<span class="n">nr_to_be_unused</span> <span class="o">+=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">inuse_pages</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">val</span><span class="o">-&gt;</span><span class="n">freeswap</span> <span class="o">=</span> <span class="n">nr_swap_pages</span> <span class="o">+</span> <span class="n">nr_to_be_unused</span><span class="p">;</span>
	<span class="n">val</span><span class="o">-&gt;</span><span class="n">totalswap</span> <span class="o">=</span> <span class="n">total_swap_pages</span> <span class="o">+</span> <span class="n">nr_to_be_unused</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Verify that a swap entry is valid and increment its swap map count.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns error code in following case.</span>
<span class="cm"> * - success -&gt; 0</span>
<span class="cm"> * - swp_entry is invalid -&gt; EINVAL</span>
<span class="cm"> * - swp_entry is migration entry -&gt; EINVAL</span>
<span class="cm"> * - swap-cache reference is requested but there is already one. -&gt; EEXIST</span>
<span class="cm"> * - swap-cache reference is requested but the entry is not used. -&gt; ENOENT</span>
<span class="cm"> * - swap-mapped reference requested but needs continued swap count. -&gt; ENOMEM</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__swap_duplicate</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">usage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">has_cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">non_swap_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">swp_type</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&gt;=</span> <span class="n">nr_swapfiles</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad_file</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">swap_info</span><span class="p">[</span><span class="n">type</span><span class="p">];</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">swp_offset</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unlock_out</span><span class="p">;</span>

	<span class="n">count</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
	<span class="n">has_cache</span> <span class="o">=</span> <span class="n">count</span> <span class="o">&amp;</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SWAP_HAS_CACHE</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">usage</span> <span class="o">==</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* set SWAP_HAS_CACHE if there is no cache and entry is used */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_cache</span> <span class="o">&amp;&amp;</span> <span class="n">count</span><span class="p">)</span>
			<span class="n">has_cache</span> <span class="o">=</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">has_cache</span><span class="p">)</span>		<span class="cm">/* someone else added cache */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">else</span>				<span class="cm">/* no users remaining */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">||</span> <span class="n">has_cache</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">COUNT_CONTINUED</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">SWAP_MAP_MAX</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">usage</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">COUNT_CONTINUED</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SWAP_MAP_MAX</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">swap_count_continued</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">COUNT_CONTINUED</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>			<span class="cm">/* unused swap entry */</span>

	<span class="n">p</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span> <span class="o">|</span> <span class="n">has_cache</span><span class="p">;</span>

<span class="nl">unlock_out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="nl">bad_file:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;swap_dup: %s%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Bad_file</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Help swapoff by noting that swap entry belongs to shmem/tmpfs</span>
<span class="cm"> * (in which case its reference count is never incremented).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">swap_shmem_alloc</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__swap_duplicate</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">SWAP_MAP_SHMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Increase reference count of swap entry by 1.</span>
<span class="cm"> * Returns 0 for success, or -ENOMEM if a swap_count_continuation is required</span>
<span class="cm"> * but could not be atomically allocated.  Returns 0, just as if it succeeded,</span>
<span class="cm"> * if __swap_duplicate() fails for another reason (-EINVAL or -ENOENT), which</span>
<span class="cm"> * might occur if a page table entry has got corrupted.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">swap_duplicate</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">__swap_duplicate</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">add_swap_count_continuation</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @entry: swap entry for which we allocate swap cache.</span>
<span class="cm"> *</span>
<span class="cm"> * Called when allocating swap cache for existing swap entry,</span>
<span class="cm"> * This can return error codes. Returns 0 at success.</span>
<span class="cm"> * -EBUSY means there is a swap cache.</span>
<span class="cm"> * Note: return code is different from swap_duplicate().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">swapcache_prepare</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__swap_duplicate</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">SWAP_HAS_CACHE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * add_swap_count_continuation - called when a swap count is duplicated</span>
<span class="cm"> * beyond SWAP_MAP_MAX, it allocates a new page and links that to the entry&#39;s</span>
<span class="cm"> * page of the original vmalloc&#39;ed swap_map, to hold the continuation count</span>
<span class="cm"> * (for that entry and for its neighbouring PAGE_SIZE swap entries).  Called</span>
<span class="cm"> * again when count is duplicated beyond SWAP_MAP_MAX * SWAP_CONT_MAX, etc.</span>
<span class="cm"> *</span>
<span class="cm"> * These continuation pages are seldom referenced: the common paths all work</span>
<span class="cm"> * on the original swap_map, only referring to a continuation page when the</span>
<span class="cm"> * low &quot;digit&quot; of a count is incremented or decremented through SWAP_MAP_MAX.</span>
<span class="cm"> *</span>
<span class="cm"> * add_swap_count_continuation(, GFP_ATOMIC) can be called while holding</span>
<span class="cm"> * page table locks; if it fails, add_swap_count_continuation(, GFP_KERNEL)</span>
<span class="cm"> * can be called after dropping locks.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">add_swap_count_continuation</span><span class="p">(</span><span class="n">swp_entry_t</span> <span class="n">entry</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">list_page</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When debugging, it&#39;s easier to use __GFP_ZERO here; but it&#39;s better</span>
<span class="cm">	 * for latency not to zero a page while GFP_ATOMIC and holding locks.</span>
<span class="cm">	 */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">gfp_mask</span> <span class="o">|</span> <span class="n">__GFP_HIGHMEM</span><span class="p">);</span>

	<span class="n">si</span> <span class="o">=</span> <span class="n">swap_info_get</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">si</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * An acceptable race has occurred since the failing</span>
<span class="cm">		 * __swap_duplicate(): the swap entry has been freed,</span>
<span class="cm">		 * perhaps even the whole swap_map cleared for swapoff.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">outer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">swp_offset</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SWAP_HAS_CACHE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">COUNT_CONTINUED</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SWAP_MAP_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The higher the swap count, the more likely it is that tasks</span>
<span class="cm">		 * will race to add swap count continuation: we need to avoid</span>
<span class="cm">		 * over-provisioning.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are fortunate that although vmalloc_to_page uses pte_offset_map,</span>
<span class="cm">	 * no architecture is using highmem pages for kernel pagetables: so it</span>
<span class="cm">	 * will not corrupt the GFP_ATOMIC caller&#39;s atomic pagetable kmaps.</span>
<span class="cm">	 */</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">vmalloc_to_page</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Page allocation does not initialize the page&#39;s lru field,</span>
<span class="cm">	 * but it does always reset its private field.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_private</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">&amp;</span> <span class="n">COUNT_CONTINUED</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">set_page_private</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">SWP_CONTINUED</span><span class="p">);</span>
		<span class="n">si</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">SWP_CONTINUED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">list_page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the previous map said no continuation, but we&#39;ve found</span>
<span class="cm">		 * a continuation page, free our allocation and use this one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">count</span> <span class="o">&amp;</span> <span class="n">COUNT_CONTINUED</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">map</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">list_page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this continuation count now has some space in it,</span>
<span class="cm">		 * free our allocation and use this one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">count</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">COUNT_CONTINUED</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SWAP_CONT_MAX</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>			<span class="cm">/* now it&#39;s attached, don&#39;t free it */</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">swap_lock</span><span class="p">);</span>
<span class="nl">outer:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * swap_count_continued - when the original swap_map count is incremented</span>
<span class="cm"> * from SWAP_MAP_MAX, check if there is already a continuation page to carry</span>
<span class="cm"> * into, carry if so, or else fail until a new continuation page is allocated;</span>
<span class="cm"> * when the original swap_map count is decremented from 0 with continuation,</span>
<span class="cm"> * borrow from the continuation and report whether it still holds more.</span>
<span class="cm"> * Called while __swap_duplicate() or swap_entry_free() holds swap_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">swap_count_continued</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span><span class="p">,</span>
				 <span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">vmalloc_to_page</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_private</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SWP_CONTINUED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">&amp;</span> <span class="n">COUNT_CONTINUED</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>		<span class="cm">/* need to add count continuation */</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
	<span class="n">map</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">SWAP_MAP_MAX</span><span class="p">)</span>	<span class="cm">/* initial increment from swap_map */</span>
		<span class="k">goto</span> <span class="n">init_map</span><span class="p">;</span>		<span class="cm">/* jump over SWAP_CONT_MAX checks */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="p">(</span><span class="n">SWAP_MAP_MAX</span> <span class="o">|</span> <span class="n">COUNT_CONTINUED</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* incrementing */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Think of how you add 1 to 999</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">map</span> <span class="o">==</span> <span class="p">(</span><span class="n">SWAP_CONT_MAX</span> <span class="o">|</span> <span class="n">COUNT_CONTINUED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">head</span><span class="p">);</span>
			<span class="n">map</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">map</span> <span class="o">==</span> <span class="n">SWAP_CONT_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>	<span class="cm">/* add count continuation */</span>
			<span class="n">map</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
<span class="nl">init_map:</span>		<span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* we didn&#39;t zero the page */</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">map</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">map</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
			<span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">COUNT_CONTINUED</span><span class="p">;</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>			<span class="cm">/* incremented */</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>				<span class="cm">/* decrementing */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Think of how you subtract 1 from 1000</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="n">COUNT_CONTINUED</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">map</span> <span class="o">==</span> <span class="n">COUNT_CONTINUED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">head</span><span class="p">);</span>
			<span class="n">map</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">*</span><span class="n">map</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="o">*</span><span class="n">map</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">map</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">map</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
			<span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="n">SWAP_CONT_MAX</span> <span class="o">|</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">COUNT_CONTINUED</span><span class="p">;</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="n">COUNT_CONTINUED</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * free_swap_count_continuations - swapoff free all the continuation pages</span>
<span class="cm"> * appended to the swap_map, after swap_map is quiesced, before vfree&#39;ing it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">free_swap_count_continuations</span><span class="p">(</span><span class="k">struct</span> <span class="n">swap_info_struct</span> <span class="o">*</span><span class="n">si</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">si</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">;</span> <span class="n">offset</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">vmalloc_to_page</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">swap_map</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_private</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
			<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
				<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
				<span class="n">list_del</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
				<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
