<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › compaction.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>compaction.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/mm/compaction.c</span>
<span class="cm"> *</span>
<span class="cm"> * Memory compaction for the reduction of external fragmentation. Note that</span>
<span class="cm"> * this heavily depends upon page migration to do all the real heavy</span>
<span class="cm"> * lifting</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright IBM Corp. 2007-2010 Mel Gorman &lt;mel@csn.ul.ie&gt;</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/migrate.h&gt;</span>
<span class="cp">#include &lt;linux/compaction.h&gt;</span>
<span class="cp">#include &lt;linux/mm_inline.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#if defined CONFIG_COMPACTION || defined CONFIG_CMA</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/compaction.h&gt;</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">release_freepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">freelist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">freelist</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">map_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">arch_alloc_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">kernel_map_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">migrate_async_suitable</span><span class="p">(</span><span class="kt">int</span> <span class="n">migratetype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">is_migrate_cma</span><span class="p">(</span><span class="n">migratetype</span><span class="p">)</span> <span class="o">||</span> <span class="n">migratetype</span> <span class="o">==</span> <span class="n">MIGRATE_MOVABLE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Isolate free pages onto a private freelist. Caller must hold zone-&gt;lock.</span>
<span class="cm"> * If @strict is true, will abort returning 0 on any invalid PFNs or non-free</span>
<span class="cm"> * pages inside of the pageblock (even though it may still end up isolating</span>
<span class="cm"> * some pages).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">isolate_freepages_block</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blockpfn</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">freelist</span><span class="p">,</span>
				<span class="n">bool</span> <span class="n">strict</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_isolated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">cursor</span><span class="p">;</span>

	<span class="n">cursor</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">blockpfn</span><span class="p">);</span>

	<span class="cm">/* Isolate free pages. This assumes the block is valid */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">blockpfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span><span class="p">;</span> <span class="n">blockpfn</span><span class="o">++</span><span class="p">,</span> <span class="n">cursor</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">isolated</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">cursor</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid_within</span><span class="p">(</span><span class="n">blockpfn</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strict</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nr_scanned</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageBuddy</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">strict</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Found a free page, break it into order-0 pages */</span>
		<span class="n">isolated</span> <span class="o">=</span> <span class="n">split_free_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isolated</span> <span class="o">&amp;&amp;</span> <span class="n">strict</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">total_isolated</span> <span class="o">+=</span> <span class="n">isolated</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">isolated</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">freelist</span><span class="p">);</span>
			<span class="n">page</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* If a page was split, advance to the end of it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isolated</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">blockpfn</span> <span class="o">+=</span> <span class="n">isolated</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">cursor</span> <span class="o">+=</span> <span class="n">isolated</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">trace_mm_compaction_isolate_freepages</span><span class="p">(</span><span class="n">nr_scanned</span><span class="p">,</span> <span class="n">total_isolated</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">total_isolated</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * isolate_freepages_range() - isolate free pages.</span>
<span class="cm"> * @start_pfn: The first PFN to start isolating.</span>
<span class="cm"> * @end_pfn:   The one-past-last PFN.</span>
<span class="cm"> *</span>
<span class="cm"> * Non-free pages, invalid PFNs, or zone boundaries within the</span>
<span class="cm"> * [start_pfn, end_pfn) range are considered errors, cause function to</span>
<span class="cm"> * undo its actions and return zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise, function returns one-past-the-last PFN of isolated page</span>
<span class="cm"> * (which may be greater then end_pfn if end fell in a middle of</span>
<span class="cm"> * a free page).</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">isolate_freepages_range</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">isolated</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">block_end_pfn</span><span class="p">,</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">freelist</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">))</span>
		<span class="n">zone</span> <span class="o">=</span> <span class="n">page_zone</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">=</span> <span class="n">start_pfn</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span><span class="p">;</span> <span class="n">pfn</span> <span class="o">+=</span> <span class="n">isolated</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">)</span> <span class="o">||</span> <span class="n">zone</span> <span class="o">!=</span> <span class="n">page_zone</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">)))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * On subsequent iterations ALIGN() is actually not needed,</span>
<span class="cm">		 * but we keep it that we not to complicate the code.</span>
<span class="cm">		 */</span>
		<span class="n">block_end_pfn</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">pfn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pageblock_nr_pages</span><span class="p">);</span>
		<span class="n">block_end_pfn</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">block_end_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">isolated</span> <span class="o">=</span> <span class="n">isolate_freepages_block</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">block_end_pfn</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">freelist</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * In strict mode, isolate_freepages_block() returns 0 if</span>
<span class="cm">		 * there are any holes in the block (ie. invalid PFNs or</span>
<span class="cm">		 * non-free pages).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isolated</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we managed to isolate pages, it is always (1 &lt;&lt; n) *</span>
<span class="cm">		 * pageblock_nr_pages for some non-negative n.  (Max order</span>
<span class="cm">		 * page may span two pageblocks).</span>
<span class="cm">		 */</span>
	<span class="p">}</span>

	<span class="cm">/* split_free_page does not map the pages */</span>
	<span class="n">map_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freelist</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Loop terminated early, cleanup. */</span>
		<span class="n">release_freepages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freelist</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We don&#39;t use freelists for anything. */</span>
	<span class="k">return</span> <span class="n">pfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Update the number of anon and file isolated pages in the zone */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">acct_isolated</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compact_control</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">migratepages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span>
		<span class="n">count</span><span class="p">[</span><span class="o">!!</span><span class="n">page_is_file_cache</span><span class="p">(</span><span class="n">page</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>

	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ISOLATED_ANON</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">__mod_zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ISOLATED_FILE</span><span class="p">,</span> <span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* Similar to reclaim, but different enough that they don&#39;t share logic */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">too_many_isolated</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">active</span><span class="p">,</span> <span class="n">inactive</span><span class="p">,</span> <span class="n">isolated</span><span class="p">;</span>

	<span class="n">inactive</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_INACTIVE_FILE</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_INACTIVE_ANON</span><span class="p">);</span>
	<span class="n">active</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ACTIVE_FILE</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ACTIVE_ANON</span><span class="p">);</span>
	<span class="n">isolated</span> <span class="o">=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ISOLATED_FILE</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_ISOLATED_ANON</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">isolated</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">inactive</span> <span class="o">+</span> <span class="n">active</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * isolate_migratepages_range() - isolate all migrate-able pages in range.</span>
<span class="cm"> * @zone:	Zone pages are in.</span>
<span class="cm"> * @cc:		Compaction control structure.</span>
<span class="cm"> * @low_pfn:	The first PFN of the range.</span>
<span class="cm"> * @end_pfn:	The one-past-the-last PFN of the range.</span>
<span class="cm"> *</span>
<span class="cm"> * Isolate all pages that can be migrated from the range specified by</span>
<span class="cm"> * [low_pfn, end_pfn).  Returns zero if there is a fatal signal</span>
<span class="cm"> * pending), otherwise PFN of the first page that was not scanned</span>
<span class="cm"> * (which may be both less, equal to or more then end_pfn).</span>
<span class="cm"> *</span>
<span class="cm"> * Assumes that cc-&gt;migratepages is empty and cc-&gt;nr_migratepages is</span>
<span class="cm"> * zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Apart from cc-&gt;migratepages and cc-&gt;nr_migratetypes this function</span>
<span class="cm"> * does not modify any cc&#39;s fields, in particular it does not modify</span>
<span class="cm"> * (or read for that matter) cc-&gt;migrate_pfn.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">isolate_migratepages_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compact_control</span> <span class="o">*</span><span class="n">cc</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">low_pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_pageblock_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pageblock_nr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr_isolated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">migratelist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">migratepages</span><span class="p">;</span>
	<span class="n">isolate_mode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lruvec</span> <span class="o">*</span><span class="n">lruvec</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ensure that there are not too many pages isolated from the LRU</span>
<span class="cm">	 * list by either parallel reclaimers or compaction. If there are,</span>
<span class="cm">	 * delay for some time until fewer pages are isolated</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">too_many_isolated</span><span class="p">(</span><span class="n">zone</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* async migration should just abort */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">congestion_wait</span><span class="p">(</span><span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Time to isolate some pages for migration */</span>
	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">low_pfn</span> <span class="o">&lt;</span> <span class="n">end_pfn</span><span class="p">;</span> <span class="n">low_pfn</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">locked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="cm">/* give a chance to irqs before checking need_resched() */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">low_pfn</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">SWAP_CLUSTER_MAX</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
			<span class="n">locked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">()</span> <span class="o">||</span> <span class="n">spin_is_contended</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked</span><span class="p">)</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * migrate_pfn does not necessarily start aligned to a</span>
<span class="cm">		 * pageblock. Ensure that pfn_valid is called when moving</span>
<span class="cm">		 * into a new MAX_ORDER_NR_PAGES range in case of large</span>
<span class="cm">		 * memory holes within the zone</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">low_pfn</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MAX_ORDER_NR_PAGES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">low_pfn</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">low_pfn</span> <span class="o">+=</span> <span class="n">MAX_ORDER_NR_PAGES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid_within</span><span class="p">(</span><span class="n">low_pfn</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">nr_scanned</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get the page and ensure the page is within the same zone.</span>
<span class="cm">		 * See the comment in isolate_freepages about overlapping</span>
<span class="cm">		 * nodes. It is deliberate that the new zone lock is not taken</span>
<span class="cm">		 * as memory compaction should not move pages between nodes.</span>
<span class="cm">		 */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">low_pfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">zone</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Skip if free */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageBuddy</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * For async migration, also only scan in MOVABLE blocks. Async</span>
<span class="cm">		 * migration is optimistic to see if the minimum amount of work</span>
<span class="cm">		 * satisfies the allocation</span>
<span class="cm">		 */</span>
		<span class="n">pageblock_nr</span> <span class="o">=</span> <span class="n">low_pfn</span> <span class="o">&gt;&gt;</span> <span class="n">pageblock_order</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">&amp;&amp;</span> <span class="n">last_pageblock_nr</span> <span class="o">!=</span> <span class="n">pageblock_nr</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">migrate_async_suitable</span><span class="p">(</span><span class="n">get_pageblock_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">low_pfn</span> <span class="o">+=</span> <span class="n">pageblock_nr_pages</span><span class="p">;</span>
			<span class="n">low_pfn</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">low_pfn</span><span class="p">,</span> <span class="n">pageblock_nr_pages</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">last_pageblock_nr</span> <span class="o">=</span> <span class="n">pageblock_nr</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageLRU</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * PageLRU is set, and lru_lock excludes isolation,</span>
<span class="cm">		 * splitting and collapsing (collapsing has already</span>
<span class="cm">		 * happened if PageLRU is set).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageTransHuge</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">low_pfn</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">)</span>
			<span class="n">mode</span> <span class="o">|=</span> <span class="n">ISOLATE_ASYNC_MIGRATE</span><span class="p">;</span>

		<span class="n">lruvec</span> <span class="o">=</span> <span class="n">mem_cgroup_page_lruvec</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">zone</span><span class="p">);</span>

		<span class="cm">/* Try isolate the page */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__isolate_lru_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">PageTransCompound</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

		<span class="cm">/* Successfully isolated */</span>
		<span class="n">del_page_from_lru_list</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">lruvec</span><span class="p">,</span> <span class="n">page_lru</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">migratelist</span><span class="p">);</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_migratepages</span><span class="o">++</span><span class="p">;</span>
		<span class="n">nr_isolated</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Avoid isolating too much */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_migratepages</span> <span class="o">==</span> <span class="n">COMPACT_CLUSTER_MAX</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">low_pfn</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">acct_isolated</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">cc</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>

	<span class="n">trace_mm_compaction_isolate_migratepages</span><span class="p">(</span><span class="n">nr_scanned</span><span class="p">,</span> <span class="n">nr_isolated</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">low_pfn</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_COMPACTION || CONFIG_CMA */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_COMPACTION</span>

<span class="cm">/* Returns true if the page is within a block suitable for migration to */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">suitable_migration_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>

	<span class="kt">int</span> <span class="n">migratetype</span> <span class="o">=</span> <span class="n">get_pageblock_migratetype</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t interfere with memory hot-remove or the min_free_kbytes blocks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">migratetype</span> <span class="o">==</span> <span class="n">MIGRATE_ISOLATE</span> <span class="o">||</span> <span class="n">migratetype</span> <span class="o">==</span> <span class="n">MIGRATE_RESERVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* If the page is a large free page, then allow migration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageBuddy</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">page_order</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">pageblock_order</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* If the block is MIGRATE_MOVABLE or MIGRATE_CMA, allow migration */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">migrate_async_suitable</span><span class="p">(</span><span class="n">migratetype</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* Otherwise skip the block */</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Based on information in the current compact_control, find blocks</span>
<span class="cm"> * suitable for isolating free pages from and then isolate them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">isolate_freepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">compact_control</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">high_pfn</span><span class="p">,</span> <span class="n">low_pfn</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">zone_end_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_freepages</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_freepages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">freelist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">freepages</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialise the free scanner. The starting point is where we last</span>
<span class="cm">	 * scanned from (or the end of the zone if starting). The low point</span>
<span class="cm">	 * is the end of the pageblock the migration scanner is using.</span>
<span class="cm">	 */</span>
	<span class="n">pfn</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">free_pfn</span><span class="p">;</span>
	<span class="n">low_pfn</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">migrate_pfn</span> <span class="o">+</span> <span class="n">pageblock_nr_pages</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take care that if the migration scanner is at the end of the zone</span>
<span class="cm">	 * that the free scanner does not accidentally move to the next zone</span>
<span class="cm">	 * in the next isolation cycle.</span>
<span class="cm">	 */</span>
	<span class="n">high_pfn</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">low_pfn</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>

	<span class="n">zone_end_pfn</span> <span class="o">=</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">zone_start_pfn</span> <span class="o">+</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">spanned_pages</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Isolate free pages until enough are available to migrate the</span>
<span class="cm">	 * pages on cc-&gt;migratepages. We stop searching if the migrate</span>
<span class="cm">	 * and free page scanners meet or enough free pages are isolated.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">pfn</span> <span class="o">&gt;</span> <span class="n">low_pfn</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_migratepages</span> <span class="o">&gt;</span> <span class="n">nr_freepages</span><span class="p">;</span>
					<span class="n">pfn</span> <span class="o">-=</span> <span class="n">pageblock_nr_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">isolated</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check for overlapping nodes/zones. It&#39;s possible on some</span>
<span class="cm">		 * configurations to have a setup like</span>
<span class="cm">		 * node0 node1 node0</span>
<span class="cm">		 * i.e. it&#39;s possible that all pages within a zones range of</span>
<span class="cm">		 * pages do not belong to a single zone.</span>
<span class="cm">		 */</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">zone</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Check the block is suitable for migration */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">suitable_migration_target</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Found a block suitable for isolating free pages from. Now</span>
<span class="cm">		 * we disabled interrupts, double check things are ok and</span>
<span class="cm">		 * isolate the pages. This is to minimise the time IRQs</span>
<span class="cm">		 * are disabled</span>
<span class="cm">		 */</span>
		<span class="n">isolated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">suitable_migration_target</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">end_pfn</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">pfn</span> <span class="o">+</span> <span class="n">pageblock_nr_pages</span><span class="p">,</span> <span class="n">zone_end_pfn</span><span class="p">);</span>
			<span class="n">isolated</span> <span class="o">=</span> <span class="n">isolate_freepages_block</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">,</span>
							   <span class="n">freelist</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="n">nr_freepages</span> <span class="o">+=</span> <span class="n">isolated</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Record the highest PFN we isolated pages from. When next</span>
<span class="cm">		 * looking for free pages, the search will restart here as</span>
<span class="cm">		 * page migration may have returned some pages to the allocator</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isolated</span><span class="p">)</span>
			<span class="n">high_pfn</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">high_pfn</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* split_free_page does not map the pages */</span>
	<span class="n">map_pages</span><span class="p">(</span><span class="n">freelist</span><span class="p">);</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">free_pfn</span> <span class="o">=</span> <span class="n">high_pfn</span><span class="p">;</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_freepages</span> <span class="o">=</span> <span class="n">nr_freepages</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a migrate-callback that &quot;allocates&quot; freepages by taking pages</span>
<span class="cm"> * from the isolated freelists in the block we are migrating to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">compaction_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">migratepage</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">,</span>
					<span class="kt">int</span> <span class="o">**</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compact_control</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">compact_control</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">freepage</span><span class="p">;</span>

	<span class="cm">/* Isolate free pages if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">freepages</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">isolate_freepages</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">zone</span><span class="p">,</span> <span class="n">cc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">freepages</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">freepage</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">freepages</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">freepage</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_freepages</span><span class="o">--</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">freepage</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We cannot control nr_migratepages and nr_freepages fully when migration is</span>
<span class="cm"> * running as migrate_pages() has no knowledge of compact_control. When</span>
<span class="cm"> * migration is complete, we count the number of pages on the lists by hand.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_nr_listpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">compact_control</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_migratepages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_freepages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">migratepages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span>
		<span class="n">nr_migratepages</span><span class="o">++</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">freepages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span>
		<span class="n">nr_freepages</span><span class="o">++</span><span class="p">;</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_migratepages</span> <span class="o">=</span> <span class="n">nr_migratepages</span><span class="p">;</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_freepages</span> <span class="o">=</span> <span class="n">nr_freepages</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* possible outcome of isolate_migratepages */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
	<span class="n">ISOLATE_ABORT</span><span class="p">,</span>		<span class="cm">/* Abort compaction now */</span>
	<span class="n">ISOLATE_NONE</span><span class="p">,</span>		<span class="cm">/* No pages isolated, continue scanning */</span>
	<span class="n">ISOLATE_SUCCESS</span><span class="p">,</span>	<span class="cm">/* Pages isolated, migrate */</span>
<span class="p">}</span> <span class="n">isolate_migrate_t</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Isolate all pages that can be migrated from the block pointed to by</span>
<span class="cm"> * the migrate scanner within compact_control.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">isolate_migrate_t</span> <span class="nf">isolate_migratepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">compact_control</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">low_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">;</span>

	<span class="cm">/* Do not scan outside zone boundaries */</span>
	<span class="n">low_pfn</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">migrate_pfn</span><span class="p">,</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">zone_start_pfn</span><span class="p">);</span>

	<span class="cm">/* Only scan within a pageblock boundary */</span>
	<span class="n">end_pfn</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">low_pfn</span> <span class="o">+</span> <span class="n">pageblock_nr_pages</span><span class="p">,</span> <span class="n">pageblock_nr_pages</span><span class="p">);</span>

	<span class="cm">/* Do not cross the free scanner or scan within a memory hole */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&gt;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">free_pfn</span> <span class="o">||</span> <span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">low_pfn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">migrate_pfn</span> <span class="o">=</span> <span class="n">end_pfn</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ISOLATE_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Perform the isolation */</span>
	<span class="n">low_pfn</span> <span class="o">=</span> <span class="n">isolate_migratepages_range</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">low_pfn</span><span class="p">,</span> <span class="n">end_pfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">low_pfn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ISOLATE_ABORT</span><span class="p">;</span>

	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">migrate_pfn</span> <span class="o">=</span> <span class="n">low_pfn</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ISOLATE_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compact_finished</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">compact_control</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">order</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">watermark</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">COMPACT_PARTIAL</span><span class="p">;</span>

	<span class="cm">/* Compaction run completes if the migrate and free scanner meet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">free_pfn</span> <span class="o">&lt;=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">migrate_pfn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">COMPACT_COMPLETE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * order == -1 is expected when compacting via</span>
<span class="cm">	 * /proc/sys/vm/compact_memory</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">COMPACT_CONTINUE</span><span class="p">;</span>

	<span class="cm">/* Compaction run is not finished if the watermark is not met */</span>
	<span class="n">watermark</span> <span class="o">=</span> <span class="n">low_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>
	<span class="n">watermark</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zone_watermark_ok</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">,</span> <span class="n">watermark</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">COMPACT_CONTINUE</span><span class="p">;</span>

	<span class="cm">/* Direct compactor: Is a suitable page free? */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">order</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">;</span> <span class="n">order</span> <span class="o">&lt;</span> <span class="n">MAX_ORDER</span><span class="p">;</span> <span class="n">order</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Job done if page is free of the right migratetype */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">order</span><span class="p">].</span><span class="n">free_list</span><span class="p">[</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">migratetype</span><span class="p">]))</span>
			<span class="k">return</span> <span class="n">COMPACT_PARTIAL</span><span class="p">;</span>

		<span class="cm">/* Job done if allocation would set block type */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">pageblock_order</span> <span class="o">&amp;&amp;</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">order</span><span class="p">].</span><span class="n">nr_free</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">COMPACT_PARTIAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">COMPACT_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compaction_suitable: Is this suitable to run compaction on this zone now?</span>
<span class="cm"> * Returns</span>
<span class="cm"> *   COMPACT_SKIPPED  - If there are too few free pages for compaction</span>
<span class="cm"> *   COMPACT_PARTIAL  - If the allocation would succeed without compaction</span>
<span class="cm"> *   COMPACT_CONTINUE - If compaction should run now</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">compaction_suitable</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fragindex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">watermark</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * order == -1 is expected when compacting via</span>
<span class="cm">	 * /proc/sys/vm/compact_memory</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">COMPACT_CONTINUE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Watermarks for order-0 must be met for compaction. Note the 2UL.</span>
<span class="cm">	 * This is because during migration, copies of pages need to be</span>
<span class="cm">	 * allocated and for a short time, the footprint is higher</span>
<span class="cm">	 */</span>
	<span class="n">watermark</span> <span class="o">=</span> <span class="n">low_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2UL</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zone_watermark_ok</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">watermark</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">COMPACT_SKIPPED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * fragmentation index determines if allocation failures are due to</span>
<span class="cm">	 * low memory or external fragmentation</span>
<span class="cm">	 *</span>
<span class="cm">	 * index of -1000 implies allocations might succeed depending on</span>
<span class="cm">	 * watermarks</span>
<span class="cm">	 * index towards 0 implies failure is due to lack of memory</span>
<span class="cm">	 * index towards 1000 implies failure is due to fragmentation</span>
<span class="cm">	 *</span>
<span class="cm">	 * Only compact if a failure would be due to fragmentation.</span>
<span class="cm">	 */</span>
	<span class="n">fragindex</span> <span class="o">=</span> <span class="n">fragmentation_index</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fragindex</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">fragindex</span> <span class="o">&lt;=</span> <span class="n">sysctl_extfrag_threshold</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">COMPACT_SKIPPED</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fragindex</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1000</span> <span class="o">&amp;&amp;</span> <span class="n">zone_watermark_ok</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">watermark</span><span class="p">,</span>
	    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">COMPACT_PARTIAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">COMPACT_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compact_zone</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compact_control</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">compaction_suitable</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COMPACT_PARTIAL</span>:
	<span class="k">case</span> <span class="n">COMPACT_SKIPPED</span>:
		<span class="cm">/* Compaction is likely to fail */</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">COMPACT_CONTINUE</span>:
		<span class="cm">/* Fall through to compaction */</span>
		<span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup to move all movable pages to the end of the zone */</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">migrate_pfn</span> <span class="o">=</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">zone_start_pfn</span><span class="p">;</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">free_pfn</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">migrate_pfn</span> <span class="o">+</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">spanned_pages</span><span class="p">;</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">free_pfn</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">pageblock_nr_pages</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">migrate_prep_local</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">compact_finished</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">cc</span><span class="p">))</span> <span class="o">==</span> <span class="n">COMPACT_CONTINUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_migrate</span><span class="p">,</span> <span class="n">nr_remaining</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">isolate_migratepages</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">cc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ISOLATE_ABORT</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">COMPACT_PARTIAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISOLATE_NONE</span>:
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ISOLATE_SUCCESS</span>:
			<span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nr_migrate</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_migratepages</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">migrate_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">migratepages</span><span class="p">,</span> <span class="n">compaction_alloc</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">cc</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
				<span class="n">cc</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">?</span> <span class="n">MIGRATE_SYNC_LIGHT</span> <span class="o">:</span> <span class="n">MIGRATE_ASYNC</span><span class="p">);</span>
		<span class="n">update_nr_listpages</span><span class="p">(</span><span class="n">cc</span><span class="p">);</span>
		<span class="n">nr_remaining</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_migratepages</span><span class="p">;</span>

		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">COMPACTBLOCKS</span><span class="p">);</span>
		<span class="n">count_vm_events</span><span class="p">(</span><span class="n">COMPACTPAGES</span><span class="p">,</span> <span class="n">nr_migrate</span> <span class="o">-</span> <span class="n">nr_remaining</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_remaining</span><span class="p">)</span>
			<span class="n">count_vm_events</span><span class="p">(</span><span class="n">COMPACTPAGEFAILED</span><span class="p">,</span> <span class="n">nr_remaining</span><span class="p">);</span>
		<span class="n">trace_mm_compaction_migratepages</span><span class="p">(</span><span class="n">nr_migrate</span> <span class="o">-</span> <span class="n">nr_remaining</span><span class="p">,</span>
						<span class="n">nr_remaining</span><span class="p">);</span>

		<span class="cm">/* Release LRU pages not migrated */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">putback_lru_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">migratepages</span><span class="p">);</span>
			<span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_migratepages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="cm">/* Release free pages and check accounting */</span>
	<span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_freepages</span> <span class="o">-=</span> <span class="n">release_freepages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">freepages</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_freepages</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">compact_zone_order</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
				 <span class="n">bool</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compact_control</span> <span class="n">cc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">nr_freepages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_migratepages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span>
		<span class="p">.</span><span class="n">migratetype</span> <span class="o">=</span> <span class="n">allocflags_to_migratetype</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">),</span>
		<span class="p">.</span><span class="n">zone</span> <span class="o">=</span> <span class="n">zone</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sync</span> <span class="o">=</span> <span class="n">sync</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="p">.</span><span class="n">freepages</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="p">.</span><span class="n">migratepages</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">compact_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">sysctl_extfrag_threshold</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_compact_pages - Direct compact to satisfy a high-order allocation</span>
<span class="cm"> * @zonelist: The zonelist used for the current allocation</span>
<span class="cm"> * @order: The order of the current allocation</span>
<span class="cm"> * @gfp_mask: The GFP mask of the current allocation</span>
<span class="cm"> * @nodemask: The allowed nodes to allocate from</span>
<span class="cm"> * @sync: Whether migration is synchronous or not</span>
<span class="cm"> *</span>
<span class="cm"> * This is the main entry point for direct page compaction.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">try_to_compact_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">zone_type</span> <span class="n">high_zoneidx</span> <span class="o">=</span> <span class="n">gfp_zone</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">may_enter_fs</span> <span class="o">=</span> <span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_FS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">may_perform_io</span> <span class="o">=</span> <span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_IO</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">COMPACT_SKIPPED</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check whether it is worth even starting compaction. The order check is</span>
<span class="cm">	 * made because an assumption is made that the page allocator can satisfy</span>
<span class="cm">	 * the &quot;cheaper&quot; orders without taking special steps</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">order</span> <span class="o">||</span> <span class="o">!</span><span class="n">may_enter_fs</span> <span class="o">||</span> <span class="o">!</span><span class="n">may_perform_io</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">count_vm_event</span><span class="p">(</span><span class="n">COMPACTSTALL</span><span class="p">);</span>

	<span class="cm">/* Compact each zone in the list */</span>
	<span class="n">for_each_zone_zonelist_nodemask</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span> <span class="n">high_zoneidx</span><span class="p">,</span>
								<span class="n">nodemask</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">compact_zone_order</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

		<span class="cm">/* If a normal allocation would succeed, stop compacting */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zone_watermark_ok</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">low_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Compact all zones within a node */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__compact_pgdat</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="k">struct</span> <span class="n">compact_control</span> <span class="o">*</span><span class="n">cc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">zoneid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">zoneid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">zoneid</span> <span class="o">&lt;</span> <span class="n">MAX_NR_ZONES</span><span class="p">;</span> <span class="n">zoneid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">zone</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zones</span><span class="p">[</span><span class="n">zoneid</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">populated_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_freepages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">nr_migratepages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cc</span><span class="o">-&gt;</span><span class="n">zone</span> <span class="o">=</span> <span class="n">zone</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">freepages</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">migratepages</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">compaction_deferred</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">))</span>
			<span class="n">compact_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">cc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">zone_watermark_ok</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">,</span>
						<span class="n">low_wmark_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ok</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;</span> <span class="n">zone</span><span class="o">-&gt;</span><span class="n">compact_order_failed</span><span class="p">)</span>
				<span class="n">zone</span><span class="o">-&gt;</span><span class="n">compact_order_failed</span> <span class="o">=</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* Currently async compaction is never deferred. */</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span> <span class="o">&amp;&amp;</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">sync</span><span class="p">)</span>
				<span class="n">defer_compaction</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">cc</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">freepages</span><span class="p">));</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">migratepages</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">compact_pgdat</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compact_control</span> <span class="n">cc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sync</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">__compact_pgdat</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compact_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">compact_control</span> <span class="n">cc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sync</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">__compact_pgdat</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">cc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Compact all nodes in the system */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">compact_nodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="cm">/* Flush pending updates to the LRU lists */</span>
	<span class="n">lru_add_drain_all</span><span class="p">();</span>

	<span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span>
		<span class="n">compact_node</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">COMPACT_COMPLETE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* The written value is actually unused, all memory is compacted */</span>
<span class="kt">int</span> <span class="n">sysctl_compact_memory</span><span class="p">;</span>

<span class="cm">/* This is the entry point for compacting all nodes via /proc/sys/vm */</span>
<span class="kt">int</span> <span class="nf">sysctl_compaction_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">compact_nodes</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sysctl_extfrag_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_dointvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_SYSFS) &amp;&amp; defined(CONFIG_NUMA)</span>
<span class="kt">ssize_t</span> <span class="nf">sysfs_compact_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nid</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span> <span class="o">&amp;&amp;</span> <span class="n">node_online</span><span class="p">(</span><span class="n">nid</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Flush pending updates to the LRU lists */</span>
		<span class="n">lru_add_drain_all</span><span class="p">();</span>

		<span class="n">compact_node</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">compact</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">sysfs_compact_node</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">compaction_register_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">device_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_compact</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">compaction_unregister_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">device_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_compact</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSFS &amp;&amp; CONFIG_NUMA */</span><span class="cp"></span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_COMPACTION */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
