<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › truncate.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>truncate.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * mm/truncate.c - code for taking down pages from address_spaces</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002, Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> * 10Sep2002	Andrew Morton</span>
<span class="cm"> *		Initial version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &lt;linux/task_io_accounting_ops.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;	</span><span class="cm">/* grr. try_to_release_page,</span>
<span class="cm">				   do_invalidatepage */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/cleancache.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>


<span class="cm">/**</span>
<span class="cm"> * do_invalidatepage - invalidate part or all of a page</span>
<span class="cm"> * @page: the page which is affected</span>
<span class="cm"> * @offset: the index of the truncation point</span>
<span class="cm"> *</span>
<span class="cm"> * do_invalidatepage() is called when all or part of the page has become</span>
<span class="cm"> * invalidated by a truncate operation.</span>
<span class="cm"> *</span>
<span class="cm"> * do_invalidatepage() does not have to release all buffers, but it must</span>
<span class="cm"> * ensure that no dirty buffer is left outside @offset and that no I/O</span>
<span class="cm"> * is underway against any of the blocks which are outside the truncation</span>
<span class="cm"> * point.  Because the caller is about to free (and possibly reuse) those</span>
<span class="cm"> * blocks on-disk.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">do_invalidatepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">invalidatepage</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">invalidatepage</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">invalidatepage</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLOCK</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">invalidatepage</span><span class="p">)</span>
		<span class="n">invalidatepage</span> <span class="o">=</span> <span class="n">block_invalidatepage</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">invalidatepage</span><span class="p">)</span>
		<span class="p">(</span><span class="o">*</span><span class="n">invalidatepage</span><span class="p">)(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">truncate_partial_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">partial</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">zero_user_segment</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="n">cleancache_invalidate_page</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_private</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">do_invalidatepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">partial</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This cancels just the dirty bit on the kernel page itself, it</span>
<span class="cm"> * does NOT actually remove dirty bits on any mmap&#39;s that may be</span>
<span class="cm"> * around. It also leaves the page tagged dirty, so any sync</span>
<span class="cm"> * activity will still find it on the dirty lists, and in particular,</span>
<span class="cm"> * clear_page_dirty_for_io() will still look at the dirty bits in</span>
<span class="cm"> * the VM.</span>
<span class="cm"> *</span>
<span class="cm"> * Doing this should *normally* only ever be done when a page</span>
<span class="cm"> * is truncated, and is not actually mapped anywhere at all. However,</span>
<span class="cm"> * fs/buffer.c does this when it notices that somebody has cleaned</span>
<span class="cm"> * out all the buffers on a page without actually doing it through</span>
<span class="cm"> * the VM. Can you say &quot;ext3 is horribly ugly&quot;? Tought you could.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cancel_dirty_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">account_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TestClearPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="n">mapping_cap_account_dirty</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_FILE_DIRTY</span><span class="p">);</span>
			<span class="n">dec_bdi_stat</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span>
					<span class="n">BDI_RECLAIMABLE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">account_size</span><span class="p">)</span>
				<span class="n">task_io_account_cancelled_write</span><span class="p">(</span><span class="n">account_size</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">cancel_dirty_page</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If truncate cannot remove the fs-private metadata from the page, the page</span>
<span class="cm"> * becomes orphaned.  It will be left on the LRU and may even be mapped into</span>
<span class="cm"> * user pagetables if we&#39;re racing with filemap_fault().</span>
<span class="cm"> *</span>
<span class="cm"> * We need to bale out if page-&gt;mapping is no longer equal to the original</span>
<span class="cm"> * mapping.  This happens a) when the VM reclaimed the page while we waited on</span>
<span class="cm"> * its lock, b) when a concurrent invalidate_mapping_pages got there first and</span>
<span class="cm"> * c) when tmpfs swizzles a page between a tmpfs inode and swapper_space.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">truncate_complete_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_private</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">do_invalidatepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">cancel_dirty_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>

	<span class="n">clear_page_mlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ClearPageMappedToDisk</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">delete_from_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is for invalidate_mapping_pages().  That function can be called at</span>
<span class="cm"> * any time, and is not supposed to throw away dirty pages.  But pages can</span>
<span class="cm"> * be marked dirty at any time too, so use remove_mapping which safely</span>
<span class="cm"> * discards clean, unused pages.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns non-zero if the page was successfully invalidated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">invalidate_complete_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_private</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">try_to_release_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">clear_page_mlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">remove_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">truncate_inode_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
				   <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
				   <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">truncate_complete_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used to get rid of pages on hardware memory corruption.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">generic_error_remove_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only punch for normal data pages for now.</span>
<span class="cm">	 * Handling other types like directories would need more auditing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">truncate_inode_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_error_remove_page</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Safely invalidate one page from its pagecache mapping.</span>
<span class="cm"> * It only drops clean, unused pages. The page must be locked.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if the page is successfully invalidated, otherwise 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">invalidate_inode_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">invalidate_complete_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * truncate_inode_pages_range - truncate range of pages specified by start &amp; end byte offsets</span>
<span class="cm"> * @mapping: mapping to truncate</span>
<span class="cm"> * @lstart: offset from which to truncate</span>
<span class="cm"> * @lend: offset to which to truncate</span>
<span class="cm"> *</span>
<span class="cm"> * Truncate the page cache, removing the pages that are between</span>
<span class="cm"> * specified offsets (and zeroing out partial page</span>
<span class="cm"> * (if lstart is not page aligned)).</span>
<span class="cm"> *</span>
<span class="cm"> * Truncate takes two passes - the first pass is nonblocking.  It will not</span>
<span class="cm"> * block on page locks and it will not block on writeback.  The second pass</span>
<span class="cm"> * will wait.  This is to prevent as much IO as possible in the affected region.</span>
<span class="cm"> * The first pass will remove most pages, so the search cost of the second pass</span>
<span class="cm"> * is low.</span>
<span class="cm"> *</span>
<span class="cm"> * We pass down the cache-hot hint to the page freeing code.  Even if the</span>
<span class="cm"> * mapping is large, it is probably the case that the final pages are the most</span>
<span class="cm"> * recently touched, and freeing happens in ascending file offset order.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">truncate_inode_pages_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">pgoff_t</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">lstart</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">partial</span> <span class="o">=</span> <span class="n">lstart</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cleancache_invalidate_inode</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">lend</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">lend</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">pagevec_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
			<span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">PAGEVEC_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mem_cgroup_uncharge_start</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="cm">/* We rely upon deletion not changing page-&gt;index */</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">index</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">truncate_inode_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">mem_cgroup_uncharge_end</span><span class="p">();</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">partial</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">find_lock_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">truncate_partial_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">partial</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pagevec_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
			<span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">PAGEVEC_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mem_cgroup_uncharge_start</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="cm">/* We rely upon deletion not changing page-&gt;index */</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">truncate_inode_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">mem_cgroup_uncharge_end</span><span class="p">();</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cleancache_invalidate_inode</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">truncate_inode_pages_range</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * truncate_inode_pages - truncate *all* the pages from an offset</span>
<span class="cm"> * @mapping: mapping to truncate</span>
<span class="cm"> * @lstart: offset from which to truncate</span>
<span class="cm"> *</span>
<span class="cm"> * Called under (and serialised by) inode-&gt;i_mutex.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: When this function returns, there can be a page in the process of</span>
<span class="cm"> * deletion (inside __delete_from_page_cache()) in the specified range.  Thus</span>
<span class="cm"> * mapping-&gt;nrpages can be non-zero when this function returns even after</span>
<span class="cm"> * truncation of the whole mapping.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">truncate_inode_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lstart</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">truncate_inode_pages_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">lstart</span><span class="p">,</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">truncate_inode_pages</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * invalidate_mapping_pages - Invalidate all the unlocked pages of one inode</span>
<span class="cm"> * @mapping: the address_space which holds the pages to invalidate</span>
<span class="cm"> * @start: the offset &#39;from&#39; which to invalidate</span>
<span class="cm"> * @end: the offset &#39;to&#39; which to invalidate (inclusive)</span>
<span class="cm"> *</span>
<span class="cm"> * This function only removes the unlocked pages, if you want to</span>
<span class="cm"> * remove all the pages of one inode, you must call truncate_inode_pages.</span>
<span class="cm"> *</span>
<span class="cm"> * invalidate_mapping_pages() will not block on IO activity. It will not</span>
<span class="cm"> * invalidate pages which are dirty, locked, under writeback or mapped into</span>
<span class="cm"> * pagetables.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">invalidate_mapping_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="n">pgoff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Note: this function may get called on a shmem/tmpfs mapping:</span>
<span class="cm">	 * pagevec_lookup() might then return 0 prematurely (because it</span>
<span class="cm">	 * got a gangful of swap entries); but it&#39;s hardly worth worrying</span>
<span class="cm">	 * about - it can rarely have anything to free from such a mapping</span>
<span class="cm">	 * (most pages are dirty), and already skips over any difficulties.</span>
<span class="cm">	 */</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">pagevec_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
			<span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">PAGEVEC_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mem_cgroup_uncharge_start</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="cm">/* We rely upon deletion not changing page-&gt;index */</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">index</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">invalidate_inode_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * Invalidation is a hint that the page is no longer</span>
<span class="cm">			 * of interest and try to speed up its reclaim.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">deactivate_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">mem_cgroup_uncharge_end</span><span class="p">();</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">invalidate_mapping_pages</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is like invalidate_complete_page(), except it ignores the page&#39;s</span>
<span class="cm"> * refcount.  We do this because invalidate_inode_pages2() needs stronger</span>
<span class="cm"> * invalidation guarantees, and cannot afford to leave pages behind because</span>
<span class="cm"> * shrink_page_list() has a temp ref on them, or because they&#39;re transiently</span>
<span class="cm"> * sitting in the lru_cache_add() pagevecs.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">invalidate_complete_page2</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page_has_private</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">try_to_release_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="n">clear_page_mlock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_has_private</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">__delete_from_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="n">mem_cgroup_uncharge_cache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">freepage</span><span class="p">)</span>
		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">freepage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>	<span class="cm">/* pagecache ref */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">failed:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_launder_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span> <span class="o">||</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">launder_page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">launder_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * invalidate_inode_pages2_range - remove range of pages from an address_space</span>
<span class="cm"> * @mapping: the address_space</span>
<span class="cm"> * @start: the page offset &#39;from&#39; which to invalidate</span>
<span class="cm"> * @end: the page offset &#39;to&#39; which to invalidate (inclusive)</span>
<span class="cm"> *</span>
<span class="cm"> * Any pages which are found to be mapped into pagetables are unmapped prior to</span>
<span class="cm"> * invalidation.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EBUSY if any pages could not be invalidated.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">invalidate_inode_pages2_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				  <span class="n">pgoff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">did_range_unmap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cleancache_invalidate_inode</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">pagevec_lookup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
			<span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">PAGEVEC_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mem_cgroup_uncharge_start</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="cm">/* We rely upon deletion not changing page-&gt;index */</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">index</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">did_range_unmap</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * Zap the rest of the file in one hit.</span>
<span class="cm">					 */</span>
					<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">loff_t</span><span class="p">)(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">end</span> <span class="o">-</span> <span class="n">index</span><span class="p">)</span>
							 <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
					    <span class="mi">0</span><span class="p">);</span>
					<span class="n">did_range_unmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * Just zap this page</span>
<span class="cm">					 */</span>
					<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
					   <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
					   <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">ret2</span> <span class="o">=</span> <span class="n">do_launder_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">invalidate_complete_page2</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">page</span><span class="p">))</span>
					<span class="n">ret2</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">mem_cgroup_uncharge_end</span><span class="p">();</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cleancache_invalidate_inode</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">invalidate_inode_pages2_range</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * invalidate_inode_pages2 - remove all pages from an address_space</span>
<span class="cm"> * @mapping: the address_space</span>
<span class="cm"> *</span>
<span class="cm"> * Any pages which are found to be mapped into pagetables are unmapped prior to</span>
<span class="cm"> * invalidation.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EBUSY if any pages could not be invalidated.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">invalidate_inode_pages2</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">invalidate_inode_pages2_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">invalidate_inode_pages2</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * truncate_pagecache - unmap and remove pagecache that has been truncated</span>
<span class="cm"> * @inode: inode</span>
<span class="cm"> * @oldsize: old file size</span>
<span class="cm"> * @newsize: new file size</span>
<span class="cm"> *</span>
<span class="cm"> * inode&#39;s new i_size must already be written before truncate_pagecache</span>
<span class="cm"> * is called.</span>
<span class="cm"> *</span>
<span class="cm"> * This function should typically be called before the filesystem</span>
<span class="cm"> * releases resources associated with the freed range (eg. deallocates</span>
<span class="cm"> * blocks). This way, pagecache will always stay logically coherent</span>
<span class="cm"> * with on-disk format, and the filesystem would not have to deal with</span>
<span class="cm"> * situations such as writepage being called for a page that has already</span>
<span class="cm"> * had its underlying blocks deallocated.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">truncate_pagecache</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">oldsize</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">newsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">holebegin</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">newsize</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * unmap_mapping_range is called twice, first simply for</span>
<span class="cm">	 * efficiency so that truncate_inode_pages does fewer</span>
<span class="cm">	 * single-page unmaps.  However after this first call, and</span>
<span class="cm">	 * before truncate_inode_pages finishes, it is possible for</span>
<span class="cm">	 * private pages to be COWed, which remain after</span>
<span class="cm">	 * truncate_inode_pages finishes, hence the second</span>
<span class="cm">	 * unmap_mapping_range call must be made for correctness.</span>
<span class="cm">	 */</span>
	<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">holebegin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
	<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">holebegin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">truncate_pagecache</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * truncate_setsize - update inode and pagecache for a new file size</span>
<span class="cm"> * @inode: inode</span>
<span class="cm"> * @newsize: new file size</span>
<span class="cm"> *</span>
<span class="cm"> * truncate_setsize updates i_size and performs pagecache truncation (if</span>
<span class="cm"> * necessary) to @newsize. It will be typically be called from the filesystem&#39;s</span>
<span class="cm"> * setattr function when ATTR_SIZE is passed in.</span>
<span class="cm"> *</span>
<span class="cm"> * Must be called with inode_mutex held and before all filesystem specific</span>
<span class="cm"> * block truncation has been performed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">truncate_setsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">newsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">oldsize</span><span class="p">;</span>

	<span class="n">oldsize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>

	<span class="n">truncate_pagecache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">oldsize</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">truncate_setsize</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vmtruncate - unmap mappings &quot;freed&quot; by truncate() syscall</span>
<span class="cm"> * @inode: inode of the file used</span>
<span class="cm"> * @newsize: file offset to start truncating</span>
<span class="cm"> *</span>
<span class="cm"> * This function is deprecated and truncate_setsize or truncate_pagecache</span>
<span class="cm"> * should be used instead, together with filesystem specific block truncation.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vmtruncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">newsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode_newsize_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">truncate_setsize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">truncate</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span><span class="o">-&gt;</span><span class="n">truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vmtruncate</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * truncate_pagecache_range - unmap and remove pagecache that is hole-punched</span>
<span class="cm"> * @inode: inode</span>
<span class="cm"> * @lstart: offset of beginning of hole</span>
<span class="cm"> * @lend: offset of last byte of hole</span>
<span class="cm"> *</span>
<span class="cm"> * This function should typically be called before the filesystem</span>
<span class="cm"> * releases resources associated with the freed range (eg. deallocates</span>
<span class="cm"> * blocks). This way, pagecache will always stay logically coherent</span>
<span class="cm"> * with on-disk format, and the filesystem would not have to deal with</span>
<span class="cm"> * situations such as writepage being called for a page that has already</span>
<span class="cm"> * had its underlying blocks deallocated.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">truncate_pagecache_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">lend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">unmap_start</span> <span class="o">=</span> <span class="n">round_up</span><span class="p">(</span><span class="n">lstart</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">unmap_end</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">lend</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This rounding is currently just for example: unmap_mapping_range</span>
<span class="cm">	 * expands its hole outwards, whereas we want it to contract the hole</span>
<span class="cm">	 * inwards.  However, existing callers of truncate_pagecache_range are</span>
<span class="cm">	 * doing their own page rounding first; and truncate_inode_pages_range</span>
<span class="cm">	 * currently BUGs if lend is not pagealigned-1 (it handles partial</span>
<span class="cm">	 * page at start of hole, but not partial page at end of hole).  Note</span>
<span class="cm">	 * unmap_mapping_range allows holelen 0 for all, and we allow lend -1.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unlike in truncate_pagecache, unmap_mapping_range is called only</span>
<span class="cm">	 * once (before truncating pagecache), and without &quot;even_cows&quot; flag:</span>
<span class="cm">	 * hole-punching should not remove private COWed pages from the hole.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">unmap_end</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">unmap_start</span><span class="p">)</span>
		<span class="n">unmap_mapping_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">unmap_start</span><span class="p">,</span>
				    <span class="mi">1</span> <span class="o">+</span> <span class="n">unmap_end</span> <span class="o">-</span> <span class="n">unmap_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">truncate_inode_pages_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">lstart</span><span class="p">,</span> <span class="n">lend</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">truncate_pagecache_range</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
