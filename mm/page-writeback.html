<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › page-writeback.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>page-writeback.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * mm/page-writeback.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002, Linus Torvalds.</span>
<span class="cm"> * Copyright (C) 2007 Red Hat, Inc., Peter Zijlstra &lt;pzijlstr@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Contains functions related to writing back dirty pages at the</span>
<span class="cm"> * address_space level.</span>
<span class="cm"> *</span>
<span class="cm"> * 10Apr2002	Andrew Morton</span>
<span class="cm"> *		Initial version</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/task_io_accounting_ops.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/percpu.h&gt;</span>
<span class="cp">#include &lt;linux/notifier.h&gt;</span>
<span class="cp">#include &lt;linux/smp.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/cpu.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt; </span><span class="cm">/* __set_page_dirty_buffers */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &lt;trace/events/writeback.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Sleep at most 200ms at a time in balance_dirty_pages().</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_PAUSE		max(HZ/5, 1)</span>

<span class="cm">/*</span>
<span class="cm"> * Try to keep balance_dirty_pages() call intervals higher than this many pages</span>
<span class="cm"> * by raising pause time to max_pause when falls below it.</span>
<span class="cm"> */</span>
<span class="cp">#define DIRTY_POLL_THRESH	(128 &gt;&gt; (PAGE_SHIFT - 10))</span>

<span class="cm">/*</span>
<span class="cm"> * Estimate write bandwidth at 200ms intervals.</span>
<span class="cm"> */</span>
<span class="cp">#define BANDWIDTH_INTERVAL	max(HZ/5, 1)</span>

<span class="cp">#define RATELIMIT_CALC_SHIFT	10</span>

<span class="cm">/*</span>
<span class="cm"> * After a CPU has dirtied this many pages, balance_dirty_pages_ratelimited</span>
<span class="cm"> * will look to see if it needs to force writeback or throttling.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="n">ratelimit_pages</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

<span class="cm">/* The following parameters are exported via /proc/sys/vm */</span>

<span class="cm">/*</span>
<span class="cm"> * Start background writeback (via writeback threads) at this percentage</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">dirty_background_ratio</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * dirty_background_bytes starts at 0 (disabled) so that it is a function of</span>
<span class="cm"> * dirty_background_ratio * the amount of dirtyable memory</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_background_bytes</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * free highmem will not be subtracted from the total free memory</span>
<span class="cm"> * for calculating free ratios if vm_highmem_is_dirtyable is true</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">vm_highmem_is_dirtyable</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The generator of dirty data starts writeback at this percentage</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">vm_dirty_ratio</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * vm_dirty_bytes starts at 0 (disabled) so that it is a function of</span>
<span class="cm"> * vm_dirty_ratio * the amount of dirtyable memory</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vm_dirty_bytes</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * The interval between `kupdate&#39;-style writebacks</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirty_writeback_interval</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span> <span class="cm">/* centiseconds */</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dirty_writeback_interval</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The longest time for which data is allowed to remain dirty</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dirty_expire_interval</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span> <span class="cm">/* centiseconds */</span>

<span class="cm">/*</span>
<span class="cm"> * Flag that makes the machine dump writes/reads and block dirtyings.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">block_dump</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Flag that puts the machine in &quot;laptop mode&quot;. Doubles as a timeout in jiffies:</span>
<span class="cm"> * a full sync is triggered after this time elapses without any disk activity.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">laptop_mode</span><span class="p">;</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">laptop_mode</span><span class="p">);</span>

<span class="cm">/* End of sysctl-exported parameters */</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">global_dirty_limit</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Scale the writeback cache size proportional to the relative writeout speeds.</span>
<span class="cm"> *</span>
<span class="cm"> * We do this by keeping a floating proportion between BDIs, based on page</span>
<span class="cm"> * writeback completions [end_page_writeback()]. Those devices that write out</span>
<span class="cm"> * pages fastest will get the larger share, while the slower will get a smaller</span>
<span class="cm"> * share.</span>
<span class="cm"> *</span>
<span class="cm"> * We use page writeout completions because we are interested in getting rid of</span>
<span class="cm"> * dirty pages. Having them written out is the primary goal.</span>
<span class="cm"> *</span>
<span class="cm"> * We introduce a concept of time, a period over which we measure these events,</span>
<span class="cm"> * because demand can/will vary over time. The length of this period itself is</span>
<span class="cm"> * measured in page writeback completions.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">prop_descriptor</span> <span class="n">vm_completions</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Work out the current dirty-memory clamping and background writeout</span>
<span class="cm"> * thresholds.</span>
<span class="cm"> *</span>
<span class="cm"> * The main aim here is to lower them aggressively if there is a lot of mapped</span>
<span class="cm"> * memory around.  To avoid stressing page reclaim with lots of unreclaimable</span>
<span class="cm"> * pages.  It is better to clamp down on writers than to start swapping, and</span>
<span class="cm"> * performing lots of scanning.</span>
<span class="cm"> *</span>
<span class="cm"> * We only allow 1/2 of the currently-unmapped memory to be dirtied.</span>
<span class="cm"> *</span>
<span class="cm"> * We don&#39;t permit the clamping level to fall below 5% - that is getting rather</span>
<span class="cm"> * excessive.</span>
<span class="cm"> *</span>
<span class="cm"> * We make sure that the background writeout level is below the adjusted</span>
<span class="cm"> * clamping level.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * In a memory zone, there is a certain amount of pages we consider</span>
<span class="cm"> * available for the page cache, which is essentially the number of</span>
<span class="cm"> * free and reclaimable pages, minus some zone reserves to protect</span>
<span class="cm"> * lowmem and the ability to uphold the zone&#39;s watermarks without</span>
<span class="cm"> * requiring writeback.</span>
<span class="cm"> *</span>
<span class="cm"> * This number of dirtyable pages is the base value of which the</span>
<span class="cm"> * user-configurable dirty ratio is the effictive number of pages that</span>
<span class="cm"> * are allowed to be actually dirtied.  Per individual zone, or</span>
<span class="cm"> * globally by using the sum of dirtyable pages over all zones.</span>
<span class="cm"> *</span>
<span class="cm"> * Because the user is allowed to specify the dirty limit globally as</span>
<span class="cm"> * absolute number of bytes, calculating the per-zone dirty limit can</span>
<span class="cm"> * require translating the configured limit into a percentage of</span>
<span class="cm"> * global dirtyable memory first.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">highmem_dirtyable_memory</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_HIGHMEM</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">z</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_zones</span><span class="p">[</span><span class="n">ZONE_HIGHMEM</span><span class="p">];</span>

		<span class="n">x</span> <span class="o">+=</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">NR_FREE_PAGES</span><span class="p">)</span> <span class="o">+</span>
		     <span class="n">zone_reclaimable_pages</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">dirty_balance_reserve</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure that the number of highmem pages is never larger</span>
<span class="cm">	 * than the number of the total dirtyable memory. This can only</span>
<span class="cm">	 * occur in very strange VM situations but we want to make sure</span>
<span class="cm">	 * that this does not occur.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * global_dirtyable_memory - number of globally dirtyable pages</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the global number of pages potentially available for dirty</span>
<span class="cm"> * page cache.  This is the base value for the global dirty limits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">global_dirtyable_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>

	<span class="n">x</span> <span class="o">=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_FREE_PAGES</span><span class="p">)</span> <span class="o">+</span> <span class="n">global_reclaimable_pages</span><span class="p">()</span> <span class="o">-</span>
	    <span class="n">dirty_balance_reserve</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vm_highmem_is_dirtyable</span><span class="p">)</span>
		<span class="n">x</span> <span class="o">-=</span> <span class="n">highmem_dirtyable_memory</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Ensure that we never return 0 */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * global_dirty_limits - background-writeback and dirty-throttling thresholds</span>
<span class="cm"> *</span>
<span class="cm"> * Calculate the dirty thresholds based on sysctl parameters</span>
<span class="cm"> * - vm.dirty_background_ratio  or  vm.dirty_background_bytes</span>
<span class="cm"> * - vm.dirty_ratio             or  vm.dirty_bytes</span>
<span class="cm"> * The dirty limits will be lifted by 1/4 for PF_LESS_THROTTLE (ie. nfsd) and</span>
<span class="cm"> * real-time tasks.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">global_dirty_limits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pbackground</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">pdirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">background</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">available_memory</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vm_dirty_bytes</span> <span class="o">||</span> <span class="o">!</span><span class="n">dirty_background_bytes</span><span class="p">)</span>
		<span class="n">available_memory</span> <span class="o">=</span> <span class="n">global_dirtyable_memory</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vm_dirty_bytes</span><span class="p">)</span>
		<span class="n">dirty</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">vm_dirty_bytes</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dirty</span> <span class="o">=</span> <span class="p">(</span><span class="n">vm_dirty_ratio</span> <span class="o">*</span> <span class="n">available_memory</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dirty_background_bytes</span><span class="p">)</span>
		<span class="n">background</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">dirty_background_bytes</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">background</span> <span class="o">=</span> <span class="p">(</span><span class="n">dirty_background_ratio</span> <span class="o">*</span> <span class="n">available_memory</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">background</span> <span class="o">&gt;=</span> <span class="n">dirty</span><span class="p">)</span>
		<span class="n">background</span> <span class="o">=</span> <span class="n">dirty</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_LESS_THROTTLE</span> <span class="o">||</span> <span class="n">rt_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">background</span> <span class="o">+=</span> <span class="n">background</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">dirty</span> <span class="o">+=</span> <span class="n">dirty</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">pbackground</span> <span class="o">=</span> <span class="n">background</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pdirty</span> <span class="o">=</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="n">trace_global_dirty_state</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">dirty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zone_dirtyable_memory - number of dirtyable pages in a zone</span>
<span class="cm"> * @zone: the zone</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the zone&#39;s number of pages potentially available for dirty</span>
<span class="cm"> * page cache.  This is the base value for the per-zone dirty limits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">zone_dirtyable_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The effective global number of dirtyable pages may exclude</span>
<span class="cm">	 * highmem as a big-picture measure to keep the ratio between</span>
<span class="cm">	 * dirty memory and lowmem reasonable.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But this function is purely about the individual zone and a</span>
<span class="cm">	 * highmem zone can hold its share of dirty pages, so we don&#39;t</span>
<span class="cm">	 * care about vm_highmem_is_dirtyable here.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_FREE_PAGES</span><span class="p">)</span> <span class="o">+</span>
	       <span class="n">zone_reclaimable_pages</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span> <span class="o">-</span>
	       <span class="n">zone</span><span class="o">-&gt;</span><span class="n">dirty_balance_reserve</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zone_dirty_limit - maximum number of dirty pages allowed in a zone</span>
<span class="cm"> * @zone: the zone</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the maximum number of dirty pages allowed in a zone, based</span>
<span class="cm"> * on the zone&#39;s dirtyable memory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">zone_dirty_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone_memory</span> <span class="o">=</span> <span class="n">zone_dirtyable_memory</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vm_dirty_bytes</span><span class="p">)</span>
		<span class="n">dirty</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">vm_dirty_bytes</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">*</span>
			<span class="n">zone_memory</span> <span class="o">/</span> <span class="n">global_dirtyable_memory</span><span class="p">();</span>
	<span class="k">else</span>
		<span class="n">dirty</span> <span class="o">=</span> <span class="n">vm_dirty_ratio</span> <span class="o">*</span> <span class="n">zone_memory</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_LESS_THROTTLE</span> <span class="o">||</span> <span class="n">rt_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span>
		<span class="n">dirty</span> <span class="o">+=</span> <span class="n">dirty</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dirty</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * zone_dirty_ok - tells whether a zone is within its dirty limits</span>
<span class="cm"> * @zone: the zone to check</span>
<span class="cm"> *</span>
<span class="cm"> * Returns %true when the dirty pages in @zone are within the zone&#39;s</span>
<span class="cm"> * dirty limit, %false if the limit is exceeded.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">zone_dirty_ok</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">zone_dirty_limit</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_FILE_DIRTY</span><span class="p">)</span> <span class="o">+</span>
	       <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_UNSTABLE_NFS</span><span class="p">)</span> <span class="o">+</span>
	       <span class="n">zone_page_state</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">NR_WRITEBACK</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * couple the period to the dirty_ratio:</span>
<span class="cm"> *</span>
<span class="cm"> *   period/2 ~ roundup_pow_of_two(dirty limit)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">calc_period_shift</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_total</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vm_dirty_bytes</span><span class="p">)</span>
		<span class="n">dirty_total</span> <span class="o">=</span> <span class="n">vm_dirty_bytes</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dirty_total</span> <span class="o">=</span> <span class="p">(</span><span class="n">vm_dirty_ratio</span> <span class="o">*</span> <span class="n">global_dirtyable_memory</span><span class="p">())</span> <span class="o">/</span>
				<span class="mi">100</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">dirty_total</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update the period when the dirty threshold changes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_completion_period</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">calc_period_shift</span><span class="p">();</span>
	<span class="n">prop_change_shift</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm_completions</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>

	<span class="n">writeback_set_ratelimit</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dirty_background_ratio_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">write</span><span class="p">)</span>
		<span class="n">dirty_background_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dirty_background_bytes_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">proc_doulongvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">write</span><span class="p">)</span>
		<span class="n">dirty_background_ratio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dirty_ratio_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">old_ratio</span> <span class="o">=</span> <span class="n">vm_dirty_ratio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">proc_dointvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">vm_dirty_ratio</span> <span class="o">!=</span> <span class="n">old_ratio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_completion_period</span><span class="p">();</span>
		<span class="n">vm_dirty_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dirty_bytes_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">lenp</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_bytes</span> <span class="o">=</span> <span class="n">vm_dirty_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">proc_doulongvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">lenp</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">vm_dirty_bytes</span> <span class="o">!=</span> <span class="n">old_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_completion_period</span><span class="p">();</span>
		<span class="n">vm_dirty_ratio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Increment the BDI&#39;s writeout completion count and the global writeout</span>
<span class="cm"> * completion count. Called from test_clear_page_writeback().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__bdi_writeout_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__inc_bdi_stat</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_WRITTEN</span><span class="p">);</span>
	<span class="n">__prop_inc_percpu_max</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm_completions</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">completions</span><span class="p">,</span>
			      <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">max_prop_frac</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bdi_writeout_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">__bdi_writeout_inc</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">bdi_writeout_inc</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Obtain an accurate fraction of the BDI&#39;s portion.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_writeout_fraction</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
		<span class="kt">long</span> <span class="o">*</span><span class="n">numerator</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">denominator</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prop_fraction_percpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm_completions</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">completions</span><span class="p">,</span>
				<span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bdi_min_ratio keeps the sum of the minimum dirty shares of all</span>
<span class="cm"> * registered backing devices, which, for obvious reasons, can not</span>
<span class="cm"> * exceed 100%.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bdi_min_ratio</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">bdi_set_min_ratio</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_ratio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">min_ratio</span> <span class="o">&gt;</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">max_ratio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">min_ratio</span> <span class="o">-=</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">min_ratio</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bdi_min_ratio</span> <span class="o">+</span> <span class="n">min_ratio</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bdi_min_ratio</span> <span class="o">+=</span> <span class="n">min_ratio</span><span class="p">;</span>
			<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">min_ratio</span> <span class="o">+=</span> <span class="n">min_ratio</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bdi_set_max_ratio</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">max_ratio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_ratio</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">min_ratio</span> <span class="o">&gt;</span> <span class="n">max_ratio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">max_ratio</span> <span class="o">=</span> <span class="n">max_ratio</span><span class="p">;</span>
		<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">max_prop_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">PROP_FRAC_BASE</span> <span class="o">*</span> <span class="n">max_ratio</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bdi_set_max_ratio</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">dirty_freerun_ceiling</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thresh</span><span class="p">,</span>
					   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bg_thresh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">thresh</span> <span class="o">+</span> <span class="n">bg_thresh</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hard_dirty_limit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thresh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="n">global_dirty_limit</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bdi_dirty_limit - @bdi&#39;s share of dirty throttling threshold</span>
<span class="cm"> * @bdi: the backing_dev_info to query</span>
<span class="cm"> * @dirty: global dirty limit in pages</span>
<span class="cm"> *</span>
<span class="cm"> * Returns @bdi&#39;s dirty limit in pages. The term &quot;dirty&quot; in the context of</span>
<span class="cm"> * dirty balancing includes all PG_dirty, PG_writeback and NFS unstable pages.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that balance_dirty_pages() will only seriously take it as a hard limit</span>
<span class="cm"> * when sleeping max_pause per page is not enough to keep the dirty pages under</span>
<span class="cm"> * control. For example, when the device is completely stalled due to some error</span>
<span class="cm"> * conditions, or when there are 1000 dd tasks writing to a slow 10MB/s USB key.</span>
<span class="cm"> * In the other normal situations, it acts more gently by throttling the tasks</span>
<span class="cm"> * more (rather than completely block them) when the bdi dirty pages go high.</span>
<span class="cm"> *</span>
<span class="cm"> * It allocates high/low dirty limits to fast/slow devices, in order to prevent</span>
<span class="cm"> * - starving fast devices</span>
<span class="cm"> * - piling up dirty pages (that will take long time to sync) on slow devices</span>
<span class="cm"> *</span>
<span class="cm"> * The bdi&#39;s share of dirty limit will be adapting to its throughput and</span>
<span class="cm"> * bounded by the bdi-&gt;min_ratio and/or bdi-&gt;max_ratio parameters, if set.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">bdi_dirty_limit</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">bdi_dirty</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">numerator</span><span class="p">,</span> <span class="n">denominator</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate this BDI&#39;s share of the dirty ratio.</span>
<span class="cm">	 */</span>
	<span class="n">bdi_writeout_fraction</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numerator</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">denominator</span><span class="p">);</span>

	<span class="n">bdi_dirty</span> <span class="o">=</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="n">bdi_min_ratio</span><span class="p">))</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">bdi_dirty</span> <span class="o">*=</span> <span class="n">numerator</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">bdi_dirty</span><span class="p">,</span> <span class="n">denominator</span><span class="p">);</span>

	<span class="n">bdi_dirty</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">*</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">min_ratio</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdi_dirty</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">*</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">max_ratio</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
		<span class="n">bdi_dirty</span> <span class="o">=</span> <span class="n">dirty</span> <span class="o">*</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">max_ratio</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bdi_dirty</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Dirty position control.</span>
<span class="cm"> *</span>
<span class="cm"> * (o) global/bdi setpoints</span>
<span class="cm"> *</span>
<span class="cm"> * We want the dirty pages be balanced around the global/bdi setpoints.</span>
<span class="cm"> * When the number of dirty pages is higher/lower than the setpoint, the</span>
<span class="cm"> * dirty position control ratio (and hence task dirty ratelimit) will be</span>
<span class="cm"> * decreased/increased to bring the dirty pages back to the setpoint.</span>
<span class="cm"> *</span>
<span class="cm"> *     pos_ratio = 1 &lt;&lt; RATELIMIT_CALC_SHIFT</span>
<span class="cm"> *</span>
<span class="cm"> *     if (dirty &lt; setpoint) scale up   pos_ratio</span>
<span class="cm"> *     if (dirty &gt; setpoint) scale down pos_ratio</span>
<span class="cm"> *</span>
<span class="cm"> *     if (bdi_dirty &lt; bdi_setpoint) scale up   pos_ratio</span>
<span class="cm"> *     if (bdi_dirty &gt; bdi_setpoint) scale down pos_ratio</span>
<span class="cm"> *</span>
<span class="cm"> *     task_ratelimit = dirty_ratelimit * pos_ratio &gt;&gt; RATELIMIT_CALC_SHIFT</span>
<span class="cm"> *</span>
<span class="cm"> * (o) global control line</span>
<span class="cm"> *</span>
<span class="cm"> *     ^ pos_ratio</span>
<span class="cm"> *     |</span>
<span class="cm"> *     |            |&lt;===== global dirty control scope ======&gt;|</span>
<span class="cm"> * 2.0 .............*</span>
<span class="cm"> *     |            .*</span>
<span class="cm"> *     |            . *</span>
<span class="cm"> *     |            .   *</span>
<span class="cm"> *     |            .     *</span>
<span class="cm"> *     |            .        *</span>
<span class="cm"> *     |            .            *</span>
<span class="cm"> * 1.0 ................................*</span>
<span class="cm"> *     |            .                  .     *</span>
<span class="cm"> *     |            .                  .          *</span>
<span class="cm"> *     |            .                  .              *</span>
<span class="cm"> *     |            .                  .                 *</span>
<span class="cm"> *     |            .                  .                    *</span>
<span class="cm"> *   0 +------------.------------------.----------------------*-------------&gt;</span>
<span class="cm"> *           freerun^          setpoint^                 limit^   dirty pages</span>
<span class="cm"> *</span>
<span class="cm"> * (o) bdi control line</span>
<span class="cm"> *</span>
<span class="cm"> *     ^ pos_ratio</span>
<span class="cm"> *     |</span>
<span class="cm"> *     |            *</span>
<span class="cm"> *     |              *</span>
<span class="cm"> *     |                *</span>
<span class="cm"> *     |                  *</span>
<span class="cm"> *     |                    * |&lt;=========== span ============&gt;|</span>
<span class="cm"> * 1.0 .......................*</span>
<span class="cm"> *     |                      . *</span>
<span class="cm"> *     |                      .   *</span>
<span class="cm"> *     |                      .     *</span>
<span class="cm"> *     |                      .       *</span>
<span class="cm"> *     |                      .         *</span>
<span class="cm"> *     |                      .           *</span>
<span class="cm"> *     |                      .             *</span>
<span class="cm"> *     |                      .               *</span>
<span class="cm"> *     |                      .                 *</span>
<span class="cm"> *     |                      .                   *</span>
<span class="cm"> *     |                      .                     *</span>
<span class="cm"> * 1/4 ...............................................* * * * * * * * * * * *</span>
<span class="cm"> *     |                      .                         .</span>
<span class="cm"> *     |                      .                           .</span>
<span class="cm"> *     |                      .                             .</span>
<span class="cm"> *   0 +----------------------.-------------------------------.-------------&gt;</span>
<span class="cm"> *                bdi_setpoint^                    x_intercept^</span>
<span class="cm"> *</span>
<span class="cm"> * The bdi control line won&#39;t drop below pos_ratio=1/4, so that bdi_dirty can</span>
<span class="cm"> * be smoothly throttled down to normal if it starts high in situations like</span>
<span class="cm"> * - start writing to a slow SD card and a fast disk at the same time. The SD</span>
<span class="cm"> *   card&#39;s bdi_dirty may rush to many times higher than bdi_setpoint.</span>
<span class="cm"> * - the bdi dirty thresh drops quickly due to change of JBOD workload</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">bdi_position_ratio</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thresh</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bg_thresh</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_thresh</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_bw</span> <span class="o">=</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">avg_write_bandwidth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freerun</span> <span class="o">=</span> <span class="n">dirty_freerun_ceiling</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="n">bg_thresh</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">hard_dirty_limit</span><span class="p">(</span><span class="n">thresh</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x_intercept</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">setpoint</span><span class="p">;</span>		<span class="cm">/* dirty pages&#39; target balance point */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_setpoint</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">span</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">pos_ratio</span><span class="p">;</span>		<span class="cm">/* for scaling up/down the rate limit */</span>
	<span class="kt">long</span> <span class="n">x</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * global setpoint</span>
<span class="cm">	 *</span>
<span class="cm">	 *                           setpoint - dirty 3</span>
<span class="cm">	 *        f(dirty) := 1.0 + (----------------)</span>
<span class="cm">	 *                           limit - setpoint</span>
<span class="cm">	 *</span>
<span class="cm">	 * it&#39;s a 3rd order polynomial that subjects to</span>
<span class="cm">	 *</span>
<span class="cm">	 * (1) f(freerun)  = 2.0 =&gt; rampup dirty_ratelimit reasonably fast</span>
<span class="cm">	 * (2) f(setpoint) = 1.0 =&gt; the balance point</span>
<span class="cm">	 * (3) f(limit)    = 0   =&gt; the hard limit</span>
<span class="cm">	 * (4) df/dx      &lt;= 0	 =&gt; negative feedback control</span>
<span class="cm">	 * (5) the closer to setpoint, the smaller |df/dx| (and the reverse)</span>
<span class="cm">	 *     =&gt; fast response on large errors; small oscillation near setpoint</span>
<span class="cm">	 */</span>
	<span class="n">setpoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">freerun</span> <span class="o">+</span> <span class="n">limit</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">div_s64</span><span class="p">((</span><span class="n">setpoint</span> <span class="o">-</span> <span class="n">dirty</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">RATELIMIT_CALC_SHIFT</span><span class="p">,</span>
		    <span class="n">limit</span> <span class="o">-</span> <span class="n">setpoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">pos_ratio</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
	<span class="n">pos_ratio</span> <span class="o">=</span> <span class="n">pos_ratio</span> <span class="o">*</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">RATELIMIT_CALC_SHIFT</span><span class="p">;</span>
	<span class="n">pos_ratio</span> <span class="o">=</span> <span class="n">pos_ratio</span> <span class="o">*</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">RATELIMIT_CALC_SHIFT</span><span class="p">;</span>
	<span class="n">pos_ratio</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RATELIMIT_CALC_SHIFT</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have computed basic pos_ratio above based on global situation. If</span>
<span class="cm">	 * the bdi is over/under its share of dirty pages, we want to scale</span>
<span class="cm">	 * pos_ratio further down/up. That is done by the following mechanism.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * bdi setpoint</span>
<span class="cm">	 *</span>
<span class="cm">	 *        f(bdi_dirty) := 1.0 + k * (bdi_dirty - bdi_setpoint)</span>
<span class="cm">	 *</span>
<span class="cm">	 *                        x_intercept - bdi_dirty</span>
<span class="cm">	 *                     := --------------------------</span>
<span class="cm">	 *                        x_intercept - bdi_setpoint</span>
<span class="cm">	 *</span>
<span class="cm">	 * The main bdi control line is a linear function that subjects to</span>
<span class="cm">	 *</span>
<span class="cm">	 * (1) f(bdi_setpoint) = 1.0</span>
<span class="cm">	 * (2) k = - 1 / (8 * write_bw)  (in single bdi case)</span>
<span class="cm">	 *     or equally: x_intercept = bdi_setpoint + 8 * write_bw</span>
<span class="cm">	 *</span>
<span class="cm">	 * For single bdi case, the dirty pages are observed to fluctuate</span>
<span class="cm">	 * regularly within range</span>
<span class="cm">	 *        [bdi_setpoint - write_bw/2, bdi_setpoint + write_bw/2]</span>
<span class="cm">	 * for various filesystems, where (2) can yield in a reasonable 12.5%</span>
<span class="cm">	 * fluctuation range for pos_ratio.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For JBOD case, bdi_thresh (not bdi_dirty!) could fluctuate up to its</span>
<span class="cm">	 * own size, so move the slope over accordingly and choose a slope that</span>
<span class="cm">	 * yields 100% pos_ratio fluctuation on suddenly doubled bdi_thresh.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bdi_thresh</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">))</span>
		<span class="n">bdi_thresh</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * It&#39;s very possible that bdi_thresh is close to 0 not because the</span>
<span class="cm">	 * device is slow, but that it has remained inactive for long time.</span>
<span class="cm">	 * Honour such devices a reasonable good (hopefully IO efficient)</span>
<span class="cm">	 * threshold, so that the occasional writes won&#39;t be blocked and active</span>
<span class="cm">	 * writes can rampup the threshold quickly.</span>
<span class="cm">	 */</span>
	<span class="n">bdi_thresh</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">bdi_thresh</span><span class="p">,</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">dirty</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * scale global setpoint to bdi&#39;s:</span>
<span class="cm">	 *	bdi_setpoint = setpoint * bdi_thresh / thresh</span>
<span class="cm">	 */</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">bdi_thresh</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">,</span> <span class="n">thresh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bdi_setpoint</span> <span class="o">=</span> <span class="n">setpoint</span> <span class="o">*</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Use span=(8*write_bw) in single bdi case as indicated by</span>
<span class="cm">	 * (thresh - bdi_thresh ~= 0) and transit to bdi_thresh in JBOD case.</span>
<span class="cm">	 *</span>
<span class="cm">	 *        bdi_thresh                    thresh - bdi_thresh</span>
<span class="cm">	 * span = ---------- * (8 * write_bw) + ------------------- * bdi_thresh</span>
<span class="cm">	 *          thresh                            thresh</span>
<span class="cm">	 */</span>
	<span class="n">span</span> <span class="o">=</span> <span class="p">(</span><span class="n">thresh</span> <span class="o">-</span> <span class="n">bdi_thresh</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">write_bw</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">x_intercept</span> <span class="o">=</span> <span class="n">bdi_setpoint</span> <span class="o">+</span> <span class="n">span</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdi_dirty</span> <span class="o">&lt;</span> <span class="n">x_intercept</span> <span class="o">-</span> <span class="n">span</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pos_ratio</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">pos_ratio</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_intercept</span> <span class="o">-</span> <span class="n">bdi_dirty</span><span class="p">),</span>
				    <span class="n">x_intercept</span> <span class="o">-</span> <span class="n">bdi_setpoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pos_ratio</span> <span class="o">/=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * bdi reserve area, safeguard against dirty pool underrun and disk idle</span>
<span class="cm">	 * It may push the desired control point of global dirty pages higher</span>
<span class="cm">	 * than setpoint.</span>
<span class="cm">	 */</span>
	<span class="n">x_intercept</span> <span class="o">=</span> <span class="n">bdi_thresh</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdi_dirty</span> <span class="o">&lt;</span> <span class="n">x_intercept</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bdi_dirty</span> <span class="o">&gt;</span> <span class="n">x_intercept</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>
			<span class="n">pos_ratio</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">(</span><span class="n">pos_ratio</span> <span class="o">*</span> <span class="n">x_intercept</span><span class="p">,</span> <span class="n">bdi_dirty</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">pos_ratio</span> <span class="o">*=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pos_ratio</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_update_write_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elapsed</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">written</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">period</span> <span class="o">=</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">avg</span> <span class="o">=</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">avg_write_bandwidth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old</span> <span class="o">=</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">write_bandwidth</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bw</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * bw = written * HZ / elapsed</span>
<span class="cm">	 *</span>
<span class="cm">	 *                   bw * elapsed + write_bandwidth * (period - elapsed)</span>
<span class="cm">	 * write_bandwidth = ---------------------------------------------------</span>
<span class="cm">	 *                                          period</span>
<span class="cm">	 */</span>
	<span class="n">bw</span> <span class="o">=</span> <span class="n">written</span> <span class="o">-</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">written_stamp</span><span class="p">;</span>
	<span class="n">bw</span> <span class="o">*=</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">elapsed</span> <span class="o">&gt;</span> <span class="n">period</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">bw</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">);</span>
		<span class="n">avg</span> <span class="o">=</span> <span class="n">bw</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bw</span> <span class="o">+=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">write_bandwidth</span> <span class="o">*</span> <span class="p">(</span><span class="n">period</span> <span class="o">-</span> <span class="n">elapsed</span><span class="p">);</span>
	<span class="n">bw</span> <span class="o">&gt;&gt;=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">period</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * one more level of smoothing, for filtering out sudden spikes</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">avg</span> <span class="o">&gt;</span> <span class="n">old</span> <span class="o">&amp;&amp;</span> <span class="n">old</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bw</span><span class="p">)</span>
		<span class="n">avg</span> <span class="o">-=</span> <span class="p">(</span><span class="n">avg</span> <span class="o">-</span> <span class="n">old</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">avg</span> <span class="o">&lt;</span> <span class="n">old</span> <span class="o">&amp;&amp;</span> <span class="n">old</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bw</span><span class="p">)</span>
		<span class="n">avg</span> <span class="o">+=</span> <span class="p">(</span><span class="n">old</span> <span class="o">-</span> <span class="n">avg</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">write_bandwidth</span> <span class="o">=</span> <span class="n">bw</span><span class="p">;</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">avg_write_bandwidth</span> <span class="o">=</span> <span class="n">avg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The global dirtyable memory and dirty threshold could be suddenly knocked</span>
<span class="cm"> * down by a large amount (eg. on the startup of KVM in a swapless system).</span>
<span class="cm"> * This may throw the system into deep dirty exceeded state and throttle</span>
<span class="cm"> * heavy/light dirtiers alike. To retain good responsiveness, maintain</span>
<span class="cm"> * global_dirty_limit for tracking slowly down to the knocked down dirty</span>
<span class="cm"> * threshold.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_dirty_limit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thresh</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">global_dirty_limit</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Follow up in one step.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">limit</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">update</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Follow down slowly. Use the higher one as the target, because thresh</span>
<span class="cm">	 * may drop below dirty. This is exactly the reason to introduce</span>
<span class="cm">	 * global_dirty_limit which is guaranteed to lie above the dirty pages.</span>
<span class="cm">	 */</span>
	<span class="n">thresh</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="n">dirty</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">limit</span> <span class="o">-=</span> <span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">thresh</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">update</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">update:</span>
	<span class="n">global_dirty_limit</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">global_update_bandwidth</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thresh</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">dirty_lock</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">update_time</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * check locklessly first to optimize away locking for the most time</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">update_time</span> <span class="o">+</span> <span class="n">BANDWIDTH_INTERVAL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirty_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">update_time</span> <span class="o">+</span> <span class="n">BANDWIDTH_INTERVAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">update_dirty_limit</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="n">dirty</span><span class="p">);</span>
		<span class="n">update_time</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirty_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Maintain bdi-&gt;dirty_ratelimit, the base dirty throttle rate.</span>
<span class="cm"> *</span>
<span class="cm"> * Normal bdi tasks will be curbed at or below it in long term.</span>
<span class="cm"> * Obviously it should be around (write_bw / N) when there are N dd tasks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_update_dirty_ratelimit</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thresh</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bg_thresh</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_thresh</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_dirty</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirtied</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elapsed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freerun</span> <span class="o">=</span> <span class="n">dirty_freerun_ceiling</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="n">bg_thresh</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">hard_dirty_limit</span><span class="p">(</span><span class="n">thresh</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">setpoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">freerun</span> <span class="o">+</span> <span class="n">limit</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">write_bw</span> <span class="o">=</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">avg_write_bandwidth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_ratelimit</span> <span class="o">=</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirty_ratelimit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_rate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">task_ratelimit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">balanced_dirty_ratelimit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos_ratio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">step</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The dirty rate will match the writeout rate in long term, except</span>
<span class="cm">	 * when dirty pages are truncated by userspace or re-dirtied by FS.</span>
<span class="cm">	 */</span>
	<span class="n">dirty_rate</span> <span class="o">=</span> <span class="p">(</span><span class="n">dirtied</span> <span class="o">-</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirtied_stamp</span><span class="p">)</span> <span class="o">*</span> <span class="n">HZ</span> <span class="o">/</span> <span class="n">elapsed</span><span class="p">;</span>

	<span class="n">pos_ratio</span> <span class="o">=</span> <span class="n">bdi_position_ratio</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">bg_thresh</span><span class="p">,</span> <span class="n">dirty</span><span class="p">,</span>
				       <span class="n">bdi_thresh</span><span class="p">,</span> <span class="n">bdi_dirty</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * task_ratelimit reflects each dd&#39;s dirty rate for the past 200ms.</span>
<span class="cm">	 */</span>
	<span class="n">task_ratelimit</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">dirty_ratelimit</span> <span class="o">*</span>
					<span class="n">pos_ratio</span> <span class="o">&gt;&gt;</span> <span class="n">RATELIMIT_CALC_SHIFT</span><span class="p">;</span>
	<span class="n">task_ratelimit</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* it helps rampup dirty_ratelimit from tiny values */</span>

	<span class="cm">/*</span>
<span class="cm">	 * A linear estimation of the &quot;balanced&quot; throttle rate. The theory is,</span>
<span class="cm">	 * if there are N dd tasks, each throttled at task_ratelimit, the bdi&#39;s</span>
<span class="cm">	 * dirty_rate will be measured to be (N * task_ratelimit). So the below</span>
<span class="cm">	 * formula will yield the balanced rate limit (write_bw / N).</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that the expanded form is not a pure rate feedback:</span>
<span class="cm">	 *	rate_(i+1) = rate_(i) * (write_bw / dirty_rate)		     (1)</span>
<span class="cm">	 * but also takes pos_ratio into account:</span>
<span class="cm">	 *	rate_(i+1) = rate_(i) * (write_bw / dirty_rate) * pos_ratio  (2)</span>
<span class="cm">	 *</span>
<span class="cm">	 * (1) is not realistic because pos_ratio also takes part in balancing</span>
<span class="cm">	 * the dirty rate.  Consider the state</span>
<span class="cm">	 *	pos_ratio = 0.5						     (3)</span>
<span class="cm">	 *	rate = 2 * (write_bw / N)				     (4)</span>
<span class="cm">	 * If (1) is used, it will stuck in that state! Because each dd will</span>
<span class="cm">	 * be throttled at</span>
<span class="cm">	 *	task_ratelimit = pos_ratio * rate = (write_bw / N)	     (5)</span>
<span class="cm">	 * yielding</span>
<span class="cm">	 *	dirty_rate = N * task_ratelimit = write_bw		     (6)</span>
<span class="cm">	 * put (6) into (1) we get</span>
<span class="cm">	 *	rate_(i+1) = rate_(i)					     (7)</span>
<span class="cm">	 *</span>
<span class="cm">	 * So we end up using (2) to always keep</span>
<span class="cm">	 *	rate_(i+1) ~= (write_bw / N)				     (8)</span>
<span class="cm">	 * regardless of the value of pos_ratio. As long as (8) is satisfied,</span>
<span class="cm">	 * pos_ratio is able to drive itself to 1.0, which is not only where</span>
<span class="cm">	 * the dirty count meet the setpoint, but also where the slope of</span>
<span class="cm">	 * pos_ratio is most flat and hence task_ratelimit is least fluctuated.</span>
<span class="cm">	 */</span>
	<span class="n">balanced_dirty_ratelimit</span> <span class="o">=</span> <span class="n">div_u64</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">task_ratelimit</span> <span class="o">*</span> <span class="n">write_bw</span><span class="p">,</span>
					   <span class="n">dirty_rate</span> <span class="o">|</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * balanced_dirty_ratelimit ~= (write_bw / N) &lt;= write_bw</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">balanced_dirty_ratelimit</span> <span class="o">&gt;</span> <span class="n">write_bw</span><span class="p">))</span>
		<span class="n">balanced_dirty_ratelimit</span> <span class="o">=</span> <span class="n">write_bw</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We could safely do this and return immediately:</span>
<span class="cm">	 *</span>
<span class="cm">	 *	bdi-&gt;dirty_ratelimit = balanced_dirty_ratelimit;</span>
<span class="cm">	 *</span>
<span class="cm">	 * However to get a more stable dirty_ratelimit, the below elaborated</span>
<span class="cm">	 * code makes use of task_ratelimit to filter out sigular points and</span>
<span class="cm">	 * limit the step size.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The below code essentially only uses the relative value of</span>
<span class="cm">	 *</span>
<span class="cm">	 *	task_ratelimit - dirty_ratelimit</span>
<span class="cm">	 *	= (pos_ratio - 1) * dirty_ratelimit</span>
<span class="cm">	 *</span>
<span class="cm">	 * which reflects the direction and size of dirty position error.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * dirty_ratelimit will follow balanced_dirty_ratelimit iff</span>
<span class="cm">	 * task_ratelimit is on the same side of dirty_ratelimit, too.</span>
<span class="cm">	 * For example, when</span>
<span class="cm">	 * - dirty_ratelimit &gt; balanced_dirty_ratelimit</span>
<span class="cm">	 * - dirty_ratelimit &gt; task_ratelimit (dirty pages are above setpoint)</span>
<span class="cm">	 * lowering dirty_ratelimit will help meet both the position and rate</span>
<span class="cm">	 * control targets. Otherwise, don&#39;t update dirty_ratelimit if it will</span>
<span class="cm">	 * only help meet the rate target. After all, what the users ultimately</span>
<span class="cm">	 * feel and care are stable dirty rate and small position error.</span>
<span class="cm">	 *</span>
<span class="cm">	 * |task_ratelimit - dirty_ratelimit| is used to limit the step size</span>
<span class="cm">	 * and filter out the sigular points of balanced_dirty_ratelimit. Which</span>
<span class="cm">	 * keeps jumping around randomly and can even leap far away at times</span>
<span class="cm">	 * due to the small 200ms estimation period of dirty_rate (we want to</span>
<span class="cm">	 * keep that period small to reduce time lags).</span>
<span class="cm">	 */</span>
	<span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">&lt;</span> <span class="n">setpoint</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">balanced_dirty_ratelimit</span><span class="p">,</span>
			 <span class="n">min</span><span class="p">(</span><span class="n">balanced_dirty_ratelimit</span><span class="p">,</span> <span class="n">task_ratelimit</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dirty_ratelimit</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span>
			<span class="n">step</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">dirty_ratelimit</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">balanced_dirty_ratelimit</span><span class="p">,</span>
			 <span class="n">max</span><span class="p">(</span><span class="n">balanced_dirty_ratelimit</span><span class="p">,</span> <span class="n">task_ratelimit</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dirty_ratelimit</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">)</span>
			<span class="n">step</span> <span class="o">=</span> <span class="n">dirty_ratelimit</span> <span class="o">-</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t pursue 100% rate matching. It&#39;s impossible since the balanced</span>
<span class="cm">	 * rate itself is constantly fluctuating. So decrease the track speed</span>
<span class="cm">	 * when it gets close to the target. Helps eliminate pointless tremors.</span>
<span class="cm">	 */</span>
	<span class="n">step</span> <span class="o">&gt;&gt;=</span> <span class="n">dirty_ratelimit</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Limit the tracking speed to avoid overshooting.</span>
<span class="cm">	 */</span>
	<span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dirty_ratelimit</span> <span class="o">&lt;</span> <span class="n">balanced_dirty_ratelimit</span><span class="p">)</span>
		<span class="n">dirty_ratelimit</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dirty_ratelimit</span> <span class="o">-=</span> <span class="n">step</span><span class="p">;</span>

	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirty_ratelimit</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dirty_ratelimit</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">);</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">balanced_dirty_ratelimit</span> <span class="o">=</span> <span class="n">balanced_dirty_ratelimit</span><span class="p">;</span>

	<span class="n">trace_bdi_dirty_ratelimit</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">dirty_rate</span><span class="p">,</span> <span class="n">task_ratelimit</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__bdi_update_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thresh</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bg_thresh</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_thresh</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_dirty</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bw_time_stamp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirtied</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">written</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * rate-limit, only update once every 200ms.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elapsed</span> <span class="o">&lt;</span> <span class="n">BANDWIDTH_INTERVAL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dirtied</span> <span class="o">=</span> <span class="n">percpu_counter_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bdi_stat</span><span class="p">[</span><span class="n">BDI_DIRTIED</span><span class="p">]);</span>
	<span class="n">written</span> <span class="o">=</span> <span class="n">percpu_counter_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bdi_stat</span><span class="p">[</span><span class="n">BDI_WRITTEN</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Skip quiet periods when disk bandwidth is under-utilized.</span>
<span class="cm">	 * (at least 1s idle time between two flusher runs)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elapsed</span> <span class="o">&gt;</span> <span class="n">HZ</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bw_time_stamp</span><span class="p">,</span> <span class="n">start_time</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">snapshot</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">thresh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">global_update_bandwidth</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="n">dirty</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
		<span class="n">bdi_update_dirty_ratelimit</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">bg_thresh</span><span class="p">,</span> <span class="n">dirty</span><span class="p">,</span>
					   <span class="n">bdi_thresh</span><span class="p">,</span> <span class="n">bdi_dirty</span><span class="p">,</span>
					   <span class="n">dirtied</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bdi_update_write_bandwidth</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">elapsed</span><span class="p">,</span> <span class="n">written</span><span class="p">);</span>

<span class="nl">snapshot:</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirtied_stamp</span> <span class="o">=</span> <span class="n">dirtied</span><span class="p">;</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">written_stamp</span> <span class="o">=</span> <span class="n">written</span><span class="p">;</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bw_time_stamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_update_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thresh</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bg_thresh</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_thresh</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_dirty</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_is_after_eq_jiffies</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bw_time_stamp</span> <span class="o">+</span> <span class="n">BANDWIDTH_INTERVAL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">__bdi_update_bandwidth</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">bg_thresh</span><span class="p">,</span> <span class="n">dirty</span><span class="p">,</span>
			       <span class="n">bdi_thresh</span><span class="p">,</span> <span class="n">bdi_dirty</span><span class="p">,</span> <span class="n">start_time</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * After a task dirtied this many pages, balance_dirty_pages_ratelimited_nr()</span>
<span class="cm"> * will look to see if it needs to start dirty throttling.</span>
<span class="cm"> *</span>
<span class="cm"> * If dirty_poll_interval is too low, big NUMA machines will call the expensive</span>
<span class="cm"> * global_page_state() too often. So scale it near-sqrt to the safety margin</span>
<span class="cm"> * (the number of pages we may dirty without exceeding the dirty limits).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">dirty_poll_interval</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thresh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thresh</span> <span class="o">&gt;</span> <span class="n">dirty</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ilog2</span><span class="p">(</span><span class="n">thresh</span> <span class="o">-</span> <span class="n">dirty</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">bdi_max_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">bw</span> <span class="o">=</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">avg_write_bandwidth</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">t</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Limit pause time for small memory systems. If sleeping for too long</span>
<span class="cm">	 * time, a small pool of dirty/writeback pages may go empty and disk go</span>
<span class="cm">	 * idle.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 8 serves as the safety ratio.</span>
<span class="cm">	 */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">bdi_dirty</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">bw</span> <span class="o">/</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">8</span><span class="p">));</span>
	<span class="n">t</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">MAX_PAUSE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">bdi_min_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
			  <span class="kt">long</span> <span class="n">max_pause</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">task_ratelimit</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_ratelimit</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="o">*</span><span class="n">nr_dirtied_pause</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">avg_write_bandwidth</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirty_ratelimit</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">t</span><span class="p">;</span>		<span class="cm">/* target pause */</span>
	<span class="kt">long</span> <span class="n">pause</span><span class="p">;</span>	<span class="cm">/* estimated next pause */</span>
	<span class="kt">int</span> <span class="n">pages</span><span class="p">;</span>	<span class="cm">/* target nr_dirtied_pause */</span>

	<span class="cm">/* target for 10ms pause on 1-dd case */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Scale up pause time for concurrent dirtiers in order to reduce CPU</span>
<span class="cm">	 * overheads.</span>
<span class="cm">	 *</span>
<span class="cm">	 * (N * 10ms) on 2^N concurrent tasks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&gt;</span> <span class="n">lo</span><span class="p">)</span>
		<span class="n">t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a bit convoluted. We try to base the next nr_dirtied_pause</span>
<span class="cm">	 * on the much more stable dirty_ratelimit. However the next pause time</span>
<span class="cm">	 * will be computed based on task_ratelimit and the two rate limits may</span>
<span class="cm">	 * depart considerably at some time. Especially if task_ratelimit goes</span>
<span class="cm">	 * below dirty_ratelimit/2 and the target pause is max_pause, the next</span>
<span class="cm">	 * pause time will be max_pause*2 _trimmed down_ to max_pause.  As a</span>
<span class="cm">	 * result task_ratelimit won&#39;t be executed faithfully, which could</span>
<span class="cm">	 * eventually bring down dirty_ratelimit.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We apply two rules to fix it up:</span>
<span class="cm">	 * 1) try to estimate the next pause time and if necessary, use a lower</span>
<span class="cm">	 *    nr_dirtied_pause so as not to exceed max_pause. When this happens,</span>
<span class="cm">	 *    nr_dirtied_pause will be &quot;dancing&quot; with task_ratelimit.</span>
<span class="cm">	 * 2) limit the target pause time to max_pause/2, so that the normal</span>
<span class="cm">	 *    small fluctuations of task_ratelimit won&#39;t trigger rule (1) and</span>
<span class="cm">	 *    nr_dirtied_pause will remain as stable as dirty_ratelimit.</span>
<span class="cm">	 */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max_pause</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">pages</span> <span class="o">=</span> <span class="n">dirty_ratelimit</span> <span class="o">*</span> <span class="n">t</span> <span class="o">/</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">HZ</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tiny nr_dirtied_pause is found to hurt I/O performance in the test</span>
<span class="cm">	 * case fio-mmap-randwrite-64k, which does 16*{sync read, async write}.</span>
<span class="cm">	 * When the 16 consecutive reads are often interrupted by some dirty</span>
<span class="cm">	 * throttling pause during the async writes, cfq will go into idles</span>
<span class="cm">	 * (deadline is fine). So push nr_dirtied_pause as high as possible</span>
<span class="cm">	 * until reaches DIRTY_POLL_THRESH=32 pages.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pages</span> <span class="o">&lt;</span> <span class="n">DIRTY_POLL_THRESH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">max_pause</span><span class="p">;</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">dirty_ratelimit</span> <span class="o">*</span> <span class="n">t</span> <span class="o">/</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">HZ</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pages</span> <span class="o">&gt;</span> <span class="n">DIRTY_POLL_THRESH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pages</span> <span class="o">=</span> <span class="n">DIRTY_POLL_THRESH</span><span class="p">;</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">DIRTY_POLL_THRESH</span> <span class="o">/</span> <span class="n">dirty_ratelimit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pause</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">pages</span> <span class="o">/</span> <span class="p">(</span><span class="n">task_ratelimit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pause</span> <span class="o">&gt;</span> <span class="n">max_pause</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">max_pause</span><span class="p">;</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">task_ratelimit</span> <span class="o">*</span> <span class="n">t</span> <span class="o">/</span> <span class="n">roundup_pow_of_two</span><span class="p">(</span><span class="n">HZ</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">nr_dirtied_pause</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The minimal pause time will normally be half the target pause time.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">pages</span> <span class="o">&gt;=</span> <span class="n">DIRTY_POLL_THRESH</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">t</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * balance_dirty_pages() must be called by processes which are generating dirty</span>
<span class="cm"> * data.  It looks at the number of dirty pages in the machine and will force</span>
<span class="cm"> * the caller to wait once crossing the (background_thresh + dirty_thresh) / 2.</span>
<span class="cm"> * If we&#39;re over `background_thresh&#39; then the writeback threads are woken to</span>
<span class="cm"> * perform some writeout.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">balance_dirty_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages_dirtied</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_reclaimable</span><span class="p">;</span>	<span class="cm">/* = file_dirty + unstable_nfs */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_reclaimable</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_dirty</span><span class="p">;</span>  <span class="cm">/* = file_dirty + writeback + unstable_nfs */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_dirty</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freerun</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">background_thresh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_thresh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_thresh</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">period</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">pause</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">max_pause</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">min_pause</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_dirtied_pause</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dirty_exceeded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">task_ratelimit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_ratelimit</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos_ratio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Unstable writes are a feature of certain networked</span>
<span class="cm">		 * filesystems (i.e. NFS) in which data may have been</span>
<span class="cm">		 * written to the server&#39;s write cache, but has not yet</span>
<span class="cm">		 * been flushed to permanent storage.</span>
<span class="cm">		 */</span>
		<span class="n">nr_reclaimable</span> <span class="o">=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_FILE_DIRTY</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_UNSTABLE_NFS</span><span class="p">);</span>
		<span class="n">nr_dirty</span> <span class="o">=</span> <span class="n">nr_reclaimable</span> <span class="o">+</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_WRITEBACK</span><span class="p">);</span>

		<span class="n">global_dirty_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">background_thresh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dirty_thresh</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Throttle it only when the background writeback cannot</span>
<span class="cm">		 * catch-up. This avoids (excessively) small writeouts</span>
<span class="cm">		 * when the bdi limits are ramping up.</span>
<span class="cm">		 */</span>
		<span class="n">freerun</span> <span class="o">=</span> <span class="n">dirty_freerun_ceiling</span><span class="p">(</span><span class="n">dirty_thresh</span><span class="p">,</span>
						<span class="n">background_thresh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_dirty</span> <span class="o">&lt;=</span> <span class="n">freerun</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">dirty_paused_when</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied_pause</span> <span class="o">=</span>
				<span class="n">dirty_poll_interval</span><span class="p">(</span><span class="n">nr_dirty</span><span class="p">,</span> <span class="n">dirty_thresh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">writeback_in_progress</span><span class="p">(</span><span class="n">bdi</span><span class="p">)))</span>
			<span class="n">bdi_start_background_writeback</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * bdi_thresh is not treated as some limiting factor as</span>
<span class="cm">		 * dirty_thresh, due to reasons</span>
<span class="cm">		 * - in JBOD setup, bdi_thresh can fluctuate a lot</span>
<span class="cm">		 * - in a system with HDD and USB key, the USB key may somehow</span>
<span class="cm">		 *   go into state (bdi_dirty &gt;&gt; bdi_thresh) either because</span>
<span class="cm">		 *   bdi_dirty starts high, or because bdi_thresh drops low.</span>
<span class="cm">		 *   In this case we don&#39;t want to hard throttle the USB key</span>
<span class="cm">		 *   dirtiers for 100 seconds until bdi_dirty drops under</span>
<span class="cm">		 *   bdi_thresh. Instead the auxiliary bdi control line in</span>
<span class="cm">		 *   bdi_position_ratio() will let the dirtier task progress</span>
<span class="cm">		 *   at some rate &lt;= (write_bw / 2) for bringing down bdi_dirty.</span>
<span class="cm">		 */</span>
		<span class="n">bdi_thresh</span> <span class="o">=</span> <span class="n">bdi_dirty_limit</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">dirty_thresh</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * In order to avoid the stacked BDI deadlock we need</span>
<span class="cm">		 * to ensure we accurately count the &#39;dirty&#39; pages when</span>
<span class="cm">		 * the threshold is low.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Otherwise it would be possible to get thresh+n pages</span>
<span class="cm">		 * reported dirty, even though there are thresh-m pages</span>
<span class="cm">		 * actually dirty; with m+n sitting in the percpu</span>
<span class="cm">		 * deltas.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bdi_thresh</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bdi_stat_error</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bdi_reclaimable</span> <span class="o">=</span> <span class="n">bdi_stat_sum</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_RECLAIMABLE</span><span class="p">);</span>
			<span class="n">bdi_dirty</span> <span class="o">=</span> <span class="n">bdi_reclaimable</span> <span class="o">+</span>
				    <span class="n">bdi_stat_sum</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_WRITEBACK</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">bdi_reclaimable</span> <span class="o">=</span> <span class="n">bdi_stat</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_RECLAIMABLE</span><span class="p">);</span>
			<span class="n">bdi_dirty</span> <span class="o">=</span> <span class="n">bdi_reclaimable</span> <span class="o">+</span>
				    <span class="n">bdi_stat</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_WRITEBACK</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">dirty_exceeded</span> <span class="o">=</span> <span class="p">(</span><span class="n">bdi_dirty</span> <span class="o">&gt;</span> <span class="n">bdi_thresh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				  <span class="p">(</span><span class="n">nr_dirty</span> <span class="o">&gt;</span> <span class="n">dirty_thresh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dirty_exceeded</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirty_exceeded</span><span class="p">)</span>
			<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirty_exceeded</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">bdi_update_bandwidth</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">dirty_thresh</span><span class="p">,</span> <span class="n">background_thresh</span><span class="p">,</span>
				     <span class="n">nr_dirty</span><span class="p">,</span> <span class="n">bdi_thresh</span><span class="p">,</span> <span class="n">bdi_dirty</span><span class="p">,</span>
				     <span class="n">start_time</span><span class="p">);</span>

		<span class="n">dirty_ratelimit</span> <span class="o">=</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirty_ratelimit</span><span class="p">;</span>
		<span class="n">pos_ratio</span> <span class="o">=</span> <span class="n">bdi_position_ratio</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">dirty_thresh</span><span class="p">,</span>
					       <span class="n">background_thresh</span><span class="p">,</span> <span class="n">nr_dirty</span><span class="p">,</span>
					       <span class="n">bdi_thresh</span><span class="p">,</span> <span class="n">bdi_dirty</span><span class="p">);</span>
		<span class="n">task_ratelimit</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">dirty_ratelimit</span> <span class="o">*</span> <span class="n">pos_ratio</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
							<span class="n">RATELIMIT_CALC_SHIFT</span><span class="p">;</span>
		<span class="n">max_pause</span> <span class="o">=</span> <span class="n">bdi_max_pause</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">bdi_dirty</span><span class="p">);</span>
		<span class="n">min_pause</span> <span class="o">=</span> <span class="n">bdi_min_pause</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">max_pause</span><span class="p">,</span>
					  <span class="n">task_ratelimit</span><span class="p">,</span> <span class="n">dirty_ratelimit</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">nr_dirtied_pause</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">task_ratelimit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">period</span> <span class="o">=</span> <span class="n">max_pause</span><span class="p">;</span>
			<span class="n">pause</span> <span class="o">=</span> <span class="n">max_pause</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">pause</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">period</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">pages_dirtied</span> <span class="o">/</span> <span class="n">task_ratelimit</span><span class="p">;</span>
		<span class="n">pause</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">dirty_paused_when</span><span class="p">)</span>
			<span class="n">pause</span> <span class="o">-=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">dirty_paused_when</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * For less than 1s think time (ext3/4 may block the dirtier</span>
<span class="cm">		 * for up to 800ms from time to time on 1-HDD; so does xfs,</span>
<span class="cm">		 * however at much less frequency), try to compensate it in</span>
<span class="cm">		 * future periods by updating the virtual time; otherwise just</span>
<span class="cm">		 * do a reset, as it may be a light dirtier.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pause</span> <span class="o">&lt;</span> <span class="n">min_pause</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trace_balance_dirty_pages</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span>
						  <span class="n">dirty_thresh</span><span class="p">,</span>
						  <span class="n">background_thresh</span><span class="p">,</span>
						  <span class="n">nr_dirty</span><span class="p">,</span>
						  <span class="n">bdi_thresh</span><span class="p">,</span>
						  <span class="n">bdi_dirty</span><span class="p">,</span>
						  <span class="n">dirty_ratelimit</span><span class="p">,</span>
						  <span class="n">task_ratelimit</span><span class="p">,</span>
						  <span class="n">pages_dirtied</span><span class="p">,</span>
						  <span class="n">period</span><span class="p">,</span>
						  <span class="n">min</span><span class="p">(</span><span class="n">pause</span><span class="p">,</span> <span class="mi">0L</span><span class="p">),</span>
						  <span class="n">start_time</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pause</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">HZ</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">dirty_paused_when</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">dirty_paused_when</span> <span class="o">+=</span> <span class="n">period</span><span class="p">;</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied_pause</span> <span class="o">&lt;=</span> <span class="n">pages_dirtied</span><span class="p">)</span>
				<span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied_pause</span> <span class="o">+=</span> <span class="n">pages_dirtied</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pause</span> <span class="o">&gt;</span> <span class="n">max_pause</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* for occasional dropped task_ratelimit */</span>
			<span class="n">now</span> <span class="o">+=</span> <span class="n">min</span><span class="p">(</span><span class="n">pause</span> <span class="o">-</span> <span class="n">max_pause</span><span class="p">,</span> <span class="n">max_pause</span><span class="p">);</span>
			<span class="n">pause</span> <span class="o">=</span> <span class="n">max_pause</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">pause:</span>
		<span class="n">trace_balance_dirty_pages</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span>
					  <span class="n">dirty_thresh</span><span class="p">,</span>
					  <span class="n">background_thresh</span><span class="p">,</span>
					  <span class="n">nr_dirty</span><span class="p">,</span>
					  <span class="n">bdi_thresh</span><span class="p">,</span>
					  <span class="n">bdi_dirty</span><span class="p">,</span>
					  <span class="n">dirty_ratelimit</span><span class="p">,</span>
					  <span class="n">task_ratelimit</span><span class="p">,</span>
					  <span class="n">pages_dirtied</span><span class="p">,</span>
					  <span class="n">period</span><span class="p">,</span>
					  <span class="n">pause</span><span class="p">,</span>
					  <span class="n">start_time</span><span class="p">);</span>
		<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_KILLABLE</span><span class="p">);</span>
		<span class="n">io_schedule_timeout</span><span class="p">(</span><span class="n">pause</span><span class="p">);</span>

		<span class="n">current</span><span class="o">-&gt;</span><span class="n">dirty_paused_when</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">pause</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied_pause</span> <span class="o">=</span> <span class="n">nr_dirtied_pause</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This is typically equal to (nr_dirty &lt; dirty_thresh) and can</span>
<span class="cm">		 * also keep &quot;1000+ dd on a slow USB stick&quot; under control.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">task_ratelimit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * In the case of an unresponding NFS server and the NFS dirty</span>
<span class="cm">		 * pages exceeds dirty_thresh, give the other good bdi&#39;s a pipe</span>
<span class="cm">		 * to go through, so that tasks on them still remain responsive.</span>
<span class="cm">		 *</span>
<span class="cm">		 * In theory 1 page is enough to keep the comsumer-producer</span>
<span class="cm">		 * pipe going: the flusher cleans 1 page =&gt; the task dirties 1</span>
<span class="cm">		 * more page. However bdi_dirty has accounting errors.  So use</span>
<span class="cm">		 * the larger and more IO friendly bdi_stat_error.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bdi_dirty</span> <span class="o">&lt;=</span> <span class="n">bdi_stat_error</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fatal_signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirty_exceeded</span> <span class="o">&amp;&amp;</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirty_exceeded</span><span class="p">)</span>
		<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirty_exceeded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">writeback_in_progress</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In laptop mode, we wait until hitting the higher threshold before</span>
<span class="cm">	 * starting background writeout, and then write out all the way down</span>
<span class="cm">	 * to the lower threshold.  So slow writers cause minimal disk activity.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In normal mode, we start background writeout at the lower</span>
<span class="cm">	 * background_thresh, to keep the amount of dirty memory low.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">laptop_mode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_reclaimable</span> <span class="o">&gt;</span> <span class="n">background_thresh</span><span class="p">)</span>
		<span class="n">bdi_start_background_writeback</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_page_dirty_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">page_mkwrite</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">page_mkwrite</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
			<span class="n">balance_dirty_pages_ratelimited</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">bdp_ratelimits</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Normal tasks are throttled by</span>
<span class="cm"> *	loop {</span>
<span class="cm"> *		dirty tsk-&gt;nr_dirtied_pause pages;</span>
<span class="cm"> *		take a snap in balance_dirty_pages();</span>
<span class="cm"> *	}</span>
<span class="cm"> * However there is a worst case. If every task exit immediately when dirtied</span>
<span class="cm"> * (tsk-&gt;nr_dirtied_pause - 1) pages, balance_dirty_pages() will never be</span>
<span class="cm"> * called to throttle the page dirties. The solution is to save the not yet</span>
<span class="cm"> * throttled page dirties in dirty_throttle_leaks on task exit and charge them</span>
<span class="cm"> * randomly into the running tasks. This works well for the above worst case,</span>
<span class="cm"> * as the new task will pick up and accumulate the old task&#39;s leaked dirty</span>
<span class="cm"> * count and eventually get throttled.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_PER_CPU</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">dirty_throttle_leaks</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * balance_dirty_pages_ratelimited_nr - balance dirty memory state</span>
<span class="cm"> * @mapping: address_space which was dirtied</span>
<span class="cm"> * @nr_pages_dirtied: number of pages which the caller has just dirtied</span>
<span class="cm"> *</span>
<span class="cm"> * Processes which are dirtying memory should call in here once for each page</span>
<span class="cm"> * which was newly dirtied.  The function will periodically check the system&#39;s</span>
<span class="cm"> * dirty state and will initiate writeback if needed.</span>
<span class="cm"> *</span>
<span class="cm"> * On really big machines, get_writeback_state is expensive, so try to avoid</span>
<span class="cm"> * calling it too often (ratelimiting).  But once we&#39;re over the dirty memory</span>
<span class="cm"> * limit we decrease the ratelimiting by a lot, to prevent individual processes</span>
<span class="cm"> * from overshooting the limit by (ratelimit_pages) each.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">balance_dirty_pages_ratelimited_nr</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages_dirtied</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ratelimit</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdi_cap_account_dirty</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ratelimit</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied_pause</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirty_exceeded</span><span class="p">)</span>
		<span class="n">ratelimit</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ratelimit</span><span class="p">,</span> <span class="mi">32</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">));</span>

	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * This prevents one CPU to accumulate too many dirtied pages without</span>
<span class="cm">	 * calling into balance_dirty_pages(), which can happen when there are</span>
<span class="cm">	 * 1000+ tasks, all of them start dirtying pages at exactly the same</span>
<span class="cm">	 * time, hence all honoured too large initial task-&gt;nr_dirtied_pause.</span>
<span class="cm">	 */</span>
	<span class="n">p</span> <span class="o">=</span>  <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">bdp_ratelimits</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span> <span class="o">&gt;=</span> <span class="n">ratelimit</span><span class="p">))</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">ratelimit_pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ratelimit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Pick up the dirtied pages by the exited tasks. This avoids lots of</span>
<span class="cm">	 * short-lived tasks (eg. gcc invocations in a kernel build) escaping</span>
<span class="cm">	 * the dirty throttling and livelock other long-run dirtiers.</span>
<span class="cm">	 */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">dirty_throttle_leaks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span> <span class="o">&lt;</span> <span class="n">ratelimit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_pages_dirtied</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">ratelimit</span> <span class="o">-</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span><span class="p">);</span>
		<span class="o">*</span><span class="n">p</span> <span class="o">-=</span> <span class="n">nr_pages_dirtied</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span> <span class="o">+=</span> <span class="n">nr_pages_dirtied</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">preempt_enable</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span> <span class="o">&gt;=</span> <span class="n">ratelimit</span><span class="p">))</span>
		<span class="n">balance_dirty_pages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">balance_dirty_pages_ratelimited_nr</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">throttle_vm_writeout</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">background_thresh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_thresh</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">global_dirty_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">background_thresh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dirty_thresh</span><span class="p">);</span>
		<span class="n">dirty_thresh</span> <span class="o">=</span> <span class="n">hard_dirty_limit</span><span class="p">(</span><span class="n">dirty_thresh</span><span class="p">);</span>

                <span class="cm">/*</span>
<span class="cm">                 * Boost the allowable dirty threshold a bit for page</span>
<span class="cm">                 * allocators so they don&#39;t get DoS&#39;ed by heavy writers</span>
<span class="cm">                 */</span>
                <span class="n">dirty_thresh</span> <span class="o">+=</span> <span class="n">dirty_thresh</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>      <span class="cm">/* wheeee... */</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_UNSTABLE_NFS</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_WRITEBACK</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">dirty_thresh</span><span class="p">)</span>
                        	<span class="k">break</span><span class="p">;</span>
                <span class="n">congestion_wait</span><span class="p">(</span><span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The caller might hold locks which can prevent IO completion</span>
<span class="cm">		 * or progress in the filesystem.  So we cannot just sit here</span>
<span class="cm">		 * waiting for IO to complete.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__GFP_FS</span><span class="o">|</span><span class="n">__GFP_IO</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="n">__GFP_FS</span><span class="o">|</span><span class="n">__GFP_IO</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sysctl handler for /proc/sys/vm/dirty_writeback_centisecs</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">dirty_writeback_centisecs_handler</span><span class="p">(</span><span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_dointvec</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="n">bdi_arm_supers_timer</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_BLOCK</span>
<span class="kt">void</span> <span class="nf">laptop_mode_timer_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_FILE_DIRTY</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_UNSTABLE_NFS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We want to write everything out, not just down to the dirty</span>
<span class="cm">	 * threshold</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdi_has_dirty_io</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">))</span>
		<span class="n">bdi_start_writeback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span>
					<span class="n">WB_REASON_LAPTOP_TIMER</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We&#39;ve spun up the disk and we&#39;re in laptop mode: schedule writeback</span>
<span class="cm"> * of all dirty data a few seconds from now.  If the flush is already scheduled</span>
<span class="cm"> * then push it back - the user is still using the disk.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">laptop_io_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">laptop_mode_wb_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">laptop_mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We&#39;re in laptop mode and we&#39;ve just synced. The sync&#39;s writes will have</span>
<span class="cm"> * caused another writeback to be scheduled by laptop_io_completion.</span>
<span class="cm"> * Nothing needs to be written back anymore, so we unschedule the writeback.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">laptop_sync_completion</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi_list</span><span class="p">,</span> <span class="n">bdi_list</span><span class="p">)</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">laptop_mode_wb_timer</span><span class="p">);</span>

	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * If ratelimit_pages is too high then we can get into dirty-data overload</span>
<span class="cm"> * if a large number of processes all perform writes at the same time.</span>
<span class="cm"> * If it is too low then SMP machines will call the (expensive)</span>
<span class="cm"> * get_writeback_state too often.</span>
<span class="cm"> *</span>
<span class="cm"> * Here we set ratelimit_pages to a level which ensures that when all CPUs are</span>
<span class="cm"> * dirtying in parallel, we cannot go more than 3% (1/32) over the dirty memory</span>
<span class="cm"> * thresholds.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">writeback_set_ratelimit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">background_thresh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_thresh</span><span class="p">;</span>
	<span class="n">global_dirty_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">background_thresh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dirty_thresh</span><span class="p">);</span>
	<span class="n">global_dirty_limit</span> <span class="o">=</span> <span class="n">dirty_thresh</span><span class="p">;</span>
	<span class="n">ratelimit_pages</span> <span class="o">=</span> <span class="n">dirty_thresh</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_online_cpus</span><span class="p">()</span> <span class="o">*</span> <span class="mi">32</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ratelimit_pages</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
		<span class="n">ratelimit_pages</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__cpuinit</span>
<span class="nf">ratelimit_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">u</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writeback_set_ratelimit</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">NOTIFY_DONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">notifier_block</span> <span class="n">__cpuinitdata</span> <span class="n">ratelimit_nb</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">notifier_call</span>	<span class="o">=</span> <span class="n">ratelimit_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Called early on to tune the page writeback dirty limits.</span>
<span class="cm"> *</span>
<span class="cm"> * We used to scale dirty pages according to how total memory</span>
<span class="cm"> * related to pages that could be allocated for buffers (by</span>
<span class="cm"> * comparing nr_free_buffer_pages() to vm_total_pages.</span>
<span class="cm"> *</span>
<span class="cm"> * However, that was when we used &quot;dirty_ratio&quot; to scale with</span>
<span class="cm"> * all memory, and we don&#39;t do that any more. &quot;dirty_ratio&quot;</span>
<span class="cm"> * is now applied to total non-HIGHPAGE memory (by subtracting</span>
<span class="cm"> * totalhigh_pages from vm_total_pages), and as such we can&#39;t</span>
<span class="cm"> * get into the old insane situation any more where we had</span>
<span class="cm"> * large amounts of dirty pages compared to a small amount of</span>
<span class="cm"> * non-HIGHMEM memory.</span>
<span class="cm"> *</span>
<span class="cm"> * But we might still want to scale the dirty_ratio by how</span>
<span class="cm"> * much memory the box has..</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">page_writeback_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">shift</span><span class="p">;</span>

	<span class="n">writeback_set_ratelimit</span><span class="p">();</span>
	<span class="n">register_cpu_notifier</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ratelimit_nb</span><span class="p">);</span>

	<span class="n">shift</span> <span class="o">=</span> <span class="n">calc_period_shift</span><span class="p">();</span>
	<span class="n">prop_descriptor_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vm_completions</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * tag_pages_for_writeback - tag pages to be written by write_cache_pages</span>
<span class="cm"> * @mapping: address space structure to write</span>
<span class="cm"> * @start: starting page index</span>
<span class="cm"> * @end: ending page index (inclusive)</span>
<span class="cm"> *</span>
<span class="cm"> * This function scans the page range from @start to @end (inclusive) and tags</span>
<span class="cm"> * all pages that have DIRTY tag set with a special TOWRITE tag. The idea is</span>
<span class="cm"> * that write_cache_pages (or whoever calls this function) will then use</span>
<span class="cm"> * TOWRITE tag to identify pages eligible for writeback.  This mechanism is</span>
<span class="cm"> * used to avoid livelocking of writeback by a process steadily creating new</span>
<span class="cm"> * dirty pages in the file (thus it is important for this function to be quick</span>
<span class="cm"> * so that it can tag pages faster than a dirtying process can create them).</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> * We tag pages in batches of WRITEBACK_TAG_BATCH to reduce tree_lock latency.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tag_pages_for_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			     <span class="n">pgoff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">pgoff_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define WRITEBACK_TAG_BATCH 4096</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tagged</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="n">tagged</span> <span class="o">=</span> <span class="n">radix_tree_range_tag_if_tagged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">WRITEBACK_TAG_BATCH</span><span class="p">,</span>
				<span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">,</span> <span class="n">PAGECACHE_TAG_TOWRITE</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">tagged</span> <span class="o">&gt;</span> <span class="n">WRITEBACK_TAG_BATCH</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="cm">/* We check &#39;start&#39; to handle wrapping when end == ~0UL */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">tagged</span> <span class="o">&gt;=</span> <span class="n">WRITEBACK_TAG_BATCH</span> <span class="o">&amp;&amp;</span> <span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">tag_pages_for_writeback</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * write_cache_pages - walk the list of dirty pages of the given address space and write all of them.</span>
<span class="cm"> * @mapping: address space structure to write</span>
<span class="cm"> * @wbc: subtract the number of written pages from *@wbc-&gt;nr_to_write</span>
<span class="cm"> * @writepage: function called for each page</span>
<span class="cm"> * @data: data passed to writepage function</span>
<span class="cm"> *</span>
<span class="cm"> * If a page is already under I/O, write_cache_pages() skips it, even</span>
<span class="cm"> * if it&#39;s dirty.  This is desirable behaviour for memory-cleaning writeback,</span>
<span class="cm"> * but it is INCORRECT for data-integrity system calls such as fsync().  fsync()</span>
<span class="cm"> * and msync() need to guarantee that all the data which was dirty at the time</span>
<span class="cm"> * the call was made get new I/O started against them.  If wbc-&gt;sync_mode is</span>
<span class="cm"> * WB_SYNC_ALL then we were called for data integrity and we must wait for</span>
<span class="cm"> * existing IO to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * To avoid livelocks (when other process dirties new pages), we first tag</span>
<span class="cm"> * pages which should be written back with TOWRITE tag and only then start</span>
<span class="cm"> * writing them. For data-integrity sync we have to be careful so that we do</span>
<span class="cm"> * not miss some pages (e.g., because some other process has cleared TOWRITE</span>
<span class="cm"> * tag we set). The rule we follow is that TOWRITE tag can be cleared only</span>
<span class="cm"> * by the process clearing the DIRTY tag (and submitting the page for IO).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">write_cache_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span> <span class="n">writepage_t</span> <span class="n">writepage</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">writeback_index</span><span class="p">);</span>
	<span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">end</span><span class="p">;</span>		<span class="cm">/* Inclusive */</span>
	<span class="n">pgoff_t</span> <span class="n">done_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cycled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">range_whole</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writeback_index</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span><span class="p">;</span> <span class="cm">/* prev offset */</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">writeback_index</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cycled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cycled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span> <span class="o">==</span> <span class="n">LLONG_MAX</span><span class="p">)</span>
			<span class="n">range_whole</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cycled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* ignore range_cyclic tests */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">||</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">tagged_writepages</span><span class="p">)</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">PAGECACHE_TAG_TOWRITE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">||</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">tagged_writepages</span><span class="p">)</span>
		<span class="n">tag_pages_for_writeback</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">done_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">pagevec_lookup_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span>
			      <span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span><span class="n">PAGEVEC_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="cm">/*</span>
<span class="cm">			 * At this point, the page may be truncated or</span>
<span class="cm">			 * invalidated (changing page-&gt;mapping to NULL), or</span>
<span class="cm">			 * even swizzled back from swapper_space to tmpfs file</span>
<span class="cm">			 * mapping. However, page-&gt;index will not change</span>
<span class="cm">			 * because we have a reference on the page.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * can&#39;t be range_cyclic (1st pass) because</span>
<span class="cm">				 * end == -1 in that case.</span>
<span class="cm">				 */</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">done_index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

			<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Page truncated or invalidated. We can freely skip it</span>
<span class="cm">			 * then, even for data integrity operations: the page</span>
<span class="cm">			 * has disappeared concurrently, so there could be no</span>
<span class="cm">			 * real expectation of this data interity operation</span>
<span class="cm">			 * even if there is now a new, dirty page at the same</span>
<span class="cm">			 * pagecache address.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">continue_unlock:</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* someone wrote it for us */</span>
				<span class="k">goto</span> <span class="n">continue_unlock</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">!=</span> <span class="n">WB_SYNC_NONE</span><span class="p">)</span>
					<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">else</span>
					<span class="k">goto</span> <span class="n">continue_unlock</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">continue_unlock</span><span class="p">;</span>

			<span class="n">trace_wbc_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">writepage</span><span class="p">)(</span><span class="n">page</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">AOP_WRITEPAGE_ACTIVATE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * done_index is set past this page,</span>
<span class="cm">					 * so media errors will not choke</span>
<span class="cm">					 * background writeout for the entire</span>
<span class="cm">					 * file. This has consequences for</span>
<span class="cm">					 * range_cyclic semantics (ie. it may</span>
<span class="cm">					 * not be suitable for data integrity</span>
<span class="cm">					 * writeout).</span>
<span class="cm">					 */</span>
					<span class="n">done_index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * We stop writing back only if we are not doing</span>
<span class="cm">			 * integrity sync. In case of integrity sync we have to</span>
<span class="cm">			 * keep going until we have written all the pages</span>
<span class="cm">			 * we tagged for writeback prior to entering this loop.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_NONE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cycled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * range_cyclic:</span>
<span class="cm">		 * We hit the last page and there is more work to be done: wrap</span>
<span class="cm">		 * back to the start of the file</span>
<span class="cm">		 */</span>
		<span class="n">cycled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">writeback_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span> <span class="o">||</span> <span class="p">(</span><span class="n">range_whole</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span> <span class="o">=</span> <span class="n">done_index</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">write_cache_pages</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Function used by generic_writepages to call the real writepage</span>
<span class="cm"> * function and set the mapping flags on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span>
		       <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
	<span class="n">mapping_set_error</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * generic_writepages - walk the list of dirty pages of the given address space and writepage() all of them.</span>
<span class="cm"> * @mapping: address space structure to write</span>
<span class="cm"> * @wbc: subtract the number of written pages from *@wbc-&gt;nr_to_write</span>
<span class="cm"> *</span>
<span class="cm"> * This is a library function, which implements the writepages()</span>
<span class="cm"> * address_space_operation.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">generic_writepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="n">plug</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* deal with chardevs and other special file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">writepage</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">write_cache_pages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span> <span class="n">__writepage</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_writepages</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">do_writepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">writepages</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">writepages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">generic_writepages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * write_one_page - write out a single page and optionally wait on I/O</span>
<span class="cm"> * @page: the page to write</span>
<span class="cm"> * @wait: if true, wait on writeout</span>
<span class="cm"> *</span>
<span class="cm"> * The page must be locked by the caller and will be unlocked upon return.</span>
<span class="cm"> *</span>
<span class="cm"> * write_one_page() returns a negative error code if I/O failed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">write_one_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="n">wbc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sync_mode</span> <span class="o">=</span> <span class="n">WB_SYNC_ALL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_to_write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span>
		<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wbc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageError</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">write_one_page</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * For address_spaces which do not use buffers nor write back.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__set_page_dirty_no_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">TestSetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function for set_page_dirty family.</span>
<span class="cm"> * NOTE: This relies on being atomic wrt interrupts.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_page_dirtied</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping_cap_account_dirty</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_FILE_DIRTY</span><span class="p">);</span>
		<span class="n">__inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_DIRTIED</span><span class="p">);</span>
		<span class="n">__inc_bdi_stat</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span> <span class="n">BDI_RECLAIMABLE</span><span class="p">);</span>
		<span class="n">__inc_bdi_stat</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span> <span class="n">BDI_DIRTIED</span><span class="p">);</span>
		<span class="n">task_io_account_write</span><span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span><span class="o">++</span><span class="p">;</span>
		<span class="n">this_cpu_inc</span><span class="p">(</span><span class="n">bdp_ratelimits</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">account_page_dirtied</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function for set_page_writeback family.</span>
<span class="cm"> * NOTE: Unlike account_page_dirtied this does not rely on being atomic</span>
<span class="cm"> * wrt interrupts.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_page_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_WRITEBACK</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">account_page_writeback</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * For address_spaces which do not use buffers.  Just tag the page as dirty in</span>
<span class="cm"> * its radix tree.</span>
<span class="cm"> *</span>
<span class="cm"> * This is also used when a single buffer is being dirtied: we want to set the</span>
<span class="cm"> * page dirty in that case, but not all the buffers.  This is a &quot;bottom-up&quot;</span>
<span class="cm"> * dirtying, whereas __set_page_dirty_buffers() is a &quot;top-down&quot; dirtying.</span>
<span class="cm"> *</span>
<span class="cm"> * Most callers have locked the page, which pins the address_space in memory.</span>
<span class="cm"> * But zap_pte_range() does not lock the page, however in that case the</span>
<span class="cm"> * mapping is pinned by the vma&#39;s -&gt;vm_file reference.</span>
<span class="cm"> *</span>
<span class="cm"> * We take care to handle the case where the page was truncated from the</span>
<span class="cm"> * mapping by re-checking page_mapping() inside tree_lock.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TestSetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="n">mapping2</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mapping2</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Race with truncate? */</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">mapping2</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">);</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
			<span class="n">account_page_dirtied</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
			<span class="n">radix_tree_tag_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span>
				<span class="n">page_index</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* !PageAnon &amp;&amp; !swapper_space */</span>
			<span class="n">__mark_inode_dirty</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">I_DIRTY_PAGES</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__set_page_dirty_nobuffers</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Call this whenever redirtying a page, to de-account the dirty counters</span>
<span class="cm"> * (NR_DIRTIED, BDI_DIRTIED, tsk-&gt;nr_dirtied), so that they match the written</span>
<span class="cm"> * counters (NR_WRITTEN, BDI_WRITTEN) in long term. The mismatches will lead to</span>
<span class="cm"> * systematic errors in balanced_dirty_ratelimit and the dirty pages position</span>
<span class="cm"> * control.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">account_page_redirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="n">mapping_cap_account_dirty</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span><span class="o">--</span><span class="p">;</span>
		<span class="n">dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_DIRTIED</span><span class="p">);</span>
		<span class="n">dec_bdi_stat</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span> <span class="n">BDI_DIRTIED</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">account_page_redirty</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * When a writepage implementation decides that it doesn&#39;t want to write this</span>
<span class="cm"> * page for some reason, it should redirty the locked page via</span>
<span class="cm"> * redirty_page_for_writepage() and it should then unlock the page and return 0</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">redirty_page_for_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">pages_skipped</span><span class="o">++</span><span class="p">;</span>
	<span class="n">account_page_redirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">redirty_page_for_writepage</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Dirty a page.</span>
<span class="cm"> *</span>
<span class="cm"> * For pages with a mapping this should be done under the page lock</span>
<span class="cm"> * for the benefit of asynchronous memory errors who prefer a consistent</span>
<span class="cm"> * dirty state. This rule can be broken in some special cases,</span>
<span class="cm"> * but should be better not to.</span>
<span class="cm"> *</span>
<span class="cm"> * If the mapping doesn&#39;t provide a set_page_dirty a_op, then</span>
<span class="cm"> * just fall through and assume that it wants buffer_heads.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">spd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">set_page_dirty</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * readahead/lru_deactivate_page could remain</span>
<span class="cm">		 * PG_readahead/PG_reclaim due to race with end_page_writeback</span>
<span class="cm">		 * About readahead, if the page is written, the flags would be</span>
<span class="cm">		 * reset. So no problem.</span>
<span class="cm">		 * About lru_deactivate_page, if the page is redirty, the flag</span>
<span class="cm">		 * will be reset. So no problem. but if the page is used by readahead</span>
<span class="cm">		 * it will confuse readahead and make it restart the size rampup</span>
<span class="cm">		 * process. But it&#39;s a trivial problem.</span>
<span class="cm">		 */</span>
		<span class="n">ClearPageReclaim</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_BLOCK</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spd</span><span class="p">)</span>
			<span class="n">spd</span> <span class="o">=</span> <span class="n">__set_page_dirty_buffers</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">spd</span><span class="p">)(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TestSetPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_page_dirty</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * set_page_dirty() is racy if the caller has no reference against</span>
<span class="cm"> * page-&gt;mapping-&gt;host, and if the page is unlocked.  This is because another</span>
<span class="cm"> * CPU could truncate the page off the mapping and then free the mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * Usually, the page _is_ locked, or the caller is a user-space process which</span>
<span class="cm"> * holds a reference on the inode by having an open file.</span>
<span class="cm"> *</span>
<span class="cm"> * In other cases, the page should be locked before running set_page_dirty().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">set_page_dirty_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_page_dirty_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Clear a page&#39;s dirty flag, while caring for dirty memory accounting.</span>
<span class="cm"> * Returns true if the page was previously dirty.</span>
<span class="cm"> *</span>
<span class="cm"> * This is for preparing to put the page under writeout.  We leave the page</span>
<span class="cm"> * tagged as dirty in the radix tree so that a concurrent write-for-sync</span>
<span class="cm"> * can discover it via a PAGECACHE_TAG_DIRTY walk.  The -&gt;writepage</span>
<span class="cm"> * implementation will run either set_page_writeback() or set_page_dirty(),</span>
<span class="cm"> * at which stage we bring the page&#39;s dirty flag and radix-tree dirty tag</span>
<span class="cm"> * back into sync.</span>
<span class="cm"> *</span>
<span class="cm"> * This incoherency between the page&#39;s dirty flag and radix-tree tag is</span>
<span class="cm"> * unfortunate, but it only exists while the page is locked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">clear_page_dirty_for_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span> <span class="o">&amp;&amp;</span> <span class="n">mapping_cap_account_dirty</span><span class="p">(</span><span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Yes, Virginia, this is indeed insane.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We use this sequence to make sure that</span>
<span class="cm">		 *  (a) we account for dirty stats properly</span>
<span class="cm">		 *  (b) we tell the low-level filesystem to</span>
<span class="cm">		 *      mark the whole page dirty if it was</span>
<span class="cm">		 *      dirty in a pagetable. Only to then</span>
<span class="cm">		 *  (c) clean the page again and return 1 to</span>
<span class="cm">		 *      cause the writeback.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This way we avoid all nasty races with the</span>
<span class="cm">		 * dirty bit in multiple places and clearing</span>
<span class="cm">		 * them concurrently from different threads.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note! Normally the &quot;set_page_dirty(page)&quot;</span>
<span class="cm">		 * has no effect on the actual dirty bit - since</span>
<span class="cm">		 * that will already usually be set. But we</span>
<span class="cm">		 * need the side effects, and it can help us</span>
<span class="cm">		 * avoid races.</span>
<span class="cm">		 *</span>
<span class="cm">		 * We basically use the page &quot;master dirty bit&quot;</span>
<span class="cm">		 * as a serialization point for all the different</span>
<span class="cm">		 * threads doing their things.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_mkclean</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We carefully synchronise fault handlers against</span>
<span class="cm">		 * installing a dirty pte and marking the page dirty</span>
<span class="cm">		 * at this point. We do this by having them hold the</span>
<span class="cm">		 * page lock at some point after installing their</span>
<span class="cm">		 * pte, but before marking the page dirty.</span>
<span class="cm">		 * Pages are always locked coming in here, so we get</span>
<span class="cm">		 * the desired exclusion. See mm/memory.c:do_wp_page()</span>
<span class="cm">		 * for more comments.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TestClearPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_FILE_DIRTY</span><span class="p">);</span>
			<span class="n">dec_bdi_stat</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">,</span>
					<span class="n">BDI_RECLAIMABLE</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">TestClearPageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">clear_page_dirty_for_io</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">test_clear_page_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">TestClearPageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">radix_tree_tag_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span>
						<span class="n">page_index</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
						<span class="n">PAGECACHE_TAG_WRITEBACK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bdi_cap_account_writeback</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">__dec_bdi_stat</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_WRITEBACK</span><span class="p">);</span>
				<span class="n">__bdi_writeout_inc</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">TestClearPageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dec_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_WRITEBACK</span><span class="p">);</span>
		<span class="n">inc_zone_page_state</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">NR_WRITTEN</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_set_page_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page_mapping</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">TestSetPageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">radix_tree_tag_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span>
						<span class="n">page_index</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
						<span class="n">PAGECACHE_TAG_WRITEBACK</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bdi_cap_account_writeback</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span>
				<span class="n">__inc_bdi_stat</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_WRITEBACK</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">radix_tree_tag_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span>
						<span class="n">page_index</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
						<span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">);</span>
		<span class="n">radix_tree_tag_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span>
				     <span class="n">page_index</span><span class="p">(</span><span class="n">page</span><span class="p">),</span>
				     <span class="n">PAGECACHE_TAG_TOWRITE</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">TestSetPageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">account_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">test_set_page_writeback</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return true if any of the pages in the mapping are marked with the</span>
<span class="cm"> * passed tag.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mapping_tagged</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">radix_tree_tagged</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">page_tree</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">mapping_tagged</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
