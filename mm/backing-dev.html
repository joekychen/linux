<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › backing-dev.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>backing-dev.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;trace/events/writeback.h&gt;</span>

<span class="k">static</span> <span class="n">atomic_long_t</span> <span class="n">bdi_seq</span> <span class="o">=</span> <span class="n">ATOMIC_LONG_INIT</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="n">default_backing_dev_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;default&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ra_pages</span>	<span class="o">=</span> <span class="n">VM_MAX_READAHEAD</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">/</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">state</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">capabilities</span>	<span class="o">=</span> <span class="n">BDI_CAP_MAP_COPY</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">default_backing_dev_info</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="n">noop_backing_dev_info</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;noop&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">capabilities</span>	<span class="o">=</span> <span class="n">BDI_CAP_NO_ACCT_AND_WRITEBACK</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">noop_backing_dev_info</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">bdi_class</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * bdi_lock protects updates to bdi_list and bdi_pending_list, as well as</span>
<span class="cm"> * reader side protection for bdi_pending_list. bdi_list has RCU reader side</span>
<span class="cm"> * locking.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">bdi_lock</span><span class="p">);</span>
<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">bdi_list</span><span class="p">);</span>
<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">bdi_pending_list</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">sync_supers_tsk</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">timer_list</span> <span class="n">sync_supers_timer</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">bdi_sync_supers</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sync_supers_timer_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">bdi_lock_two</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wb1</span> <span class="o">&lt;</span> <span class="n">wb2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb1</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb2</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb2</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb1</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">bdi_debug_root</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_debug_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bdi_debug_root</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="s">&quot;bdi&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bdi_debug_stats_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">background_thresh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dirty_thresh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bdi_thresh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_dirty</span><span class="p">,</span> <span class="n">nr_io</span><span class="p">,</span> <span class="n">nr_more_io</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">nr_dirty</span> <span class="o">=</span> <span class="n">nr_io</span> <span class="o">=</span> <span class="n">nr_more_io</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_dirty</span><span class="p">,</span> <span class="n">i_wb_list</span><span class="p">)</span>
		<span class="n">nr_dirty</span><span class="o">++</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_io</span><span class="p">,</span> <span class="n">i_wb_list</span><span class="p">)</span>
		<span class="n">nr_io</span><span class="o">++</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_more_io</span><span class="p">,</span> <span class="n">i_wb_list</span><span class="p">)</span>
		<span class="n">nr_more_io</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="n">global_dirty_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">background_thresh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dirty_thresh</span><span class="p">);</span>
	<span class="n">bdi_thresh</span> <span class="o">=</span> <span class="n">bdi_dirty_limit</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">dirty_thresh</span><span class="p">);</span>

<span class="cp">#define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
		   <span class="s">&quot;BdiWriteback:       %10lu kB</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;BdiReclaimable:     %10lu kB</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;BdiDirtyThresh:     %10lu kB</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;DirtyThresh:        %10lu kB</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;BackgroundThresh:   %10lu kB</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;BdiDirtied:         %10lu kB</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;BdiWritten:         %10lu kB</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;BdiWriteBandwidth:  %10lu kBps</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;b_dirty:            %10lu</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;b_io:               %10lu</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;b_more_io:          %10lu</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;bdi_list:           %10u</span><span class="se">\n</span><span class="s">&quot;</span>
		   <span class="s">&quot;state:              %10lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">K</span><span class="p">(</span><span class="n">bdi_stat</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_WRITEBACK</span><span class="p">)),</span>
		   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">K</span><span class="p">(</span><span class="n">bdi_stat</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_RECLAIMABLE</span><span class="p">)),</span>
		   <span class="n">K</span><span class="p">(</span><span class="n">bdi_thresh</span><span class="p">),</span>
		   <span class="n">K</span><span class="p">(</span><span class="n">dirty_thresh</span><span class="p">),</span>
		   <span class="n">K</span><span class="p">(</span><span class="n">background_thresh</span><span class="p">),</span>
		   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">K</span><span class="p">(</span><span class="n">bdi_stat</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_DIRTIED</span><span class="p">)),</span>
		   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">K</span><span class="p">(</span><span class="n">bdi_stat</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_WRITTEN</span><span class="p">)),</span>
		   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">K</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">write_bandwidth</span><span class="p">),</span>
		   <span class="n">nr_dirty</span><span class="p">,</span>
		   <span class="n">nr_io</span><span class="p">,</span>
		   <span class="n">nr_more_io</span><span class="p">,</span>
		   <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bdi_list</span><span class="p">),</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="cp">#undef K</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bdi_debug_stats_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">bdi_debug_stats_show</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">bdi_debug_stats_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">bdi_debug_stats_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_debug_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">debug_dir</span> <span class="o">=</span> <span class="n">debugfs_create_dir</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bdi_debug_root</span><span class="p">);</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">debug_stats</span> <span class="o">=</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;stats&quot;</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">debug_dir</span><span class="p">,</span>
					       <span class="n">bdi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi_debug_stats_fops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_debug_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">debug_stats</span><span class="p">);</span>
	<span class="n">debugfs_remove</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">debug_dir</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bdi_debug_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bdi_debug_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
				      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bdi_debug_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">read_ahead_kb_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">read_ahead_kb</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">read_ahead_kb</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">ra_pages</span> <span class="o">=</span> <span class="n">read_ahead_kb</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define K(pages) ((pages) &lt;&lt; (PAGE_SHIFT - 10))</span>

<span class="cp">#define BDI_SHOW(name, expr)						\</span>
<span class="cp">static ssize_t name##_show(struct device *dev,				\</span>
<span class="cp">			   struct device_attribute *attr, char *page)	\</span>
<span class="cp">{									\</span>
<span class="cp">	struct backing_dev_info *bdi = dev_get_drvdata(dev);		\</span>
<span class="cp">									\</span>
<span class="cp">	return snprintf(page, PAGE_SIZE-1, &quot;%lld\n&quot;, (long long)expr);	\</span>
<span class="cp">}</span>

<span class="n">BDI_SHOW</span><span class="p">(</span><span class="n">read_ahead_kb</span><span class="p">,</span> <span class="n">K</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">ra_pages</span><span class="p">))</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">min_ratio_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ratio</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ratio</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bdi_set_min_ratio</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">ratio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">BDI_SHOW</span><span class="p">(</span><span class="n">min_ratio</span><span class="p">,</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">min_ratio</span><span class="p">)</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">max_ratio_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ratio</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">ratio</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span> <span class="o">||</span> <span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bdi_set_max_ratio</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">ratio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">BDI_SHOW</span><span class="p">(</span><span class="n">max_ratio</span><span class="p">,</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">max_ratio</span><span class="p">)</span>

<span class="cp">#define __ATTR_RW(attr) __ATTR(attr, 0644, attr##_show, attr##_store)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="n">bdi_dev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR_RW</span><span class="p">(</span><span class="n">read_ahead_kb</span><span class="p">),</span>
	<span class="n">__ATTR_RW</span><span class="p">(</span><span class="n">min_ratio</span><span class="p">),</span>
	<span class="n">__ATTR_RW</span><span class="p">(</span><span class="n">max_ratio</span><span class="p">),</span>
	<span class="n">__ATTR_NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="nf">bdi_class_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bdi_class</span> <span class="o">=</span> <span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="s">&quot;bdi&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">bdi_class</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">bdi_class</span><span class="p">);</span>

	<span class="n">bdi_class</span><span class="o">-&gt;</span><span class="n">dev_attrs</span> <span class="o">=</span> <span class="n">bdi_dev_attrs</span><span class="p">;</span>
	<span class="n">bdi_debug_init</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">postcore_initcall</span><span class="p">(</span><span class="n">bdi_class_init</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">default_bdi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sync_supers_tsk</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">bdi_sync_supers</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;sync_supers&quot;</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sync_supers_tsk</span><span class="p">));</span>

	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_supers_timer</span><span class="p">,</span> <span class="n">sync_supers_timer_fn</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bdi_arm_supers_timer</span><span class="p">();</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">bdi_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">default_backing_dev_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">bdi_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">default_backing_dev_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;default&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">bdi_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">noop_backing_dev_info</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">default_bdi_init</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bdi_has_dirty_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">wb_has_dirty_io</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * kupdated() used to do this. We cannot do it from the bdi_forker_thread()</span>
<span class="cm"> * or we risk deadlocking on -&gt;s_umount. The longer term solution would be</span>
<span class="cm"> * to implement sync_supers_bdi() or similar and simply do it from the</span>
<span class="cm"> * bdi writeback thread individually.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bdi_sync_supers</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do this periodically, like kupdated() did before.</span>
<span class="cm">		 */</span>
		<span class="n">sync_supers</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bdi_arm_supers_timer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirty_writeback_interval</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">dirty_writeback_interval</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sync_supers_timer</span><span class="p">,</span> <span class="n">round_jiffies_up</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sync_supers_timer_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">sync_supers_tsk</span><span class="p">);</span>
	<span class="n">bdi_arm_supers_timer</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wakeup_timer_fn</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_writeback_wake_thread</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * When bdi tasks are inactive for long time, they are killed.</span>
<span class="cm">		 * In this case we have to wake-up the forker thread which</span>
<span class="cm">		 * should create and run the bdi thread.</span>
<span class="cm">		 */</span>
		<span class="n">trace_writeback_wake_forker_thread</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">default_backing_dev_info</span><span class="p">.</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is used when the first inode for this bdi is marked dirty. It</span>
<span class="cm"> * wakes-up the corresponding bdi thread which should then take care of the</span>
<span class="cm"> * periodic background write-out of dirty inodes. Since the write-out would</span>
<span class="cm"> * starts only &#39;dirty_writeback_interval&#39; centisecs from now anyway, we just</span>
<span class="cm"> * set up a timer which wakes the bdi thread up later.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, we wouldn&#39;t bother setting up the timer, but this function is on the</span>
<span class="cm"> * fast-path (used by &#39;__mark_inode_dirty()&#39;), so we save few context switches</span>
<span class="cm"> * by delaying the wake-up.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bdi_wakeup_thread_delayed</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">dirty_writeback_interval</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">wakeup_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the longest interval (jiffies) bdi threads are allowed to be</span>
<span class="cm"> * inactive.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">bdi_longest_inactive</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interval</span><span class="p">;</span>

	<span class="n">interval</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">dirty_writeback_interval</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="mi">5UL</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">,</span> <span class="n">interval</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clear pending bit and wakeup anybody waiting for flusher thread creation or</span>
<span class="cm"> * shutdown</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_clear_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">BDI_pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">BDI_pending</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bdi_forker_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">me</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_SWAPWRITE</span><span class="p">;</span>
	<span class="n">set_freezable</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Our parent may run at a different priority, just set us to normal</span>
<span class="cm">	 */</span>
	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">;</span>
		<span class="k">enum</span> <span class="p">{</span>
			<span class="n">NO_ACTION</span><span class="p">,</span>   <span class="cm">/* Nothing to do */</span>
			<span class="n">FORK_THREAD</span><span class="p">,</span> <span class="cm">/* Fork bdi thread */</span>
			<span class="n">KILL_THREAD</span><span class="p">,</span> <span class="cm">/* Kill inactive bdi thread */</span>
		<span class="p">}</span> <span class="n">action</span> <span class="o">=</span> <span class="n">NO_ACTION</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Temporary measure, we want to make sure we don&#39;t see</span>
<span class="cm">		 * dirty data on the default backing_dev_info</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wb_has_dirty_io</span><span class="p">(</span><span class="n">me</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">wakeup_timer</span><span class="p">);</span>
			<span class="n">wb_do_writeback</span><span class="p">(</span><span class="n">me</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * In the following loop we are going to check whether we have</span>
<span class="cm">		 * some work to do without any synchronization with tasks</span>
<span class="cm">		 * waking us up to do work for them. Set the task state here</span>
<span class="cm">		 * so that we don&#39;t miss wakeups after verifying conditions.</span>
<span class="cm">		 */</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi_list</span><span class="p">,</span> <span class="n">bdi_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bool</span> <span class="n">have_dirty_io</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdi_cap_writeback_dirty</span><span class="p">(</span><span class="n">bdi</span><span class="p">)</span> <span class="o">||</span>
			     <span class="n">bdi_cap_flush_forker</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BDI_registered</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">),</span>
			     <span class="s">&quot;bdi %p/%s is not registered!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bdi</span><span class="p">,</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

			<span class="n">have_dirty_io</span> <span class="o">=</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">)</span> <span class="o">||</span>
					<span class="n">wb_has_dirty_io</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the bdi has work to do, but the thread does not</span>
<span class="cm">			 * exist - create it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span> <span class="o">&amp;&amp;</span> <span class="n">have_dirty_io</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Set the pending bit - if someone will try to</span>
<span class="cm">				 * unregister this bdi - it&#39;ll wait on this bit.</span>
<span class="cm">				 */</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">BDI_pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
				<span class="n">action</span> <span class="o">=</span> <span class="n">FORK_THREAD</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * If there is no work to do and the bdi thread was</span>
<span class="cm">			 * inactive long enough - kill it. The wb_lock is taken</span>
<span class="cm">			 * to make sure no-one adds more work to this bdi and</span>
<span class="cm">			 * wakes the bdi thread up.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">have_dirty_io</span> <span class="o">&amp;&amp;</span>
			    <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">last_active</span> <span class="o">+</span>
						<span class="n">bdi_longest_inactive</span><span class="p">()))</span> <span class="p">{</span>
				<span class="n">task</span> <span class="o">=</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span><span class="p">;</span>
				<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">BDI_pending</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
				<span class="n">action</span> <span class="o">=</span> <span class="n">KILL_THREAD</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi_lock</span><span class="p">);</span>

		<span class="cm">/* Keep working if default bdi still has things to do */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">me</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">))</span>
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">FORK_THREAD</span>:
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
			<span class="n">task</span> <span class="o">=</span> <span class="n">kthread_create</span><span class="p">(</span><span class="n">bdi_writeback_thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">,</span>
					      <span class="s">&quot;flush-%s&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">task</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If thread creation fails, force writeout of</span>
<span class="cm">				 * the bdi from the thread. Hopefully 1024 is</span>
<span class="cm">				 * large enough for efficient IO.</span>
<span class="cm">				 */</span>
				<span class="n">writeback_inodes_wb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span>
						    <span class="n">WB_REASON_FORKER_THREAD</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The spinlock makes sure we do not lose</span>
<span class="cm">				 * wake-ups when racing with &#39;bdi_queue_work()&#39;.</span>
<span class="cm">				 * And as soon as the bdi thread is visible, we</span>
<span class="cm">				 * can start it.</span>
<span class="cm">				 */</span>
				<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
				<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">task</span><span class="p">;</span>
				<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
				<span class="n">wake_up_process</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">bdi_clear_pending</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">KILL_THREAD</span>:
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
			<span class="n">kthread_stop</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
			<span class="n">bdi_clear_pending</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">NO_ACTION</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wb_has_dirty_io</span><span class="p">(</span><span class="n">me</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">dirty_writeback_interval</span><span class="p">)</span>
				<span class="cm">/*</span>
<span class="cm">				 * There are no dirty data. The only thing we</span>
<span class="cm">				 * should now care about is checking for</span>
<span class="cm">				 * inactive bdi threads and killing them. Thus,</span>
<span class="cm">				 * let&#39;s sleep for longer time, save energy and</span>
<span class="cm">				 * be friendly for battery-driven devices.</span>
<span class="cm">				 */</span>
				<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">bdi_longest_inactive</span><span class="p">());</span>
			<span class="k">else</span>
				<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">dirty_writeback_interval</span> <span class="o">*</span> <span class="mi">10</span><span class="p">));</span>
			<span class="n">try_to_freeze</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove bdi from bdi_list, and ensure that it is no longer visible</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_remove_from_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi_lock</span><span class="p">);</span>
	<span class="n">list_del_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bdi_list</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi_lock</span><span class="p">);</span>

	<span class="n">synchronize_rcu_expedited</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">bdi_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>	<span class="cm">/* The driver needs to use separate queues per device */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">device_create_vargs</span><span class="p">(</span><span class="n">bdi_class</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">bdi</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Just start the forker thread for our default backing_dev_info,</span>
<span class="cm">	 * and add other bdi&#39;s to the list. They will get a thread created</span>
<span class="cm">	 * on-demand when they need it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdi_cap_flush_forker</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">;</span>

		<span class="n">wb</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">bdi_forker_thread</span><span class="p">,</span> <span class="n">wb</span><span class="p">,</span> <span class="s">&quot;bdi-%s&quot;</span><span class="p">,</span>
						<span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bdi_debug_register</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">BDI_registered</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi_lock</span><span class="p">);</span>
	<span class="n">list_add_tail_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bdi_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi_list</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi_lock</span><span class="p">);</span>

	<span class="n">trace_writeback_bdi_register</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bdi_register</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bdi_register_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bdi_register</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;%u:%u&quot;</span><span class="p">,</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bdi_register_dev</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Remove bdi from the global list and shutdown any threads we have running</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_wb_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdi_cap_writeback_dirty</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure nobody finds us on the bdi_list anymore</span>
<span class="cm">	 */</span>
	<span class="n">bdi_remove_from_list</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If setup is pending, wait for that to complete first</span>
<span class="cm">	 */</span>
	<span class="n">wait_on_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">BDI_pending</span><span class="p">,</span> <span class="n">bdi_sched_wait</span><span class="p">,</span>
			<span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finally, kill the kernel thread. We don&#39;t need to be RCU</span>
<span class="cm">	 * safe anymore, since the bdi is gone from visibility.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
	<span class="n">task</span> <span class="o">=</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span><span class="p">;</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">)</span>
		<span class="n">kthread_stop</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This bdi is going away now, make sure that no super_blocks point to it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_prune_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">super_blocks</span><span class="p">,</span> <span class="n">s_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span> <span class="o">==</span> <span class="n">bdi</span><span class="p">)</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_backing_dev_info</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bdi_unregister</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bdi_set_min_ratio</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">trace_writeback_bdi_unregister</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
		<span class="n">bdi_prune_sb</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
		<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">wakeup_timer</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdi_cap_flush_forker</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span>
			<span class="n">bdi_wb_shutdown</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
		<span class="n">bdi_debug_unregister</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>

		<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
		<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>

		<span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bdi_unregister</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_wb_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wb</span><span class="p">));</span>

	<span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">bdi</span><span class="p">;</span>
	<span class="n">wb</span><span class="o">-&gt;</span><span class="n">last_old_flush</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_dirty</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_io</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_more_io</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">setup_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">wakeup_timer</span><span class="p">,</span> <span class="n">wakeup_timer_fn</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bdi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initial write bandwidth: 100 MB/s</span>
<span class="cm"> */</span>
<span class="cp">#define INIT_BW		(100 &lt;&lt; (20 - PAGE_SHIFT))</span>

<span class="kt">int</span> <span class="nf">bdi_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">min_ratio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">max_ratio</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">max_prop_frac</span> <span class="o">=</span> <span class="n">PROP_FRAC_BASE</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bdi_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>

	<span class="n">bdi_wb_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">,</span> <span class="n">bdi</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_BDI_STAT_ITEMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">percpu_counter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bdi_stat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirty_exceeded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bw_time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">written_stamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">balanced_dirty_ratelimit</span> <span class="o">=</span> <span class="n">INIT_BW</span><span class="p">;</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">dirty_ratelimit</span> <span class="o">=</span> <span class="n">INIT_BW</span><span class="p">;</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">write_bandwidth</span> <span class="o">=</span> <span class="n">INIT_BW</span><span class="p">;</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">avg_write_bandwidth</span> <span class="o">=</span> <span class="n">INIT_BW</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">prop_local_init_percpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">completions</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">err:</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
			<span class="n">percpu_counter_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bdi_stat</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bdi_init</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">bdi_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Splice our entries to the default_backing_dev_info, if this</span>
<span class="cm">	 * bdi disappears</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdi_has_dirty_io</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_backing_dev_info</span><span class="p">.</span><span class="n">wb</span><span class="p">;</span>

		<span class="n">bdi_lock_two</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">,</span> <span class="n">dst</span><span class="p">);</span>
		<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">b_dirty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">b_dirty</span><span class="p">);</span>
		<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">b_io</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">b_io</span><span class="p">);</span>
		<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">b_more_io</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">b_more_io</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bdi_unregister</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If bdi_unregister() had already been called earlier, the</span>
<span class="cm">	 * wakeup_timer could still be armed because bdi_prune_sb()</span>
<span class="cm">	 * can race with the bdi_wakeup_thread_delayed() calls from</span>
<span class="cm">	 * __mark_inode_dirty().</span>
<span class="cm">	 */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">wakeup_timer</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_BDI_STAT_ITEMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">percpu_counter_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">bdi_stat</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">prop_local_destroy_percpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">completions</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bdi_destroy</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * For use from filesystems to quickly init and register a bdi associated</span>
<span class="cm"> * with dirty writeback</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bdi_setup_and_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">bdi</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">=</span> <span class="n">cap</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">bdi_init</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;%.28s%s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s">&quot;-%d&quot;</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">bdi_register</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">atomic_long_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi_seq</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bdi_destroy</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bdi_setup_and_register</span><span class="p">);</span>

<span class="k">static</span> <span class="n">wait_queue_head_t</span> <span class="n">congestion_wqh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">__WAIT_QUEUE_HEAD_INITIALIZER</span><span class="p">(</span><span class="n">congestion_wqh</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
		<span class="n">__WAIT_QUEUE_HEAD_INITIALIZER</span><span class="p">(</span><span class="n">congestion_wqh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="p">};</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">nr_bdi_congested</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">clear_bdi_congested</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">bdi_state</span> <span class="n">bit</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">congestion_wqh</span><span class="p">[</span><span class="n">sync</span><span class="p">];</span>

	<span class="n">bit</span> <span class="o">=</span> <span class="n">sync</span> <span class="o">?</span> <span class="n">BDI_sync_congested</span> <span class="o">:</span> <span class="n">BDI_async_congested</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_bdi_congested</span><span class="p">[</span><span class="n">sync</span><span class="p">]);</span>
	<span class="n">smp_mb__after_clear_bit</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="n">wqh</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="n">wqh</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">clear_bdi_congested</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">set_bdi_congested</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">bdi_state</span> <span class="n">bit</span><span class="p">;</span>

	<span class="n">bit</span> <span class="o">=</span> <span class="n">sync</span> <span class="o">?</span> <span class="n">BDI_sync_congested</span> <span class="o">:</span> <span class="n">BDI_async_congested</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_bdi_congested</span><span class="p">[</span><span class="n">sync</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">set_bdi_congested</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * congestion_wait - wait for a backing_dev to become uncongested</span>
<span class="cm"> * @sync: SYNC or ASYNC IO</span>
<span class="cm"> * @timeout: timeout in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * Waits for up to @timeout jiffies for a backing_dev (any backing_dev) to exit</span>
<span class="cm"> * write congestion.  If no backing_devs are congested then just wait for the</span>
<span class="cm"> * next write to be completed.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">congestion_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">congestion_wqh</span><span class="p">[</span><span class="n">sync</span><span class="p">];</span>

	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">io_schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">trace_writeback_congestion_wait</span><span class="p">(</span><span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">timeout</span><span class="p">),</span>
					<span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">start</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">congestion_wait</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * wait_iff_congested - Conditionally wait for a backing_dev to become uncongested or a zone to complete writes</span>
<span class="cm"> * @zone: A zone to check if it is heavily congested</span>
<span class="cm"> * @sync: SYNC or ASYNC IO</span>
<span class="cm"> * @timeout: timeout in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * In the event of a congested backing_dev (any backing_dev) and the given</span>
<span class="cm"> * @zone has experienced recent congestion, this waits for up to @timeout</span>
<span class="cm"> * jiffies for either a BDI to exit congestion of the given @sync queue</span>
<span class="cm"> * or a write to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * In the absence of zone congestion, cond_resched() is called to yield</span>
<span class="cm"> * the processor if necessary but otherwise does not sleep.</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is 0 if the sleep is for the full timeout. Otherwise,</span>
<span class="cm"> * it is the number of jiffies that were still remaining when the function</span>
<span class="cm"> * returned. return_value == timeout implies the function did not sleep.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">wait_iff_congested</span><span class="p">(</span><span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">congestion_wqh</span><span class="p">[</span><span class="n">sync</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is no congestion, or heavy congestion is not being</span>
<span class="cm">	 * encountered in the current zone, yield if necessary instead</span>
<span class="cm">	 * of sleeping on the congestion queue</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr_bdi_congested</span><span class="p">[</span><span class="n">sync</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
			<span class="o">!</span><span class="n">zone_is_reclaim_congested</span><span class="p">(</span><span class="n">zone</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="cm">/* In case we scheduled, work out time remaining */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">-</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Sleep until uncongested or a write happens */</span>
	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">io_schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">trace_writeback_wait_iff_congested</span><span class="p">(</span><span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">timeout</span><span class="p">),</span>
					<span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="n">jiffies</span> <span class="o">-</span> <span class="n">start</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">wait_iff_congested</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
