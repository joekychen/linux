<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › hugetlb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>hugetlb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Generic hugetlb support.</span>
<span class="cm"> * (C) William Irwin, April 2004</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/sysctl.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/mmu_notifier.h&gt;</span>
<span class="cp">#include &lt;linux/nodemask.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/mempolicy.h&gt;</span>
<span class="cp">#include &lt;linux/cpuset.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/sysfs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/rmap.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/swapops.h&gt;</span>

<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/pgtable.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &lt;linux/hugetlb.h&gt;</span>
<span class="cp">#include &lt;linux/node.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hugetlb_zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hugetlb_infinity</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
<span class="k">static</span> <span class="n">gfp_t</span> <span class="n">htlb_alloc_mask</span> <span class="o">=</span> <span class="n">GFP_HIGHUSER</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hugepages_treat_as_movable</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">max_hstate</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">default_hstate_idx</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">hstate</span> <span class="n">hstates</span><span class="p">[</span><span class="n">HUGE_MAX_HSTATE</span><span class="p">];</span>

<span class="n">__initdata</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">huge_boot_pages</span><span class="p">);</span>

<span class="cm">/* for command line parsing */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span> <span class="n">__initdata</span> <span class="n">parsed_hstate</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">default_hstate_max_huge_pages</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__initdata</span> <span class="n">default_hstate_size</span><span class="p">;</span>

<span class="cp">#define for_each_hstate(h) \</span>
<span class="cp">	for ((h) = hstates; (h) &lt; &amp;hstates[max_hstate]; (h)++)</span>

<span class="cm">/*</span>
<span class="cm"> * Protects updates to hugepage_freelists, nr_huge_pages, and free_huge_pages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">hugetlb_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">unlock_or_release_subpool</span><span class="p">(</span><span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="n">spool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">free</span> <span class="o">=</span> <span class="p">(</span><span class="n">spool</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">spool</span><span class="o">-&gt;</span><span class="n">used_hpages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/* If no pages are used, and no other handles to the subpool</span>
<span class="cm">	 * remain, free the subpool the subpool remain */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">spool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="nf">hugepage_new_subpool</span><span class="p">(</span><span class="kt">long</span> <span class="n">nr_blocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="n">spool</span><span class="p">;</span>

	<span class="n">spool</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">spool</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spool</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spool</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spool</span><span class="o">-&gt;</span><span class="n">max_hpages</span> <span class="o">=</span> <span class="n">nr_blocks</span><span class="p">;</span>
	<span class="n">spool</span><span class="o">-&gt;</span><span class="n">used_hpages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">spool</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">hugepage_put_subpool</span><span class="p">(</span><span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="n">spool</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">spool</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">spool</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
	<span class="n">unlock_or_release_subpool</span><span class="p">(</span><span class="n">spool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hugepage_subpool_get_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="n">spool</span><span class="p">,</span>
				      <span class="kt">long</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spool</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">spool</span><span class="o">-&gt;</span><span class="n">used_hpages</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">spool</span><span class="o">-&gt;</span><span class="n">max_hpages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spool</span><span class="o">-&gt;</span><span class="n">used_hpages</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hugepage_subpool_put_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="n">spool</span><span class="p">,</span>
				       <span class="kt">long</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spool</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">spool</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spool</span><span class="o">-&gt;</span><span class="n">used_hpages</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="cm">/* If hugetlbfs_put_super couldn&#39;t free spool due to</span>
<span class="cm">	* an outstanding quota reference, free it now. */</span>
	<span class="n">unlock_or_release_subpool</span><span class="p">(</span><span class="n">spool</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="nf">subpool_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">HUGETLBFS_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">spool</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="nf">subpool_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">subpool_inode</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Region tracking -- allows tracking of reservations and instantiated pages</span>
<span class="cm"> *                    across the pages in a mapping.</span>
<span class="cm"> *</span>
<span class="cm"> * The region data structures are protected by a combination of the mmap_sem</span>
<span class="cm"> * and the hugetlb_instantion_mutex.  To access or modify a region the caller</span>
<span class="cm"> * must either hold the mmap_sem for write, or the mmap_sem for read and</span>
<span class="cm"> * the hugetlb_instantiation mutex:</span>
<span class="cm"> *</span>
<span class="cm"> *	down_write(&amp;mm-&gt;mmap_sem);</span>
<span class="cm"> * or</span>
<span class="cm"> *	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="cm"> *	mutex_lock(&amp;hugetlb_instantiation_mutex);</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">file_region</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">from</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">to</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">region_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">long</span> <span class="n">f</span><span class="p">,</span> <span class="kt">long</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_region</span> <span class="o">*</span><span class="n">rg</span><span class="p">,</span> <span class="o">*</span><span class="n">nrg</span><span class="p">,</span> <span class="o">*</span><span class="n">trg</span><span class="p">;</span>

	<span class="cm">/* Locate the region we are either in or before. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;=</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Round our left edge to the current segment if it encloses us. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&gt;</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">;</span>

	<span class="cm">/* Check for and consume any regions we now overlap with. */</span>
	<span class="n">nrg</span> <span class="o">=</span> <span class="n">rg</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">trg</span><span class="p">,</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* If this area reaches higher then extend our area to</span>
<span class="cm">		 * include it completely.  If this is not the first area</span>
<span class="cm">		 * which we intend to reuse, free it. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rg</span> <span class="o">!=</span> <span class="n">nrg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">nrg</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
	<span class="n">nrg</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">region_chg</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">long</span> <span class="n">f</span><span class="p">,</span> <span class="kt">long</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_region</span> <span class="o">*</span><span class="n">rg</span><span class="p">,</span> <span class="o">*</span><span class="n">nrg</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">chg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Locate the region we are before or in. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;=</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* If we are below the current region then a new region is required.</span>
<span class="cm">	 * Subtle, allocate a new region at the position but make it zero</span>
<span class="cm">	 * size such that we can guarantee to record the reservation. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">head</span> <span class="o">||</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nrg</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">nrg</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nrg</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">nrg</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
		<span class="n">nrg</span><span class="o">-&gt;</span><span class="n">to</span>   <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nrg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nrg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">t</span> <span class="o">-</span> <span class="n">f</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Round our left edge to the current segment if it encloses us. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&gt;</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">;</span>
	<span class="n">chg</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">f</span><span class="p">;</span>

	<span class="cm">/* Check for and consume any regions we now overlap with. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">chg</span><span class="p">;</span>

		<span class="cm">/* We overlap with this area, if it extends further than</span>
<span class="cm">		 * us then we must extend ourselves.  Account for its</span>
<span class="cm">		 * existing reservation. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chg</span> <span class="o">+=</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">-</span> <span class="n">t</span><span class="p">;</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">chg</span> <span class="o">-=</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">-</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">chg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">region_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_region</span> <span class="o">*</span><span class="n">rg</span><span class="p">,</span> <span class="o">*</span><span class="n">trg</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">chg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Locate the region we are either in or before. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If we are in the middle of a region then adjust it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chg</span> <span class="o">=</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">-</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">rg</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">rg</span><span class="p">),</span> <span class="n">link</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Drop any remaining regions. */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">trg</span><span class="p">,</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">chg</span> <span class="o">+=</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">-</span> <span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">chg</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">region_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">long</span> <span class="n">f</span><span class="p">,</span> <span class="kt">long</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_region</span> <span class="o">*</span><span class="n">rg</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">chg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Locate each segment we overlap with, and count that overlap. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="n">seg_from</span><span class="p">;</span>
		<span class="kt">long</span> <span class="n">seg_to</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">&lt;=</span> <span class="n">f</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">seg_from</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">from</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="n">seg_to</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">rg</span><span class="o">-&gt;</span><span class="n">to</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>

		<span class="n">chg</span> <span class="o">+=</span> <span class="n">seg_to</span> <span class="o">-</span> <span class="n">seg_from</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">chg</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Convert the address within this vma to the page offset within</span>
<span class="cm"> * the mapping, in pagecache page units; huge pages here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pgoff_t</span> <span class="nf">vma_hugecache_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">address</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">huge_page_shift</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&gt;&gt;</span> <span class="n">huge_page_order</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">pgoff_t</span> <span class="nf">linear_hugepage_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vma_hugecache_offset</span><span class="p">(</span><span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">),</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the size of the pages allocated when backing a VMA. In the majority</span>
<span class="cm"> * cases this will be same size as used by the page table entries.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vma_kernel_pagesize</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">hstate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="n">hstate</span> <span class="o">=</span> <span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">hstate</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vma_kernel_pagesize</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Return the page size being used by the MMU to back a VMA. In the majority</span>
<span class="cm"> * of cases, the page size used by the kernel matches the MMU size. On</span>
<span class="cm"> * architectures where it differs, an architecture-specific version of this</span>
<span class="cm"> * function is required.</span>
<span class="cm"> */</span>
<span class="cp">#ifndef vma_mmu_pagesize</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vma_mmu_pagesize</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vma_kernel_pagesize</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Flags for MAP_PRIVATE reservations.  These are stored in the bottom</span>
<span class="cm"> * bits of the reservation map pointer, which are always clear due to</span>
<span class="cm"> * alignment.</span>
<span class="cm"> */</span>
<span class="cp">#define HPAGE_RESV_OWNER    (1UL &lt;&lt; 0)</span>
<span class="cp">#define HPAGE_RESV_UNMAPPED (1UL &lt;&lt; 1)</span>
<span class="cp">#define HPAGE_RESV_MASK (HPAGE_RESV_OWNER | HPAGE_RESV_UNMAPPED)</span>

<span class="cm">/*</span>
<span class="cm"> * These helpers are used to track how many pages are reserved for</span>
<span class="cm"> * faults in a MAP_PRIVATE mapping. Only the process that called mmap()</span>
<span class="cm"> * is guaranteed to have their future faults succeed.</span>
<span class="cm"> *</span>
<span class="cm"> * With the exception of reset_vma_resv_huge_pages() which is called at fork(),</span>
<span class="cm"> * the reserve counters are updated with the hugetlb_lock held. It is safe</span>
<span class="cm"> * to reset the VMA at fork() time as it is not in use yet and there is no</span>
<span class="cm"> * chance of the global counters getting corrupted as a result of the values.</span>
<span class="cm"> *</span>
<span class="cm"> * The private mapping reservation is represented in a subtly different</span>
<span class="cm"> * manner to a shared mapping.  A shared mapping has a region map associated</span>
<span class="cm"> * with the underlying file, this region map represents the backing file</span>
<span class="cm"> * pages which have ever had a reservation assigned which this persists even</span>
<span class="cm"> * after the page is instantiated.  A private mapping has a region map</span>
<span class="cm"> * associated with the original mmap which is attached to all VMAs which</span>
<span class="cm"> * reference it, this region map represents those offsets which have consumed</span>
<span class="cm"> * reservation ie. where pages have been instantiated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_vma_private_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_vma_private_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
							<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">resv_map</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">refs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">regions</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="nf">resv_map_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="n">resv_map</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">resv_map</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resv_map</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resv_map</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resv_map</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">resv_map</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">resv_map_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="n">resv_map</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resv_map</span><span class="p">,</span> <span class="n">refs</span><span class="p">);</span>

	<span class="cm">/* Clear out any active regions before we release the map. */</span>
	<span class="n">region_truncate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resv_map</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">resv_map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="nf">vma_resv_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="p">)(</span><span class="n">get_vma_private_data</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">&amp;</span>
							<span class="o">~</span><span class="n">HPAGE_RESV_MASK</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_vma_resv_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">);</span>

	<span class="n">set_vma_private_data</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="p">(</span><span class="n">get_vma_private_data</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">HPAGE_RESV_MASK</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">map</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_vma_resv_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">);</span>

	<span class="n">set_vma_private_data</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">get_vma_private_data</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">|</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_vma_resv_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">get_vma_private_data</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Decrement the reserved pages in the hugepage pool by one */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">decrement_hugepage_resv_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NORESERVE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Shared mappings always use reserves */</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_vma_resv_set</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">HPAGE_RESV_OWNER</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Only the process that called mmap() has reserves for</span>
<span class="cm">		 * private mappings.</span>
<span class="cm">		 */</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Reset counters to 0 and clear all HPAGE_RESV_* flags */</span>
<span class="kt">void</span> <span class="nf">reset_vma_resv_huge_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">))</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns true if the VMA has associated reserve pages */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vma_has_reserves</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_vma_resv_set</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">HPAGE_RESV_OWNER</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_gigantic_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">page_hstate</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dst_base</span> <span class="o">=</span> <span class="n">dst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">src_base</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pages_per_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">);</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">copy_highpage</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dst</span> <span class="o">=</span> <span class="n">mem_map_next</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dst_base</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">src</span> <span class="o">=</span> <span class="n">mem_map_next</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src_base</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">copy_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">page_hstate</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pages_per_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_ORDER_NR_PAGES</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">copy_gigantic_page</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pages_per_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">copy_highpage</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">src</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">enqueue_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hugepage_freelists</span><span class="p">[</span><span class="n">nid</span><span class="p">]);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">dequeue_huge_page_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hugepage_freelists</span><span class="p">[</span><span class="n">nid</span><span class="p">]))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hugepage_freelists</span><span class="p">[</span><span class="n">nid</span><span class="p">].</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
	<span class="n">set_page_refcounted</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span><span class="o">--</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">dequeue_huge_page_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">avoid_reserve</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">mpol</span><span class="p">;</span>
	<span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodemask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zonelist</span> <span class="o">*</span><span class="n">zonelist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">zoneref</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cpuset_mems_cookie</span><span class="p">;</span>

<span class="nl">retry_cpuset:</span>
	<span class="n">cpuset_mems_cookie</span> <span class="o">=</span> <span class="n">get_mems_allowed</span><span class="p">();</span>
	<span class="n">zonelist</span> <span class="o">=</span> <span class="n">huge_zonelist</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>
					<span class="n">htlb_alloc_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mpol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nodemask</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * A child process with MAP_PRIVATE mappings created by their parent</span>
<span class="cm">	 * have no page reserves. This check ensures that reservations are</span>
<span class="cm">	 * not &quot;stolen&quot;. The child may still get SIGKILLed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma_has_reserves</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span> <span class="o">-</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* If reserves cannot be used, ensure enough pages are in the pool */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">avoid_reserve</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span> <span class="o">-</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">for_each_zone_zonelist_nodemask</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zonelist</span><span class="p">,</span>
						<span class="n">MAX_NR_ZONES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nodemask</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cpuset_zone_allowed_softwall</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">htlb_alloc_mask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">dequeue_huge_page_node</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">zone_to_nid</span><span class="p">(</span><span class="n">zone</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">avoid_reserve</span><span class="p">)</span>
					<span class="n">decrement_hugepage_resv_vma</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mpol_cond_put</span><span class="p">(</span><span class="n">mpol</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">put_mems_allowed</span><span class="p">(</span><span class="n">cpuset_mems_cookie</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">retry_cpuset</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">mpol_cond_put</span><span class="p">(</span><span class="n">mpol</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_and_free_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">);</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages</span><span class="o">--</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages_node</span><span class="p">[</span><span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">)]</span><span class="o">--</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pages_per_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PG_locked</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PG_error</span> <span class="o">|</span>
				<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PG_referenced</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PG_dirty</span> <span class="o">|</span>
				<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PG_active</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PG_reserved</span> <span class="o">|</span>
				<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PG_private</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PG_writeback</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">set_compound_page_dtor</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">set_page_refcounted</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">arch_release_hugepage</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">huge_page_order</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="nf">size_to_hstate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>

	<span class="n">for_each_hstate</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">h</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Can&#39;t pass hstate in here because it is called from the</span>
<span class="cm">	 * compound page destructor.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">page_hstate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="n">spool</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="p">)</span><span class="n">page_private</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">set_page_private</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">huge_page_order</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MAX_ORDER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_and_free_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages</span><span class="o">--</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">enqueue_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="n">hugepage_subpool_put_pages</span><span class="p">(</span><span class="n">spool</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prep_new_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">set_compound_page_dtor</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">free_huge_page</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span> <span class="cm">/* free it into the hugepage allocator */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prep_compound_gigantic_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">page</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* we rely on prep_new_huge_page to set the destructor */</span>
	<span class="n">set_compound_order</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="n">__SetPageHead</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mem_map_next</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__SetPageTail</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">set_page_count</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">first_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">PageHuge</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">compound_page_dtor</span> <span class="o">*</span><span class="n">dtor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">compound_head</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">dtor</span> <span class="o">=</span> <span class="n">get_compound_page_dtor</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dtor</span> <span class="o">==</span> <span class="n">free_huge_page</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">PageHuge</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_fresh_huge_page_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_exact_node</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span>
		<span class="n">htlb_alloc_mask</span><span class="o">|</span><span class="n">__GFP_COMP</span><span class="o">|</span><span class="n">__GFP_THISNODE</span><span class="o">|</span>
						<span class="n">__GFP_REPEAT</span><span class="o">|</span><span class="n">__GFP_NOWARN</span><span class="p">,</span>
		<span class="n">huge_page_order</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arch_prepare_hugepage</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">huge_page_order</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prep_new_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * common helper functions for hstate_next_node_to_{alloc|free}.</span>
<span class="cm"> * We may have allocated or freed a huge page based on a different</span>
<span class="cm"> * nodes_allowed previously, so h-&gt;next_node_to_{alloc|free} might</span>
<span class="cm"> * be outside of *nodes_allowed.  Ensure that we use an allowed</span>
<span class="cm"> * node for alloc or free.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">next_node_allowed</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nid</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="n">MAX_NUMNODES</span><span class="p">)</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="o">*</span><span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">nid</span> <span class="o">&gt;=</span> <span class="n">MAX_NUMNODES</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_valid_node_allowed</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_isset</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">))</span>
		<span class="n">nid</span> <span class="o">=</span> <span class="n">next_node_allowed</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns the previously saved node [&quot;this node&quot;] from which to</span>
<span class="cm"> * allocate a persistent huge page for the pool and advance the</span>
<span class="cm"> * next node from which to allocate, handling wrap at end of node</span>
<span class="cm"> * mask.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hstate_next_node_to_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
					<span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nodes_allowed</span><span class="p">);</span>

	<span class="n">nid</span> <span class="o">=</span> <span class="n">get_valid_node_allowed</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">next_nid_to_alloc</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">next_nid_to_alloc</span> <span class="o">=</span> <span class="n">next_node_allowed</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_fresh_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">start_nid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_nid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">start_nid</span> <span class="o">=</span> <span class="n">hstate_next_node_to_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="n">next_nid</span> <span class="o">=</span> <span class="n">start_nid</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_fresh_huge_page_node</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">next_nid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">next_nid</span> <span class="o">=</span> <span class="n">hstate_next_node_to_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next_nid</span> <span class="o">!=</span> <span class="n">start_nid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">HTLB_BUDDY_PGALLOC</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">count_vm_event</span><span class="p">(</span><span class="n">HTLB_BUDDY_PGALLOC_FAIL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper for free_pool_huge_page() - return the previously saved</span>
<span class="cm"> * node [&quot;this node&quot;] from which to free a huge page.  Advance the</span>
<span class="cm"> * next node id whether or not we find a free huge page to free so</span>
<span class="cm"> * that the next attempt to free addresses the next node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hstate_next_node_to_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">nodes_allowed</span><span class="p">);</span>

	<span class="n">nid</span> <span class="o">=</span> <span class="n">get_valid_node_allowed</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">next_nid_to_free</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">next_nid_to_free</span> <span class="o">=</span> <span class="n">next_node_allowed</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Free huge page from pool from next node to free.</span>
<span class="cm"> * Attempt to keep persistent huge pages more or less</span>
<span class="cm"> * balanced over allowed nodes.</span>
<span class="cm"> * Called with hugetlb_lock locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">free_pool_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">,</span>
							 <span class="n">bool</span> <span class="n">acct_surplus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start_nid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_nid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">start_nid</span> <span class="o">=</span> <span class="n">hstate_next_node_to_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="n">next_nid</span> <span class="o">=</span> <span class="n">start_nid</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we&#39;re returning unused surplus pages, only examine</span>
<span class="cm">		 * nodes with surplus pages.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">acct_surplus</span> <span class="o">||</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages_node</span><span class="p">[</span><span class="n">next_nid</span><span class="p">])</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hugepage_freelists</span><span class="p">[</span><span class="n">next_nid</span><span class="p">]))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span>
				<span class="n">list_entry</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hugepage_freelists</span><span class="p">[</span><span class="n">next_nid</span><span class="p">].</span><span class="n">next</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span><span class="o">--</span><span class="p">;</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages_node</span><span class="p">[</span><span class="n">next_nid</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">acct_surplus</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages</span><span class="o">--</span><span class="p">;</span>
				<span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages_node</span><span class="p">[</span><span class="n">next_nid</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">update_and_free_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">next_nid</span> <span class="o">=</span> <span class="n">hstate_next_node_to_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next_nid</span> <span class="o">!=</span> <span class="n">start_nid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_buddy_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r_nid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Assume we will successfully allocate the surplus page to</span>
<span class="cm">	 * prevent racing processes from causing the surplus to exceed</span>
<span class="cm">	 * overcommit</span>
<span class="cm">	 *</span>
<span class="cm">	 * This however introduces a different race, where a process B</span>
<span class="cm">	 * tries to grow the static hugepage pool while alloc_pages() is</span>
<span class="cm">	 * called by process A. B will only examine the per-node</span>
<span class="cm">	 * counters in determining if surplus huge pages can be</span>
<span class="cm">	 * converted to normal huge pages in adjust_pool_surplus(). A</span>
<span class="cm">	 * won&#39;t be able to increment the per-node counter, until the</span>
<span class="cm">	 * lock is dropped by B, but B doesn&#39;t drop hugetlb_lock until</span>
<span class="cm">	 * no more huge pages can be converted from surplus to normal</span>
<span class="cm">	 * state (and doesn&#39;t try to convert again). Thus, we have a</span>
<span class="cm">	 * case where a surplus huge page exists, the pool is grown, and</span>
<span class="cm">	 * the surplus huge page still exists after, even though it</span>
<span class="cm">	 * should just have been converted to a normal huge page. This</span>
<span class="cm">	 * does not leak memory, though, as the hugepage will be freed</span>
<span class="cm">	 * once it is out of use. It also does not allow the counters to</span>
<span class="cm">	 * go out of whack in adjust_pool_surplus() as we don&#39;t modify</span>
<span class="cm">	 * the node values until we&#39;ve gotten the hugepage and only the</span>
<span class="cm">	 * per-node value is checked there.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages</span> <span class="o">&gt;=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_overcommit_huge_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages</span><span class="o">++</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">htlb_alloc_mask</span><span class="o">|</span><span class="n">__GFP_COMP</span><span class="o">|</span>
				   <span class="n">__GFP_REPEAT</span><span class="o">|</span><span class="n">__GFP_NOWARN</span><span class="p">,</span>
				   <span class="n">huge_page_order</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_pages_exact_node</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span>
			<span class="n">htlb_alloc_mask</span><span class="o">|</span><span class="n">__GFP_COMP</span><span class="o">|</span><span class="n">__GFP_THISNODE</span><span class="o">|</span>
			<span class="n">__GFP_REPEAT</span><span class="o">|</span><span class="n">__GFP_NOWARN</span><span class="p">,</span> <span class="n">huge_page_order</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="n">arch_prepare_hugepage</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__free_pages</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">huge_page_order</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
		<span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">r_nid</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">set_compound_page_dtor</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">free_huge_page</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We incremented the global counters already</span>
<span class="cm">		 */</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages_node</span><span class="p">[</span><span class="n">r_nid</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages_node</span><span class="p">[</span><span class="n">r_nid</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">__count_vm_event</span><span class="p">(</span><span class="n">HTLB_BUDDY_PGALLOC</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages</span><span class="o">--</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages</span><span class="o">--</span><span class="p">;</span>
		<span class="n">__count_vm_event</span><span class="p">(</span><span class="n">HTLB_BUDDY_PGALLOC_FAIL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This allocation function is useful in the context where vma is irrelevant.</span>
<span class="cm"> * E.g. soft-offlining uses this function because it only cares physical</span>
<span class="cm"> * address of error page.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_huge_page_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">dequeue_huge_page_node</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_buddy_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Increase the hugetlb pool such that it can accommodate a reservation</span>
<span class="cm"> * of size &#39;delta&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gather_surplus_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">surplus_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">needed</span><span class="p">,</span> <span class="n">allocated</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">alloc_ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">needed</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span> <span class="o">-</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needed</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">surplus_list</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="nl">retry:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">needed</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_buddy_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">alloc_ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">surplus_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">allocated</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * After retaking hugetlb_lock, we need to recalculate &#39;needed&#39;</span>
<span class="cm">	 * because either resv_huge_pages or free_huge_pages may have changed.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="n">needed</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span> <span class="o">-</span>
			<span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span> <span class="o">+</span> <span class="n">allocated</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">needed</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alloc_ok</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * We were not able to allocate enough pages to</span>
<span class="cm">		 * satisfy the entire reservation so we free what</span>
<span class="cm">		 * we&#39;ve allocated so far.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * The surplus_list now contains _at_least_ the number of extra pages</span>
<span class="cm">	 * needed to accommodate the reservation.  Add the appropriate number</span>
<span class="cm">	 * of pages to the hugetlb pool and free the extras back to the buddy</span>
<span class="cm">	 * allocator.  Commit the entire reservation here to prevent another</span>
<span class="cm">	 * process from stealing the pages as they are added to the pool but</span>
<span class="cm">	 * before they are reserved.</span>
<span class="cm">	 */</span>
	<span class="n">needed</span> <span class="o">+=</span> <span class="n">allocated</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Free the needed pages to the hugetlb pool */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">surplus_list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">--</span><span class="n">needed</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * This page is now managed by the hugetlb allocator and has</span>
<span class="cm">		 * no users -- drop the buddy allocator&#39;s reference.</span>
<span class="cm">		 */</span>
		<span class="n">put_page_testzero</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="n">enqueue_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">free:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>

	<span class="cm">/* Free unnecessary surplus pages to the buddy allocator */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">surplus_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">surplus_list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When releasing a hugetlb pool reservation, any surplus pages that were</span>
<span class="cm"> * allocated to satisfy the reservation must be explicitly freed if they were</span>
<span class="cm"> * never used.</span>
<span class="cm"> * Called with hugetlb_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">return_unused_surplus_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">unused_resv_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="cm">/* Uncommit the reservation */</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span> <span class="o">-=</span> <span class="n">unused_resv_pages</span><span class="p">;</span>

	<span class="cm">/* Cannot return gigantic pages currently */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">unused_resv_pages</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We want to release as many surplus pages as possible, spread</span>
<span class="cm">	 * evenly across all nodes with memory. Iterate across these nodes</span>
<span class="cm">	 * until we can no longer free unreserved surplus pages. This occurs</span>
<span class="cm">	 * when the nodes with surplus pages have no free pages.</span>
<span class="cm">	 * free_pool_huge_page() will balance the the freed pages across the</span>
<span class="cm">	 * on-line nodes with memory and will handle the hstate accounting.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nr_pages</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">free_pool_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Determine if the huge page at addr within the vma has an associated</span>
<span class="cm"> * reservation.  Where it does not we will need to logically increase</span>
<span class="cm"> * reservation and actually increase subpool usage before an allocation</span>
<span class="cm"> * can occur.  Where any new reservation would be required the</span>
<span class="cm"> * reservation change is prepared, but not committed.  Once the page</span>
<span class="cm"> * has been allocated from the subpool and instantiated the change should</span>
<span class="cm"> * be committed via vma_commit_reservation.  No action is required on</span>
<span class="cm"> * failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">vma_needs_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgoff_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">vma_hugecache_offset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">region_chg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">,</span>
							<span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_vma_resv_set</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">HPAGE_RESV_OWNER</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
		<span class="kt">long</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">pgoff_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">vma_hugecache_offset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="n">reservations</span> <span class="o">=</span> <span class="n">vma_resv_map</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">region_chg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reservations</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vma_commit_reservation</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pgoff_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">vma_hugecache_offset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="n">region_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_vma_resv_set</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">HPAGE_RESV_OWNER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pgoff_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">vma_hugecache_offset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="n">reservations</span> <span class="o">=</span> <span class="n">vma_resv_map</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

		<span class="cm">/* Mark this page used in the map. */</span>
		<span class="n">region_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reservations</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">alloc_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">avoid_reserve</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="n">spool</span> <span class="o">=</span> <span class="n">subpool_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">chg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Processes that did not create the mapping will have no</span>
<span class="cm">	 * reserves and will not have accounted against subpool</span>
<span class="cm">	 * limit. Check that the subpool limit can be made before</span>
<span class="cm">	 * satisfying the allocation MAP_NORESERVE mappings may also</span>
<span class="cm">	 * need pages and subpool limit allocated allocated if no reserve</span>
<span class="cm">	 * mapping overlaps.</span>
<span class="cm">	 */</span>
	<span class="n">chg</span> <span class="o">=</span> <span class="n">vma_needs_reservation</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">VM_FAULT_OOM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chg</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hugepage_subpool_get_pages</span><span class="p">(</span><span class="n">spool</span><span class="p">,</span> <span class="n">chg</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">VM_FAULT_SIGBUS</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">dequeue_huge_page_vma</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">avoid_reserve</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_buddy_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hugepage_subpool_put_pages</span><span class="p">(</span><span class="n">spool</span><span class="p">,</span> <span class="n">chg</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">VM_FAULT_SIGBUS</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">set_page_private</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">spool</span><span class="p">);</span>

	<span class="n">vma_commit_reservation</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__weak</span> <span class="nf">alloc_bootmem_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">huge_bootmem_page</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_nodes</span> <span class="o">=</span> <span class="n">nodes_weight</span><span class="p">(</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">nr_nodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="n">__alloc_bootmem_node_nopanic</span><span class="p">(</span>
				<span class="n">NODE_DATA</span><span class="p">(</span><span class="n">hstate_next_node_to_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">])),</span>
				<span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Use the beginning of the huge page to store the</span>
<span class="cm">			 * huge_bootmem_page struct (until gather_bootmem</span>
<span class="cm">			 * puts them into the mem_map).</span>
<span class="cm">			 */</span>
			<span class="n">m</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nr_nodes</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">virt_to_phys</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="cm">/* Put them into a private list first because mem_map is not up yet */</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">huge_boot_pages</span><span class="p">);</span>
	<span class="n">m</span><span class="o">-&gt;</span><span class="n">hstate</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">prep_compound_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">order</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">MAX_ORDER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="n">prep_compound_gigantic_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">prep_compound_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Put bootmem huge pages into the standard lists after mem_map is up */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">gather_bootmem_prealloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">huge_bootmem_page</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">huge_boot_pages</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">hstate</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">phys</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
		<span class="n">free_bootmem_late</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">m</span><span class="p">,</span>
				  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">huge_bootmem_page</span><span class="p">));</span>
<span class="cp">#else</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">__ClearPageReserved</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">page_count</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">prep_compound_huge_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">);</span>
		<span class="n">prep_new_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we had gigantic hugepages allocated at boot time, we need</span>
<span class="cm">		 * to restore the &#39;stolen&#39; pages to totalram_pages in order to</span>
<span class="cm">		 * fix confusing memory reports from free(1) and another</span>
<span class="cm">		 * side-effects, like CommitLimit going negative.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">MAX_ORDER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">totalram_pages</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">hugetlb_hstate_alloc_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_huge_pages</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_bootmem_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc_fresh_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">max_huge_pages</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">hugetlb_init_hstates</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>

	<span class="n">for_each_hstate</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* oversize hugepages were init&#39;ed in early boot */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&lt;</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
			<span class="n">hugetlb_hstate_alloc_pages</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">memfmt</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">))</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu GB&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">))</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu MB&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">20</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu KB&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">report_hugepages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>

	<span class="n">for_each_hstate</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;HugeTLB registered %s page size, &quot;</span>
				 <span class="s">&quot;pre-allocated %ld pages</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">memfmt</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">)),</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_HIGHMEM</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">try_to_free_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span>
						<span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">freel</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hugepage_freelists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">freel</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages</span><span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
			<span class="n">update_and_free_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span><span class="o">--</span><span class="p">;</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages_node</span><span class="p">[</span><span class="n">page_to_nid</span><span class="p">(</span><span class="n">page</span><span class="p">)]</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">try_to_free_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span>
						<span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Increment or decrement surplus_huge_pages.  Keep node-specific counters</span>
<span class="cm"> * balanced by operating on them in a round-robin fashion.</span>
<span class="cm"> * Returns 1 if an adjustment was made.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">adjust_pool_surplus</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start_nid</span><span class="p">,</span> <span class="n">next_nid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">VM_BUG_ON</span><span class="p">(</span><span class="n">delta</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">delta</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">start_nid</span> <span class="o">=</span> <span class="n">hstate_next_node_to_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">start_nid</span> <span class="o">=</span> <span class="n">hstate_next_node_to_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="n">next_nid</span> <span class="o">=</span> <span class="n">start_nid</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">next_nid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * To shrink on this node, there must be a surplus page</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">next_nid</span> <span class="o">=</span> <span class="n">hstate_next_node_to_alloc</span><span class="p">(</span><span class="n">h</span><span class="p">,</span>
								<span class="n">nodes_allowed</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Surplus cannot exceed the total number of pages</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">&gt;=</span>
						<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">next_nid</span> <span class="o">=</span> <span class="n">hstate_next_node_to_free</span><span class="p">(</span><span class="n">h</span><span class="p">,</span>
								<span class="n">nodes_allowed</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">next_nid</span> <span class="o">!=</span> <span class="n">start_nid</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define persistent_huge_pages(h) (h-&gt;nr_huge_pages - h-&gt;surplus_huge_pages)</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">set_max_huge_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span>
						<span class="n">nodemask_t</span> <span class="o">*</span><span class="n">nodes_allowed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_count</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_huge_pages</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Increase the pool size</span>
<span class="cm">	 * First take pages out of surplus state.  Then make up the</span>
<span class="cm">	 * remaining difference by allocating fresh huge pages.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We might race with alloc_buddy_huge_page() here and be unable</span>
<span class="cm">	 * to convert a surplus huge page to a normal huge page. That is</span>
<span class="cm">	 * not critical, though, it just means the overall size of the</span>
<span class="cm">	 * pool might be one hugepage larger than it needs to be, but</span>
<span class="cm">	 * within all the constraints specified by the sysctls.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">persistent_huge_pages</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adjust_pool_surplus</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">persistent_huge_pages</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this allocation races such that we no longer need the</span>
<span class="cm">		 * page, free_huge_page will handle it by freeing the page</span>
<span class="cm">		 * and reducing the surplus.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_fresh_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Bail for signals. Probably ctrl-c from user */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decrease the pool size</span>
<span class="cm">	 * First return free pages to the buddy allocator (being careful</span>
<span class="cm">	 * to keep enough around to satisfy reservations).  Then place</span>
<span class="cm">	 * pages into surplus state as needed so the pool will shrink</span>
<span class="cm">	 * to the desired size as pages become free.</span>
<span class="cm">	 *</span>
<span class="cm">	 * By placing pages into the surplus state independent of the</span>
<span class="cm">	 * overcommit value, we are allowing the surplus pool size to</span>
<span class="cm">	 * exceed overcommit. There are few sane options here. Since</span>
<span class="cm">	 * alloc_buddy_huge_page() is checking the global counter,</span>
<span class="cm">	 * though, we&#39;ll note that we&#39;re not allowed to exceed surplus</span>
<span class="cm">	 * and won&#39;t grow the pool anywhere else. Not until one of the</span>
<span class="cm">	 * sysctls are changed, or the surplus pages go out of use.</span>
<span class="cm">	 */</span>
	<span class="n">min_count</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span> <span class="o">+</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages</span> <span class="o">-</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span><span class="p">;</span>
	<span class="n">min_count</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">min_count</span><span class="p">);</span>
	<span class="n">try_to_free_low</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">min_count</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">min_count</span> <span class="o">&lt;</span> <span class="n">persistent_huge_pages</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">free_pool_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">persistent_huge_pages</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adjust_pool_surplus</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">persistent_huge_pages</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define HSTATE_ATTR_RO(_name) \</span>
<span class="cp">	static struct kobj_attribute _name##_attr = __ATTR_RO(_name)</span>

<span class="cp">#define HSTATE_ATTR(_name) \</span>
<span class="cp">	static struct kobj_attribute _name##_attr = \</span>
<span class="cp">		__ATTR(_name, 0644, _name##_show, _name##_store)</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">hugepages_kobj</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">HUGE_MAX_HSTATE</span><span class="p">];</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">kobj_to_node_hstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nidp</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="nf">kobj_to_hstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nidp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HUGE_MAX_HSTATE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">kobj</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nidp</span><span class="p">)</span>
				<span class="o">*</span><span class="n">nidp</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">hstates</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>

	<span class="k">return</span> <span class="n">kobj_to_node_hstate</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">nidp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nr_hugepages_show_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_huge_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">h</span> <span class="o">=</span> <span class="n">kobj_to_hstate</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="n">nr_huge_pages</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">nr_huge_pages</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_huge_pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nr_hugepages_store_common</span><span class="p">(</span><span class="n">bool</span> <span class="n">obey_mempolicy</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="n">NODEMASK_ALLOC</span><span class="p">(</span><span class="n">nodemask_t</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">,</span> <span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">h</span> <span class="o">=</span> <span class="n">kobj_to_hstate</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * global hstate attribute</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">obey_mempolicy</span> <span class="o">&amp;&amp;</span>
				<span class="n">init_nodemask_of_mempolicy</span><span class="p">(</span><span class="n">nodes_allowed</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">NODEMASK_FREE</span><span class="p">(</span><span class="n">nodes_allowed</span><span class="p">);</span>
			<span class="n">nodes_allowed</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nodes_allowed</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * per node hstate attribute: adjust count to global,</span>
<span class="cm">		 * but restrict alloc/free to the specified node.</span>
<span class="cm">		 */</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages</span> <span class="o">-</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>
		<span class="n">init_nodemask_of_node</span><span class="p">(</span><span class="n">nodes_allowed</span><span class="p">,</span> <span class="n">nid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">nodes_allowed</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">];</span>

	<span class="n">h</span><span class="o">-&gt;</span><span class="n">max_huge_pages</span> <span class="o">=</span> <span class="n">set_max_huge_pages</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nodes_allowed</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">])</span>
		<span class="n">NODEMASK_FREE</span><span class="p">(</span><span class="n">nodes_allowed</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">NODEMASK_FREE</span><span class="p">(</span><span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nr_hugepages_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nr_hugepages_show_common</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nr_hugepages_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nr_hugepages_store_common</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">HSTATE_ATTR</span><span class="p">(</span><span class="n">nr_hugepages</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_NUMA</span>

<span class="cm">/*</span>
<span class="cm"> * hstate attribute for optionally mempolicy-based constraint on persistent</span>
<span class="cm"> * huge page alloc/free.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nr_hugepages_mempolicy_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nr_hugepages_show_common</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nr_hugepages_mempolicy_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nr_hugepages_store_common</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">kobj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">HSTATE_ATTR</span><span class="p">(</span><span class="n">nr_hugepages_mempolicy</span><span class="p">);</span>
<span class="cp">#endif</span>


<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nr_overcommit_hugepages_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">kobj_to_hstate</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_overcommit_huge_pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">nr_overcommit_hugepages_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">input</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">kobj_to_hstate</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">strict_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_overcommit_huge_pages</span> <span class="o">=</span> <span class="n">input</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">HSTATE_ATTR</span><span class="p">(</span><span class="n">nr_overcommit_hugepages</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">free_hugepages_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">free_huge_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">h</span> <span class="o">=</span> <span class="n">kobj_to_hstate</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="n">free_huge_pages</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">free_huge_pages</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">free_huge_pages</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">HSTATE_ATTR_RO</span><span class="p">(</span><span class="n">free_hugepages</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">resv_hugepages_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">kobj_to_hstate</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">HSTATE_ATTR_RO</span><span class="p">(</span><span class="n">resv_hugepages</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">surplus_hugepages_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">kobj_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">surplus_huge_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">h</span> <span class="o">=</span> <span class="n">kobj_to_hstate</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nid</span> <span class="o">==</span> <span class="n">NUMA_NO_NODE</span><span class="p">)</span>
		<span class="n">surplus_huge_pages</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">surplus_huge_pages</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">surplus_huge_pages</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">HSTATE_ATTR_RO</span><span class="p">(</span><span class="n">surplus_hugepages</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">hstate_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">nr_hugepages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">nr_overcommit_hugepages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">free_hugepages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">resv_hugepages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">surplus_hugepages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
	<span class="o">&amp;</span><span class="n">nr_hugepages_mempolicy_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">hstate_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">hstate_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hugetlb_sysfs_add_hstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">kobject</span> <span class="o">**</span><span class="n">hstate_kobjs</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">attribute_group</span> <span class="o">*</span><span class="n">hstate_attr_group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">h</span> <span class="o">-</span> <span class="n">hstates</span><span class="p">;</span>

	<span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">hi</span><span class="p">])</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">hi</span><span class="p">],</span> <span class="n">hstate_attr_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">hi</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">hugetlb_sysfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">hugepages_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;hugepages&quot;</span><span class="p">,</span> <span class="n">mm_kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hugepages_kobj</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_hstate</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">hugetlb_sysfs_add_hstate</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">hugepages_kobj</span><span class="p">,</span>
					 <span class="n">hstate_kobjs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hstate_attr_group</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Hugetlb: Unable to add hstate %s&quot;</span><span class="p">,</span>
								<span class="n">h</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>

<span class="cm">/*</span>
<span class="cm"> * node_hstate/s - associate per node hstate attributes, via their kobjects,</span>
<span class="cm"> * with node devices in node_devices[] using a parallel array.  The array</span>
<span class="cm"> * index of a node device or _hstate == node id.</span>
<span class="cm"> * This is here to avoid any static dependency of the node device driver, in</span>
<span class="cm"> * the base kernel, on the hugetlb module.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">node_hstate</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kobject</span>		<span class="o">*</span><span class="n">hugepages_kobj</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span>		<span class="o">*</span><span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">HUGE_MAX_HSTATE</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">node_hstate</span> <span class="n">node_hstates</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span>

<span class="cm">/*</span>
<span class="cm"> * A subset of global hstate attributes for node devices</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">per_node_hstate_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">nr_hugepages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">free_hugepages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">surplus_hugepages_attr</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">per_node_hstate_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">per_node_hstate_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * kobj_to_node_hstate - lookup global hstate for node device hstate attr kobj.</span>
<span class="cm"> * Returns node id via non-NULL nidp.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="nf">kobj_to_node_hstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nidp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nid</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">nid</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">node_hstate</span> <span class="o">*</span><span class="n">nhs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_hstates</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HUGE_MAX_HSTATE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">kobj</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nidp</span><span class="p">)</span>
					<span class="o">*</span><span class="n">nidp</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
				<span class="k">return</span> <span class="o">&amp;</span><span class="n">hstates</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unregister hstate attributes from a single node device.</span>
<span class="cm"> * No-op if no hstate attributes attached.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hugetlb_unregister_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_hstate</span> <span class="o">*</span><span class="n">nhs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_hstates</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">id</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hugepages_kobj</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* no hstate attributes */</span>

	<span class="n">for_each_hstate</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="n">hstates</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">kobject_put</span><span class="p">(</span><span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="n">hstates</span><span class="p">]);</span>
			<span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="n">hstates</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">kobject_put</span><span class="p">(</span><span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hugepages_kobj</span><span class="p">);</span>
	<span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hugepages_kobj</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hugetlb module exit:  unregister hstate attributes from node devices</span>
<span class="cm"> * that have them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hugetlb_unregister_all_nodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * disable node device registrations.</span>
<span class="cm">	 */</span>
	<span class="n">register_hugetlbfs_with_node</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * remove hstate attributes from any nodes that have them.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">nid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nid</span> <span class="o">&lt;</span> <span class="n">nr_node_ids</span><span class="p">;</span> <span class="n">nid</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hugetlb_unregister_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_devices</span><span class="p">[</span><span class="n">nid</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Register hstate attributes for a single node device.</span>
<span class="cm"> * No-op if attributes already registered.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">hugetlb_register_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">node_hstate</span> <span class="o">*</span><span class="n">nhs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_hstates</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">id</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hugepages_kobj</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>		<span class="cm">/* already allocated */</span>

	<span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hugepages_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;hugepages&quot;</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hugepages_kobj</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_hstate</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">hugetlb_sysfs_add_hstate</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hugepages_kobj</span><span class="p">,</span>
						<span class="n">nhs</span><span class="o">-&gt;</span><span class="n">hstate_kobjs</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">per_node_hstate_attr_group</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Hugetlb: Unable to add hstate %s&quot;</span>
					<span class="s">&quot; for node %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">h</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
			<span class="n">hugetlb_unregister_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hugetlb init time:  register hstate attributes for all registered node</span>
<span class="cm"> * devices of nodes that have memory.  All on-line nodes should have</span>
<span class="cm"> * registered their associated device by this time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">hugetlb_register_all_nodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>

	<span class="n">for_each_node_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_devices</span><span class="p">[</span><span class="n">nid</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">nid</span><span class="p">)</span>
			<span class="n">hugetlb_register_node</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let the node device driver know we&#39;re here so it can</span>
<span class="cm">	 * [un]register hstate attributes on node hotplug.</span>
<span class="cm">	 */</span>
	<span class="n">register_hugetlbfs_with_node</span><span class="p">(</span><span class="n">hugetlb_register_node</span><span class="p">,</span>
				     <span class="n">hugetlb_unregister_node</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else	</span><span class="cm">/* !CONFIG_NUMA */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="nf">kobj_to_node_hstate</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nidp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nidp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">nidp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hugetlb_unregister_all_nodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hugetlb_register_all_nodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">hugetlb_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>

	<span class="n">hugetlb_unregister_all_nodes</span><span class="p">();</span>

	<span class="n">for_each_hstate</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kobject_put</span><span class="p">(</span><span class="n">hstate_kobjs</span><span class="p">[</span><span class="n">h</span> <span class="o">-</span> <span class="n">hstates</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">kobject_put</span><span class="p">(</span><span class="n">hugepages_kobj</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">hugetlb_exit</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hugetlb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Some platform decide whether they support huge pages at boot</span>
<span class="cm">	 * time. On these, such as powerpc, HPAGE_SHIFT is set to 0 when</span>
<span class="cm">	 * there is no such support</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">HPAGE_SHIFT</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size_to_hstate</span><span class="p">(</span><span class="n">default_hstate_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">default_hstate_size</span> <span class="o">=</span> <span class="n">HPAGE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size_to_hstate</span><span class="p">(</span><span class="n">default_hstate_size</span><span class="p">))</span>
			<span class="n">hugetlb_add_hstate</span><span class="p">(</span><span class="n">HUGETLB_PAGE_ORDER</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">default_hstate_idx</span> <span class="o">=</span> <span class="n">size_to_hstate</span><span class="p">(</span><span class="n">default_hstate_size</span><span class="p">)</span> <span class="o">-</span> <span class="n">hstates</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">default_hstate_max_huge_pages</span><span class="p">)</span>
		<span class="n">default_hstate</span><span class="p">.</span><span class="n">max_huge_pages</span> <span class="o">=</span> <span class="n">default_hstate_max_huge_pages</span><span class="p">;</span>

	<span class="n">hugetlb_init_hstates</span><span class="p">();</span>

	<span class="n">gather_bootmem_prealloc</span><span class="p">();</span>

	<span class="n">report_hugepages</span><span class="p">();</span>

	<span class="n">hugetlb_sysfs_init</span><span class="p">();</span>

	<span class="n">hugetlb_register_all_nodes</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">hugetlb_init</span><span class="p">);</span>

<span class="cm">/* Should be called on processing a hugepagesz=... option */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">hugetlb_add_hstate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size_to_hstate</span><span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;hugepagesz= specified twice, ignoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">max_hstate</span> <span class="o">&gt;=</span> <span class="n">HUGE_MAX_HSTATE</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hstates</span><span class="p">[</span><span class="n">max_hstate</span><span class="o">++</span><span class="p">];</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hugepage_freelists</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">next_nid_to_alloc</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]);</span>
	<span class="n">h</span><span class="o">-&gt;</span><span class="n">next_nid_to_free</span> <span class="o">=</span> <span class="n">first_node</span><span class="p">(</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">]);</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">HSTATE_NAME_LEN</span><span class="p">,</span> <span class="s">&quot;hugepages-%lukB&quot;</span><span class="p">,</span>
					<span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">/</span><span class="mi">1024</span><span class="p">);</span>

	<span class="n">parsed_hstate</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hugetlb_nrpages_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">mhp</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">last_mhp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * !max_hstate means we haven&#39;t parsed a hugepagesz= parameter yet,</span>
<span class="cm">	 * so this hugepages= parameter goes to the &quot;default hstate&quot;.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_hstate</span><span class="p">)</span>
		<span class="n">mhp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_hstate_max_huge_pages</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mhp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parsed_hstate</span><span class="o">-&gt;</span><span class="n">max_huge_pages</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mhp</span> <span class="o">==</span> <span class="n">last_mhp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;hugepages= specified twice without &quot;</span>
			<span class="s">&quot;interleaving hugepagesz=, ignoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%lu&quot;</span><span class="p">,</span> <span class="n">mhp</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">mhp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Global state is always initialized later in hugetlb_init.</span>
<span class="cm">	 * But we need to allocate &gt;= MAX_ORDER hstates here early to still</span>
<span class="cm">	 * use the bootmem allocator.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_hstate</span> <span class="o">&amp;&amp;</span> <span class="n">parsed_hstate</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
		<span class="n">hugetlb_hstate_alloc_pages</span><span class="p">(</span><span class="n">parsed_hstate</span><span class="p">);</span>

	<span class="n">last_mhp</span> <span class="o">=</span> <span class="n">mhp</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;hugepages=&quot;</span><span class="p">,</span> <span class="n">hugetlb_nrpages_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hugetlb_default_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">default_hstate_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;default_hugepagesz=&quot;</span><span class="p">,</span> <span class="n">hugetlb_default_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cpuset_mems_nr</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">node</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">for_each_node_mask</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cpuset_current_mems_allowed</span><span class="p">)</span>
		<span class="n">nr</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SYSCTL</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hugetlb_sysctl_handler_common</span><span class="p">(</span><span class="n">bool</span> <span class="n">obey_mempolicy</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_hstate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">max_huge_pages</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">table</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">table</span><span class="o">-&gt;</span><span class="n">maxlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">proc_doulongvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NODEMASK_ALLOC</span><span class="p">(</span><span class="n">nodemask_t</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">,</span>
						<span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">obey_mempolicy</span> <span class="o">&amp;&amp;</span>
			       <span class="n">init_nodemask_of_mempolicy</span><span class="p">(</span><span class="n">nodes_allowed</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">NODEMASK_FREE</span><span class="p">(</span><span class="n">nodes_allowed</span><span class="p">);</span>
			<span class="n">nodes_allowed</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">max_huge_pages</span> <span class="o">=</span> <span class="n">set_max_huge_pages</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">nodes_allowed</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nodes_allowed</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">node_states</span><span class="p">[</span><span class="n">N_HIGH_MEMORY</span><span class="p">])</span>
			<span class="n">NODEMASK_FREE</span><span class="p">(</span><span class="n">nodes_allowed</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">hugetlb_sysctl_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">return</span> <span class="n">hugetlb_sysctl_handler_common</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span>
							<span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="kt">int</span> <span class="nf">hugetlb_mempolicy_sysctl_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			  <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hugetlb_sysctl_handler_common</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span>
							<span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_NUMA */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">hugetlb_treat_movable_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_dointvec</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hugepages_treat_as_movable</span><span class="p">)</span>
		<span class="n">htlb_alloc_mask</span> <span class="o">=</span> <span class="n">GFP_HIGHUSER_MOVABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">htlb_alloc_mask</span> <span class="o">=</span> <span class="n">GFP_HIGHUSER</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">hugetlb_overcommit_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ctl_table</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">,</span>
			<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_hstate</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_overcommit_huge_pages</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="n">MAX_ORDER</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">table</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">table</span><span class="o">-&gt;</span><span class="n">maxlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">proc_doulongvec_minmax</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">write</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_overcommit_huge_pages</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_SYSCTL */</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">hugetlb_report_meminfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_hstate</span><span class="p">;</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">m</span><span class="p">,</span>
			<span class="s">&quot;HugePages_Total:   %5lu</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;HugePages_Free:    %5lu</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;HugePages_Rsvd:    %5lu</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;HugePages_Surp:    %5lu</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;Hugepagesize:   %8lu kB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages</span><span class="p">,</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span><span class="p">,</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">resv_huge_pages</span><span class="p">,</span>
			<span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages</span><span class="p">,</span>
			<span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">huge_page_order</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">10</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">hugetlb_report_node_meminfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_hstate</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span>
		<span class="s">&quot;Node %d HugePages_Total: %5u</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;Node %d HugePages_Free:  %5u</span><span class="se">\n</span><span class="s">&quot;</span>
		<span class="s">&quot;Node %d HugePages_Surp:  %5u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">nid</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">],</span>
		<span class="n">nid</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">],</span>
		<span class="n">nid</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">surplus_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* Return the number pages of memory we physically have, in PAGE_SIZE units. */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hugetlb_total_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">default_hstate</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">nr_huge_pages</span> <span class="o">*</span> <span class="n">pages_per_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hugetlb_acct_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="kt">long</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * When cpuset is configured, it breaks the strict hugetlb page</span>
<span class="cm">	 * reservation as the accounting is done on a global variable. Such</span>
<span class="cm">	 * reservation is completely rubbish in the presence of cpuset because</span>
<span class="cm">	 * the reservation is not checked against page availability for the</span>
<span class="cm">	 * current cpuset. Application can still potentially OOM&#39;ed by kernel</span>
<span class="cm">	 * with lack of free htlb page in cpuset that the task is in.</span>
<span class="cm">	 * Attempt to enforce strict accounting with cpuset is almost</span>
<span class="cm">	 * impossible (or too ugly) because cpuset is too fluid that</span>
<span class="cm">	 * task or memory node can be dynamically moved between cpusets.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The change of semantics for shared hugetlb mapping with cpuset is</span>
<span class="cm">	 * undesirable. However, in order to preserve some of the semantics,</span>
<span class="cm">	 * we fall back to check against current free page availability as</span>
<span class="cm">	 * a best attempt and hopefully to minimize the impact of changing</span>
<span class="cm">	 * semantics that cpuset has.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gather_surplus_pages</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">cpuset_mems_nr</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages_node</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">return_unused_surplus_pages</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">return_unused_surplus_pages</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span><span class="n">delta</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hugetlb_vm_op_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="n">reservations</span> <span class="o">=</span> <span class="n">vma_resv_map</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This new VMA should share its siblings reservation map if present.</span>
<span class="cm">	 * The VMA will only ever have a valid reservation map pointer where</span>
<span class="cm">	 * it is being copied for another still existing VMA.  As that VMA</span>
<span class="cm">	 * has a reference to the reservation map it cannot disappear until</span>
<span class="cm">	 * after this open call completes.  It is therefore safe to take a</span>
<span class="cm">	 * new reference here without additional locking.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reservations</span><span class="p">)</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reservations</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">resv_map_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="n">reservations</span> <span class="o">=</span> <span class="n">vma_resv_map</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reservations</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reservations</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">,</span> <span class="n">resv_map_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hugetlb_vm_op_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="n">reservations</span> <span class="o">=</span> <span class="n">vma_resv_map</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="n">spool</span> <span class="o">=</span> <span class="n">subpool_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reserve</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reservations</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">vma_hugecache_offset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">);</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">vma_hugecache_offset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>

		<span class="n">reserve</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">-</span>
			<span class="n">region_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reservations</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

		<span class="n">resv_map_put</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reserve</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hugetlb_acct_memory</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="n">reserve</span><span class="p">);</span>
			<span class="n">hugepage_subpool_put_pages</span><span class="p">(</span><span class="n">spool</span><span class="p">,</span> <span class="n">reserve</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We cannot handle pagefaults against hugetlb pages at all.  They cause</span>
<span class="cm"> * handle_mm_fault() to try to instantiate regular-sized pages in the</span>
<span class="cm"> * hugegpage VMA.  do_page_fault() is supposed to trap this, so BUG is we get</span>
<span class="cm"> * this far.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hugetlb_vm_op_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">hugetlb_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">hugetlb_vm_op_fault</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">hugetlb_vm_op_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">close</span> <span class="o">=</span> <span class="n">hugetlb_vm_op_close</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">pte_t</span> <span class="nf">make_huge_pte</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">writable</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">writable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span>
		    <span class="n">pte_mkwrite</span><span class="p">(</span><span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">)));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">huge_pte_wrprotect</span><span class="p">(</span><span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkyoung</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkhuge</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">arch_make_huge_pte</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">writable</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_huge_ptep_writable</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkwrite</span><span class="p">(</span><span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">ptep</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">huge_ptep_set_access_flags</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">copy_hugetlb_page_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">src_pte</span><span class="p">,</span> <span class="o">*</span><span class="n">dst_pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">ptepage</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>

	<span class="n">cow</span> <span class="o">=</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_SHARED</span> <span class="o">|</span> <span class="n">VM_MAYWRITE</span><span class="p">))</span> <span class="o">==</span> <span class="n">VM_MAYWRITE</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">src_pte</span> <span class="o">=</span> <span class="n">huge_pte_offset</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src_pte</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">dst_pte</span> <span class="o">=</span> <span class="n">huge_pte_alloc</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dst_pte</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

		<span class="cm">/* If the pagetables are shared don&#39;t copy or take references */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dst_pte</span> <span class="o">==</span> <span class="n">src_pte</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">,</span> <span class="n">SINGLE_DEPTH_NESTING</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">huge_pte_none</span><span class="p">(</span><span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">src_pte</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cow</span><span class="p">)</span>
				<span class="n">huge_ptep_set_wrprotect</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">src_pte</span><span class="p">);</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">src_pte</span><span class="p">);</span>
			<span class="n">ptepage</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
			<span class="n">get_page</span><span class="p">(</span><span class="n">ptepage</span><span class="p">);</span>
			<span class="n">page_dup_rmap</span><span class="p">(</span><span class="n">ptepage</span><span class="p">);</span>
			<span class="n">set_huge_pte_at</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">dst_pte</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_hugetlb_entry_migration</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">swp_entry_t</span> <span class="n">swp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">huge_pte_none</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">||</span> <span class="n">pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">swp</span> <span class="o">=</span> <span class="n">pte_to_swp_entry</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">non_swap_entry</span><span class="p">(</span><span class="n">swp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_migration_entry</span><span class="p">(</span><span class="n">swp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_hugetlb_entry_hwpoisoned</span><span class="p">(</span><span class="n">pte_t</span> <span class="n">pte</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">swp_entry_t</span> <span class="n">swp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">huge_pte_none</span><span class="p">(</span><span class="n">pte</span><span class="p">)</span> <span class="o">||</span> <span class="n">pte_present</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">swp</span> <span class="o">=</span> <span class="n">pte_to_swp_entry</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">non_swap_entry</span><span class="p">(</span><span class="n">swp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_hwpoison_entry</span><span class="p">(</span><span class="n">swp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__unmap_hugepage_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">ref_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * A page gathering list, protected by per file i_mmap_mutex. The</span>
<span class="cm">	 * lock is used to avoid list corruption from multiple unmapping</span>
<span class="cm">	 * of the same page since we are using page-&gt;lru.</span>
<span class="cm">	 */</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">page_list</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_vm_hugetlb_page</span><span class="p">(</span><span class="n">vma</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>

	<span class="n">mmu_notifier_invalidate_range_start</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">address</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">address</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ptep</span> <span class="o">=</span> <span class="n">huge_pte_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptep</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">huge_pmd_unshare</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pte</span> <span class="o">=</span> <span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">huge_pte_none</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * HWPoisoned hugepage is already unmapped and dropped reference</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_hugetlb_entry_hwpoisoned</span><span class="p">(</span><span class="n">pte</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If a reference page is supplied, it is because a specific</span>
<span class="cm">		 * page is being unmapped, not a range. Ensure the page we</span>
<span class="cm">		 * are about to unmap is the actual page of interest.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref_page</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">ref_page</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Mark the VMA as having unmapped its page so that</span>
<span class="cm">			 * future faults in this VMA will fail rather than</span>
<span class="cm">			 * looking like data was lost</span>
<span class="cm">			 */</span>
			<span class="n">set_vma_resv_flags</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">HPAGE_RESV_UNMAPPED</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pte</span> <span class="o">=</span> <span class="n">huge_ptep_get_and_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte_dirty</span><span class="p">(</span><span class="n">pte</span><span class="p">))</span>
			<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_list</span><span class="p">);</span>

		<span class="cm">/* Bail out after unmapping reference page if supplied */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref_page</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">flush_tlb_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_remove_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unmap_hugepage_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">ref_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="n">__unmap_hugepage_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">ref_page</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is called when the original mapper is failing to COW a MAP_PRIVATE</span>
<span class="cm"> * mappping it owns the reserve page for. The intention is to unmap the page</span>
<span class="cm"> * from other VMAs and let the children be SIGKILLed if they are faulting the</span>
<span class="cm"> * same region.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">unmap_ref_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">iter_vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">prio_tree_iter</span> <span class="n">iter</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">pgoff</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * vm_pgoff is in PAGE_SIZE units, hence the different calculation</span>
<span class="cm">	 * from page cache lookup which is in HPAGE_SIZE units.</span>
<span class="cm">	 */</span>
	<span class="n">address</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="n">pgoff</span> <span class="o">=</span> <span class="n">vma_hugecache_offset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Take the mapping lock for the duration of the table walk. As</span>
<span class="cm">	 * this mapping should be shared between all the VMAs,</span>
<span class="cm">	 * __unmap_hugepage_range() is called as the lock is already held</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="n">vma_prio_tree_foreach</span><span class="p">(</span><span class="n">iter_vma</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">,</span> <span class="n">pgoff</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Do not unmap the current VMA */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iter_vma</span> <span class="o">==</span> <span class="n">vma</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Unmap the page from other VMAs without their own reserves.</span>
<span class="cm">		 * They get marked to be SIGKILLed if they fault in these</span>
<span class="cm">		 * areas. This is because a future no-page fault on this VMA</span>
<span class="cm">		 * could insert a zeroed page instead of the data existing</span>
<span class="cm">		 * from the time of fork. This would look like data corruption</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_vma_resv_set</span><span class="p">(</span><span class="n">iter_vma</span><span class="p">,</span> <span class="n">HPAGE_RESV_OWNER</span><span class="p">))</span>
			<span class="n">__unmap_hugepage_range</span><span class="p">(</span><span class="n">iter_vma</span><span class="p">,</span>
				<span class="n">address</span><span class="p">,</span> <span class="n">address</span> <span class="o">+</span> <span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
				<span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Hugetlb_cow() should be called with page lock of the original hugepage held.</span>
<span class="cm"> * Called with hugetlb_instantiation_mutex held and pte_page locked so we</span>
<span class="cm"> * cannot race with other handlers or page migration.</span>
<span class="cm"> * Keep the pte_same checks anyway to make transition from the mutex easier.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hugetlb_cow</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="n">pte_t</span> <span class="n">pte</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pagecache_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">old_page</span><span class="p">,</span> <span class="o">*</span><span class="n">new_page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">avoidcopy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">outside_reserve</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">old_page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>

<span class="nl">retry_avoidcopy:</span>
	<span class="cm">/* If no-one else is actually using this page, avoid the copy</span>
<span class="cm">	 * and just make the page writable */</span>
	<span class="n">avoidcopy</span> <span class="o">=</span> <span class="p">(</span><span class="n">page_mapcount</span><span class="p">(</span><span class="n">old_page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">avoidcopy</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageAnon</span><span class="p">(</span><span class="n">old_page</span><span class="p">))</span>
			<span class="n">page_move_anon_rmap</span><span class="p">(</span><span class="n">old_page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="n">set_huge_ptep_writable</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the process that created a MAP_PRIVATE mapping is about to</span>
<span class="cm">	 * perform a COW due to a shared page count, attempt to satisfy</span>
<span class="cm">	 * the allocation without using the existing reserves. The pagecache</span>
<span class="cm">	 * page is used to determine if the reserve at this address was</span>
<span class="cm">	 * consumed or not. If reserves were used, a partial faulted mapping</span>
<span class="cm">	 * at the time of fork() could consume its reserves on COW instead</span>
<span class="cm">	 * of the full address range.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">is_vma_resv_set</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">HPAGE_RESV_OWNER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">old_page</span> <span class="o">!=</span> <span class="n">pagecache_page</span><span class="p">)</span>
		<span class="n">outside_reserve</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>

	<span class="cm">/* Drop page_table_lock as buddy allocator may be called */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">new_page</span> <span class="o">=</span> <span class="n">alloc_huge_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">outside_reserve</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If a process owning a MAP_PRIVATE mapping fails to COW,</span>
<span class="cm">		 * it is due to references held by a child and an insufficient</span>
<span class="cm">		 * huge page pool. To guarantee the original mappers</span>
<span class="cm">		 * reliability, unmap the page from child processes. The child</span>
<span class="cm">		 * may get SIGKILLed if it later faults.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">outside_reserve</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">huge_pte_none</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unmap_ref_private</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">old_page</span><span class="p">,</span> <span class="n">address</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">huge_pte_none</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
				<span class="n">ptep</span> <span class="o">=</span> <span class="n">huge_pte_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pte_same</span><span class="p">(</span><span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">ptep</span><span class="p">),</span> <span class="n">pte</span><span class="p">)))</span>
					<span class="k">goto</span> <span class="n">retry_avoidcopy</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * race occurs while re-acquiring page_table_lock, and</span>
<span class="cm">				 * our job is done.</span>
<span class="cm">				 */</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Caller expects lock to be held */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * When the original hugepage is shared one, it does not have</span>
<span class="cm">	 * anon_vma prepared.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">anon_vma_prepare</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
		<span class="cm">/* Caller expects lock to be held */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">copy_user_huge_page</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">old_page</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span>
			    <span class="n">pages_per_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
	<span class="n">__SetPageUptodate</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Retake the page_table_lock to check for racing updates</span>
<span class="cm">	 * before the page tables are altered</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">ptep</span> <span class="o">=</span> <span class="n">huge_pte_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span> <span class="o">&amp;</span> <span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">pte_same</span><span class="p">(</span><span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">ptep</span><span class="p">),</span> <span class="n">pte</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Break COW */</span>
		<span class="n">mmu_notifier_invalidate_range_start</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span>
			<span class="n">address</span> <span class="o">&amp;</span> <span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
			<span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="o">+</span> <span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
		<span class="n">huge_ptep_clear_flush</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
		<span class="n">set_huge_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span>
				<span class="n">make_huge_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">new_page</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
		<span class="n">page_remove_rmap</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
		<span class="n">hugepage_add_new_anon_rmap</span><span class="p">(</span><span class="n">new_page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="cm">/* Make the old page be freed below */</span>
		<span class="n">new_page</span> <span class="o">=</span> <span class="n">old_page</span><span class="p">;</span>
		<span class="n">mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span>
			<span class="n">address</span> <span class="o">&amp;</span> <span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
			<span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="o">+</span> <span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">new_page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">old_page</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return the pagecache page at a given address within a VMA */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">hugetlbfs_pagecache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">vma_hugecache_offset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">find_lock_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return whether there is a pagecache page to back given address within VMA.</span>
<span class="cm"> * Caller follow_hugetlb_page() holds page_table_lock so we cannot lock_page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">hugetlbfs_pagecache_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">idx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">vma_hugecache_offset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">page</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hugetlb_no_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">anon_rmap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">new_pte</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Currently, we are forced to kill the process in the event the</span>
<span class="cm">	 * original mapper has unmapped pages from the child due to a failed</span>
<span class="cm">	 * COW. Warn that such a situation has occurred as it may not be obvious</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_vma_resv_set</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">HPAGE_RESV_UNMAPPED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;PID %d killed due to inadequate hugepage pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="n">idx</span> <span class="o">=</span> <span class="n">vma_hugecache_offset</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use page lock to guard against racing truncation</span>
<span class="cm">	 * before we get page_table_lock.</span>
<span class="cm">	 */</span>
<span class="nl">retry:</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">find_lock_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">huge_page_shift</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_huge_page</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">PTR_ERR</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">clear_huge_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">pages_per_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
		<span class="n">__SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">add_to_page_cache</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">+=</span> <span class="n">blocks_per_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">anon_vma_prepare</span><span class="p">(</span><span class="n">vma</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">backout_unlocked</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">anon_rmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If memory error occurs between mmap() and fault, some process</span>
<span class="cm">		 * don&#39;t have hwpoisoned swap entry for errored virtual address.</span>
<span class="cm">		 * So we need to block hugepage fault by PG_hwpoison bit check.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PageHWPoison</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_HWPOISON</span> <span class="o">|</span>
			      <span class="n">VM_FAULT_SET_HINDEX</span><span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">hstates</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">backout_unlocked</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are going to COW a private mapping later, we examine the</span>
<span class="cm">	 * pending reservations for this page now. This will ensure that</span>
<span class="cm">	 * any allocations necessary to record that reservation occur outside</span>
<span class="cm">	 * the spinlock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma_needs_reservation</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">backout_unlocked</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">huge_page_shift</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">backout</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">huge_pte_none</span><span class="p">(</span><span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">ptep</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">backout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">anon_rmap</span><span class="p">)</span>
		<span class="n">hugepage_add_new_anon_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">page_dup_rmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">new_pte</span> <span class="o">=</span> <span class="n">make_huge_pte</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)));</span>
	<span class="n">set_huge_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">new_pte</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Optimization, do the COW without a second fault */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">hugetlb_cow</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">new_pte</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">backout:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
<span class="nl">backout_unlocked:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">hugetlb_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">entry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pagecache_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">hugetlb_instantiation_mutex</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="n">address</span> <span class="o">&amp;=</span> <span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>

	<span class="n">ptep</span> <span class="o">=</span> <span class="n">huge_pte_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptep</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_hugetlb_entry_migration</span><span class="p">(</span><span class="n">entry</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">migration_entry_wait</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ptep</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_hugetlb_entry_hwpoisoned</span><span class="p">(</span><span class="n">entry</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">VM_FAULT_HWPOISON_LARGE</span> <span class="o">|</span>
			       <span class="n">VM_FAULT_SET_HINDEX</span><span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">hstates</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ptep</span> <span class="o">=</span> <span class="n">huge_pte_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptep</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Serialize hugepage allocation and instantiation, so that we don&#39;t</span>
<span class="cm">	 * get spurious allocation failures if two CPUs race to instantiate</span>
<span class="cm">	 * the same page in the page cache.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_instantiation_mutex</span><span class="p">);</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">ptep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">huge_pte_none</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">hugetlb_no_page</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_mutex</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are going to COW the mapping later, we examine the pending</span>
<span class="cm">	 * reservations for this page now. This will ensure that any</span>
<span class="cm">	 * allocations necessary to record that reservation occur outside the</span>
<span class="cm">	 * spinlock. For private mappings, we also lookup the pagecache</span>
<span class="cm">	 * page now as it is used to determine if a reservation has been</span>
<span class="cm">	 * consumed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pte_write</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma_needs_reservation</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_mutex</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">))</span>
			<span class="n">pagecache_page</span> <span class="o">=</span> <span class="n">hugetlbfs_pagecache_page</span><span class="p">(</span><span class="n">h</span><span class="p">,</span>
								<span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * hugetlb_cow() requires page locks of pte_page(entry) and</span>
<span class="cm">	 * pagecache_page, so here we need take the former one</span>
<span class="cm">	 * when page != pagecache_page or !pagecache_page.</span>
<span class="cm">	 * Note that locking order is always pagecache_page -&gt; page,</span>
<span class="cm">	 * so no worry about deadlock.</span>
<span class="cm">	 */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">pagecache_page</span><span class="p">)</span>
		<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="cm">/* Check for a racing update before calling hugetlb_cow */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pte_same</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">ptep</span><span class="p">))))</span>
		<span class="k">goto</span> <span class="n">out_page_table_lock</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pte_write</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">hugetlb_cow</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
							<span class="n">pagecache_page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_page_table_lock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkdirty</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">pte_mkyoung</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">huge_ptep_set_access_flags</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span>
						<span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FAULT_FLAG_WRITE</span><span class="p">))</span>
		<span class="n">update_mmu_cache</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>

<span class="nl">out_page_table_lock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pagecache_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">pagecache_page</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">pagecache_page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="n">pagecache_page</span><span class="p">)</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

<span class="nl">out_mutex:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_instantiation_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Can be overriden by architectures */</span>
<span class="n">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">))</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span>
<span class="n">follow_huge_pud</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span>
	       <span class="n">pud_t</span> <span class="o">*</span><span class="n">pud</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">follow_hugetlb_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">**</span><span class="n">vmas</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">position</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="o">*</span><span class="n">position</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="o">*</span><span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&amp;&amp;</span> <span class="n">remainder</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">absent</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Some archs (sparc64, sh*) have multiple pte_ts to</span>
<span class="cm">		 * each hugepage.  We have to make sure we get the</span>
<span class="cm">		 * first, for the page indexing below to work.</span>
<span class="cm">		 */</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="n">huge_pte_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">&amp;</span> <span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">));</span>
		<span class="n">absent</span> <span class="o">=</span> <span class="o">!</span><span class="n">pte</span> <span class="o">||</span> <span class="n">huge_pte_none</span><span class="p">(</span><span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * When coredumping, it suits get_dump_page if we just return</span>
<span class="cm">		 * an error where there&#39;s an empty slot with no huge pagecache</span>
<span class="cm">		 * to back it.  This way, we avoid allocating a hugepage, and</span>
<span class="cm">		 * the sparse dumpfile avoids allocating disk blocks, but its</span>
<span class="cm">		 * huge holes still show up with zeroes where they need to be.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">absent</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_DUMP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">hugetlbfs_pagecache_present</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">remainder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">absent</span> <span class="o">||</span>
		    <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pte_write</span><span class="p">(</span><span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">pte</span><span class="p">))))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">hugetlb_fault</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">,</span>
				<span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FOLL_WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="n">FAULT_FLAG_WRITE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">VM_FAULT_ERROR</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">remainder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pfn_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">huge_page_mask</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
<span class="nl">same_page:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem_map_offset</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pfn_offset</span><span class="p">);</span>
			<span class="n">get_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vmas</span><span class="p">)</span>
			<span class="n">vmas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vma</span><span class="p">;</span>

		<span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="o">++</span><span class="n">pfn_offset</span><span class="p">;</span>
		<span class="o">--</span><span class="n">remainder</span><span class="p">;</span>
		<span class="o">++</span><span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">&amp;&amp;</span> <span class="n">remainder</span> <span class="o">&amp;&amp;</span>
				<span class="n">pfn_offset</span> <span class="o">&lt;</span> <span class="n">pages_per_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We use pfn_offset to avoid touching the pageframes</span>
<span class="cm">			 * of this compound page.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">same_page</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="o">*</span><span class="n">length</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
	<span class="o">*</span><span class="n">position</span> <span class="o">=</span> <span class="n">vaddr</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">i</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">hugetlb_change_protection</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">newprot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">address</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">ptep</span><span class="p">;</span>
	<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">flush_cache_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">address</span> <span class="o">+=</span> <span class="n">huge_page_size</span><span class="p">(</span><span class="n">h</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ptep</span> <span class="o">=</span> <span class="n">huge_pte_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptep</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">huge_pmd_unshare</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">huge_pte_none</span><span class="p">(</span><span class="n">huge_ptep_get</span><span class="p">(</span><span class="n">ptep</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pte</span> <span class="o">=</span> <span class="n">huge_ptep_get_and_clear</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">);</span>
			<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_mkhuge</span><span class="p">(</span><span class="n">pte_modify</span><span class="p">(</span><span class="n">pte</span><span class="p">,</span> <span class="n">newprot</span><span class="p">));</span>
			<span class="n">set_huge_pte_at</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">ptep</span><span class="p">,</span> <span class="n">pte</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">page_table_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">i_mmap_mutex</span><span class="p">);</span>

	<span class="n">flush_tlb_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">hugetlb_reserve_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					<span class="kt">long</span> <span class="n">from</span><span class="p">,</span> <span class="kt">long</span> <span class="n">to</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
					<span class="n">vm_flags_t</span> <span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span><span class="p">,</span> <span class="n">chg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="n">spool</span> <span class="o">=</span> <span class="n">subpool_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only apply hugepage reservation if asked. At fault time, an</span>
<span class="cm">	 * attempt will be made for VM_NORESERVE to allocate a page</span>
<span class="cm">	 * without using reserves</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NORESERVE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Shared mappings base their reservation on the number of pages that</span>
<span class="cm">	 * are already allocated on behalf of the file. Private mappings need</span>
<span class="cm">	 * to reserve the full area even if read-only as mprotect() may be</span>
<span class="cm">	 * called to make the mapping read-write. Assume !vma is a shm mapping</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">)</span>
		<span class="n">chg</span> <span class="o">=</span> <span class="n">region_chg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">resv_map</span> <span class="o">*</span><span class="n">resv_map</span> <span class="o">=</span> <span class="n">resv_map_alloc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resv_map</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">chg</span> <span class="o">=</span> <span class="n">to</span> <span class="o">-</span> <span class="n">from</span><span class="p">;</span>

		<span class="n">set_vma_resv_map</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">resv_map</span><span class="p">);</span>
		<span class="n">set_vma_resv_flags</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">HPAGE_RESV_OWNER</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">chg</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* There must be enough pages in the subpool for the mapping */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hugepage_subpool_get_pages</span><span class="p">(</span><span class="n">spool</span><span class="p">,</span> <span class="n">chg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check enough hugepages are available for the reservation.</span>
<span class="cm">	 * Hand the pages back to the subpool if there are not</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">hugetlb_acct_memory</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">chg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hugepage_subpool_put_pages</span><span class="p">(</span><span class="n">spool</span><span class="p">,</span> <span class="n">chg</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Account for the reservations made. Shared mappings record regions</span>
<span class="cm">	 * that have reservations as they are shared by multiple VMAs.</span>
<span class="cm">	 * When the last VMA disappears, the region map says how much</span>
<span class="cm">	 * the reservation was and the page cache tells how much of</span>
<span class="cm">	 * the reservation was consumed. Private mappings are per-VMA and</span>
<span class="cm">	 * only the consumed reservations are tracked. When the VMA</span>
<span class="cm">	 * disappears, the original reservation is the VMA size and the</span>
<span class="cm">	 * consumed reservations are stored in the map. Hence, nothing</span>
<span class="cm">	 * else has to be done for private mappings here</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span> <span class="o">||</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_MAYSHARE</span><span class="p">)</span>
		<span class="n">region_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="p">)</span>
		<span class="n">resv_map_put</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">hugetlb_unreserve_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">long</span> <span class="n">freed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">hstate_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">chg</span> <span class="o">=</span> <span class="n">region_truncate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">private_list</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">hugepage_subpool</span> <span class="o">*</span><span class="n">spool</span> <span class="o">=</span> <span class="n">subpool_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">-=</span> <span class="p">(</span><span class="n">blocks_per_huge_page</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="n">freed</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="n">hugepage_subpool_put_pages</span><span class="p">(</span><span class="n">spool</span><span class="p">,</span> <span class="p">(</span><span class="n">chg</span> <span class="o">-</span> <span class="n">freed</span><span class="p">));</span>
	<span class="n">hugetlb_acct_memory</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">chg</span> <span class="o">-</span> <span class="n">freed</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_MEMORY_FAILURE</span>

<span class="cm">/* Should be called in hugetlb_lock */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">is_hugepage_on_freelist</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">hpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">page_hstate</span><span class="p">(</span><span class="n">hpage</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">hpage</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">hugepage_freelists</span><span class="p">[</span><span class="n">nid</span><span class="p">],</span> <span class="n">lru</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">hpage</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called from memory failure code.</span>
<span class="cm"> * Assume the caller holds page lock of the head page.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">dequeue_hwpoisoned_huge_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">hpage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hstate</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="n">page_hstate</span><span class="p">(</span><span class="n">hpage</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">page_to_nid</span><span class="p">(</span><span class="n">hpage</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_hugepage_on_freelist</span><span class="p">(</span><span class="n">hpage</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpage</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">set_page_refcounted</span><span class="p">(</span><span class="n">hpage</span><span class="p">);</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages</span><span class="o">--</span><span class="p">;</span>
		<span class="n">h</span><span class="o">-&gt;</span><span class="n">free_huge_pages_node</span><span class="p">[</span><span class="n">nid</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hugetlb_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
