<!DOCTYPE html>
<html><head><title>joekychen/linux » mm › bootmem.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>bootmem.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  bootmem - A boot-time physical memory allocator and configurator</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1999 Ingo Molnar</span>
<span class="cm"> *                1999 Kanoj Sarcar, SGI</span>
<span class="cm"> *                2008 Johannes Weiner</span>
<span class="cm"> *</span>
<span class="cm"> * Access to this subsystem has to be serialized externally (which is true</span>
<span class="cm"> * for the boot process anyway).</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pfn.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/bootmem.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/kmemleak.h&gt;</span>
<span class="cp">#include &lt;linux/range.h&gt;</span>
<span class="cp">#include &lt;linux/memblock.h&gt;</span>

<span class="cp">#include &lt;asm/bug.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/processor.h&gt;</span>

<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#ifndef CONFIG_NEED_MULTIPLE_NODES</span>
<span class="k">struct</span> <span class="n">pglist_data</span> <span class="n">__refdata</span> <span class="n">contig_page_data</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">bdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bootmem_node_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">contig_page_data</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_low_pfn</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_low_pfn</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_pfn</span><span class="p">;</span>

<span class="n">bootmem_data_t</span> <span class="n">bootmem_node_data</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">]</span> <span class="n">__initdata</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">bdata_list</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">bdata_list</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">bootmem_debug</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">bootmem_debug_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bootmem_debug</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">early_param</span><span class="p">(</span><span class="s">&quot;bootmem_debug&quot;</span><span class="p">,</span> <span class="n">bootmem_debug_setup</span><span class="p">);</span>

<span class="cp">#define bdebug(fmt, args...) ({				\</span>
<span class="cp">	if (unlikely(bootmem_debug))			\</span>
<span class="cp">		printk(KERN_INFO			\</span>
<span class="cp">			&quot;bootmem::%s &quot; fmt,		\</span>
<span class="cp">			__func__, ## args);		\</span>
<span class="cp">})</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">bootmap_bytes</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bootmem_bootmap_pages - calculate bitmap size in pages</span>
<span class="cm"> * @pages: number of pages the bitmap has to represent</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">bootmem_bootmap_pages</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">bootmap_bytes</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * link bdata in order</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">link_bootmem</span><span class="p">(</span><span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">bdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">ent</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdata_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span> <span class="o">&lt;</span> <span class="n">ent</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdata_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called once to set up the allocator itself.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">init_bootmem_core</span><span class="p">(</span><span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mapstart</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mapsize</span><span class="p">;</span>

	<span class="n">mminit_validate_memmodel_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
	<span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">mapstart</span><span class="p">));</span>
	<span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">link_bootmem</span><span class="p">(</span><span class="n">bdata</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initially all pages are reserved - setup_arch() has to</span>
<span class="cm">	 * register free RAM areas explicitly.</span>
<span class="cm">	 */</span>
	<span class="n">mapsize</span> <span class="o">=</span> <span class="n">bootmap_bytes</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">);</span>

	<span class="n">bdebug</span><span class="p">(</span><span class="s">&quot;nid=%td start=%lx map=%lx end=%lx mapsize=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bdata</span> <span class="o">-</span> <span class="n">bootmem_node_data</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mapstart</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mapsize</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_bootmem_node - register a node as boot memory</span>
<span class="cm"> * @pgdat: node to register</span>
<span class="cm"> * @freepfn: pfn where the bitmap for this node is to be placed</span>
<span class="cm"> * @startpfn: first pfn on the node</span>
<span class="cm"> * @endpfn: first pfn after the node</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes needed to hold the bitmap for this node.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">init_bootmem_node</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">freepfn</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">startpfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">endpfn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">init_bootmem_core</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">bdata</span><span class="p">,</span> <span class="n">freepfn</span><span class="p">,</span> <span class="n">startpfn</span><span class="p">,</span> <span class="n">endpfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * init_bootmem - register boot memory</span>
<span class="cm"> * @start: pfn where the bitmap is to be placed</span>
<span class="cm"> * @pages: number of available physical pages</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes needed to hold the bitmap.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">init_bootmem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">max_low_pfn</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="n">min_low_pfn</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">init_bootmem_core</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bdata</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * free_bootmem_late - free bootmem pages directly to page allocator</span>
<span class="cm"> * @addr: starting address of the range</span>
<span class="cm"> * @size: size of the range in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * This is only useful when the bootmem allocator has already been torn</span>
<span class="cm"> * down, but we are still initializing the system.  Pages are given directly</span>
<span class="cm"> * to the page allocator, no bootmem metadata is updated because it is gone.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">free_bootmem_late</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cursor</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">kmemleak_free_part</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">cursor</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">cursor</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">cursor</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__free_pages_bootmem</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">cursor</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">totalram_pages</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">free_all_bootmem_core</span><span class="p">(</span><span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">bdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span><span class="p">;</span>

	<span class="n">bdebug</span><span class="p">(</span><span class="s">&quot;nid=%td start=%lx end=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bdata</span> <span class="o">-</span> <span class="n">bootmem_node_data</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">vec</span><span class="p">;</span>

		<span class="n">map</span> <span class="o">=</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span><span class="p">;</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">;</span>
		<span class="n">vec</span> <span class="o">=</span> <span class="o">~</span><span class="n">map</span><span class="p">[</span><span class="n">idx</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we have a properly aligned and fully unreserved</span>
<span class="cm">		 * BITS_PER_LONG block of pages in front of us, free</span>
<span class="cm">		 * it in one go.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">vec</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">order</span> <span class="o">=</span> <span class="n">ilog2</span><span class="p">(</span><span class="n">BITS_PER_LONG</span><span class="p">);</span>

			<span class="n">__free_pages_bootmem</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">order</span><span class="p">);</span>
			<span class="n">count</span> <span class="o">+=</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
			<span class="n">start</span> <span class="o">+=</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">vec</span> <span class="o">&gt;&gt;=</span> <span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">vec</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">page</span> <span class="o">=</span> <span class="n">pfn_to_page</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">off</span><span class="p">);</span>
					<span class="n">__free_pages_bootmem</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="n">count</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">vec</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">off</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">BITS_PER_LONG</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span><span class="p">);</span>
	<span class="n">pages</span> <span class="o">=</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span> <span class="o">-</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">;</span>
	<span class="n">pages</span> <span class="o">=</span> <span class="n">bootmem_bootmap_pages</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">+=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pages</span><span class="o">--</span><span class="p">)</span>
		<span class="n">__free_pages_bootmem</span><span class="p">(</span><span class="n">page</span><span class="o">++</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">bdebug</span><span class="p">(</span><span class="s">&quot;nid=%td released=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bdata</span> <span class="o">-</span> <span class="n">bootmem_node_data</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_all_bootmem_node - release a node&#39;s free pages to the buddy allocator</span>
<span class="cm"> * @pgdat: node to be released</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of pages actually released.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">free_all_bootmem_node</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_page_bootmem_info_node</span><span class="p">(</span><span class="n">pgdat</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">free_all_bootmem_core</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">bdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_all_bootmem - release free pages to the buddy allocator</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of pages actually released.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">free_all_bootmem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">bdata</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdata_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">total_pages</span> <span class="o">+=</span> <span class="n">free_all_bootmem_core</span><span class="p">(</span><span class="n">bdata</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">total_pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">__free</span><span class="p">(</span><span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sidx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span><span class="p">;</span>

	<span class="n">bdebug</span><span class="p">(</span><span class="s">&quot;nid=%td start=%lx end=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bdata</span> <span class="o">-</span> <span class="n">bootmem_node_data</span><span class="p">,</span>
		<span class="n">sidx</span> <span class="o">+</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">,</span>
		<span class="n">eidx</span> <span class="o">+</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">hint_idx</span> <span class="o">&gt;</span> <span class="n">sidx</span><span class="p">)</span>
		<span class="n">bdata</span><span class="o">-&gt;</span><span class="n">hint_idx</span> <span class="o">=</span> <span class="n">sidx</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="n">sidx</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">eidx</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">__reserve</span><span class="p">(</span><span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sidx</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eidx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">exclusive</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BOOTMEM_EXCLUSIVE</span><span class="p">;</span>

	<span class="n">bdebug</span><span class="p">(</span><span class="s">&quot;nid=%td start=%lx end=%lx flags=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bdata</span> <span class="o">-</span> <span class="n">bootmem_node_data</span><span class="p">,</span>
		<span class="n">sidx</span> <span class="o">+</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">,</span>
		<span class="n">eidx</span> <span class="o">+</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">,</span>
		<span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="n">sidx</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">eidx</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">exclusive</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__free</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">sidx</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">bdebug</span><span class="p">(</span><span class="s">&quot;silent double reserve of PFN %lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">idx</span> <span class="o">+</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mark_bootmem_node</span><span class="p">(</span><span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">reserve</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sidx</span><span class="p">,</span> <span class="n">eidx</span><span class="p">;</span>

	<span class="n">bdebug</span><span class="p">(</span><span class="s">&quot;nid=%td start=%lx end=%lx reserve=%d flags=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bdata</span> <span class="o">-</span> <span class="n">bootmem_node_data</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">reserve</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span><span class="p">);</span>

	<span class="n">sidx</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">;</span>
	<span class="n">eidx</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reserve</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__reserve</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">sidx</span><span class="p">,</span> <span class="n">eidx</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__free</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">sidx</span><span class="p">,</span> <span class="n">eidx</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">mark_bootmem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">reserve</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pos</span><span class="p">;</span>
	<span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">bdata</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdata_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span> <span class="o">||</span>
		    <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">start</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">max</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">mark_bootmem_node</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">reserve</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reserve</span> <span class="o">&amp;&amp;</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mark_bootmem</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_bootmem_node - mark a page range as usable</span>
<span class="cm"> * @pgdat: node the range resides on</span>
<span class="cm"> * @physaddr: starting address of the range</span>
<span class="cm"> * @size: size of the range in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Partial pages will be considered reserved and left as they are.</span>
<span class="cm"> *</span>
<span class="cm"> * The range must reside completely on the specified node.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">free_bootmem_node</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physaddr</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">kmemleak_free_part</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">physaddr</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">physaddr</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">physaddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">mark_bootmem_node</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">bdata</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * free_bootmem - mark a page range as usable</span>
<span class="cm"> * @addr: starting address of the range</span>
<span class="cm"> * @size: size of the range in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Partial pages will be considered reserved and left as they are.</span>
<span class="cm"> *</span>
<span class="cm"> * The range must be contiguous but may span node boundaries.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">free_bootmem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">kmemleak_free_part</span><span class="p">(</span><span class="n">__va</span><span class="p">(</span><span class="n">addr</span><span class="p">),</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">mark_bootmem</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * reserve_bootmem_node - mark a page range as reserved</span>
<span class="cm"> * @pgdat: node the range resides on</span>
<span class="cm"> * @physaddr: starting address of the range</span>
<span class="cm"> * @size: size of the range in bytes</span>
<span class="cm"> * @flags: reservation flags (see linux/bootmem.h)</span>
<span class="cm"> *</span>
<span class="cm"> * Partial pages will be reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * The range must reside completely on the specified node.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">reserve_bootmem_node</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">physaddr</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">physaddr</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">physaddr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mark_bootmem_node</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">bdata</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * reserve_bootmem - mark a page range as usable</span>
<span class="cm"> * @addr: starting address of the range</span>
<span class="cm"> * @size: size of the range in bytes</span>
<span class="cm"> * @flags: reservation flags (see linux/bootmem.h)</span>
<span class="cm"> *</span>
<span class="cm"> * Partial pages will be reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * The range must be contiguous but may span node boundaries.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">reserve_bootmem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mark_bootmem</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__weak</span> <span class="n">__init</span> <span class="nf">reserve_bootmem_generic</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">phys</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">reserve_bootmem</span><span class="p">(</span><span class="n">phys</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">align_idx</span><span class="p">(</span><span class="k">struct</span> <span class="n">bootmem_data</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Align the index with respect to the node start so that the</span>
<span class="cm">	 * combination of both satisfies the requested alignment.</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">__init</span> <span class="nf">align_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">bootmem_data</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span>
				      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">);</span>

	<span class="cm">/* Same as align_idx for byte offsets */</span>

	<span class="k">return</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="n">align</span><span class="p">)</span> <span class="o">-</span> <span class="n">base</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">alloc_bootmem_bdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">bootmem_data</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fallback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">sidx</span><span class="p">,</span> <span class="n">midx</span><span class="p">,</span> <span class="n">step</span><span class="p">;</span>

	<span class="n">bdebug</span><span class="p">(</span><span class="s">&quot;nid=%td size=%lx [%lu pages] align=%lx goal=%lx limit=%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">bdata</span> <span class="o">-</span> <span class="n">bootmem_node_data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
		<span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">align</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">align</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="n">goal</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">min</span> <span class="o">=</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">;</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span><span class="p">;</span>

	<span class="n">goal</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">limit</span> <span class="o">&gt;&gt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="n">max</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">)</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">step</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">align</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">goal</span> <span class="o">&amp;&amp;</span> <span class="n">min</span> <span class="o">&lt;</span> <span class="n">goal</span> <span class="o">&amp;&amp;</span> <span class="n">goal</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>

	<span class="n">sidx</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">;</span>
	<span class="n">midx</span> <span class="o">=</span> <span class="n">max</span> <span class="o">-</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">hint_idx</span> <span class="o">&gt;</span> <span class="n">sidx</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Handle the valid case of sidx being zero and still</span>
<span class="cm">		 * catch the fallback below.</span>
<span class="cm">		 */</span>
		<span class="n">fallback</span> <span class="o">=</span> <span class="n">sidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sidx</span> <span class="o">=</span> <span class="n">align_idx</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">hint_idx</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">merge</span><span class="p">;</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">region</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">eidx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">start_off</span><span class="p">,</span> <span class="n">end_off</span><span class="p">;</span>
<span class="nl">find_block:</span>
		<span class="n">sidx</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span><span class="p">,</span> <span class="n">midx</span><span class="p">,</span> <span class="n">sidx</span><span class="p">);</span>
		<span class="n">sidx</span> <span class="o">=</span> <span class="n">align_idx</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">sidx</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
		<span class="n">eidx</span> <span class="o">=</span> <span class="n">sidx</span> <span class="o">+</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sidx</span> <span class="o">&gt;=</span> <span class="n">midx</span> <span class="o">||</span> <span class="n">eidx</span> <span class="o">&gt;</span> <span class="n">midx</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">sidx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">eidx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_bootmem_map</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sidx</span> <span class="o">=</span> <span class="n">align_idx</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sidx</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
					<span class="n">sidx</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">find_block</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">last_end_off</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">last_end_off</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">sidx</span><span class="p">)</span>
			<span class="n">start_off</span> <span class="o">=</span> <span class="n">align_off</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">last_end_off</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">start_off</span> <span class="o">=</span> <span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">sidx</span><span class="p">);</span>

		<span class="n">merge</span> <span class="o">=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">start_off</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sidx</span><span class="p">;</span>
		<span class="n">end_off</span> <span class="o">=</span> <span class="n">start_off</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">bdata</span><span class="o">-&gt;</span><span class="n">last_end_off</span> <span class="o">=</span> <span class="n">end_off</span><span class="p">;</span>
		<span class="n">bdata</span><span class="o">-&gt;</span><span class="n">hint_idx</span> <span class="o">=</span> <span class="n">PFN_UP</span><span class="p">(</span><span class="n">end_off</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Reserve the area now:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__reserve</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">start_off</span><span class="p">)</span> <span class="o">+</span> <span class="n">merge</span><span class="p">,</span>
				<span class="n">PFN_UP</span><span class="p">(</span><span class="n">end_off</span><span class="p">),</span> <span class="n">BOOTMEM_EXCLUSIVE</span><span class="p">))</span>
			<span class="n">BUG</span><span class="p">();</span>

		<span class="n">region</span> <span class="o">=</span> <span class="n">phys_to_virt</span><span class="p">(</span><span class="n">PFN_PHYS</span><span class="p">(</span><span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">start_off</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * The min_count is set to 0 so that bootmem allocated blocks</span>
<span class="cm">		 * are never reported as leaks.</span>
<span class="cm">		 */</span>
		<span class="n">kmemleak_alloc</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">region</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fallback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sidx</span> <span class="o">=</span> <span class="n">align_idx</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">fallback</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
		<span class="n">fallback</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">find_block</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">alloc_arch_preferred_bootmem</span><span class="p">(</span><span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">bdata</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">slab_is_available</span><span class="p">()))</span>
		<span class="k">return</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_HAVE_ARCH_BOOTMEM</span>
	<span class="p">{</span>
		<span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">p_bdata</span><span class="p">;</span>

		<span class="n">p_bdata</span> <span class="o">=</span> <span class="n">bootmem_arch_preferred_node</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span>
							<span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p_bdata</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">alloc_bootmem_bdata</span><span class="p">(</span><span class="n">p_bdata</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span>
							<span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">alloc_bootmem_core</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bootmem_data_t</span> <span class="o">*</span><span class="n">bdata</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">region</span><span class="p">;</span>

	<span class="n">region</span> <span class="o">=</span> <span class="n">alloc_arch_preferred_bootmem</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">region</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdata_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">goal</span> <span class="o">&amp;&amp;</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_low_pfn</span> <span class="o">&lt;=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">goal</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&amp;&amp;</span> <span class="n">bdata</span><span class="o">-&gt;</span><span class="n">node_min_pfn</span> <span class="o">&gt;=</span> <span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">region</span> <span class="o">=</span> <span class="n">alloc_bootmem_bdata</span><span class="p">(</span><span class="n">bdata</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">region</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">region</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">___alloc_bootmem_nopanic</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

<span class="nl">restart:</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">alloc_bootmem_core</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">goal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __alloc_bootmem_nopanic - allocate boot memory without panicking</span>
<span class="cm"> * @size: size of the request in bytes</span>
<span class="cm"> * @align: alignment of the region</span>
<span class="cm"> * @goal: preferred starting address of the region</span>
<span class="cm"> *</span>
<span class="cm"> * The goal is dropped if it can not be satisfied and the allocation will</span>
<span class="cm"> * fall back to memory below @goal.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocation may happen on any node in the system.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NULL on failure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">__alloc_bootmem_nopanic</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">___alloc_bootmem_nopanic</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">___alloc_bootmem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">___alloc_bootmem_nopanic</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Whoops, we cannot satisfy the allocation request.</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;bootmem alloc of %lu bytes failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Out of memory&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __alloc_bootmem - allocate boot memory</span>
<span class="cm"> * @size: size of the request in bytes</span>
<span class="cm"> * @align: alignment of the region</span>
<span class="cm"> * @goal: preferred starting address of the region</span>
<span class="cm"> *</span>
<span class="cm"> * The goal is dropped if it can not be satisfied and the allocation will</span>
<span class="cm"> * fall back to memory below @goal.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocation may happen on any node in the system.</span>
<span class="cm"> *</span>
<span class="cm"> * The function panics if the request can not be satisfied.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">__alloc_bootmem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">___alloc_bootmem</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">___alloc_bootmem_node_nopanic</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">alloc_arch_preferred_bootmem</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">bdata</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
					   <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">alloc_bootmem_bdata</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">bdata</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">alloc_bootmem_core</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">goal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">__alloc_bootmem_node_nopanic</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">slab_is_available</span><span class="p">()))</span>
		<span class="k">return</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">,</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">___alloc_bootmem_node_nopanic</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">___alloc_bootmem_node</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">___alloc_bootmem_node_nopanic</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;bootmem alloc of %lu bytes failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Out of memory&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __alloc_bootmem_node - allocate boot memory from a specific node</span>
<span class="cm"> * @pgdat: node to allocate from</span>
<span class="cm"> * @size: size of the request in bytes</span>
<span class="cm"> * @align: alignment of the region</span>
<span class="cm"> * @goal: preferred starting address of the region</span>
<span class="cm"> *</span>
<span class="cm"> * The goal is dropped if it can not be satisfied and the allocation will</span>
<span class="cm"> * fall back to memory below @goal.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocation may fall back to any node in the system if the specified node</span>
<span class="cm"> * can not hold the requested memory.</span>
<span class="cm"> *</span>
<span class="cm"> * The function panics if the request can not be satisfied.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">__alloc_bootmem_node</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">slab_is_available</span><span class="p">()))</span>
		<span class="k">return</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">,</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">);</span>

	<span class="k">return</span>  <span class="n">___alloc_bootmem_node</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">__alloc_bootmem_node_high</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef MAX_DMA32_PFN</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end_pfn</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">slab_is_available</span><span class="p">()))</span>
		<span class="k">return</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">,</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">);</span>

	<span class="cm">/* update goal according ...MAX_DMA32_PFN */</span>
	<span class="n">end_pfn</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">+</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_pfn</span> <span class="o">&gt;</span> <span class="n">MAX_DMA32_PFN</span> <span class="o">+</span> <span class="p">(</span><span class="mi">128</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">20</span> <span class="o">-</span> <span class="n">PAGE_SHIFT</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">goal</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MAX_DMA32_PFN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_goal</span><span class="p">;</span>

		<span class="n">new_goal</span> <span class="o">=</span> <span class="n">MAX_DMA32_PFN</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">alloc_bootmem_bdata</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">bdata</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span>
						 <span class="n">new_goal</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">__alloc_bootmem_node</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>

<span class="p">}</span>

<span class="cp">#ifndef ARCH_LOW_ADDRESS_LIMIT</span>
<span class="cp">#define ARCH_LOW_ADDRESS_LIMIT	0xffffffffUL</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * __alloc_bootmem_low - allocate low boot memory</span>
<span class="cm"> * @size: size of the request in bytes</span>
<span class="cm"> * @align: alignment of the region</span>
<span class="cm"> * @goal: preferred starting address of the region</span>
<span class="cm"> *</span>
<span class="cm"> * The goal is dropped if it can not be satisfied and the allocation will</span>
<span class="cm"> * fall back to memory below @goal.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocation may happen on any node in the system.</span>
<span class="cm"> *</span>
<span class="cm"> * The function panics if the request can not be satisfied.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">__alloc_bootmem_low</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">___alloc_bootmem</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">ARCH_LOW_ADDRESS_LIMIT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __alloc_bootmem_low_node - allocate low boot memory from a specific node</span>
<span class="cm"> * @pgdat: node to allocate from</span>
<span class="cm"> * @size: size of the request in bytes</span>
<span class="cm"> * @align: alignment of the region</span>
<span class="cm"> * @goal: preferred starting address of the region</span>
<span class="cm"> *</span>
<span class="cm"> * The goal is dropped if it can not be satisfied and the allocation will</span>
<span class="cm"> * fall back to memory below @goal.</span>
<span class="cm"> *</span>
<span class="cm"> * Allocation may fall back to any node in the system if the specified node</span>
<span class="cm"> * can not hold the requested memory.</span>
<span class="cm"> *</span>
<span class="cm"> * The function panics if the request can not be satisfied.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="o">*</span> <span class="n">__init</span> <span class="nf">__alloc_bootmem_low_node</span><span class="p">(</span><span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">align</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">slab_is_available</span><span class="p">()))</span>
		<span class="k">return</span> <span class="n">kzalloc_node</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_NOWAIT</span><span class="p">,</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">___alloc_bootmem_node</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span>
				     <span class="n">goal</span><span class="p">,</span> <span class="n">ARCH_LOW_ADDRESS_LIMIT</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
